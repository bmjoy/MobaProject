// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RCToCS.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_RCToCS_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_RCToCS_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_RCToCS_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_RCToCS_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_RCToCS_2eproto;
namespace RCToCS {
class AskAddMailReq;
struct AskAddMailReqDefaultTypeInternal;
extern AskAddMailReqDefaultTypeInternal _AskAddMailReq_default_instance_;
class AskAddNotice;
struct AskAddNoticeDefaultTypeInternal;
extern AskAddNoticeDefaultTypeInternal _AskAddNotice_default_instance_;
class AskDeleteNotice;
struct AskDeleteNoticeDefaultTypeInternal;
extern AskDeleteNoticeDefaultTypeInternal _AskDeleteNotice_default_instance_;
class AskNoticeInfo;
struct AskNoticeInfoDefaultTypeInternal;
extern AskNoticeInfoDefaultTypeInternal _AskNoticeInfo_default_instance_;
class AskRegist;
struct AskRegistDefaultTypeInternal;
extern AskRegistDefaultTypeInternal _AskRegist_default_instance_;
class AskServerInfo;
struct AskServerInfoDefaultTypeInternal;
extern AskServerInfoDefaultTypeInternal _AskServerInfo_default_instance_;
class AskServerUserInfo;
struct AskServerUserInfoDefaultTypeInternal;
extern AskServerUserInfoDefaultTypeInternal _AskServerUserInfo_default_instance_;
class CreateCDKey;
struct CreateCDKeyDefaultTypeInternal;
extern CreateCDKeyDefaultTypeInternal _CreateCDKey_default_instance_;
class CreateCDKey_giftInfo;
struct CreateCDKey_giftInfoDefaultTypeInternal;
extern CreateCDKey_giftInfoDefaultTypeInternal _CreateCDKey_giftInfo_default_instance_;
class QueryCDKey;
struct QueryCDKeyDefaultTypeInternal;
extern QueryCDKeyDefaultTypeInternal _QueryCDKey_default_instance_;
}  // namespace RCToCS
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace RCToCS {
enum MsgID : int {
  eMsgRC2CS_Begin = 33000,
  eMsgRC2CS_AskRegist = 33001,
  eMsgRC2CS_AskServerInfo = 33002,
  eMsgRC2CS_AskServerUserInfo = 33003,
  eMsgRC2CS_AskNoticeInfo = 33004,
  eMsgRC2CS_AskAddNotice = 33005,
  eMsgRC2CS_AskDeleteNotice = 33006,
  eMsgRC2CS_AskAddOneMail = 33007,
  eMsgRC2CS_AskCreateCDKey = 33008,
  eMsgRC2CS_AskQueryCDkey = 33009,
  eMsgRC2CS_End = 33499,
};

bool MsgID_IsValid(int value);
extern const uint32_t MsgID_internal_data_[];
constexpr MsgID MsgID_MIN = static_cast<MsgID>(33000);
constexpr MsgID MsgID_MAX = static_cast<MsgID>(33499);
constexpr int MsgID_ARRAYSIZE = 33499 + 1;
const ::google::protobuf::EnumDescriptor*
MsgID_descriptor();
template <typename T>
const std::string& MsgID_Name(T value) {
  static_assert(std::is_same<T, MsgID>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgID_Name().");
  return ::google::protobuf::internal::NameOfEnum(MsgID_descriptor(), value);
}
inline bool MsgID_Parse(absl::string_view name, MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgID>(
      MsgID_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class QueryCDKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.QueryCDKey) */ {
 public:
  inline QueryCDKey() : QueryCDKey(nullptr) {}
  ~QueryCDKey() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryCDKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryCDKey(const QueryCDKey& from) : QueryCDKey(nullptr, from) {}
  inline QueryCDKey(QueryCDKey&& from) noexcept
      : QueryCDKey(nullptr, std::move(from)) {}
  inline QueryCDKey& operator=(const QueryCDKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryCDKey& operator=(QueryCDKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryCDKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryCDKey* internal_default_instance() {
    return reinterpret_cast<const QueryCDKey*>(
        &_QueryCDKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(QueryCDKey& a, QueryCDKey& b) { a.Swap(&b); }
  inline void Swap(QueryCDKey* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryCDKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryCDKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryCDKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryCDKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryCDKey& from) { QueryCDKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryCDKey* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.QueryCDKey"; }

 protected:
  explicit QueryCDKey(::google::protobuf::Arena* arena);
  QueryCDKey(::google::protobuf::Arena* arena, const QueryCDKey& from);
  QueryCDKey(::google::protobuf::Arena* arena, QueryCDKey&& from) noexcept
      : QueryCDKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskQueryCDkey];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.QueryCDKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class CreateCDKey_giftInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.CreateCDKey.giftInfo) */ {
 public:
  inline CreateCDKey_giftInfo() : CreateCDKey_giftInfo(nullptr) {}
  ~CreateCDKey_giftInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateCDKey_giftInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateCDKey_giftInfo(const CreateCDKey_giftInfo& from) : CreateCDKey_giftInfo(nullptr, from) {}
  inline CreateCDKey_giftInfo(CreateCDKey_giftInfo&& from) noexcept
      : CreateCDKey_giftInfo(nullptr, std::move(from)) {}
  inline CreateCDKey_giftInfo& operator=(const CreateCDKey_giftInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCDKey_giftInfo& operator=(CreateCDKey_giftInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCDKey_giftInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCDKey_giftInfo* internal_default_instance() {
    return reinterpret_cast<const CreateCDKey_giftInfo*>(
        &_CreateCDKey_giftInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CreateCDKey_giftInfo& a, CreateCDKey_giftInfo& b) { a.Swap(&b); }
  inline void Swap(CreateCDKey_giftInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCDKey_giftInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCDKey_giftInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CreateCDKey_giftInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateCDKey_giftInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateCDKey_giftInfo& from) { CreateCDKey_giftInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateCDKey_giftInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.CreateCDKey.giftInfo"; }

 protected:
  explicit CreateCDKey_giftInfo(::google::protobuf::Arena* arena);
  CreateCDKey_giftInfo(::google::protobuf::Arena* arena, const CreateCDKey_giftInfo& from);
  CreateCDKey_giftInfo(::google::protobuf::Arena* arena, CreateCDKey_giftInfo&& from) noexcept
      : CreateCDKey_giftInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kItemNumFieldNumber = 2,
  };
  // optional int32 item_id = 1;
  bool has_item_id() const;
  void clear_item_id() ;
  ::int32_t item_id() const;
  void set_item_id(::int32_t value);

  private:
  ::int32_t _internal_item_id() const;
  void _internal_set_item_id(::int32_t value);

  public:
  // optional int32 item_num = 2;
  bool has_item_num() const;
  void clear_item_num() ;
  ::int32_t item_num() const;
  void set_item_num(::int32_t value);

  private:
  ::int32_t _internal_item_num() const;
  void _internal_set_item_num(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.CreateCDKey.giftInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t item_id_;
    ::int32_t item_num_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskServerUserInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.AskServerUserInfo) */ {
 public:
  inline AskServerUserInfo() : AskServerUserInfo(nullptr) {}
  ~AskServerUserInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskServerUserInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskServerUserInfo(const AskServerUserInfo& from) : AskServerUserInfo(nullptr, from) {}
  inline AskServerUserInfo(AskServerUserInfo&& from) noexcept
      : AskServerUserInfo(nullptr, std::move(from)) {}
  inline AskServerUserInfo& operator=(const AskServerUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskServerUserInfo& operator=(AskServerUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskServerUserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskServerUserInfo* internal_default_instance() {
    return reinterpret_cast<const AskServerUserInfo*>(
        &_AskServerUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AskServerUserInfo& a, AskServerUserInfo& b) { a.Swap(&b); }
  inline void Swap(AskServerUserInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskServerUserInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskServerUserInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskServerUserInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskServerUserInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskServerUserInfo& from) { AskServerUserInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskServerUserInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.AskServerUserInfo"; }

 protected:
  explicit AskServerUserInfo(::google::protobuf::Arena* arena);
  AskServerUserInfo(::google::protobuf::Arena* arena, const AskServerUserInfo& from);
  AskServerUserInfo(::google::protobuf::Arena* arena, AskServerUserInfo&& from) noexcept
      : AskServerUserInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskServerUserInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.AskServerUserInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskServerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.AskServerInfo) */ {
 public:
  inline AskServerInfo() : AskServerInfo(nullptr) {}
  ~AskServerInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskServerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskServerInfo(const AskServerInfo& from) : AskServerInfo(nullptr, from) {}
  inline AskServerInfo(AskServerInfo&& from) noexcept
      : AskServerInfo(nullptr, std::move(from)) {}
  inline AskServerInfo& operator=(const AskServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskServerInfo& operator=(AskServerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskServerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskServerInfo* internal_default_instance() {
    return reinterpret_cast<const AskServerInfo*>(
        &_AskServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AskServerInfo& a, AskServerInfo& b) { a.Swap(&b); }
  inline void Swap(AskServerInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskServerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskServerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskServerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskServerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskServerInfo& from) { AskServerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskServerInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.AskServerInfo"; }

 protected:
  explicit AskServerInfo(::google::protobuf::Arena* arena);
  AskServerInfo(::google::protobuf::Arena* arena, const AskServerInfo& from);
  AskServerInfo(::google::protobuf::Arena* arena, AskServerInfo&& from) noexcept
      : AskServerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskServerInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.AskServerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskRegist final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.AskRegist) */ {
 public:
  inline AskRegist() : AskRegist(nullptr) {}
  ~AskRegist() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRegist(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRegist(const AskRegist& from) : AskRegist(nullptr, from) {}
  inline AskRegist(AskRegist&& from) noexcept
      : AskRegist(nullptr, std::move(from)) {}
  inline AskRegist& operator=(const AskRegist& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRegist& operator=(AskRegist&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRegist& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRegist* internal_default_instance() {
    return reinterpret_cast<const AskRegist*>(
        &_AskRegist_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AskRegist& a, AskRegist& b) { a.Swap(&b); }
  inline void Swap(AskRegist* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRegist* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRegist* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRegist>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRegist& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRegist& from) { AskRegist::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRegist* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.AskRegist"; }

 protected:
  explicit AskRegist(::google::protobuf::Arena* arena);
  AskRegist(::google::protobuf::Arena* arena, const AskRegist& from);
  AskRegist(::google::protobuf::Arena* arena, AskRegist&& from) noexcept
      : AskRegist(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional bytes key = 2;
  bool has_key() const;
  void clear_key() ;
  const std::string& key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key(Arg_&& arg, Args_... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* value);

  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(
      const std::string& value);
  std::string* _internal_mutable_key();

  public:
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskRegist];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.AskRegist)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr key_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskNoticeInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.AskNoticeInfo) */ {
 public:
  inline AskNoticeInfo() : AskNoticeInfo(nullptr) {}
  ~AskNoticeInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskNoticeInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskNoticeInfo(const AskNoticeInfo& from) : AskNoticeInfo(nullptr, from) {}
  inline AskNoticeInfo(AskNoticeInfo&& from) noexcept
      : AskNoticeInfo(nullptr, std::move(from)) {}
  inline AskNoticeInfo& operator=(const AskNoticeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskNoticeInfo& operator=(AskNoticeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskNoticeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskNoticeInfo* internal_default_instance() {
    return reinterpret_cast<const AskNoticeInfo*>(
        &_AskNoticeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AskNoticeInfo& a, AskNoticeInfo& b) { a.Swap(&b); }
  inline void Swap(AskNoticeInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskNoticeInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskNoticeInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskNoticeInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskNoticeInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskNoticeInfo& from) { AskNoticeInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskNoticeInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.AskNoticeInfo"; }

 protected:
  explicit AskNoticeInfo(::google::protobuf::Arena* arena);
  AskNoticeInfo(::google::protobuf::Arena* arena, const AskNoticeInfo& from);
  AskNoticeInfo(::google::protobuf::Arena* arena, AskNoticeInfo&& from) noexcept
      : AskNoticeInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskNoticeInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.AskNoticeInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskDeleteNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.AskDeleteNotice) */ {
 public:
  inline AskDeleteNotice() : AskDeleteNotice(nullptr) {}
  ~AskDeleteNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskDeleteNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskDeleteNotice(const AskDeleteNotice& from) : AskDeleteNotice(nullptr, from) {}
  inline AskDeleteNotice(AskDeleteNotice&& from) noexcept
      : AskDeleteNotice(nullptr, std::move(from)) {}
  inline AskDeleteNotice& operator=(const AskDeleteNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskDeleteNotice& operator=(AskDeleteNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskDeleteNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskDeleteNotice* internal_default_instance() {
    return reinterpret_cast<const AskDeleteNotice*>(
        &_AskDeleteNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(AskDeleteNotice& a, AskDeleteNotice& b) { a.Swap(&b); }
  inline void Swap(AskDeleteNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskDeleteNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskDeleteNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskDeleteNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskDeleteNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskDeleteNotice& from) { AskDeleteNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskDeleteNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.AskDeleteNotice"; }

 protected:
  explicit AskDeleteNotice(::google::protobuf::Arena* arena);
  AskDeleteNotice(::google::protobuf::Arena* arena, const AskDeleteNotice& from);
  AskDeleteNotice(::google::protobuf::Arena* arena, AskDeleteNotice&& from) noexcept
      : AskDeleteNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNoticeIdFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int32 noticeId = 2;
  bool has_noticeid() const;
  void clear_noticeid() ;
  ::int32_t noticeid() const;
  void set_noticeid(::int32_t value);

  private:
  ::int32_t _internal_noticeid() const;
  void _internal_set_noticeid(::int32_t value);

  public:
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskDeleteNotice];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.AskDeleteNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t noticeid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskAddNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.AskAddNotice) */ {
 public:
  inline AskAddNotice() : AskAddNotice(nullptr) {}
  ~AskAddNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskAddNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskAddNotice(const AskAddNotice& from) : AskAddNotice(nullptr, from) {}
  inline AskAddNotice(AskAddNotice&& from) noexcept
      : AskAddNotice(nullptr, std::move(from)) {}
  inline AskAddNotice& operator=(const AskAddNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskAddNotice& operator=(AskAddNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskAddNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskAddNotice* internal_default_instance() {
    return reinterpret_cast<const AskAddNotice*>(
        &_AskAddNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AskAddNotice& a, AskAddNotice& b) { a.Swap(&b); }
  inline void Swap(AskAddNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskAddNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskAddNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskAddNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskAddNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskAddNotice& from) { AskAddNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskAddNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.AskAddNotice"; }

 protected:
  explicit AskAddNotice(::google::protobuf::Arena* arena);
  AskAddNotice(::google::protobuf::Arena* arena, const AskAddNotice& from);
  AskAddNotice(::google::protobuf::Arena* arena, AskAddNotice&& from) noexcept
      : AskAddNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTitleFieldNumber = 3,
    kNoticeMsgFieldNumber = 7,
    kPlatformFieldNumber = 2,
    kFlagFieldNumber = 4,
    kStateFieldNumber = 5,
    kPriorityFieldNumber = 6,
    kStarTimeFieldNumber = 8,
    kEndTimeFieldNumber = 9,
    kMsgidFieldNumber = 1,
  };
  // optional bytes title = 3;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional bytes noticeMsg = 7;
  bool has_noticemsg() const;
  void clear_noticemsg() ;
  const std::string& noticemsg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_noticemsg(Arg_&& arg, Args_... args);
  std::string* mutable_noticemsg();
  PROTOBUF_NODISCARD std::string* release_noticemsg();
  void set_allocated_noticemsg(std::string* value);

  private:
  const std::string& _internal_noticemsg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_noticemsg(
      const std::string& value);
  std::string* _internal_mutable_noticemsg();

  public:
  // optional int32 platform = 2;
  bool has_platform() const;
  void clear_platform() ;
  ::int32_t platform() const;
  void set_platform(::int32_t value);

  private:
  ::int32_t _internal_platform() const;
  void _internal_set_platform(::int32_t value);

  public:
  // optional int32 flag = 4;
  bool has_flag() const;
  void clear_flag() ;
  ::int32_t flag() const;
  void set_flag(::int32_t value);

  private:
  ::int32_t _internal_flag() const;
  void _internal_set_flag(::int32_t value);

  public:
  // optional int32 state = 5;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional int32 priority = 6;
  bool has_priority() const;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // optional uint64 star_time = 8;
  bool has_star_time() const;
  void clear_star_time() ;
  ::uint64_t star_time() const;
  void set_star_time(::uint64_t value);

  private:
  ::uint64_t _internal_star_time() const;
  void _internal_set_star_time(::uint64_t value);

  public:
  // optional uint64 end_time = 9;
  bool has_end_time() const;
  void clear_end_time() ;
  ::uint64_t end_time() const;
  void set_end_time(::uint64_t value);

  private:
  ::uint64_t _internal_end_time() const;
  void _internal_set_end_time(::uint64_t value);

  public:
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskAddNotice];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.AskAddNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr noticemsg_;
    ::int32_t platform_;
    ::int32_t flag_;
    ::int32_t state_;
    ::int32_t priority_;
    ::uint64_t star_time_;
    ::uint64_t end_time_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskAddMailReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.AskAddMailReq) */ {
 public:
  inline AskAddMailReq() : AskAddMailReq(nullptr) {}
  ~AskAddMailReq() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskAddMailReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskAddMailReq(const AskAddMailReq& from) : AskAddMailReq(nullptr, from) {}
  inline AskAddMailReq(AskAddMailReq&& from) noexcept
      : AskAddMailReq(nullptr, std::move(from)) {}
  inline AskAddMailReq& operator=(const AskAddMailReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskAddMailReq& operator=(AskAddMailReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskAddMailReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskAddMailReq* internal_default_instance() {
    return reinterpret_cast<const AskAddMailReq*>(
        &_AskAddMailReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AskAddMailReq& a, AskAddMailReq& b) { a.Swap(&b); }
  inline void Swap(AskAddMailReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskAddMailReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskAddMailReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskAddMailReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskAddMailReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskAddMailReq& from) { AskAddMailReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskAddMailReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.AskAddMailReq"; }

 protected:
  explicit AskAddMailReq(::google::protobuf::Arena* arena);
  AskAddMailReq(::google::protobuf::Arena* arena, const AskAddMailReq& from);
  AskAddMailReq(::google::protobuf::Arena* arena, AskAddMailReq&& from) noexcept
      : AskAddMailReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdlistFieldNumber = 10,
    kTitleFieldNumber = 4,
    kContentFieldNumber = 5,
    kGiftFieldNumber = 6,
    kCreatetimeFieldNumber = 7,
    kEndtimeFieldNumber = 8,
    kSenderFieldNumber = 9,
    kTypeFieldNumber = 2,
    kSdkFieldNumber = 3,
    kDayFieldNumber = 11,
    kMsgidFieldNumber = 1,
  };
  // repeated int64 userIdlist = 10;
  int useridlist_size() const;
  private:
  int _internal_useridlist_size() const;

  public:
  void clear_useridlist() ;
  ::int64_t useridlist(int index) const;
  void set_useridlist(int index, ::int64_t value);
  void add_useridlist(::int64_t value);
  const ::google::protobuf::RepeatedField<::int64_t>& useridlist() const;
  ::google::protobuf::RepeatedField<::int64_t>* mutable_useridlist();

  private:
  const ::google::protobuf::RepeatedField<::int64_t>& _internal_useridlist() const;
  ::google::protobuf::RepeatedField<::int64_t>* _internal_mutable_useridlist();

  public:
  // optional string title = 4;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string content = 5;
  bool has_content() const;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // optional string gift = 6;
  bool has_gift() const;
  void clear_gift() ;
  const std::string& gift() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gift(Arg_&& arg, Args_... args);
  std::string* mutable_gift();
  PROTOBUF_NODISCARD std::string* release_gift();
  void set_allocated_gift(std::string* value);

  private:
  const std::string& _internal_gift() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gift(
      const std::string& value);
  std::string* _internal_mutable_gift();

  public:
  // optional string createtime = 7;
  bool has_createtime() const;
  void clear_createtime() ;
  const std::string& createtime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_createtime(Arg_&& arg, Args_... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* value);

  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(
      const std::string& value);
  std::string* _internal_mutable_createtime();

  public:
  // optional string endtime = 8;
  bool has_endtime() const;
  void clear_endtime() ;
  const std::string& endtime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_endtime(Arg_&& arg, Args_... args);
  std::string* mutable_endtime();
  PROTOBUF_NODISCARD std::string* release_endtime();
  void set_allocated_endtime(std::string* value);

  private:
  const std::string& _internal_endtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_endtime(
      const std::string& value);
  std::string* _internal_mutable_endtime();

  public:
  // optional string sender = 9;
  bool has_sender() const;
  void clear_sender() ;
  const std::string& sender() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* value);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // optional int32 type = 2;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional int32 sdk = 3;
  bool has_sdk() const;
  void clear_sdk() ;
  ::int32_t sdk() const;
  void set_sdk(::int32_t value);

  private:
  ::int32_t _internal_sdk() const;
  void _internal_set_sdk(::int32_t value);

  public:
  // optional int32 day = 11;
  bool has_day() const;
  void clear_day() ;
  ::int32_t day() const;
  void set_day(::int32_t value);

  private:
  ::int32_t _internal_day() const;
  void _internal_set_day(::int32_t value);

  public:
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskAddOneMail];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.AskAddMailReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 1,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int64_t> useridlist_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr gift_;
    ::google::protobuf::internal::ArenaStringPtr createtime_;
    ::google::protobuf::internal::ArenaStringPtr endtime_;
    ::google::protobuf::internal::ArenaStringPtr sender_;
    ::int32_t type_;
    ::int32_t sdk_;
    ::int32_t day_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};
// -------------------------------------------------------------------

class CreateCDKey final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:RCToCS.CreateCDKey) */ {
 public:
  inline CreateCDKey() : CreateCDKey(nullptr) {}
  ~CreateCDKey() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateCDKey(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateCDKey(const CreateCDKey& from) : CreateCDKey(nullptr, from) {}
  inline CreateCDKey(CreateCDKey&& from) noexcept
      : CreateCDKey(nullptr, std::move(from)) {}
  inline CreateCDKey& operator=(const CreateCDKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateCDKey& operator=(CreateCDKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateCDKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateCDKey* internal_default_instance() {
    return reinterpret_cast<const CreateCDKey*>(
        &_CreateCDKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CreateCDKey& a, CreateCDKey& b) { a.Swap(&b); }
  inline void Swap(CreateCDKey* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateCDKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateCDKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CreateCDKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateCDKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateCDKey& from) { CreateCDKey::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateCDKey* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "RCToCS.CreateCDKey"; }

 protected:
  explicit CreateCDKey(::google::protobuf::Arena* arena);
  CreateCDKey(::google::protobuf::Arena* arena, const CreateCDKey& from);
  CreateCDKey(::google::protobuf::Arena* arena, CreateCDKey&& from) noexcept
      : CreateCDKey(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using giftInfo = CreateCDKey_giftInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kGiftFieldNumber = 7,
    kCdkeyFieldNumber = 9,
    kTitleFieldNumber = 2,
    kContentFieldNumber = 5,
    kEndTimeFieldNumber = 4,
    kPlatformFieldNumber = 3,
    kGiftTypeFieldNumber = 6,
    kCodeLenFieldNumber = 8,
    kMsgidFieldNumber = 1,
  };
  // repeated .RCToCS.CreateCDKey.giftInfo gift = 7;
  int gift_size() const;
  private:
  int _internal_gift_size() const;

  public:
  void clear_gift() ;
  ::RCToCS::CreateCDKey_giftInfo* mutable_gift(int index);
  ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>* mutable_gift();

  private:
  const ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>& _internal_gift() const;
  ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>* _internal_mutable_gift();
  public:
  const ::RCToCS::CreateCDKey_giftInfo& gift(int index) const;
  ::RCToCS::CreateCDKey_giftInfo* add_gift();
  const ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>& gift() const;
  // repeated string cdkey = 9;
  int cdkey_size() const;
  private:
  int _internal_cdkey_size() const;

  public:
  void clear_cdkey() ;
  const std::string& cdkey(int index) const;
  std::string* mutable_cdkey(int index);
  void set_cdkey(int index, const std::string& value);
  void set_cdkey(int index, std::string&& value);
  void set_cdkey(int index, const char* value);
  void set_cdkey(int index, const char* value, std::size_t size);
  void set_cdkey(int index, absl::string_view value);
  std::string* add_cdkey();
  void add_cdkey(const std::string& value);
  void add_cdkey(std::string&& value);
  void add_cdkey(const char* value);
  void add_cdkey(const char* value, std::size_t size);
  void add_cdkey(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& cdkey() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cdkey();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cdkey() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cdkey();

  public:
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string content = 5;
  bool has_content() const;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // optional uint64 end_time = 4;
  bool has_end_time() const;
  void clear_end_time() ;
  ::uint64_t end_time() const;
  void set_end_time(::uint64_t value);

  private:
  ::uint64_t _internal_end_time() const;
  void _internal_set_end_time(::uint64_t value);

  public:
  // optional int32 platform = 3;
  bool has_platform() const;
  void clear_platform() ;
  ::int32_t platform() const;
  void set_platform(::int32_t value);

  private:
  ::int32_t _internal_platform() const;
  void _internal_set_platform(::int32_t value);

  public:
  // optional int32 gift_type = 6;
  bool has_gift_type() const;
  void clear_gift_type() ;
  ::int32_t gift_type() const;
  void set_gift_type(::int32_t value);

  private:
  ::int32_t _internal_gift_type() const;
  void _internal_set_gift_type(::int32_t value);

  public:
  // optional int32 code_len = 8;
  bool has_code_len() const;
  void clear_code_len() ;
  ::int32_t code_len() const;
  void set_code_len(::int32_t value);

  private:
  ::int32_t _internal_code_len() const;
  void _internal_set_code_len(::int32_t value);

  public:
  // optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskCreateCDKey];
  bool has_msgid() const;
  void clear_msgid() ;
  ::RCToCS::MsgID msgid() const;
  void set_msgid(::RCToCS::MsgID value);

  private:
  ::RCToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::RCToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:RCToCS.CreateCDKey)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::RCToCS::CreateCDKey_giftInfo > gift_;
    ::google::protobuf::RepeatedPtrField<std::string> cdkey_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::uint64_t end_time_;
    ::int32_t platform_;
    ::int32_t gift_type_;
    ::int32_t code_len_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RCToCS_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// QueryCDKey

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskQueryCDkey];
inline bool QueryCDKey::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryCDKey::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33009;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::RCToCS::MsgID QueryCDKey::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.QueryCDKey.msgid)
  return _internal_msgid();
}
inline void QueryCDKey::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:RCToCS.QueryCDKey.msgid)
}
inline ::RCToCS::MsgID QueryCDKey::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void QueryCDKey::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// CreateCDKey_giftInfo

// optional int32 item_id = 1;
inline bool CreateCDKey_giftInfo::has_item_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CreateCDKey_giftInfo::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t CreateCDKey_giftInfo::item_id() const {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.giftInfo.item_id)
  return _internal_item_id();
}
inline void CreateCDKey_giftInfo::set_item_id(::int32_t value) {
  _internal_set_item_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.giftInfo.item_id)
}
inline ::int32_t CreateCDKey_giftInfo::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_;
}
inline void CreateCDKey_giftInfo::_internal_set_item_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = value;
}

// optional int32 item_num = 2;
inline bool CreateCDKey_giftInfo::has_item_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CreateCDKey_giftInfo::clear_item_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CreateCDKey_giftInfo::item_num() const {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.giftInfo.item_num)
  return _internal_item_num();
}
inline void CreateCDKey_giftInfo::set_item_num(::int32_t value) {
  _internal_set_item_num(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.giftInfo.item_num)
}
inline ::int32_t CreateCDKey_giftInfo::_internal_item_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_num_;
}
inline void CreateCDKey_giftInfo::_internal_set_item_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = value;
}

// -------------------------------------------------------------------

// CreateCDKey

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskCreateCDKey];
inline bool CreateCDKey::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CreateCDKey::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33008;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::RCToCS::MsgID CreateCDKey::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.msgid)
  return _internal_msgid();
}
inline void CreateCDKey::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.msgid)
}
inline ::RCToCS::MsgID CreateCDKey::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void CreateCDKey::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string title = 2;
inline bool CreateCDKey::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CreateCDKey::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CreateCDKey::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateCDKey::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.title)
}
inline std::string* CreateCDKey::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:RCToCS.CreateCDKey.title)
  return _s;
}
inline const std::string& CreateCDKey::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void CreateCDKey::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* CreateCDKey::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* CreateCDKey::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.CreateCDKey.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CreateCDKey::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.CreateCDKey.title)
}

// optional int32 platform = 3;
inline bool CreateCDKey::has_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CreateCDKey::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t CreateCDKey::platform() const {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.platform)
  return _internal_platform();
}
inline void CreateCDKey::set_platform(::int32_t value) {
  _internal_set_platform(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.platform)
}
inline ::int32_t CreateCDKey::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_;
}
inline void CreateCDKey::_internal_set_platform(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = value;
}

// optional uint64 end_time = 4;
inline bool CreateCDKey::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CreateCDKey::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t CreateCDKey::end_time() const {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.end_time)
  return _internal_end_time();
}
inline void CreateCDKey::set_end_time(::uint64_t value) {
  _internal_set_end_time(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.end_time)
}
inline ::uint64_t CreateCDKey::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void CreateCDKey::_internal_set_end_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = value;
}

// optional string content = 5;
inline bool CreateCDKey::has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CreateCDKey::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CreateCDKey::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateCDKey::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.content)
}
inline std::string* CreateCDKey::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:RCToCS.CreateCDKey.content)
  return _s;
}
inline const std::string& CreateCDKey::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void CreateCDKey::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* CreateCDKey::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* CreateCDKey::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.CreateCDKey.content)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.content_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CreateCDKey::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.CreateCDKey.content)
}

// optional int32 gift_type = 6;
inline bool CreateCDKey::has_gift_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CreateCDKey::clear_gift_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gift_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t CreateCDKey::gift_type() const {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.gift_type)
  return _internal_gift_type();
}
inline void CreateCDKey::set_gift_type(::int32_t value) {
  _internal_set_gift_type(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.gift_type)
}
inline ::int32_t CreateCDKey::_internal_gift_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gift_type_;
}
inline void CreateCDKey::_internal_set_gift_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gift_type_ = value;
}

// repeated .RCToCS.CreateCDKey.giftInfo gift = 7;
inline int CreateCDKey::_internal_gift_size() const {
  return _internal_gift().size();
}
inline int CreateCDKey::gift_size() const {
  return _internal_gift_size();
}
inline void CreateCDKey::clear_gift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gift_.Clear();
}
inline ::RCToCS::CreateCDKey_giftInfo* CreateCDKey::mutable_gift(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RCToCS.CreateCDKey.gift)
  return _internal_mutable_gift()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>* CreateCDKey::mutable_gift()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RCToCS.CreateCDKey.gift)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_gift();
}
inline const ::RCToCS::CreateCDKey_giftInfo& CreateCDKey::gift(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.gift)
  return _internal_gift().Get(index);
}
inline ::RCToCS::CreateCDKey_giftInfo* CreateCDKey::add_gift() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::RCToCS::CreateCDKey_giftInfo* _add = _internal_mutable_gift()->Add();
  // @@protoc_insertion_point(field_add:RCToCS.CreateCDKey.gift)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>& CreateCDKey::gift() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RCToCS.CreateCDKey.gift)
  return _internal_gift();
}
inline const ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>&
CreateCDKey::_internal_gift() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gift_;
}
inline ::google::protobuf::RepeatedPtrField<::RCToCS::CreateCDKey_giftInfo>*
CreateCDKey::_internal_mutable_gift() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.gift_;
}

// optional int32 code_len = 8;
inline bool CreateCDKey::has_code_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CreateCDKey::clear_code_len() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_len_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t CreateCDKey::code_len() const {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.code_len)
  return _internal_code_len();
}
inline void CreateCDKey::set_code_len(::int32_t value) {
  _internal_set_code_len(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.code_len)
}
inline ::int32_t CreateCDKey::_internal_code_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_len_;
}
inline void CreateCDKey::_internal_set_code_len(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_len_ = value;
}

// repeated string cdkey = 9;
inline int CreateCDKey::_internal_cdkey_size() const {
  return _internal_cdkey().size();
}
inline int CreateCDKey::cdkey_size() const {
  return _internal_cdkey_size();
}
inline void CreateCDKey::clear_cdkey() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cdkey_.Clear();
}
inline std::string* CreateCDKey::add_cdkey()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_cdkey()->Add();
  // @@protoc_insertion_point(field_add_mutable:RCToCS.CreateCDKey.cdkey)
  return _s;
}
inline const std::string& CreateCDKey::cdkey(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.CreateCDKey.cdkey)
  return _internal_cdkey().Get(index);
}
inline std::string* CreateCDKey::mutable_cdkey(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:RCToCS.CreateCDKey.cdkey)
  return _internal_mutable_cdkey()->Mutable(index);
}
inline void CreateCDKey::set_cdkey(int index, const std::string& value) {
  _internal_mutable_cdkey()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::set_cdkey(int index, std::string&& value) {
  _internal_mutable_cdkey()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::set_cdkey(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_cdkey()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::set_cdkey(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_cdkey()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::set_cdkey(int index, absl::string_view value) {
  _internal_mutable_cdkey()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::add_cdkey(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cdkey()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::add_cdkey(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cdkey()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::add_cdkey(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cdkey()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::add_cdkey(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cdkey()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:RCToCS.CreateCDKey.cdkey)
}
inline void CreateCDKey::add_cdkey(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_cdkey()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:RCToCS.CreateCDKey.cdkey)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateCDKey::cdkey() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RCToCS.CreateCDKey.cdkey)
  return _internal_cdkey();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateCDKey::mutable_cdkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RCToCS.CreateCDKey.cdkey)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_cdkey();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateCDKey::_internal_cdkey() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cdkey_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateCDKey::_internal_mutable_cdkey() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.cdkey_;
}

// -------------------------------------------------------------------

// AskAddMailReq

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskAddOneMail];
inline bool AskAddMailReq::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void AskAddMailReq::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33007;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::RCToCS::MsgID AskAddMailReq::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.msgid)
  return _internal_msgid();
}
inline void AskAddMailReq::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.msgid)
}
inline ::RCToCS::MsgID AskAddMailReq::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void AskAddMailReq::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 type = 2;
inline bool AskAddMailReq::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void AskAddMailReq::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t AskAddMailReq::type() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.type)
  return _internal_type();
}
inline void AskAddMailReq::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.type)
}
inline ::int32_t AskAddMailReq::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void AskAddMailReq::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional int32 sdk = 3;
inline bool AskAddMailReq::has_sdk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void AskAddMailReq::clear_sdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdk_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t AskAddMailReq::sdk() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.sdk)
  return _internal_sdk();
}
inline void AskAddMailReq::set_sdk(::int32_t value) {
  _internal_set_sdk(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.sdk)
}
inline ::int32_t AskAddMailReq::_internal_sdk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdk_;
}
inline void AskAddMailReq::_internal_set_sdk(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdk_ = value;
}

// optional string title = 4;
inline bool AskAddMailReq::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskAddMailReq::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskAddMailReq::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddMailReq::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.title)
}
inline std::string* AskAddMailReq::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddMailReq.title)
  return _s;
}
inline const std::string& AskAddMailReq::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void AskAddMailReq::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* AskAddMailReq::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* AskAddMailReq::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddMailReq.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddMailReq::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddMailReq.title)
}

// optional string content = 5;
inline bool AskAddMailReq::has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskAddMailReq::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AskAddMailReq::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddMailReq::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.content)
}
inline std::string* AskAddMailReq::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddMailReq.content)
  return _s;
}
inline const std::string& AskAddMailReq::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void AskAddMailReq::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* AskAddMailReq::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* AskAddMailReq::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddMailReq.content)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.content_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddMailReq::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddMailReq.content)
}

// optional string gift = 6;
inline bool AskAddMailReq::has_gift() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskAddMailReq::clear_gift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gift_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& AskAddMailReq::gift() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.gift)
  return _internal_gift();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddMailReq::set_gift(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gift_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.gift)
}
inline std::string* AskAddMailReq::mutable_gift() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gift();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddMailReq.gift)
  return _s;
}
inline const std::string& AskAddMailReq::_internal_gift() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gift_.Get();
}
inline void AskAddMailReq::_internal_set_gift(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gift_.Set(value, GetArena());
}
inline std::string* AskAddMailReq::_internal_mutable_gift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.gift_.Mutable( GetArena());
}
inline std::string* AskAddMailReq::release_gift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddMailReq.gift)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.gift_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gift_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddMailReq::set_allocated_gift(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gift_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gift_.IsDefault()) {
          _impl_.gift_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddMailReq.gift)
}

// optional string createtime = 7;
inline bool AskAddMailReq::has_createtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AskAddMailReq::clear_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& AskAddMailReq::createtime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.createtime)
  return _internal_createtime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddMailReq::set_createtime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.createtime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.createtime)
}
inline std::string* AskAddMailReq::mutable_createtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddMailReq.createtime)
  return _s;
}
inline const std::string& AskAddMailReq::_internal_createtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.createtime_.Get();
}
inline void AskAddMailReq::_internal_set_createtime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.createtime_.Set(value, GetArena());
}
inline std::string* AskAddMailReq::_internal_mutable_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.createtime_.Mutable( GetArena());
}
inline std::string* AskAddMailReq::release_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddMailReq.createtime)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.createtime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.createtime_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddMailReq::set_allocated_createtime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.createtime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.createtime_.IsDefault()) {
          _impl_.createtime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddMailReq.createtime)
}

// optional string endtime = 8;
inline bool AskAddMailReq::has_endtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AskAddMailReq::clear_endtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endtime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& AskAddMailReq::endtime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.endtime)
  return _internal_endtime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddMailReq::set_endtime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.endtime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.endtime)
}
inline std::string* AskAddMailReq::mutable_endtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_endtime();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddMailReq.endtime)
  return _s;
}
inline const std::string& AskAddMailReq::_internal_endtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endtime_.Get();
}
inline void AskAddMailReq::_internal_set_endtime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.endtime_.Set(value, GetArena());
}
inline std::string* AskAddMailReq::_internal_mutable_endtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.endtime_.Mutable( GetArena());
}
inline std::string* AskAddMailReq::release_endtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddMailReq.endtime)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.endtime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.endtime_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddMailReq::set_allocated_endtime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.endtime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.endtime_.IsDefault()) {
          _impl_.endtime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddMailReq.endtime)
}

// optional string sender = 9;
inline bool AskAddMailReq::has_sender() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void AskAddMailReq::clear_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& AskAddMailReq::sender() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddMailReq::set_sender(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.sender)
}
inline std::string* AskAddMailReq::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddMailReq.sender)
  return _s;
}
inline const std::string& AskAddMailReq::_internal_sender() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_.Get();
}
inline void AskAddMailReq::_internal_set_sender(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sender_.Set(value, GetArena());
}
inline std::string* AskAddMailReq::_internal_mutable_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.sender_.Mutable( GetArena());
}
inline std::string* AskAddMailReq::release_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddMailReq.sender)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.sender_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sender_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddMailReq::set_allocated_sender(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sender_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddMailReq.sender)
}

// repeated int64 userIdlist = 10;
inline int AskAddMailReq::_internal_useridlist_size() const {
  return _internal_useridlist().size();
}
inline int AskAddMailReq::useridlist_size() const {
  return _internal_useridlist_size();
}
inline void AskAddMailReq::clear_useridlist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.useridlist_.Clear();
}
inline ::int64_t AskAddMailReq::useridlist(int index) const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.userIdlist)
  return _internal_useridlist().Get(index);
}
inline void AskAddMailReq::set_useridlist(int index, ::int64_t value) {
  _internal_mutable_useridlist()->Set(index, value);
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.userIdlist)
}
inline void AskAddMailReq::add_useridlist(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_useridlist()->Add(value);
  // @@protoc_insertion_point(field_add:RCToCS.AskAddMailReq.userIdlist)
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AskAddMailReq::useridlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:RCToCS.AskAddMailReq.userIdlist)
  return _internal_useridlist();
}
inline ::google::protobuf::RepeatedField<::int64_t>* AskAddMailReq::mutable_useridlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:RCToCS.AskAddMailReq.userIdlist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_useridlist();
}
inline const ::google::protobuf::RepeatedField<::int64_t>& AskAddMailReq::_internal_useridlist()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.useridlist_;
}
inline ::google::protobuf::RepeatedField<::int64_t>* AskAddMailReq::_internal_mutable_useridlist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.useridlist_;
}

// optional int32 day = 11;
inline bool AskAddMailReq::has_day() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void AskAddMailReq::clear_day() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.day_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t AskAddMailReq::day() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddMailReq.day)
  return _internal_day();
}
inline void AskAddMailReq::set_day(::int32_t value) {
  _internal_set_day(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddMailReq.day)
}
inline ::int32_t AskAddMailReq::_internal_day() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.day_;
}
inline void AskAddMailReq::_internal_set_day(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.day_ = value;
}

// -------------------------------------------------------------------

// AskRegist

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskRegist];
inline bool AskRegist::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskRegist::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33001;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::RCToCS::MsgID AskRegist::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskRegist.msgid)
  return _internal_msgid();
}
inline void AskRegist::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:RCToCS.AskRegist.msgid)
}
inline ::RCToCS::MsgID AskRegist::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void AskRegist::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional bytes key = 2;
inline bool AskRegist::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRegist::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskRegist::key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskRegist.key)
  return _internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskRegist::set_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskRegist.key)
}
inline std::string* AskRegist::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskRegist.key)
  return _s;
}
inline const std::string& AskRegist::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_.Get();
}
inline void AskRegist::_internal_set_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_.Set(value, GetArena());
}
inline std::string* AskRegist::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.key_.Mutable( GetArena());
}
inline std::string* AskRegist::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskRegist.key)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.key_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.key_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskRegist::set_allocated_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_.IsDefault()) {
          _impl_.key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskRegist.key)
}

// -------------------------------------------------------------------

// AskServerInfo

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskServerInfo];
inline bool AskServerInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskServerInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33002;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::RCToCS::MsgID AskServerInfo::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskServerInfo.msgid)
  return _internal_msgid();
}
inline void AskServerInfo::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:RCToCS.AskServerInfo.msgid)
}
inline ::RCToCS::MsgID AskServerInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void AskServerInfo::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// AskServerUserInfo

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskServerUserInfo];
inline bool AskServerUserInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskServerUserInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33003;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::RCToCS::MsgID AskServerUserInfo::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskServerUserInfo.msgid)
  return _internal_msgid();
}
inline void AskServerUserInfo::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:RCToCS.AskServerUserInfo.msgid)
}
inline ::RCToCS::MsgID AskServerUserInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void AskServerUserInfo::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// AskNoticeInfo

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskNoticeInfo];
inline bool AskNoticeInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskNoticeInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33004;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::RCToCS::MsgID AskNoticeInfo::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskNoticeInfo.msgid)
  return _internal_msgid();
}
inline void AskNoticeInfo::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:RCToCS.AskNoticeInfo.msgid)
}
inline ::RCToCS::MsgID AskNoticeInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void AskNoticeInfo::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// AskAddNotice

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskAddNotice];
inline bool AskAddNotice::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void AskAddNotice::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33005;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::RCToCS::MsgID AskAddNotice::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.msgid)
  return _internal_msgid();
}
inline void AskAddNotice::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.msgid)
}
inline ::RCToCS::MsgID AskAddNotice::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void AskAddNotice::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 platform = 2;
inline bool AskAddNotice::has_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskAddNotice::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AskAddNotice::platform() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.platform)
  return _internal_platform();
}
inline void AskAddNotice::set_platform(::int32_t value) {
  _internal_set_platform(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.platform)
}
inline ::int32_t AskAddNotice::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_;
}
inline void AskAddNotice::_internal_set_platform(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = value;
}

// optional bytes title = 3;
inline bool AskAddNotice::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskAddNotice::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskAddNotice::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddNotice::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.title)
}
inline std::string* AskAddNotice::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddNotice.title)
  return _s;
}
inline const std::string& AskAddNotice::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void AskAddNotice::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* AskAddNotice::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* AskAddNotice::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddNotice.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddNotice::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddNotice.title)
}

// optional int32 flag = 4;
inline bool AskAddNotice::has_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AskAddNotice::clear_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t AskAddNotice::flag() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.flag)
  return _internal_flag();
}
inline void AskAddNotice::set_flag(::int32_t value) {
  _internal_set_flag(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.flag)
}
inline ::int32_t AskAddNotice::_internal_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_;
}
inline void AskAddNotice::_internal_set_flag(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = value;
}

// optional int32 state = 5;
inline bool AskAddNotice::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AskAddNotice::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t AskAddNotice::state() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.state)
  return _internal_state();
}
inline void AskAddNotice::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.state)
}
inline ::int32_t AskAddNotice::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void AskAddNotice::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// optional int32 priority = 6;
inline bool AskAddNotice::has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void AskAddNotice::clear_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t AskAddNotice::priority() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.priority)
  return _internal_priority();
}
inline void AskAddNotice::set_priority(::int32_t value) {
  _internal_set_priority(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.priority)
}
inline ::int32_t AskAddNotice::_internal_priority() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.priority_;
}
inline void AskAddNotice::_internal_set_priority(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_ = value;
}

// optional bytes noticeMsg = 7;
inline bool AskAddNotice::has_noticemsg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskAddNotice::clear_noticemsg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noticemsg_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AskAddNotice::noticemsg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.noticeMsg)
  return _internal_noticemsg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddNotice::set_noticemsg(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.noticemsg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.noticeMsg)
}
inline std::string* AskAddNotice::mutable_noticemsg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_noticemsg();
  // @@protoc_insertion_point(field_mutable:RCToCS.AskAddNotice.noticeMsg)
  return _s;
}
inline const std::string& AskAddNotice::_internal_noticemsg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noticemsg_.Get();
}
inline void AskAddNotice::_internal_set_noticemsg(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.noticemsg_.Set(value, GetArena());
}
inline std::string* AskAddNotice::_internal_mutable_noticemsg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.noticemsg_.Mutable( GetArena());
}
inline std::string* AskAddNotice::release_noticemsg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:RCToCS.AskAddNotice.noticeMsg)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.noticemsg_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.noticemsg_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddNotice::set_allocated_noticemsg(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.noticemsg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.noticemsg_.IsDefault()) {
          _impl_.noticemsg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RCToCS.AskAddNotice.noticeMsg)
}

// optional uint64 star_time = 8;
inline bool AskAddNotice::has_star_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void AskAddNotice::clear_star_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.star_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t AskAddNotice::star_time() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.star_time)
  return _internal_star_time();
}
inline void AskAddNotice::set_star_time(::uint64_t value) {
  _internal_set_star_time(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.star_time)
}
inline ::uint64_t AskAddNotice::_internal_star_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.star_time_;
}
inline void AskAddNotice::_internal_set_star_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.star_time_ = value;
}

// optional uint64 end_time = 9;
inline bool AskAddNotice::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void AskAddNotice::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t AskAddNotice::end_time() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskAddNotice.end_time)
  return _internal_end_time();
}
inline void AskAddNotice::set_end_time(::uint64_t value) {
  _internal_set_end_time(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:RCToCS.AskAddNotice.end_time)
}
inline ::uint64_t AskAddNotice::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void AskAddNotice::_internal_set_end_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = value;
}

// -------------------------------------------------------------------

// AskDeleteNotice

// optional .RCToCS.MsgID msgid = 1 [default = eMsgRC2CS_AskDeleteNotice];
inline bool AskDeleteNotice::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskDeleteNotice::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 33006;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::RCToCS::MsgID AskDeleteNotice::msgid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskDeleteNotice.msgid)
  return _internal_msgid();
}
inline void AskDeleteNotice::set_msgid(::RCToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:RCToCS.AskDeleteNotice.msgid)
}
inline ::RCToCS::MsgID AskDeleteNotice::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::RCToCS::MsgID>(_impl_.msgid_);
}
inline void AskDeleteNotice::_internal_set_msgid(::RCToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::RCToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 noticeId = 2;
inline bool AskDeleteNotice::has_noticeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskDeleteNotice::clear_noticeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noticeid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskDeleteNotice::noticeid() const {
  // @@protoc_insertion_point(field_get:RCToCS.AskDeleteNotice.noticeId)
  return _internal_noticeid();
}
inline void AskDeleteNotice::set_noticeid(::int32_t value) {
  _internal_set_noticeid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:RCToCS.AskDeleteNotice.noticeId)
}
inline ::int32_t AskDeleteNotice::_internal_noticeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.noticeid_;
}
inline void AskDeleteNotice::_internal_set_noticeid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.noticeid_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace RCToCS


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::RCToCS::MsgID> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::RCToCS::MsgID>() {
  return ::RCToCS::MsgID_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_RCToCS_2eproto_2epb_2eh
