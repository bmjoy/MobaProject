// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GCToCS.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_GCToCS_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_GCToCS_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_GCToCS_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_GCToCS_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_GCToCS_2eproto;
namespace GCToCS {
class AddCSGMCmd;
struct AddCSGMCmdDefaultTypeInternal;
extern AddCSGMCmdDefaultTypeInternal _AddCSGMCmd_default_instance_;
class AskAddMatchTeam;
struct AskAddMatchTeamDefaultTypeInternal;
extern AskAddMatchTeamDefaultTypeInternal _AskAddMatchTeam_default_instance_;
class AskAddRoom;
struct AskAddRoomDefaultTypeInternal;
extern AskAddRoomDefaultTypeInternal _AskAddRoom_default_instance_;
class AskAddToSNSList;
struct AskAddToSNSListDefaultTypeInternal;
extern AskAddToSNSListDefaultTypeInternal _AskAddToSNSList_default_instance_;
class AskAddToSNSListByID;
struct AskAddToSNSListByIDDefaultTypeInternal;
extern AskAddToSNSListByIDDefaultTypeInternal _AskAddToSNSListByID_default_instance_;
class AskBuyGoods;
struct AskBuyGoodsDefaultTypeInternal;
extern AskBuyGoodsDefaultTypeInternal _AskBuyGoods_default_instance_;
class AskCSCreateGuideBattle;
struct AskCSCreateGuideBattleDefaultTypeInternal;
extern AskCSCreateGuideBattleDefaultTypeInternal _AskCSCreateGuideBattle_default_instance_;
class AskCanInviteFriends;
struct AskCanInviteFriendsDefaultTypeInternal;
extern AskCanInviteFriendsDefaultTypeInternal _AskCanInviteFriends_default_instance_;
class AskCancelRoom;
struct AskCancelRoomDefaultTypeInternal;
extern AskCancelRoomDefaultTypeInternal _AskCancelRoom_default_instance_;
class AskChangeRoomSeat;
struct AskChangeRoomSeatDefaultTypeInternal;
extern AskChangeRoomSeatDefaultTypeInternal _AskChangeRoomSeat_default_instance_;
class AskChangeheaderId;
struct AskChangeheaderIdDefaultTypeInternal;
extern AskChangeheaderIdDefaultTypeInternal _AskChangeheaderId_default_instance_;
class AskChatInRoom;
struct AskChatInRoomDefaultTypeInternal;
extern AskChatInRoomDefaultTypeInternal _AskChatInRoom_default_instance_;
class AskCreateMatchTeam;
struct AskCreateMatchTeamDefaultTypeInternal;
extern AskCreateMatchTeamDefaultTypeInternal _AskCreateMatchTeam_default_instance_;
class AskCreateRoom;
struct AskCreateRoomDefaultTypeInternal;
extern AskCreateRoomDefaultTypeInternal _AskCreateRoom_default_instance_;
class AskCurtNotice;
struct AskCurtNoticeDefaultTypeInternal;
extern AskCurtNoticeDefaultTypeInternal _AskCurtNotice_default_instance_;
class AskGetMailGift;
struct AskGetMailGiftDefaultTypeInternal;
extern AskGetMailGiftDefaultTypeInternal _AskGetMailGift_default_instance_;
class AskGoodscfg;
struct AskGoodscfgDefaultTypeInternal;
extern AskGoodscfgDefaultTypeInternal _AskGoodscfg_default_instance_;
class AskInviteFriendsToBattle;
struct AskInviteFriendsToBattleDefaultTypeInternal;
extern AskInviteFriendsToBattleDefaultTypeInternal _AskInviteFriendsToBattle_default_instance_;
class AskInviteJoinMatchTeam;
struct AskInviteJoinMatchTeamDefaultTypeInternal;
extern AskInviteJoinMatchTeamDefaultTypeInternal _AskInviteJoinMatchTeam_default_instance_;
class AskLeaveRoom;
struct AskLeaveRoomDefaultTypeInternal;
extern AskLeaveRoomDefaultTypeInternal _AskLeaveRoom_default_instance_;
class AskMailInfo;
struct AskMailInfoDefaultTypeInternal;
extern AskMailInfoDefaultTypeInternal _AskMailInfo_default_instance_;
class AskOneTaskRewards;
struct AskOneTaskRewardsDefaultTypeInternal;
extern AskOneTaskRewardsDefaultTypeInternal _AskOneTaskRewards_default_instance_;
class AskQueryUserByNickName;
struct AskQueryUserByNickNameDefaultTypeInternal;
extern AskQueryUserByNickNameDefaultTypeInternal _AskQueryUserByNickName_default_instance_;
class AskQuickBattle;
struct AskQuickBattleDefaultTypeInternal;
extern AskQuickBattleDefaultTypeInternal _AskQuickBattle_default_instance_;
class AskReEnterRoom;
struct AskReEnterRoomDefaultTypeInternal;
extern AskReEnterRoomDefaultTypeInternal _AskReEnterRoom_default_instance_;
class AskReadyRoom;
struct AskReadyRoomDefaultTypeInternal;
extern AskReadyRoomDefaultTypeInternal _AskReadyRoom_default_instance_;
class AskRecoinRune;
struct AskRecoinRuneDefaultTypeInternal;
extern AskRecoinRuneDefaultTypeInternal _AskRecoinRune_default_instance_;
class AskRemoveFromSNSList;
struct AskRemoveFromSNSListDefaultTypeInternal;
extern AskRemoveFromSNSListDefaultTypeInternal _AskRemoveFromSNSList_default_instance_;
class AskRemoveMatchTeam;
struct AskRemoveMatchTeamDefaultTypeInternal;
extern AskRemoveMatchTeamDefaultTypeInternal _AskRemoveMatchTeam_default_instance_;
class AskRoomList;
struct AskRoomListDefaultTypeInternal;
extern AskRoomListDefaultTypeInternal _AskRoomList_default_instance_;
class AskSendMsgToUser;
struct AskSendMsgToUserDefaultTypeInternal;
extern AskSendMsgToUserDefaultTypeInternal _AskSendMsgToUser_default_instance_;
class AskStartMatch;
struct AskStartMatchDefaultTypeInternal;
extern AskStartMatchDefaultTypeInternal _AskStartMatch_default_instance_;
class AskStartRoom;
struct AskStartRoomDefaultTypeInternal;
extern AskStartRoomDefaultTypeInternal _AskStartRoom_default_instance_;
class AskStopMatch;
struct AskStopMatchDefaultTypeInternal;
extern AskStopMatchDefaultTypeInternal _AskStopMatch_default_instance_;
class AskStopQuickBattle;
struct AskStopQuickBattleDefaultTypeInternal;
extern AskStopQuickBattleDefaultTypeInternal _AskStopQuickBattle_default_instance_;
class BlackListOnlineInfo;
struct BlackListOnlineInfoDefaultTypeInternal;
extern BlackListOnlineInfoDefaultTypeInternal _BlackListOnlineInfo_default_instance_;
class BuyRunes;
struct BuyRunesDefaultTypeInternal;
extern BuyRunesDefaultTypeInternal _BuyRunes_default_instance_;
class CDKReq;
struct CDKReqDefaultTypeInternal;
extern CDKReqDefaultTypeInternal _CDKReq_default_instance_;
class ChangeNickName;
struct ChangeNickNameDefaultTypeInternal;
extern ChangeNickNameDefaultTypeInternal _ChangeNickName_default_instance_;
class ComGuideStepID;
struct ComGuideStepIDDefaultTypeInternal;
extern ComGuideStepIDDefaultTypeInternal _ComGuideStepID_default_instance_;
class CompleteInfo;
struct CompleteInfoDefaultTypeInternal;
extern CompleteInfoDefaultTypeInternal _CompleteInfo_default_instance_;
class ComposeRunes;
struct ComposeRunesDefaultTypeInternal;
extern ComposeRunesDefaultTypeInternal _ComposeRunes_default_instance_;
class CurtUIEvent;
struct CurtUIEventDefaultTypeInternal;
extern CurtUIEventDefaultTypeInternal _CurtUIEvent_default_instance_;
class CurtUIEvent_UIEvent;
struct CurtUIEvent_UIEventDefaultTypeInternal;
extern CurtUIEvent_UIEventDefaultTypeInternal _CurtUIEvent_UIEvent_default_instance_;
class EuipRunes;
struct EuipRunesDefaultTypeInternal;
extern EuipRunesDefaultTypeInternal _EuipRunes_default_instance_;
class GCReplyAddFriendRequst;
struct GCReplyAddFriendRequstDefaultTypeInternal;
extern GCReplyAddFriendRequstDefaultTypeInternal _GCReplyAddFriendRequst_default_instance_;
class GCReplyInviteToBattle;
struct GCReplyInviteToBattleDefaultTypeInternal;
extern GCReplyInviteToBattleDefaultTypeInternal _GCReplyInviteToBattle_default_instance_;
class GuideCSStepComp;
struct GuideCSStepCompDefaultTypeInternal;
extern GuideCSStepCompDefaultTypeInternal _GuideCSStepComp_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Notice;
struct NoticeDefaultTypeInternal;
extern NoticeDefaultTypeInternal _Notice_default_instance_;
class NotifyOneMatchNeedOneRet;
struct NotifyOneMatchNeedOneRetDefaultTypeInternal;
extern NotifyOneMatchNeedOneRetDefaultTypeInternal _NotifyOneMatchNeedOneRet_default_instance_;
class ReconnectToGame;
struct ReconnectToGameDefaultTypeInternal;
extern ReconnectToGameDefaultTypeInternal _ReconnectToGame_default_instance_;
class RequestMatchTeamList;
struct RequestMatchTeamListDefaultTypeInternal;
extern RequestMatchTeamListDefaultTypeInternal _RequestMatchTeamList_default_instance_;
class UnEuipRunes;
struct UnEuipRunesDefaultTypeInternal;
extern UnEuipRunesDefaultTypeInternal _UnEuipRunes_default_instance_;
class UserAskGetCLReward;
struct UserAskGetCLRewardDefaultTypeInternal;
extern UserAskGetCLRewardDefaultTypeInternal _UserAskGetCLReward_default_instance_;
class UserGameInfo;
struct UserGameInfoDefaultTypeInternal;
extern UserGameInfoDefaultTypeInternal _UserGameInfo_default_instance_;
}  // namespace GCToCS
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace GCToCS {
enum AskCSCreateGuideBattle_guidetype : int {
  AskCSCreateGuideBattle_guidetype_first = 1,
  AskCSCreateGuideBattle_guidetype_second = 2,
  AskCSCreateGuideBattle_guidetype_other = 3,
};

bool AskCSCreateGuideBattle_guidetype_IsValid(int value);
extern const uint32_t AskCSCreateGuideBattle_guidetype_internal_data_[];
constexpr AskCSCreateGuideBattle_guidetype AskCSCreateGuideBattle_guidetype_guidetype_MIN = static_cast<AskCSCreateGuideBattle_guidetype>(1);
constexpr AskCSCreateGuideBattle_guidetype AskCSCreateGuideBattle_guidetype_guidetype_MAX = static_cast<AskCSCreateGuideBattle_guidetype>(3);
constexpr int AskCSCreateGuideBattle_guidetype_guidetype_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AskCSCreateGuideBattle_guidetype_descriptor();
template <typename T>
const std::string& AskCSCreateGuideBattle_guidetype_Name(T value) {
  static_assert(std::is_same<T, AskCSCreateGuideBattle_guidetype>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to guidetype_Name().");
  return AskCSCreateGuideBattle_guidetype_Name(static_cast<AskCSCreateGuideBattle_guidetype>(value));
}
template <>
inline const std::string& AskCSCreateGuideBattle_guidetype_Name(AskCSCreateGuideBattle_guidetype value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AskCSCreateGuideBattle_guidetype_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool AskCSCreateGuideBattle_guidetype_Parse(absl::string_view name, AskCSCreateGuideBattle_guidetype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AskCSCreateGuideBattle_guidetype>(
      AskCSCreateGuideBattle_guidetype_descriptor(), name, value);
}
enum MsgNum : int {
  eMsgToGSToCSFromGC_Begin = 8191,
  eMsgToGSToCSFromGC_AskLogin = 8193,
  eMsgToGSToCSFromGC_AskReconnectGame = 8194,
  eMsgToGSToCSFromGC_AskComleteUserInfo = 8195,
  eMsgToGSToCSFromGC_AskUserGameInfo = 8196,
  eMsgToGSToCSFromGC_UserAskGetCLReward = 8197,
  eMsgToGSToCSFromGC_Notice = 8200,
  eMsgToGSToCSFromGC_AskCurtNotice = 8201,
  eMsgToGSToCSFromGC_AskAddToSNSList = 8210,
  eMsgToGSToCSFromGC_AskRemoveFromSNSList = 8211,
  eMsgToGSToCSFromGC_AskSendMsgToUser = 8212,
  eMsgToGSToCSFromGC_AskInviteFriendsToBattle = 8213,
  eMsgToGSToCSFromGC_AskQueryUserByNickName = 8214,
  eMsgToGSToCSFromGC_GCReplyAddFriendRequst = 8215,
  eMsgToGSToCSFromGC_GCReplyInviteToBattle = 8216,
  eMsgToGSToCSFromGC_AskAddToSNSListByID = 8217,
  eMsgToGSToCSFromGC_AskCanInviteFriends = 8218,
  eMsgToGSToCSFromGC_AskBlackListOnlineInfo = 8502,
  eMsgToGSToCSFromGC_BUYRunes = 8220,
  eMsgToGSToCSFromGC_EuipRunes = 8221,
  eMsgToGSToCSFromGC_UnloadRunes = 8222,
  eMsgToGSToCSFromGC_ComposeRunes = 8223,
  eMsgToGSToCSFromGC_AskBuyGoods = 8224,
  eMsgToGSToCSFromGC_AskRecoinRune = 8503,
  eMsgToGSToCSFromGC_AskMailInfo = 8230,
  eMsgToGSToCSFromGC_AskGetMailGift = 8231,
  eMsgToGSToCSFromGC_AskGuideBattle = 8240,
  eMsgToGSToCSFromGC_AskGuideStepId = 8241,
  eMsgToGSToCSFromGC_CompCSGuideStepId = 8242,
  eMsgToGSToCSFromGC_AskQuickBattle = 8250,
  eMsgToGSToCSFromGC_AskStopQuickBattle = 8251,
  eMsgToGSToCSFromGC_AskCreateRoom = 8260,
  eMsgToGSToCSFromGC_AskAddRoom = 8261,
  eMsgToGSToCSFromGC_AskLeaveRoom = 8262,
  eMsgToGSToCSFromGC_AskChangeRoomSeat = 8263,
  eMsgToGSToCSFromGC_AskReadyRoom = 8264,
  eMsgToGSToCSFromGC_AskCancelRoom = 8265,
  eMsgToGSToCSFromGC_AskStartRoom = 8266,
  eMsgToGSToCSFromGC_AskChatInRoom = 8267,
  eMsgToGSToCSFromGC_AskReEnterRoom = 8268,
  eMsgToGSToCSFromGC_AskRoomList = 8269,
  eMsgToGSToCSFromGC_AskGoodscfg = 8270,
  eMsgToGSToCSFromGC_AskCreateMatchTeam = 8280,
  eMsgToGSToCSFromGC_AskAddMatchTeam = 8281,
  eMsgToGSToCSFromGC_AskRemoveMatchTeam = 8282,
  eMsgToGSToCSFromGC_AskInviteJoinMatchTeam = 8283,
  eMsgToGSToCSFromGC_AskStartMatch = 8284,
  eMsgToGSToCSFromGC_AskStopMatch = 8285,
  eMsgToGSToCSFromGC_AskChangeNickName = 8286,
  eMsgToGSToCSFromGC_RequestMatchTeamList = 8287,
  eMsgToGSToCSFromGC_NotifyOneMatchNeedOneRet = 8288,
  eMsgToGSToCSFromGC_AskOneTaskRewards = 8290,
  eMsgToGSToCSFromGC_AskChangeheaderId = 8500,
  eMsgToGSToCSFromGC_CDKReq = 8505,
  eMsgToGSToCSFromGC_GmCmd = 8501,
  eMsgToGSToCSFromGC_UIEvent = 8550,
  eMsgToGSToCSFromGC_End = 9000,
};

bool MsgNum_IsValid(int value);
extern const uint32_t MsgNum_internal_data_[];
constexpr MsgNum MsgNum_MIN = static_cast<MsgNum>(8191);
constexpr MsgNum MsgNum_MAX = static_cast<MsgNum>(9000);
constexpr int MsgNum_ARRAYSIZE = 9000 + 1;
const ::google::protobuf::EnumDescriptor*
MsgNum_descriptor();
template <typename T>
const std::string& MsgNum_Name(T value) {
  static_assert(std::is_same<T, MsgNum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgNum_Name().");
  return ::google::protobuf::internal::NameOfEnum(MsgNum_descriptor(), value);
}
inline bool MsgNum_Parse(absl::string_view name, MsgNum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgNum>(
      MsgNum_descriptor(), name, value);
}
enum notice_type : int {
  type_none = 0,
  type_1 = 1,
  type_2 = 2,
  type_3 = 3,
};

bool notice_type_IsValid(int value);
extern const uint32_t notice_type_internal_data_[];
constexpr notice_type notice_type_MIN = static_cast<notice_type>(0);
constexpr notice_type notice_type_MAX = static_cast<notice_type>(3);
constexpr int notice_type_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
notice_type_descriptor();
template <typename T>
const std::string& notice_type_Name(T value) {
  static_assert(std::is_same<T, notice_type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to notice_type_Name().");
  return notice_type_Name(static_cast<notice_type>(value));
}
template <>
inline const std::string& notice_type_Name(notice_type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<notice_type_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool notice_type_Parse(absl::string_view name, notice_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<notice_type>(
      notice_type_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UserGameInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.UserGameInfo) */ {
 public:
  inline UserGameInfo() : UserGameInfo(nullptr) {}
  ~UserGameInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserGameInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserGameInfo(const UserGameInfo& from) : UserGameInfo(nullptr, from) {}
  inline UserGameInfo(UserGameInfo&& from) noexcept
      : UserGameInfo(nullptr, std::move(from)) {}
  inline UserGameInfo& operator=(const UserGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserGameInfo& operator=(UserGameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserGameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserGameInfo* internal_default_instance() {
    return reinterpret_cast<const UserGameInfo*>(
        &_UserGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(UserGameInfo& a, UserGameInfo& b) { a.Swap(&b); }
  inline void Swap(UserGameInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserGameInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserGameInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserGameInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserGameInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserGameInfo& from) { UserGameInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserGameInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.UserGameInfo"; }

 protected:
  explicit UserGameInfo(::google::protobuf::Arena* arena);
  UserGameInfo(::google::protobuf::Arena* arena, const UserGameInfo& from);
  UserGameInfo(::google::protobuf::Arena* arena, UserGameInfo&& from) noexcept
      : UserGameInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskUserGameInfo];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.UserGameInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class UserAskGetCLReward final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.UserAskGetCLReward) */ {
 public:
  inline UserAskGetCLReward() : UserAskGetCLReward(nullptr) {}
  ~UserAskGetCLReward() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserAskGetCLReward(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserAskGetCLReward(const UserAskGetCLReward& from) : UserAskGetCLReward(nullptr, from) {}
  inline UserAskGetCLReward(UserAskGetCLReward&& from) noexcept
      : UserAskGetCLReward(nullptr, std::move(from)) {}
  inline UserAskGetCLReward& operator=(const UserAskGetCLReward& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserAskGetCLReward& operator=(UserAskGetCLReward&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserAskGetCLReward& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserAskGetCLReward* internal_default_instance() {
    return reinterpret_cast<const UserAskGetCLReward*>(
        &_UserAskGetCLReward_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(UserAskGetCLReward& a, UserAskGetCLReward& b) { a.Swap(&b); }
  inline void Swap(UserAskGetCLReward* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserAskGetCLReward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserAskGetCLReward* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserAskGetCLReward>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserAskGetCLReward& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserAskGetCLReward& from) { UserAskGetCLReward::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserAskGetCLReward* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.UserAskGetCLReward"; }

 protected:
  explicit UserAskGetCLReward(::google::protobuf::Arena* arena);
  UserAskGetCLReward(::google::protobuf::Arena* arena, const UserAskGetCLReward& from);
  UserAskGetCLReward(::google::protobuf::Arena* arena, UserAskGetCLReward&& from) noexcept
      : UserAskGetCLReward(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_UserAskGetCLReward];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.UserAskGetCLReward)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class UnEuipRunes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.UnEuipRunes) */ {
 public:
  inline UnEuipRunes() : UnEuipRunes(nullptr) {}
  ~UnEuipRunes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnEuipRunes(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnEuipRunes(const UnEuipRunes& from) : UnEuipRunes(nullptr, from) {}
  inline UnEuipRunes(UnEuipRunes&& from) noexcept
      : UnEuipRunes(nullptr, std::move(from)) {}
  inline UnEuipRunes& operator=(const UnEuipRunes& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnEuipRunes& operator=(UnEuipRunes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnEuipRunes& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnEuipRunes* internal_default_instance() {
    return reinterpret_cast<const UnEuipRunes*>(
        &_UnEuipRunes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(UnEuipRunes& a, UnEuipRunes& b) { a.Swap(&b); }
  inline void Swap(UnEuipRunes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnEuipRunes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnEuipRunes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UnEuipRunes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnEuipRunes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnEuipRunes& from) { UnEuipRunes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnEuipRunes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.UnEuipRunes"; }

 protected:
  explicit UnEuipRunes(::google::protobuf::Arena* arena);
  UnEuipRunes(::google::protobuf::Arena* arena, const UnEuipRunes& from);
  UnEuipRunes(::google::protobuf::Arena* arena, UnEuipRunes&& from) noexcept
      : UnEuipRunes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageFieldNumber = 2,
    kPosFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 page = 2;
  bool has_page() const;
  void clear_page() ;
  ::int32_t page() const;
  void set_page(::int32_t value);

  private:
  ::int32_t _internal_page() const;
  void _internal_set_page(::int32_t value);

  public:
  // optional int32 pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_UnloadRunes];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.UnEuipRunes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t page_;
    ::int32_t pos_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class RequestMatchTeamList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.RequestMatchTeamList) */ {
 public:
  inline RequestMatchTeamList() : RequestMatchTeamList(nullptr) {}
  ~RequestMatchTeamList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RequestMatchTeamList(
      ::google::protobuf::internal::ConstantInitialized);

  inline RequestMatchTeamList(const RequestMatchTeamList& from) : RequestMatchTeamList(nullptr, from) {}
  inline RequestMatchTeamList(RequestMatchTeamList&& from) noexcept
      : RequestMatchTeamList(nullptr, std::move(from)) {}
  inline RequestMatchTeamList& operator=(const RequestMatchTeamList& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestMatchTeamList& operator=(RequestMatchTeamList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestMatchTeamList& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestMatchTeamList* internal_default_instance() {
    return reinterpret_cast<const RequestMatchTeamList*>(
        &_RequestMatchTeamList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(RequestMatchTeamList& a, RequestMatchTeamList& b) { a.Swap(&b); }
  inline void Swap(RequestMatchTeamList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestMatchTeamList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestMatchTeamList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RequestMatchTeamList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RequestMatchTeamList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RequestMatchTeamList& from) { RequestMatchTeamList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RequestMatchTeamList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.RequestMatchTeamList"; }

 protected:
  explicit RequestMatchTeamList(::google::protobuf::Arena* arena);
  RequestMatchTeamList(::google::protobuf::Arena* arena, const RequestMatchTeamList& from);
  RequestMatchTeamList(::google::protobuf::Arena* arena, RequestMatchTeamList&& from) noexcept
      : RequestMatchTeamList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_RequestMatchTeamList];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.RequestMatchTeamList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class ReconnectToGame final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.ReconnectToGame) */ {
 public:
  inline ReconnectToGame() : ReconnectToGame(nullptr) {}
  ~ReconnectToGame() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReconnectToGame(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReconnectToGame(const ReconnectToGame& from) : ReconnectToGame(nullptr, from) {}
  inline ReconnectToGame(ReconnectToGame&& from) noexcept
      : ReconnectToGame(nullptr, std::move(from)) {}
  inline ReconnectToGame& operator=(const ReconnectToGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReconnectToGame& operator=(ReconnectToGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReconnectToGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReconnectToGame* internal_default_instance() {
    return reinterpret_cast<const ReconnectToGame*>(
        &_ReconnectToGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(ReconnectToGame& a, ReconnectToGame& b) { a.Swap(&b); }
  inline void Swap(ReconnectToGame* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReconnectToGame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReconnectToGame* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReconnectToGame>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReconnectToGame& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReconnectToGame& from) { ReconnectToGame::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReconnectToGame* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.ReconnectToGame"; }

 protected:
  explicit ReconnectToGame(::google::protobuf::Arena* arena);
  ReconnectToGame(::google::protobuf::Arena* arena, const ReconnectToGame& from);
  ReconnectToGame(::google::protobuf::Arena* arena, ReconnectToGame&& from) noexcept
      : ReconnectToGame(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 2,
    kPasswdFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string passwd = 3;
  bool has_passwd() const;
  void clear_passwd() ;
  const std::string& passwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passwd(Arg_&& arg, Args_... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* value);

  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(
      const std::string& value);
  std::string* _internal_mutable_passwd();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskReconnectGame];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.ReconnectToGame)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr passwd_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class NotifyOneMatchNeedOneRet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.NotifyOneMatchNeedOneRet) */ {
 public:
  inline NotifyOneMatchNeedOneRet() : NotifyOneMatchNeedOneRet(nullptr) {}
  ~NotifyOneMatchNeedOneRet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyOneMatchNeedOneRet(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyOneMatchNeedOneRet(const NotifyOneMatchNeedOneRet& from) : NotifyOneMatchNeedOneRet(nullptr, from) {}
  inline NotifyOneMatchNeedOneRet(NotifyOneMatchNeedOneRet&& from) noexcept
      : NotifyOneMatchNeedOneRet(nullptr, std::move(from)) {}
  inline NotifyOneMatchNeedOneRet& operator=(const NotifyOneMatchNeedOneRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyOneMatchNeedOneRet& operator=(NotifyOneMatchNeedOneRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyOneMatchNeedOneRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyOneMatchNeedOneRet* internal_default_instance() {
    return reinterpret_cast<const NotifyOneMatchNeedOneRet*>(
        &_NotifyOneMatchNeedOneRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(NotifyOneMatchNeedOneRet& a, NotifyOneMatchNeedOneRet& b) { a.Swap(&b); }
  inline void Swap(NotifyOneMatchNeedOneRet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyOneMatchNeedOneRet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyOneMatchNeedOneRet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyOneMatchNeedOneRet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyOneMatchNeedOneRet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyOneMatchNeedOneRet& from) { NotifyOneMatchNeedOneRet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyOneMatchNeedOneRet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.NotifyOneMatchNeedOneRet"; }

 protected:
  explicit NotifyOneMatchNeedOneRet(::google::protobuf::Arena* arena);
  NotifyOneMatchNeedOneRet(::google::protobuf::Arena* arena, const NotifyOneMatchNeedOneRet& from);
  NotifyOneMatchNeedOneRet(::google::protobuf::Arena* arena, NotifyOneMatchNeedOneRet&& from) noexcept
      : NotifyOneMatchNeedOneRet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapidFieldNumber = 2,
    kFightidFieldNumber = 3,
    kIsAcceptFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional uint32 mapid = 2;
  bool has_mapid() const;
  void clear_mapid() ;
  ::uint32_t mapid() const;
  void set_mapid(::uint32_t value);

  private:
  ::uint32_t _internal_mapid() const;
  void _internal_set_mapid(::uint32_t value);

  public:
  // optional uint32 fightid = 3;
  bool has_fightid() const;
  void clear_fightid() ;
  ::uint32_t fightid() const;
  void set_fightid(::uint32_t value);

  private:
  ::uint32_t _internal_fightid() const;
  void _internal_set_fightid(::uint32_t value);

  public:
  // optional bool isAccept = 4;
  bool has_isaccept() const;
  void clear_isaccept() ;
  bool isaccept() const;
  void set_isaccept(bool value);

  private:
  bool _internal_isaccept() const;
  void _internal_set_isaccept(bool value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_NotifyOneMatchNeedOneRet];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.NotifyOneMatchNeedOneRet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t mapid_;
    ::uint32_t fightid_;
    bool isaccept_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class Notice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.Notice) */ {
 public:
  inline Notice() : Notice(nullptr) {}
  ~Notice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Notice(
      ::google::protobuf::internal::ConstantInitialized);

  inline Notice(const Notice& from) : Notice(nullptr, from) {}
  inline Notice(Notice&& from) noexcept
      : Notice(nullptr, std::move(from)) {}
  inline Notice& operator=(const Notice& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notice& operator=(Notice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notice& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notice* internal_default_instance() {
    return reinterpret_cast<const Notice*>(
        &_Notice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(Notice& a, Notice& b) { a.Swap(&b); }
  inline void Swap(Notice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Notice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Notice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Notice& from) { Notice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Notice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.Notice"; }

 protected:
  explicit Notice(::google::protobuf::Arena* arena);
  Notice(::google::protobuf::Arena* arena, const Notice& from);
  Notice(::google::protobuf::Arena* arena, Notice&& from) noexcept
      : Notice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNoticeFieldNumber = 3,
    kTypeFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string notice = 3;
  bool has_notice() const;
  void clear_notice() ;
  const std::string& notice() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_notice(Arg_&& arg, Args_... args);
  std::string* mutable_notice();
  PROTOBUF_NODISCARD std::string* release_notice();
  void set_allocated_notice(std::string* value);

  private:
  const std::string& _internal_notice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notice(
      const std::string& value);
  std::string* _internal_mutable_notice();

  public:
  // optional .GCToCS.notice_type type = 2;
  bool has_type() const;
  void clear_type() ;
  ::GCToCS::notice_type type() const;
  void set_type(::GCToCS::notice_type value);

  private:
  ::GCToCS::notice_type _internal_type() const;
  void _internal_set_type(::GCToCS::notice_type value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_Notice];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.Notice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      28, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr notice_;
    int type_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class Login final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Login(
      ::google::protobuf::internal::ConstantInitialized);

  inline Login(const Login& from) : Login(nullptr, from) {}
  inline Login(Login&& from) noexcept
      : Login(nullptr, std::move(from)) {}
  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
        &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(Login& a, Login& b) { a.Swap(&b); }
  inline void Swap(Login* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Login>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Login& from) { Login::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Login* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.Login"; }

 protected:
  explicit Login(::google::protobuf::Arena* arena);
  Login(::google::protobuf::Arena* arena, const Login& from);
  Login(::google::protobuf::Arena* arena, Login&& from) noexcept
      : Login(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 4,
    kPasswdFieldNumber = 5,
    kIpaddressFieldNumber = 6,
    kEquimentidFieldNumber = 7,
    kSdkFieldNumber = 2,
    kPlatformFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional string name = 4;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string passwd = 5;
  bool has_passwd() const;
  void clear_passwd() ;
  const std::string& passwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passwd(Arg_&& arg, Args_... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* value);

  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(
      const std::string& value);
  std::string* _internal_mutable_passwd();

  public:
  // optional string ipaddress = 6;
  bool has_ipaddress() const;
  void clear_ipaddress() ;
  const std::string& ipaddress() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ipaddress(Arg_&& arg, Args_... args);
  std::string* mutable_ipaddress();
  PROTOBUF_NODISCARD std::string* release_ipaddress();
  void set_allocated_ipaddress(std::string* value);

  private:
  const std::string& _internal_ipaddress() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ipaddress(
      const std::string& value);
  std::string* _internal_mutable_ipaddress();

  public:
  // optional string equimentid = 7;
  bool has_equimentid() const;
  void clear_equimentid() ;
  const std::string& equimentid() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_equimentid(Arg_&& arg, Args_... args);
  std::string* mutable_equimentid();
  PROTOBUF_NODISCARD std::string* release_equimentid();
  void set_allocated_equimentid(std::string* value);

  private:
  const std::string& _internal_equimentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_equimentid(
      const std::string& value);
  std::string* _internal_mutable_equimentid();

  public:
  // optional int32 sdk = 2;
  bool has_sdk() const;
  void clear_sdk() ;
  ::int32_t sdk() const;
  void set_sdk(::int32_t value);

  private:
  ::int32_t _internal_sdk() const;
  void _internal_set_sdk(::int32_t value);

  public:
  // optional int32 platform = 3;
  bool has_platform() const;
  void clear_platform() ;
  ::int32_t platform() const;
  void set_platform(::int32_t value);

  private:
  ::int32_t _internal_platform() const;
  void _internal_set_platform(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskLogin];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.Login)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr passwd_;
    ::google::protobuf::internal::ArenaStringPtr ipaddress_;
    ::google::protobuf::internal::ArenaStringPtr equimentid_;
    ::int32_t sdk_;
    ::int32_t platform_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class GuideCSStepComp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.GuideCSStepComp) */ {
 public:
  inline GuideCSStepComp() : GuideCSStepComp(nullptr) {}
  ~GuideCSStepComp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideCSStepComp(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideCSStepComp(const GuideCSStepComp& from) : GuideCSStepComp(nullptr, from) {}
  inline GuideCSStepComp(GuideCSStepComp&& from) noexcept
      : GuideCSStepComp(nullptr, std::move(from)) {}
  inline GuideCSStepComp& operator=(const GuideCSStepComp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideCSStepComp& operator=(GuideCSStepComp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideCSStepComp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideCSStepComp* internal_default_instance() {
    return reinterpret_cast<const GuideCSStepComp*>(
        &_GuideCSStepComp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(GuideCSStepComp& a, GuideCSStepComp& b) { a.Swap(&b); }
  inline void Swap(GuideCSStepComp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideCSStepComp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideCSStepComp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideCSStepComp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideCSStepComp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideCSStepComp& from) { GuideCSStepComp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideCSStepComp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.GuideCSStepComp"; }

 protected:
  explicit GuideCSStepComp(::google::protobuf::Arena* arena);
  GuideCSStepComp(::google::protobuf::Arena* arena, const GuideCSStepComp& from);
  GuideCSStepComp(::google::protobuf::Arena* arena, GuideCSStepComp&& from) noexcept
      : GuideCSStepComp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidepartFieldNumber = 2,
    kBcompFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 guidepart = 2;
  bool has_guidepart() const;
  void clear_guidepart() ;
  ::int32_t guidepart() const;
  void set_guidepart(::int32_t value);

  private:
  ::int32_t _internal_guidepart() const;
  void _internal_set_guidepart(::int32_t value);

  public:
  // optional bool bcomp = 3;
  bool has_bcomp() const;
  void clear_bcomp() ;
  bool bcomp() const;
  void set_bcomp(bool value);

  private:
  bool _internal_bcomp() const;
  void _internal_set_bcomp(bool value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_CompCSGuideStepId];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.GuideCSStepComp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t guidepart_;
    bool bcomp_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class GCReplyInviteToBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.GCReplyInviteToBattle) */ {
 public:
  inline GCReplyInviteToBattle() : GCReplyInviteToBattle(nullptr) {}
  ~GCReplyInviteToBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GCReplyInviteToBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline GCReplyInviteToBattle(const GCReplyInviteToBattle& from) : GCReplyInviteToBattle(nullptr, from) {}
  inline GCReplyInviteToBattle(GCReplyInviteToBattle&& from) noexcept
      : GCReplyInviteToBattle(nullptr, std::move(from)) {}
  inline GCReplyInviteToBattle& operator=(const GCReplyInviteToBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline GCReplyInviteToBattle& operator=(GCReplyInviteToBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GCReplyInviteToBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const GCReplyInviteToBattle* internal_default_instance() {
    return reinterpret_cast<const GCReplyInviteToBattle*>(
        &_GCReplyInviteToBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(GCReplyInviteToBattle& a, GCReplyInviteToBattle& b) { a.Swap(&b); }
  inline void Swap(GCReplyInviteToBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GCReplyInviteToBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GCReplyInviteToBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GCReplyInviteToBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GCReplyInviteToBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GCReplyInviteToBattle& from) { GCReplyInviteToBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GCReplyInviteToBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.GCReplyInviteToBattle"; }

 protected:
  explicit GCReplyInviteToBattle(::google::protobuf::Arena* arena);
  GCReplyInviteToBattle(::google::protobuf::Arena* arena, const GCReplyInviteToBattle& from);
  GCReplyInviteToBattle(::google::protobuf::Arena* arena, GCReplyInviteToBattle&& from) noexcept
      : GCReplyInviteToBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_GCReplyInviteToBattle];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.GCReplyInviteToBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class GCReplyAddFriendRequst final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.GCReplyAddFriendRequst) */ {
 public:
  inline GCReplyAddFriendRequst() : GCReplyAddFriendRequst(nullptr) {}
  ~GCReplyAddFriendRequst() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GCReplyAddFriendRequst(
      ::google::protobuf::internal::ConstantInitialized);

  inline GCReplyAddFriendRequst(const GCReplyAddFriendRequst& from) : GCReplyAddFriendRequst(nullptr, from) {}
  inline GCReplyAddFriendRequst(GCReplyAddFriendRequst&& from) noexcept
      : GCReplyAddFriendRequst(nullptr, std::move(from)) {}
  inline GCReplyAddFriendRequst& operator=(const GCReplyAddFriendRequst& from) {
    CopyFrom(from);
    return *this;
  }
  inline GCReplyAddFriendRequst& operator=(GCReplyAddFriendRequst&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GCReplyAddFriendRequst& default_instance() {
    return *internal_default_instance();
  }
  static inline const GCReplyAddFriendRequst* internal_default_instance() {
    return reinterpret_cast<const GCReplyAddFriendRequst*>(
        &_GCReplyAddFriendRequst_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(GCReplyAddFriendRequst& a, GCReplyAddFriendRequst& b) { a.Swap(&b); }
  inline void Swap(GCReplyAddFriendRequst* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GCReplyAddFriendRequst* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GCReplyAddFriendRequst* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GCReplyAddFriendRequst>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GCReplyAddFriendRequst& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GCReplyAddFriendRequst& from) { GCReplyAddFriendRequst::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GCReplyAddFriendRequst* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.GCReplyAddFriendRequst"; }

 protected:
  explicit GCReplyAddFriendRequst(::google::protobuf::Arena* arena);
  GCReplyAddFriendRequst(::google::protobuf::Arena* arena, const GCReplyAddFriendRequst& from);
  GCReplyAddFriendRequst(::google::protobuf::Arena* arena, GCReplyAddFriendRequst&& from) noexcept
      : GCReplyAddFriendRequst(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuididxFieldNumber = 2,
    kReplyFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional uint64 guididx = 2;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional int32 reply = 3;
  bool has_reply() const;
  void clear_reply() ;
  ::int32_t reply() const;
  void set_reply(::int32_t value);

  private:
  ::int32_t _internal_reply() const;
  void _internal_set_reply(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_GCReplyAddFriendRequst];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.GCReplyAddFriendRequst)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guididx_;
    ::int32_t reply_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class EuipRunes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.EuipRunes) */ {
 public:
  inline EuipRunes() : EuipRunes(nullptr) {}
  ~EuipRunes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EuipRunes(
      ::google::protobuf::internal::ConstantInitialized);

  inline EuipRunes(const EuipRunes& from) : EuipRunes(nullptr, from) {}
  inline EuipRunes(EuipRunes&& from) noexcept
      : EuipRunes(nullptr, std::move(from)) {}
  inline EuipRunes& operator=(const EuipRunes& from) {
    CopyFrom(from);
    return *this;
  }
  inline EuipRunes& operator=(EuipRunes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EuipRunes& default_instance() {
    return *internal_default_instance();
  }
  static inline const EuipRunes* internal_default_instance() {
    return reinterpret_cast<const EuipRunes*>(
        &_EuipRunes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(EuipRunes& a, EuipRunes& b) { a.Swap(&b); }
  inline void Swap(EuipRunes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EuipRunes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EuipRunes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EuipRunes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EuipRunes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EuipRunes& from) { EuipRunes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EuipRunes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.EuipRunes"; }

 protected:
  explicit EuipRunes(::google::protobuf::Arena* arena);
  EuipRunes(::google::protobuf::Arena* arena, const EuipRunes& from);
  EuipRunes(::google::protobuf::Arena* arena, EuipRunes&& from) noexcept
      : EuipRunes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRuneidFieldNumber = 2,
    kToposFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional uint32 runeid = 2;
  bool has_runeid() const;
  void clear_runeid() ;
  ::uint32_t runeid() const;
  void set_runeid(::uint32_t value);

  private:
  ::uint32_t _internal_runeid() const;
  void _internal_set_runeid(::uint32_t value);

  public:
  // optional int32 topos = 3;
  bool has_topos() const;
  void clear_topos() ;
  ::int32_t topos() const;
  void set_topos(::int32_t value);

  private:
  ::int32_t _internal_topos() const;
  void _internal_set_topos(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_EuipRunes];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.EuipRunes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t runeid_;
    ::int32_t topos_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class CurtUIEvent_UIEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.CurtUIEvent.UIEvent) */ {
 public:
  inline CurtUIEvent_UIEvent() : CurtUIEvent_UIEvent(nullptr) {}
  ~CurtUIEvent_UIEvent() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurtUIEvent_UIEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline CurtUIEvent_UIEvent(const CurtUIEvent_UIEvent& from) : CurtUIEvent_UIEvent(nullptr, from) {}
  inline CurtUIEvent_UIEvent(CurtUIEvent_UIEvent&& from) noexcept
      : CurtUIEvent_UIEvent(nullptr, std::move(from)) {}
  inline CurtUIEvent_UIEvent& operator=(const CurtUIEvent_UIEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurtUIEvent_UIEvent& operator=(CurtUIEvent_UIEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurtUIEvent_UIEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurtUIEvent_UIEvent* internal_default_instance() {
    return reinterpret_cast<const CurtUIEvent_UIEvent*>(
        &_CurtUIEvent_UIEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CurtUIEvent_UIEvent& a, CurtUIEvent_UIEvent& b) { a.Swap(&b); }
  inline void Swap(CurtUIEvent_UIEvent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurtUIEvent_UIEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurtUIEvent_UIEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CurtUIEvent_UIEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurtUIEvent_UIEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CurtUIEvent_UIEvent& from) { CurtUIEvent_UIEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurtUIEvent_UIEvent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.CurtUIEvent.UIEvent"; }

 protected:
  explicit CurtUIEvent_UIEvent(::google::protobuf::Arena* arena);
  CurtUIEvent_UIEvent(::google::protobuf::Arena* arena, const CurtUIEvent_UIEvent& from);
  CurtUIEvent_UIEvent(::google::protobuf::Arena* arena, CurtUIEvent_UIEvent&& from) noexcept
      : CurtUIEvent_UIEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUiidxFieldNumber = 2,
    kEventNumFieldNumber = 3,
  };
  // optional uint32 uiidx = 2;
  bool has_uiidx() const;
  void clear_uiidx() ;
  ::uint32_t uiidx() const;
  void set_uiidx(::uint32_t value);

  private:
  ::uint32_t _internal_uiidx() const;
  void _internal_set_uiidx(::uint32_t value);

  public:
  // optional uint32 eventNum = 3;
  bool has_eventnum() const;
  void clear_eventnum() ;
  ::uint32_t eventnum() const;
  void set_eventnum(::uint32_t value);

  private:
  ::uint32_t _internal_eventnum() const;
  void _internal_set_eventnum(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.CurtUIEvent.UIEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t uiidx_;
    ::uint32_t eventnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class ComposeRunes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.ComposeRunes) */ {
 public:
  inline ComposeRunes() : ComposeRunes(nullptr) {}
  ~ComposeRunes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ComposeRunes(
      ::google::protobuf::internal::ConstantInitialized);

  inline ComposeRunes(const ComposeRunes& from) : ComposeRunes(nullptr, from) {}
  inline ComposeRunes(ComposeRunes&& from) noexcept
      : ComposeRunes(nullptr, std::move(from)) {}
  inline ComposeRunes& operator=(const ComposeRunes& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComposeRunes& operator=(ComposeRunes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComposeRunes& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComposeRunes* internal_default_instance() {
    return reinterpret_cast<const ComposeRunes*>(
        &_ComposeRunes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(ComposeRunes& a, ComposeRunes& b) { a.Swap(&b); }
  inline void Swap(ComposeRunes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComposeRunes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComposeRunes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ComposeRunes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComposeRunes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ComposeRunes& from) { ComposeRunes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ComposeRunes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.ComposeRunes"; }

 protected:
  explicit ComposeRunes(::google::protobuf::Arena* arena);
  ComposeRunes(::google::protobuf::Arena* arena, const ComposeRunes& from);
  ComposeRunes(::google::protobuf::Arena* arena, ComposeRunes&& from) noexcept
      : ComposeRunes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRunesidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // repeated uint32 runesid = 2;
  int runesid_size() const;
  private:
  int _internal_runesid_size() const;

  public:
  void clear_runesid() ;
  ::uint32_t runesid(int index) const;
  void set_runesid(int index, ::uint32_t value);
  void add_runesid(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& runesid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_runesid();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_runesid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_runesid();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_ComposeRunes];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.ComposeRunes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> runesid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class CompleteInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.CompleteInfo) */ {
 public:
  inline CompleteInfo() : CompleteInfo(nullptr) {}
  ~CompleteInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CompleteInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CompleteInfo(const CompleteInfo& from) : CompleteInfo(nullptr, from) {}
  inline CompleteInfo(CompleteInfo&& from) noexcept
      : CompleteInfo(nullptr, std::move(from)) {}
  inline CompleteInfo& operator=(const CompleteInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompleteInfo& operator=(CompleteInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompleteInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompleteInfo* internal_default_instance() {
    return reinterpret_cast<const CompleteInfo*>(
        &_CompleteInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(CompleteInfo& a, CompleteInfo& b) { a.Swap(&b); }
  inline void Swap(CompleteInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompleteInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompleteInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CompleteInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompleteInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CompleteInfo& from) { CompleteInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CompleteInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.CompleteInfo"; }

 protected:
  explicit CompleteInfo(::google::protobuf::Arena* arena);
  CompleteInfo(::google::protobuf::Arena* arena, const CompleteInfo& from);
  CompleteInfo(::google::protobuf::Arena* arena, CompleteInfo&& from) noexcept
      : CompleteInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kHeadidFieldNumber = 3,
    kSexFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional int32 headid = 3;
  bool has_headid() const;
  void clear_headid() ;
  ::int32_t headid() const;
  void set_headid(::int32_t value);

  private:
  ::int32_t _internal_headid() const;
  void _internal_set_headid(::int32_t value);

  public:
  // optional int32 sex = 4;
  bool has_sex() const;
  void clear_sex() ;
  ::int32_t sex() const;
  void set_sex(::int32_t value);

  private:
  ::int32_t _internal_sex() const;
  void _internal_set_sex(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskComleteUserInfo];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.CompleteInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      36, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::int32_t headid_;
    ::int32_t sex_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class ComGuideStepID final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.ComGuideStepID) */ {
 public:
  inline ComGuideStepID() : ComGuideStepID(nullptr) {}
  ~ComGuideStepID() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ComGuideStepID(
      ::google::protobuf::internal::ConstantInitialized);

  inline ComGuideStepID(const ComGuideStepID& from) : ComGuideStepID(nullptr, from) {}
  inline ComGuideStepID(ComGuideStepID&& from) noexcept
      : ComGuideStepID(nullptr, std::move(from)) {}
  inline ComGuideStepID& operator=(const ComGuideStepID& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComGuideStepID& operator=(ComGuideStepID&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComGuideStepID& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComGuideStepID* internal_default_instance() {
    return reinterpret_cast<const ComGuideStepID*>(
        &_ComGuideStepID_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(ComGuideStepID& a, ComGuideStepID& b) { a.Swap(&b); }
  inline void Swap(ComGuideStepID* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComGuideStepID* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComGuideStepID* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ComGuideStepID>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComGuideStepID& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ComGuideStepID& from) { ComGuideStepID::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ComGuideStepID* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.ComGuideStepID"; }

 protected:
  explicit ComGuideStepID(::google::protobuf::Arena* arena);
  ComGuideStepID(::google::protobuf::Arena* arena, const ComGuideStepID& from);
  ComGuideStepID(::google::protobuf::Arena* arena, ComGuideStepID&& from) noexcept
      : ComGuideStepID(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 2,
    kStepFieldNumber = 3,
    kStateFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 type = 2;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional int32 step = 3;
  bool has_step() const;
  void clear_step() ;
  ::int32_t step() const;
  void set_step(::int32_t value);

  private:
  ::int32_t _internal_step() const;
  void _internal_set_step(::int32_t value);

  public:
  // optional int32 state = 4;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGuideStepId];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.ComGuideStepID)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t type_;
    ::int32_t step_;
    ::int32_t state_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class ChangeNickName final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.ChangeNickName) */ {
 public:
  inline ChangeNickName() : ChangeNickName(nullptr) {}
  ~ChangeNickName() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeNickName(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChangeNickName(const ChangeNickName& from) : ChangeNickName(nullptr, from) {}
  inline ChangeNickName(ChangeNickName&& from) noexcept
      : ChangeNickName(nullptr, std::move(from)) {}
  inline ChangeNickName& operator=(const ChangeNickName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeNickName& operator=(ChangeNickName&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeNickName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeNickName* internal_default_instance() {
    return reinterpret_cast<const ChangeNickName*>(
        &_ChangeNickName_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ChangeNickName& a, ChangeNickName& b) { a.Swap(&b); }
  inline void Swap(ChangeNickName* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeNickName* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeNickName* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChangeNickName>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangeNickName& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChangeNickName& from) { ChangeNickName::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangeNickName* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.ChangeNickName"; }

 protected:
  explicit ChangeNickName(::google::protobuf::Arena* arena);
  ChangeNickName(::google::protobuf::Arena* arena, const ChangeNickName& from);
  ChangeNickName(::google::protobuf::Arena* arena, ChangeNickName&& from) noexcept
      : ChangeNickName(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewnicknameFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string newnickname = 2;
  bool has_newnickname() const;
  void clear_newnickname() ;
  const std::string& newnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_newnickname(Arg_&& arg, Args_... args);
  std::string* mutable_newnickname();
  PROTOBUF_NODISCARD std::string* release_newnickname();
  void set_allocated_newnickname(std::string* value);

  private:
  const std::string& _internal_newnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newnickname(
      const std::string& value);
  std::string* _internal_mutable_newnickname();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChangeNickName];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.ChangeNickName)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr newnickname_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class CDKReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.CDKReq) */ {
 public:
  inline CDKReq() : CDKReq(nullptr) {}
  ~CDKReq() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CDKReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline CDKReq(const CDKReq& from) : CDKReq(nullptr, from) {}
  inline CDKReq(CDKReq&& from) noexcept
      : CDKReq(nullptr, std::move(from)) {}
  inline CDKReq& operator=(const CDKReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDKReq& operator=(CDKReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDKReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDKReq* internal_default_instance() {
    return reinterpret_cast<const CDKReq*>(
        &_CDKReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CDKReq& a, CDKReq& b) { a.Swap(&b); }
  inline void Swap(CDKReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDKReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDKReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CDKReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CDKReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CDKReq& from) { CDKReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CDKReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.CDKReq"; }

 protected:
  explicit CDKReq(::google::protobuf::Arena* arena);
  CDKReq(::google::protobuf::Arena* arena, const CDKReq& from);
  CDKReq(::google::protobuf::Arena* arena, CDKReq&& from) noexcept
      : CDKReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCdkstrFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string cdkstr = 2;
  bool has_cdkstr() const;
  void clear_cdkstr() ;
  const std::string& cdkstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cdkstr(Arg_&& arg, Args_... args);
  std::string* mutable_cdkstr();
  PROTOBUF_NODISCARD std::string* release_cdkstr();
  void set_allocated_cdkstr(std::string* value);

  private:
  const std::string& _internal_cdkstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cdkstr(
      const std::string& value);
  std::string* _internal_mutable_cdkstr();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_CDKReq];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.CDKReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      28, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr cdkstr_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class BuyRunes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.BuyRunes) */ {
 public:
  inline BuyRunes() : BuyRunes(nullptr) {}
  ~BuyRunes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuyRunes(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuyRunes(const BuyRunes& from) : BuyRunes(nullptr, from) {}
  inline BuyRunes(BuyRunes&& from) noexcept
      : BuyRunes(nullptr, std::move(from)) {}
  inline BuyRunes& operator=(const BuyRunes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyRunes& operator=(BuyRunes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyRunes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyRunes* internal_default_instance() {
    return reinterpret_cast<const BuyRunes*>(
        &_BuyRunes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(BuyRunes& a, BuyRunes& b) { a.Swap(&b); }
  inline void Swap(BuyRunes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyRunes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyRunes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BuyRunes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuyRunes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuyRunes& from) { BuyRunes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuyRunes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.BuyRunes"; }

 protected:
  explicit BuyRunes(::google::protobuf::Arena* arena);
  BuyRunes(::google::protobuf::Arena* arena, const BuyRunes& from);
  BuyRunes(::google::protobuf::Arena* arena, BuyRunes&& from) noexcept
      : BuyRunes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 typeid = 2;
  bool has_typeid_() const;
  void clear_typeid_() ;
  ::int32_t typeid_() const;
  void set_typeid_(::int32_t value);

  private:
  ::int32_t _internal_typeid_() const;
  void _internal_set_typeid_(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_BUYRunes];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.BuyRunes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t typeid__;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class BlackListOnlineInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.BlackListOnlineInfo) */ {
 public:
  inline BlackListOnlineInfo() : BlackListOnlineInfo(nullptr) {}
  ~BlackListOnlineInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlackListOnlineInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlackListOnlineInfo(const BlackListOnlineInfo& from) : BlackListOnlineInfo(nullptr, from) {}
  inline BlackListOnlineInfo(BlackListOnlineInfo&& from) noexcept
      : BlackListOnlineInfo(nullptr, std::move(from)) {}
  inline BlackListOnlineInfo& operator=(const BlackListOnlineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlackListOnlineInfo& operator=(BlackListOnlineInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlackListOnlineInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlackListOnlineInfo* internal_default_instance() {
    return reinterpret_cast<const BlackListOnlineInfo*>(
        &_BlackListOnlineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(BlackListOnlineInfo& a, BlackListOnlineInfo& b) { a.Swap(&b); }
  inline void Swap(BlackListOnlineInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlackListOnlineInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlackListOnlineInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BlackListOnlineInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlackListOnlineInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlackListOnlineInfo& from) { BlackListOnlineInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BlackListOnlineInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.BlackListOnlineInfo"; }

 protected:
  explicit BlackListOnlineInfo(::google::protobuf::Arena* arena);
  BlackListOnlineInfo(::google::protobuf::Arena* arena, const BlackListOnlineInfo& from);
  BlackListOnlineInfo(::google::protobuf::Arena* arena, BlackListOnlineInfo&& from) noexcept
      : BlackListOnlineInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskBlackListOnlineInfo];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.BlackListOnlineInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskStopQuickBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskStopQuickBattle) */ {
 public:
  inline AskStopQuickBattle() : AskStopQuickBattle(nullptr) {}
  ~AskStopQuickBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskStopQuickBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskStopQuickBattle(const AskStopQuickBattle& from) : AskStopQuickBattle(nullptr, from) {}
  inline AskStopQuickBattle(AskStopQuickBattle&& from) noexcept
      : AskStopQuickBattle(nullptr, std::move(from)) {}
  inline AskStopQuickBattle& operator=(const AskStopQuickBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskStopQuickBattle& operator=(AskStopQuickBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskStopQuickBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskStopQuickBattle* internal_default_instance() {
    return reinterpret_cast<const AskStopQuickBattle*>(
        &_AskStopQuickBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(AskStopQuickBattle& a, AskStopQuickBattle& b) { a.Swap(&b); }
  inline void Swap(AskStopQuickBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskStopQuickBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskStopQuickBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskStopQuickBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskStopQuickBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskStopQuickBattle& from) { AskStopQuickBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskStopQuickBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskStopQuickBattle"; }

 protected:
  explicit AskStopQuickBattle(::google::protobuf::Arena* arena);
  AskStopQuickBattle(::google::protobuf::Arena* arena, const AskStopQuickBattle& from);
  AskStopQuickBattle(::google::protobuf::Arena* arena, AskStopQuickBattle&& from) noexcept
      : AskStopQuickBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStopQuickBattle];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskStopQuickBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskStopMatch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskStopMatch) */ {
 public:
  inline AskStopMatch() : AskStopMatch(nullptr) {}
  ~AskStopMatch() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskStopMatch(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskStopMatch(const AskStopMatch& from) : AskStopMatch(nullptr, from) {}
  inline AskStopMatch(AskStopMatch&& from) noexcept
      : AskStopMatch(nullptr, std::move(from)) {}
  inline AskStopMatch& operator=(const AskStopMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskStopMatch& operator=(AskStopMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskStopMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskStopMatch* internal_default_instance() {
    return reinterpret_cast<const AskStopMatch*>(
        &_AskStopMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(AskStopMatch& a, AskStopMatch& b) { a.Swap(&b); }
  inline void Swap(AskStopMatch* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskStopMatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskStopMatch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskStopMatch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskStopMatch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskStopMatch& from) { AskStopMatch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskStopMatch* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskStopMatch"; }

 protected:
  explicit AskStopMatch(::google::protobuf::Arena* arena);
  AskStopMatch(::google::protobuf::Arena* arena, const AskStopMatch& from);
  AskStopMatch(::google::protobuf::Arena* arena, AskStopMatch&& from) noexcept
      : AskStopMatch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStopMatch];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskStopMatch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskStartRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskStartRoom) */ {
 public:
  inline AskStartRoom() : AskStartRoom(nullptr) {}
  ~AskStartRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskStartRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskStartRoom(const AskStartRoom& from) : AskStartRoom(nullptr, from) {}
  inline AskStartRoom(AskStartRoom&& from) noexcept
      : AskStartRoom(nullptr, std::move(from)) {}
  inline AskStartRoom& operator=(const AskStartRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskStartRoom& operator=(AskStartRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskStartRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskStartRoom* internal_default_instance() {
    return reinterpret_cast<const AskStartRoom*>(
        &_AskStartRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(AskStartRoom& a, AskStartRoom& b) { a.Swap(&b); }
  inline void Swap(AskStartRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskStartRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskStartRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskStartRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskStartRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskStartRoom& from) { AskStartRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskStartRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskStartRoom"; }

 protected:
  explicit AskStartRoom(::google::protobuf::Arena* arena);
  AskStartRoom(::google::protobuf::Arena* arena, const AskStartRoom& from);
  AskStartRoom(::google::protobuf::Arena* arena, AskStartRoom&& from) noexcept
      : AskStartRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStartRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskStartRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskStartMatch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskStartMatch) */ {
 public:
  inline AskStartMatch() : AskStartMatch(nullptr) {}
  ~AskStartMatch() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskStartMatch(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskStartMatch(const AskStartMatch& from) : AskStartMatch(nullptr, from) {}
  inline AskStartMatch(AskStartMatch&& from) noexcept
      : AskStartMatch(nullptr, std::move(from)) {}
  inline AskStartMatch& operator=(const AskStartMatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskStartMatch& operator=(AskStartMatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskStartMatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskStartMatch* internal_default_instance() {
    return reinterpret_cast<const AskStartMatch*>(
        &_AskStartMatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(AskStartMatch& a, AskStartMatch& b) { a.Swap(&b); }
  inline void Swap(AskStartMatch* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskStartMatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskStartMatch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskStartMatch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskStartMatch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskStartMatch& from) { AskStartMatch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskStartMatch* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskStartMatch"; }

 protected:
  explicit AskStartMatch(::google::protobuf::Arena* arena);
  AskStartMatch(::google::protobuf::Arena* arena, const AskStartMatch& from);
  AskStartMatch(::google::protobuf::Arena* arena, AskStartMatch&& from) noexcept
      : AskStartMatch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStartMatch];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskStartMatch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSendMsgToUser final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskSendMsgToUser) */ {
 public:
  inline AskSendMsgToUser() : AskSendMsgToUser(nullptr) {}
  ~AskSendMsgToUser() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSendMsgToUser(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSendMsgToUser(const AskSendMsgToUser& from) : AskSendMsgToUser(nullptr, from) {}
  inline AskSendMsgToUser(AskSendMsgToUser&& from) noexcept
      : AskSendMsgToUser(nullptr, std::move(from)) {}
  inline AskSendMsgToUser& operator=(const AskSendMsgToUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSendMsgToUser& operator=(AskSendMsgToUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSendMsgToUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSendMsgToUser* internal_default_instance() {
    return reinterpret_cast<const AskSendMsgToUser*>(
        &_AskSendMsgToUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(AskSendMsgToUser& a, AskSendMsgToUser& b) { a.Swap(&b); }
  inline void Swap(AskSendMsgToUser* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSendMsgToUser* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSendMsgToUser* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSendMsgToUser>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSendMsgToUser& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSendMsgToUser& from) { AskSendMsgToUser::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSendMsgToUser* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskSendMsgToUser"; }

 protected:
  explicit AskSendMsgToUser(::google::protobuf::Arena* arena);
  AskSendMsgToUser(::google::protobuf::Arena* arena, const AskSendMsgToUser& from);
  AskSendMsgToUser(::google::protobuf::Arena* arena, AskSendMsgToUser&& from) noexcept
      : AskSendMsgToUser(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kContentsFieldNumber = 3,
    kGuididxFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string contents = 3;
  bool has_contents() const;
  void clear_contents() ;
  const std::string& contents() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* value);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // optional uint64 guididx = 2;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskSendMsgToUser];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskSendMsgToUser)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr contents_;
    ::uint64_t guididx_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskRoomList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskRoomList) */ {
 public:
  inline AskRoomList() : AskRoomList(nullptr) {}
  ~AskRoomList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRoomList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRoomList(const AskRoomList& from) : AskRoomList(nullptr, from) {}
  inline AskRoomList(AskRoomList&& from) noexcept
      : AskRoomList(nullptr, std::move(from)) {}
  inline AskRoomList& operator=(const AskRoomList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRoomList& operator=(AskRoomList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRoomList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRoomList* internal_default_instance() {
    return reinterpret_cast<const AskRoomList*>(
        &_AskRoomList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(AskRoomList& a, AskRoomList& b) { a.Swap(&b); }
  inline void Swap(AskRoomList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRoomList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRoomList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRoomList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRoomList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRoomList& from) { AskRoomList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRoomList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskRoomList"; }

 protected:
  explicit AskRoomList(::google::protobuf::Arena* arena);
  AskRoomList(::google::protobuf::Arena* arena, const AskRoomList& from);
  AskRoomList(::google::protobuf::Arena* arena, AskRoomList&& from) noexcept
      : AskRoomList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRoomList];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskRoomList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskRemoveMatchTeam final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskRemoveMatchTeam) */ {
 public:
  inline AskRemoveMatchTeam() : AskRemoveMatchTeam(nullptr) {}
  ~AskRemoveMatchTeam() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRemoveMatchTeam(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRemoveMatchTeam(const AskRemoveMatchTeam& from) : AskRemoveMatchTeam(nullptr, from) {}
  inline AskRemoveMatchTeam(AskRemoveMatchTeam&& from) noexcept
      : AskRemoveMatchTeam(nullptr, std::move(from)) {}
  inline AskRemoveMatchTeam& operator=(const AskRemoveMatchTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRemoveMatchTeam& operator=(AskRemoveMatchTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRemoveMatchTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRemoveMatchTeam* internal_default_instance() {
    return reinterpret_cast<const AskRemoveMatchTeam*>(
        &_AskRemoveMatchTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(AskRemoveMatchTeam& a, AskRemoveMatchTeam& b) { a.Swap(&b); }
  inline void Swap(AskRemoveMatchTeam* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRemoveMatchTeam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRemoveMatchTeam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRemoveMatchTeam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRemoveMatchTeam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRemoveMatchTeam& from) { AskRemoveMatchTeam::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRemoveMatchTeam* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskRemoveMatchTeam"; }

 protected:
  explicit AskRemoveMatchTeam(::google::protobuf::Arena* arena);
  AskRemoveMatchTeam(::google::protobuf::Arena* arena, const AskRemoveMatchTeam& from);
  AskRemoveMatchTeam(::google::protobuf::Arena* arena, AskRemoveMatchTeam&& from) noexcept
      : AskRemoveMatchTeam(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRemoveMatchTeam];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskRemoveMatchTeam)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskRemoveFromSNSList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskRemoveFromSNSList) */ {
 public:
  inline AskRemoveFromSNSList() : AskRemoveFromSNSList(nullptr) {}
  ~AskRemoveFromSNSList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRemoveFromSNSList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRemoveFromSNSList(const AskRemoveFromSNSList& from) : AskRemoveFromSNSList(nullptr, from) {}
  inline AskRemoveFromSNSList(AskRemoveFromSNSList&& from) noexcept
      : AskRemoveFromSNSList(nullptr, std::move(from)) {}
  inline AskRemoveFromSNSList& operator=(const AskRemoveFromSNSList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRemoveFromSNSList& operator=(AskRemoveFromSNSList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRemoveFromSNSList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRemoveFromSNSList* internal_default_instance() {
    return reinterpret_cast<const AskRemoveFromSNSList*>(
        &_AskRemoveFromSNSList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(AskRemoveFromSNSList& a, AskRemoveFromSNSList& b) { a.Swap(&b); }
  inline void Swap(AskRemoveFromSNSList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRemoveFromSNSList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRemoveFromSNSList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRemoveFromSNSList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRemoveFromSNSList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRemoveFromSNSList& from) { AskRemoveFromSNSList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRemoveFromSNSList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskRemoveFromSNSList"; }

 protected:
  explicit AskRemoveFromSNSList(::google::protobuf::Arena* arena);
  AskRemoveFromSNSList(::google::protobuf::Arena* arena, const AskRemoveFromSNSList& from);
  AskRemoveFromSNSList(::google::protobuf::Arena* arena, AskRemoveFromSNSList&& from) noexcept
      : AskRemoveFromSNSList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuididxFieldNumber = 2,
    kTypeFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional uint64 guididx = 2;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional int32 type = 3;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRemoveFromSNSList];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskRemoveFromSNSList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guididx_;
    ::int32_t type_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskRecoinRune final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskRecoinRune) */ {
 public:
  inline AskRecoinRune() : AskRecoinRune(nullptr) {}
  ~AskRecoinRune() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRecoinRune(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRecoinRune(const AskRecoinRune& from) : AskRecoinRune(nullptr, from) {}
  inline AskRecoinRune(AskRecoinRune&& from) noexcept
      : AskRecoinRune(nullptr, std::move(from)) {}
  inline AskRecoinRune& operator=(const AskRecoinRune& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRecoinRune& operator=(AskRecoinRune&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRecoinRune& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRecoinRune* internal_default_instance() {
    return reinterpret_cast<const AskRecoinRune*>(
        &_AskRecoinRune_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AskRecoinRune& a, AskRecoinRune& b) { a.Swap(&b); }
  inline void Swap(AskRecoinRune* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRecoinRune* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRecoinRune* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRecoinRune>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRecoinRune& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRecoinRune& from) { AskRecoinRune::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRecoinRune* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskRecoinRune"; }

 protected:
  explicit AskRecoinRune(::google::protobuf::Arena* arena);
  AskRecoinRune(::google::protobuf::Arena* arena, const AskRecoinRune& from);
  AskRecoinRune(::google::protobuf::Arena* arena, AskRecoinRune&& from) noexcept
      : AskRecoinRune(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRuneIdFieldNumber = 2,
    kPayTypeFieldNumber = 3,
    kCostFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional uint32 rune_id = 2;
  bool has_rune_id() const;
  void clear_rune_id() ;
  ::uint32_t rune_id() const;
  void set_rune_id(::uint32_t value);

  private:
  ::uint32_t _internal_rune_id() const;
  void _internal_set_rune_id(::uint32_t value);

  public:
  // optional uint32 pay_type = 3;
  bool has_pay_type() const;
  void clear_pay_type() ;
  ::uint32_t pay_type() const;
  void set_pay_type(::uint32_t value);

  private:
  ::uint32_t _internal_pay_type() const;
  void _internal_set_pay_type(::uint32_t value);

  public:
  // optional uint32 cost = 4;
  bool has_cost() const;
  void clear_cost() ;
  ::uint32_t cost() const;
  void set_cost(::uint32_t value);

  private:
  ::uint32_t _internal_cost() const;
  void _internal_set_cost(::uint32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRecoinRune];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskRecoinRune)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t rune_id_;
    ::uint32_t pay_type_;
    ::uint32_t cost_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskReadyRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskReadyRoom) */ {
 public:
  inline AskReadyRoom() : AskReadyRoom(nullptr) {}
  ~AskReadyRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskReadyRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskReadyRoom(const AskReadyRoom& from) : AskReadyRoom(nullptr, from) {}
  inline AskReadyRoom(AskReadyRoom&& from) noexcept
      : AskReadyRoom(nullptr, std::move(from)) {}
  inline AskReadyRoom& operator=(const AskReadyRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskReadyRoom& operator=(AskReadyRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskReadyRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskReadyRoom* internal_default_instance() {
    return reinterpret_cast<const AskReadyRoom*>(
        &_AskReadyRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(AskReadyRoom& a, AskReadyRoom& b) { a.Swap(&b); }
  inline void Swap(AskReadyRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskReadyRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskReadyRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskReadyRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskReadyRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskReadyRoom& from) { AskReadyRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskReadyRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskReadyRoom"; }

 protected:
  explicit AskReadyRoom(::google::protobuf::Arena* arena);
  AskReadyRoom(::google::protobuf::Arena* arena, const AskReadyRoom& from);
  AskReadyRoom(::google::protobuf::Arena* arena, AskReadyRoom&& from) noexcept
      : AskReadyRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskReadyRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskReadyRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskReEnterRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskReEnterRoom) */ {
 public:
  inline AskReEnterRoom() : AskReEnterRoom(nullptr) {}
  ~AskReEnterRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskReEnterRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskReEnterRoom(const AskReEnterRoom& from) : AskReEnterRoom(nullptr, from) {}
  inline AskReEnterRoom(AskReEnterRoom&& from) noexcept
      : AskReEnterRoom(nullptr, std::move(from)) {}
  inline AskReEnterRoom& operator=(const AskReEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskReEnterRoom& operator=(AskReEnterRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskReEnterRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskReEnterRoom* internal_default_instance() {
    return reinterpret_cast<const AskReEnterRoom*>(
        &_AskReEnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(AskReEnterRoom& a, AskReEnterRoom& b) { a.Swap(&b); }
  inline void Swap(AskReEnterRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskReEnterRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskReEnterRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskReEnterRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskReEnterRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskReEnterRoom& from) { AskReEnterRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskReEnterRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskReEnterRoom"; }

 protected:
  explicit AskReEnterRoom(::google::protobuf::Arena* arena);
  AskReEnterRoom(::google::protobuf::Arena* arena, const AskReEnterRoom& from);
  AskReEnterRoom(::google::protobuf::Arena* arena, AskReEnterRoom&& from) noexcept
      : AskReEnterRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskReEnterRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskReEnterRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskQuickBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskQuickBattle) */ {
 public:
  inline AskQuickBattle() : AskQuickBattle(nullptr) {}
  ~AskQuickBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskQuickBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskQuickBattle(const AskQuickBattle& from) : AskQuickBattle(nullptr, from) {}
  inline AskQuickBattle(AskQuickBattle&& from) noexcept
      : AskQuickBattle(nullptr, std::move(from)) {}
  inline AskQuickBattle& operator=(const AskQuickBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskQuickBattle& operator=(AskQuickBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskQuickBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskQuickBattle* internal_default_instance() {
    return reinterpret_cast<const AskQuickBattle*>(
        &_AskQuickBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(AskQuickBattle& a, AskQuickBattle& b) { a.Swap(&b); }
  inline void Swap(AskQuickBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskQuickBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskQuickBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskQuickBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskQuickBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskQuickBattle& from) { AskQuickBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskQuickBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskQuickBattle"; }

 protected:
  explicit AskQuickBattle(::google::protobuf::Arena* arena);
  AskQuickBattle(::google::protobuf::Arena* arena, const AskQuickBattle& from);
  AskQuickBattle(::google::protobuf::Arena* arena, AskQuickBattle&& from) noexcept
      : AskQuickBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 mapid = 2;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskQuickBattle];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskQuickBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mapid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskQueryUserByNickName final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskQueryUserByNickName) */ {
 public:
  inline AskQueryUserByNickName() : AskQueryUserByNickName(nullptr) {}
  ~AskQueryUserByNickName() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskQueryUserByNickName(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskQueryUserByNickName(const AskQueryUserByNickName& from) : AskQueryUserByNickName(nullptr, from) {}
  inline AskQueryUserByNickName(AskQueryUserByNickName&& from) noexcept
      : AskQueryUserByNickName(nullptr, std::move(from)) {}
  inline AskQueryUserByNickName& operator=(const AskQueryUserByNickName& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskQueryUserByNickName& operator=(AskQueryUserByNickName&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskQueryUserByNickName& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskQueryUserByNickName* internal_default_instance() {
    return reinterpret_cast<const AskQueryUserByNickName*>(
        &_AskQueryUserByNickName_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(AskQueryUserByNickName& a, AskQueryUserByNickName& b) { a.Swap(&b); }
  inline void Swap(AskQueryUserByNickName* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskQueryUserByNickName* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskQueryUserByNickName* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskQueryUserByNickName>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskQueryUserByNickName& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskQueryUserByNickName& from) { AskQueryUserByNickName::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskQueryUserByNickName* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskQueryUserByNickName"; }

 protected:
  explicit AskQueryUserByNickName(::google::protobuf::Arena* arena);
  AskQueryUserByNickName(::google::protobuf::Arena* arena, const AskQueryUserByNickName& from);
  AskQueryUserByNickName(::google::protobuf::Arena* arena, AskQueryUserByNickName&& from) noexcept
      : AskQueryUserByNickName(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskQueryUserByNickName];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskQueryUserByNickName)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskOneTaskRewards final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskOneTaskRewards) */ {
 public:
  inline AskOneTaskRewards() : AskOneTaskRewards(nullptr) {}
  ~AskOneTaskRewards() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskOneTaskRewards(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskOneTaskRewards(const AskOneTaskRewards& from) : AskOneTaskRewards(nullptr, from) {}
  inline AskOneTaskRewards(AskOneTaskRewards&& from) noexcept
      : AskOneTaskRewards(nullptr, std::move(from)) {}
  inline AskOneTaskRewards& operator=(const AskOneTaskRewards& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskOneTaskRewards& operator=(AskOneTaskRewards&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskOneTaskRewards& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskOneTaskRewards* internal_default_instance() {
    return reinterpret_cast<const AskOneTaskRewards*>(
        &_AskOneTaskRewards_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AskOneTaskRewards& a, AskOneTaskRewards& b) { a.Swap(&b); }
  inline void Swap(AskOneTaskRewards* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskOneTaskRewards* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskOneTaskRewards* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskOneTaskRewards>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskOneTaskRewards& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskOneTaskRewards& from) { AskOneTaskRewards::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskOneTaskRewards* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskOneTaskRewards"; }

 protected:
  explicit AskOneTaskRewards(::google::protobuf::Arena* arena);
  AskOneTaskRewards(::google::protobuf::Arena* arena, const AskOneTaskRewards& from);
  AskOneTaskRewards(::google::protobuf::Arena* arena, AskOneTaskRewards&& from) noexcept
      : AskOneTaskRewards(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskGuidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional uint32 task_guid = 2;
  bool has_task_guid() const;
  void clear_task_guid() ;
  ::uint32_t task_guid() const;
  void set_task_guid(::uint32_t value);

  private:
  ::uint32_t _internal_task_guid() const;
  void _internal_set_task_guid(::uint32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskOneTaskRewards];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskOneTaskRewards)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t task_guid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskMailInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskMailInfo) */ {
 public:
  inline AskMailInfo() : AskMailInfo(nullptr) {}
  ~AskMailInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskMailInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskMailInfo(const AskMailInfo& from) : AskMailInfo(nullptr, from) {}
  inline AskMailInfo(AskMailInfo&& from) noexcept
      : AskMailInfo(nullptr, std::move(from)) {}
  inline AskMailInfo& operator=(const AskMailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskMailInfo& operator=(AskMailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskMailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskMailInfo* internal_default_instance() {
    return reinterpret_cast<const AskMailInfo*>(
        &_AskMailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(AskMailInfo& a, AskMailInfo& b) { a.Swap(&b); }
  inline void Swap(AskMailInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskMailInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskMailInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskMailInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskMailInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskMailInfo& from) { AskMailInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskMailInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskMailInfo"; }

 protected:
  explicit AskMailInfo(::google::protobuf::Arena* arena);
  AskMailInfo(::google::protobuf::Arena* arena, const AskMailInfo& from);
  AskMailInfo(::google::protobuf::Arena* arena, AskMailInfo&& from) noexcept
      : AskMailInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailIdFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 mailId = 2;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskMailInfo];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskMailInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mailid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskLeaveRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskLeaveRoom) */ {
 public:
  inline AskLeaveRoom() : AskLeaveRoom(nullptr) {}
  ~AskLeaveRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskLeaveRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskLeaveRoom(const AskLeaveRoom& from) : AskLeaveRoom(nullptr, from) {}
  inline AskLeaveRoom(AskLeaveRoom&& from) noexcept
      : AskLeaveRoom(nullptr, std::move(from)) {}
  inline AskLeaveRoom& operator=(const AskLeaveRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskLeaveRoom& operator=(AskLeaveRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskLeaveRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskLeaveRoom* internal_default_instance() {
    return reinterpret_cast<const AskLeaveRoom*>(
        &_AskLeaveRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(AskLeaveRoom& a, AskLeaveRoom& b) { a.Swap(&b); }
  inline void Swap(AskLeaveRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskLeaveRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskLeaveRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskLeaveRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskLeaveRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskLeaveRoom& from) { AskLeaveRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskLeaveRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskLeaveRoom"; }

 protected:
  explicit AskLeaveRoom(::google::protobuf::Arena* arena);
  AskLeaveRoom(::google::protobuf::Arena* arena, const AskLeaveRoom& from);
  AskLeaveRoom(::google::protobuf::Arena* arena, AskLeaveRoom&& from) noexcept
      : AskLeaveRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskLeaveRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskLeaveRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskInviteJoinMatchTeam final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskInviteJoinMatchTeam) */ {
 public:
  inline AskInviteJoinMatchTeam() : AskInviteJoinMatchTeam(nullptr) {}
  ~AskInviteJoinMatchTeam() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskInviteJoinMatchTeam(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskInviteJoinMatchTeam(const AskInviteJoinMatchTeam& from) : AskInviteJoinMatchTeam(nullptr, from) {}
  inline AskInviteJoinMatchTeam(AskInviteJoinMatchTeam&& from) noexcept
      : AskInviteJoinMatchTeam(nullptr, std::move(from)) {}
  inline AskInviteJoinMatchTeam& operator=(const AskInviteJoinMatchTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskInviteJoinMatchTeam& operator=(AskInviteJoinMatchTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskInviteJoinMatchTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskInviteJoinMatchTeam* internal_default_instance() {
    return reinterpret_cast<const AskInviteJoinMatchTeam*>(
        &_AskInviteJoinMatchTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(AskInviteJoinMatchTeam& a, AskInviteJoinMatchTeam& b) { a.Swap(&b); }
  inline void Swap(AskInviteJoinMatchTeam* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskInviteJoinMatchTeam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskInviteJoinMatchTeam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskInviteJoinMatchTeam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskInviteJoinMatchTeam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskInviteJoinMatchTeam& from) { AskInviteJoinMatchTeam::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskInviteJoinMatchTeam* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskInviteJoinMatchTeam"; }

 protected:
  explicit AskInviteJoinMatchTeam(::google::protobuf::Arena* arena);
  AskInviteJoinMatchTeam(::google::protobuf::Arena* arena, const AskInviteJoinMatchTeam& from);
  AskInviteJoinMatchTeam(::google::protobuf::Arena* arena, AskInviteJoinMatchTeam&& from) noexcept
      : AskInviteJoinMatchTeam(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFriendsNickNameFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string friendsNickName = 2;
  bool has_friendsnickname() const;
  void clear_friendsnickname() ;
  const std::string& friendsnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_friendsnickname(Arg_&& arg, Args_... args);
  std::string* mutable_friendsnickname();
  PROTOBUF_NODISCARD std::string* release_friendsnickname();
  void set_allocated_friendsnickname(std::string* value);

  private:
  const std::string& _internal_friendsnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friendsnickname(
      const std::string& value);
  std::string* _internal_mutable_friendsnickname();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskInviteJoinMatchTeam];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskInviteJoinMatchTeam)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr friendsnickname_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskInviteFriendsToBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskInviteFriendsToBattle) */ {
 public:
  inline AskInviteFriendsToBattle() : AskInviteFriendsToBattle(nullptr) {}
  ~AskInviteFriendsToBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskInviteFriendsToBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskInviteFriendsToBattle(const AskInviteFriendsToBattle& from) : AskInviteFriendsToBattle(nullptr, from) {}
  inline AskInviteFriendsToBattle(AskInviteFriendsToBattle&& from) noexcept
      : AskInviteFriendsToBattle(nullptr, std::move(from)) {}
  inline AskInviteFriendsToBattle& operator=(const AskInviteFriendsToBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskInviteFriendsToBattle& operator=(AskInviteFriendsToBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskInviteFriendsToBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskInviteFriendsToBattle* internal_default_instance() {
    return reinterpret_cast<const AskInviteFriendsToBattle*>(
        &_AskInviteFriendsToBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(AskInviteFriendsToBattle& a, AskInviteFriendsToBattle& b) { a.Swap(&b); }
  inline void Swap(AskInviteFriendsToBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskInviteFriendsToBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskInviteFriendsToBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskInviteFriendsToBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskInviteFriendsToBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskInviteFriendsToBattle& from) { AskInviteFriendsToBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskInviteFriendsToBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskInviteFriendsToBattle"; }

 protected:
  explicit AskInviteFriendsToBattle(::google::protobuf::Arena* arena);
  AskInviteFriendsToBattle(::google::protobuf::Arena* arena, const AskInviteFriendsToBattle& from);
  AskInviteFriendsToBattle(::google::protobuf::Arena* arena, AskInviteFriendsToBattle&& from) noexcept
      : AskInviteFriendsToBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuididxFieldNumber = 3,
    kBattleidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional uint64 guididx = 3;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional int32 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::int32_t battleid() const;
  void set_battleid(::int32_t value);

  private:
  ::int32_t _internal_battleid() const;
  void _internal_set_battleid(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskInviteFriendsToBattle];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskInviteFriendsToBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guididx_;
    ::int32_t battleid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskGoodscfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskGoodscfg) */ {
 public:
  inline AskGoodscfg() : AskGoodscfg(nullptr) {}
  ~AskGoodscfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskGoodscfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskGoodscfg(const AskGoodscfg& from) : AskGoodscfg(nullptr, from) {}
  inline AskGoodscfg(AskGoodscfg&& from) noexcept
      : AskGoodscfg(nullptr, std::move(from)) {}
  inline AskGoodscfg& operator=(const AskGoodscfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskGoodscfg& operator=(AskGoodscfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskGoodscfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskGoodscfg* internal_default_instance() {
    return reinterpret_cast<const AskGoodscfg*>(
        &_AskGoodscfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(AskGoodscfg& a, AskGoodscfg& b) { a.Swap(&b); }
  inline void Swap(AskGoodscfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskGoodscfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskGoodscfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskGoodscfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskGoodscfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskGoodscfg& from) { AskGoodscfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskGoodscfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskGoodscfg"; }

 protected:
  explicit AskGoodscfg(::google::protobuf::Arena* arena);
  AskGoodscfg(::google::protobuf::Arena* arena, const AskGoodscfg& from);
  AskGoodscfg(::google::protobuf::Arena* arena, AskGoodscfg&& from) noexcept
      : AskGoodscfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGoodscfg];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskGoodscfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskGetMailGift final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskGetMailGift) */ {
 public:
  inline AskGetMailGift() : AskGetMailGift(nullptr) {}
  ~AskGetMailGift() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskGetMailGift(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskGetMailGift(const AskGetMailGift& from) : AskGetMailGift(nullptr, from) {}
  inline AskGetMailGift(AskGetMailGift&& from) noexcept
      : AskGetMailGift(nullptr, std::move(from)) {}
  inline AskGetMailGift& operator=(const AskGetMailGift& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskGetMailGift& operator=(AskGetMailGift&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskGetMailGift& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskGetMailGift* internal_default_instance() {
    return reinterpret_cast<const AskGetMailGift*>(
        &_AskGetMailGift_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(AskGetMailGift& a, AskGetMailGift& b) { a.Swap(&b); }
  inline void Swap(AskGetMailGift* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskGetMailGift* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskGetMailGift* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskGetMailGift>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskGetMailGift& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskGetMailGift& from) { AskGetMailGift::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskGetMailGift* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskGetMailGift"; }

 protected:
  explicit AskGetMailGift(::google::protobuf::Arena* arena);
  AskGetMailGift(::google::protobuf::Arena* arena, const AskGetMailGift& from);
  AskGetMailGift(::google::protobuf::Arena* arena, AskGetMailGift&& from) noexcept
      : AskGetMailGift(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailIdFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 mailId = 2;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGetMailGift];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskGetMailGift)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mailid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskCurtNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskCurtNotice) */ {
 public:
  inline AskCurtNotice() : AskCurtNotice(nullptr) {}
  ~AskCurtNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskCurtNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskCurtNotice(const AskCurtNotice& from) : AskCurtNotice(nullptr, from) {}
  inline AskCurtNotice(AskCurtNotice&& from) noexcept
      : AskCurtNotice(nullptr, std::move(from)) {}
  inline AskCurtNotice& operator=(const AskCurtNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskCurtNotice& operator=(AskCurtNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskCurtNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskCurtNotice* internal_default_instance() {
    return reinterpret_cast<const AskCurtNotice*>(
        &_AskCurtNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(AskCurtNotice& a, AskCurtNotice& b) { a.Swap(&b); }
  inline void Swap(AskCurtNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskCurtNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskCurtNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskCurtNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskCurtNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskCurtNotice& from) { AskCurtNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskCurtNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskCurtNotice"; }

 protected:
  explicit AskCurtNotice(::google::protobuf::Arena* arena);
  AskCurtNotice(::google::protobuf::Arena* arena, const AskCurtNotice& from);
  AskCurtNotice(::google::protobuf::Arena* arena, AskCurtNotice&& from) noexcept
      : AskCurtNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.notice_type type = 2;
  bool has_type() const;
  void clear_type() ;
  ::GCToCS::notice_type type() const;
  void set_type(::GCToCS::notice_type value);

  private:
  ::GCToCS::notice_type _internal_type() const;
  void _internal_set_type(::GCToCS::notice_type value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCurtNotice];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskCurtNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int type_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskCreateRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskCreateRoom) */ {
 public:
  inline AskCreateRoom() : AskCreateRoom(nullptr) {}
  ~AskCreateRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskCreateRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskCreateRoom(const AskCreateRoom& from) : AskCreateRoom(nullptr, from) {}
  inline AskCreateRoom(AskCreateRoom&& from) noexcept
      : AskCreateRoom(nullptr, std::move(from)) {}
  inline AskCreateRoom& operator=(const AskCreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskCreateRoom& operator=(AskCreateRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskCreateRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskCreateRoom* internal_default_instance() {
    return reinterpret_cast<const AskCreateRoom*>(
        &_AskCreateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(AskCreateRoom& a, AskCreateRoom& b) { a.Swap(&b); }
  inline void Swap(AskCreateRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskCreateRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskCreateRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskCreateRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskCreateRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskCreateRoom& from) { AskCreateRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskCreateRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskCreateRoom"; }

 protected:
  explicit AskCreateRoom(::google::protobuf::Arena* arena);
  AskCreateRoom(::google::protobuf::Arena* arena, const AskCreateRoom& from);
  AskCreateRoom(::google::protobuf::Arena* arena, AskCreateRoom&& from) noexcept
      : AskCreateRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPasswdFieldNumber = 3,
    kMapidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string passwd = 3;
  bool has_passwd() const;
  void clear_passwd() ;
  const std::string& passwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passwd(Arg_&& arg, Args_... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* value);

  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(
      const std::string& value);
  std::string* _internal_mutable_passwd();

  public:
  // optional int32 mapid = 2;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCreateRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskCreateRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr passwd_;
    ::int32_t mapid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskCreateMatchTeam final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskCreateMatchTeam) */ {
 public:
  inline AskCreateMatchTeam() : AskCreateMatchTeam(nullptr) {}
  ~AskCreateMatchTeam() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskCreateMatchTeam(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskCreateMatchTeam(const AskCreateMatchTeam& from) : AskCreateMatchTeam(nullptr, from) {}
  inline AskCreateMatchTeam(AskCreateMatchTeam&& from) noexcept
      : AskCreateMatchTeam(nullptr, std::move(from)) {}
  inline AskCreateMatchTeam& operator=(const AskCreateMatchTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskCreateMatchTeam& operator=(AskCreateMatchTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskCreateMatchTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskCreateMatchTeam* internal_default_instance() {
    return reinterpret_cast<const AskCreateMatchTeam*>(
        &_AskCreateMatchTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(AskCreateMatchTeam& a, AskCreateMatchTeam& b) { a.Swap(&b); }
  inline void Swap(AskCreateMatchTeam* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskCreateMatchTeam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskCreateMatchTeam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskCreateMatchTeam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskCreateMatchTeam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskCreateMatchTeam& from) { AskCreateMatchTeam::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskCreateMatchTeam* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskCreateMatchTeam"; }

 protected:
  explicit AskCreateMatchTeam(::google::protobuf::Arena* arena);
  AskCreateMatchTeam(::google::protobuf::Arena* arena, const AskCreateMatchTeam& from);
  AskCreateMatchTeam(::google::protobuf::Arena* arena, AskCreateMatchTeam&& from) noexcept
      : AskCreateMatchTeam(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMatchtypeFieldNumber = 2,
    kMapidFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional uint32 matchtype = 2;
  bool has_matchtype() const;
  void clear_matchtype() ;
  ::uint32_t matchtype() const;
  void set_matchtype(::uint32_t value);

  private:
  ::uint32_t _internal_matchtype() const;
  void _internal_set_matchtype(::uint32_t value);

  public:
  // optional uint32 mapid = 3;
  bool has_mapid() const;
  void clear_mapid() ;
  ::uint32_t mapid() const;
  void set_mapid(::uint32_t value);

  private:
  ::uint32_t _internal_mapid() const;
  void _internal_set_mapid(::uint32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCreateMatchTeam];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskCreateMatchTeam)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t matchtype_;
    ::uint32_t mapid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskChatInRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskChatInRoom) */ {
 public:
  inline AskChatInRoom() : AskChatInRoom(nullptr) {}
  ~AskChatInRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskChatInRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskChatInRoom(const AskChatInRoom& from) : AskChatInRoom(nullptr, from) {}
  inline AskChatInRoom(AskChatInRoom&& from) noexcept
      : AskChatInRoom(nullptr, std::move(from)) {}
  inline AskChatInRoom& operator=(const AskChatInRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskChatInRoom& operator=(AskChatInRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskChatInRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskChatInRoom* internal_default_instance() {
    return reinterpret_cast<const AskChatInRoom*>(
        &_AskChatInRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(AskChatInRoom& a, AskChatInRoom& b) { a.Swap(&b); }
  inline void Swap(AskChatInRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskChatInRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskChatInRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskChatInRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskChatInRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskChatInRoom& from) { AskChatInRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskChatInRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskChatInRoom"; }

 protected:
  explicit AskChatInRoom(::google::protobuf::Arena* arena);
  AskChatInRoom(::google::protobuf::Arena* arena, const AskChatInRoom& from);
  AskChatInRoom(::google::protobuf::Arena* arena, AskChatInRoom&& from) noexcept
      : AskChatInRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChatFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string chat = 2;
  bool has_chat() const;
  void clear_chat() ;
  const std::string& chat() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chat(Arg_&& arg, Args_... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* value);

  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(
      const std::string& value);
  std::string* _internal_mutable_chat();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChatInRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskChatInRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      33, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr chat_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskChangeheaderId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskChangeheaderId) */ {
 public:
  inline AskChangeheaderId() : AskChangeheaderId(nullptr) {}
  ~AskChangeheaderId() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskChangeheaderId(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskChangeheaderId(const AskChangeheaderId& from) : AskChangeheaderId(nullptr, from) {}
  inline AskChangeheaderId(AskChangeheaderId&& from) noexcept
      : AskChangeheaderId(nullptr, std::move(from)) {}
  inline AskChangeheaderId& operator=(const AskChangeheaderId& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskChangeheaderId& operator=(AskChangeheaderId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskChangeheaderId& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskChangeheaderId* internal_default_instance() {
    return reinterpret_cast<const AskChangeheaderId*>(
        &_AskChangeheaderId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AskChangeheaderId& a, AskChangeheaderId& b) { a.Swap(&b); }
  inline void Swap(AskChangeheaderId* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskChangeheaderId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskChangeheaderId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskChangeheaderId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskChangeheaderId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskChangeheaderId& from) { AskChangeheaderId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskChangeheaderId* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskChangeheaderId"; }

 protected:
  explicit AskChangeheaderId(::google::protobuf::Arena* arena);
  AskChangeheaderId(::google::protobuf::Arena* arena, const AskChangeheaderId& from);
  AskChangeheaderId(::google::protobuf::Arena* arena, AskChangeheaderId&& from) noexcept
      : AskChangeheaderId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewheaderidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional uint32 newheaderid = 2;
  bool has_newheaderid() const;
  void clear_newheaderid() ;
  ::uint32_t newheaderid() const;
  void set_newheaderid(::uint32_t value);

  private:
  ::uint32_t _internal_newheaderid() const;
  void _internal_set_newheaderid(::uint32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChangeheaderId];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskChangeheaderId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t newheaderid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskChangeRoomSeat final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskChangeRoomSeat) */ {
 public:
  inline AskChangeRoomSeat() : AskChangeRoomSeat(nullptr) {}
  ~AskChangeRoomSeat() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskChangeRoomSeat(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskChangeRoomSeat(const AskChangeRoomSeat& from) : AskChangeRoomSeat(nullptr, from) {}
  inline AskChangeRoomSeat(AskChangeRoomSeat&& from) noexcept
      : AskChangeRoomSeat(nullptr, std::move(from)) {}
  inline AskChangeRoomSeat& operator=(const AskChangeRoomSeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskChangeRoomSeat& operator=(AskChangeRoomSeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskChangeRoomSeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskChangeRoomSeat* internal_default_instance() {
    return reinterpret_cast<const AskChangeRoomSeat*>(
        &_AskChangeRoomSeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(AskChangeRoomSeat& a, AskChangeRoomSeat& b) { a.Swap(&b); }
  inline void Swap(AskChangeRoomSeat* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskChangeRoomSeat* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskChangeRoomSeat* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskChangeRoomSeat>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskChangeRoomSeat& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskChangeRoomSeat& from) { AskChangeRoomSeat::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskChangeRoomSeat* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskChangeRoomSeat"; }

 protected:
  explicit AskChangeRoomSeat(::google::protobuf::Arena* arena);
  AskChangeRoomSeat(::google::protobuf::Arena* arena, const AskChangeRoomSeat& from);
  AskChangeRoomSeat(::google::protobuf::Arena* arena, AskChangeRoomSeat&& from) noexcept
      : AskChangeRoomSeat(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewposFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 newpos = 2;
  bool has_newpos() const;
  void clear_newpos() ;
  ::int32_t newpos() const;
  void set_newpos(::int32_t value);

  private:
  ::int32_t _internal_newpos() const;
  void _internal_set_newpos(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChangeRoomSeat];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskChangeRoomSeat)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t newpos_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskCancelRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskCancelRoom) */ {
 public:
  inline AskCancelRoom() : AskCancelRoom(nullptr) {}
  ~AskCancelRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskCancelRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskCancelRoom(const AskCancelRoom& from) : AskCancelRoom(nullptr, from) {}
  inline AskCancelRoom(AskCancelRoom&& from) noexcept
      : AskCancelRoom(nullptr, std::move(from)) {}
  inline AskCancelRoom& operator=(const AskCancelRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskCancelRoom& operator=(AskCancelRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskCancelRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskCancelRoom* internal_default_instance() {
    return reinterpret_cast<const AskCancelRoom*>(
        &_AskCancelRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(AskCancelRoom& a, AskCancelRoom& b) { a.Swap(&b); }
  inline void Swap(AskCancelRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskCancelRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskCancelRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskCancelRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskCancelRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskCancelRoom& from) { AskCancelRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskCancelRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskCancelRoom"; }

 protected:
  explicit AskCancelRoom(::google::protobuf::Arena* arena);
  AskCancelRoom(::google::protobuf::Arena* arena, const AskCancelRoom& from);
  AskCancelRoom(::google::protobuf::Arena* arena, AskCancelRoom&& from) noexcept
      : AskCancelRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCancelRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskCancelRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskCanInviteFriends final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskCanInviteFriends) */ {
 public:
  inline AskCanInviteFriends() : AskCanInviteFriends(nullptr) {}
  ~AskCanInviteFriends() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskCanInviteFriends(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskCanInviteFriends(const AskCanInviteFriends& from) : AskCanInviteFriends(nullptr, from) {}
  inline AskCanInviteFriends(AskCanInviteFriends&& from) noexcept
      : AskCanInviteFriends(nullptr, std::move(from)) {}
  inline AskCanInviteFriends& operator=(const AskCanInviteFriends& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskCanInviteFriends& operator=(AskCanInviteFriends&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskCanInviteFriends& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskCanInviteFriends* internal_default_instance() {
    return reinterpret_cast<const AskCanInviteFriends*>(
        &_AskCanInviteFriends_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(AskCanInviteFriends& a, AskCanInviteFriends& b) { a.Swap(&b); }
  inline void Swap(AskCanInviteFriends* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskCanInviteFriends* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskCanInviteFriends* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskCanInviteFriends>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskCanInviteFriends& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskCanInviteFriends& from) { AskCanInviteFriends::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskCanInviteFriends* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskCanInviteFriends"; }

 protected:
  explicit AskCanInviteFriends(::google::protobuf::Arena* arena);
  AskCanInviteFriends(::google::protobuf::Arena* arena, const AskCanInviteFriends& from);
  AskCanInviteFriends(::google::protobuf::Arena* arena, AskCanInviteFriends&& from) noexcept
      : AskCanInviteFriends(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCanInviteFriends];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskCanInviteFriends)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskCSCreateGuideBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskCSCreateGuideBattle) */ {
 public:
  inline AskCSCreateGuideBattle() : AskCSCreateGuideBattle(nullptr) {}
  ~AskCSCreateGuideBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskCSCreateGuideBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskCSCreateGuideBattle(const AskCSCreateGuideBattle& from) : AskCSCreateGuideBattle(nullptr, from) {}
  inline AskCSCreateGuideBattle(AskCSCreateGuideBattle&& from) noexcept
      : AskCSCreateGuideBattle(nullptr, std::move(from)) {}
  inline AskCSCreateGuideBattle& operator=(const AskCSCreateGuideBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskCSCreateGuideBattle& operator=(AskCSCreateGuideBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskCSCreateGuideBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskCSCreateGuideBattle* internal_default_instance() {
    return reinterpret_cast<const AskCSCreateGuideBattle*>(
        &_AskCSCreateGuideBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(AskCSCreateGuideBattle& a, AskCSCreateGuideBattle& b) { a.Swap(&b); }
  inline void Swap(AskCSCreateGuideBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskCSCreateGuideBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskCSCreateGuideBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskCSCreateGuideBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskCSCreateGuideBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskCSCreateGuideBattle& from) { AskCSCreateGuideBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskCSCreateGuideBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskCSCreateGuideBattle"; }

 protected:
  explicit AskCSCreateGuideBattle(::google::protobuf::Arena* arena);
  AskCSCreateGuideBattle(::google::protobuf::Arena* arena, const AskCSCreateGuideBattle& from);
  AskCSCreateGuideBattle(::google::protobuf::Arena* arena, AskCSCreateGuideBattle&& from) noexcept
      : AskCSCreateGuideBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using guidetype = AskCSCreateGuideBattle_guidetype;
  static constexpr guidetype first = AskCSCreateGuideBattle_guidetype_first;
  static constexpr guidetype second = AskCSCreateGuideBattle_guidetype_second;
  static constexpr guidetype other = AskCSCreateGuideBattle_guidetype_other;
  static inline bool guidetype_IsValid(int value) {
    return AskCSCreateGuideBattle_guidetype_IsValid(value);
  }
  static constexpr guidetype guidetype_MIN = AskCSCreateGuideBattle_guidetype_guidetype_MIN;
  static constexpr guidetype guidetype_MAX = AskCSCreateGuideBattle_guidetype_guidetype_MAX;
  static constexpr int guidetype_ARRAYSIZE = AskCSCreateGuideBattle_guidetype_guidetype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* guidetype_descriptor() {
    return AskCSCreateGuideBattle_guidetype_descriptor();
  }
  template <typename T>
  static inline const std::string& guidetype_Name(T value) {
    return AskCSCreateGuideBattle_guidetype_Name(value);
  }
  static inline bool guidetype_Parse(absl::string_view name, guidetype* value) {
    return AskCSCreateGuideBattle_guidetype_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kMapidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
    kNtypeFieldNumber = 3,
  };
  // optional int32 mapid = 2;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGuideBattle];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // optional .GCToCS.AskCSCreateGuideBattle.guidetype ntype = 3;
  bool has_ntype() const;
  void clear_ntype() ;
  ::GCToCS::AskCSCreateGuideBattle_guidetype ntype() const;
  void set_ntype(::GCToCS::AskCSCreateGuideBattle_guidetype value);

  private:
  ::GCToCS::AskCSCreateGuideBattle_guidetype _internal_ntype() const;
  void _internal_set_ntype(::GCToCS::AskCSCreateGuideBattle_guidetype value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskCSCreateGuideBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mapid_;
    int msgnum_;
    int ntype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskBuyGoods final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskBuyGoods) */ {
 public:
  inline AskBuyGoods() : AskBuyGoods(nullptr) {}
  ~AskBuyGoods() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskBuyGoods(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskBuyGoods(const AskBuyGoods& from) : AskBuyGoods(nullptr, from) {}
  inline AskBuyGoods(AskBuyGoods&& from) noexcept
      : AskBuyGoods(nullptr, std::move(from)) {}
  inline AskBuyGoods& operator=(const AskBuyGoods& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskBuyGoods& operator=(AskBuyGoods&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskBuyGoods& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskBuyGoods* internal_default_instance() {
    return reinterpret_cast<const AskBuyGoods*>(
        &_AskBuyGoods_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(AskBuyGoods& a, AskBuyGoods& b) { a.Swap(&b); }
  inline void Swap(AskBuyGoods* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskBuyGoods* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskBuyGoods* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskBuyGoods>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskBuyGoods& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskBuyGoods& from) { AskBuyGoods::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskBuyGoods* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskBuyGoods"; }

 protected:
  explicit AskBuyGoods(::google::protobuf::Arena* arena);
  AskBuyGoods(::google::protobuf::Arena* arena, const AskBuyGoods& from);
  AskBuyGoods(::google::protobuf::Arena* arena, AskBuyGoods&& from) noexcept
      : AskBuyGoods(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommondityidFieldNumber = 2,
    kConsumetypeFieldNumber = 3,
    kNumFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 commondityid = 2;
  bool has_commondityid() const;
  void clear_commondityid() ;
  ::int32_t commondityid() const;
  void set_commondityid(::int32_t value);

  private:
  ::int32_t _internal_commondityid() const;
  void _internal_set_commondityid(::int32_t value);

  public:
  // optional int32 consumetype = 3;
  bool has_consumetype() const;
  void clear_consumetype() ;
  ::int32_t consumetype() const;
  void set_consumetype(::int32_t value);

  private:
  ::int32_t _internal_consumetype() const;
  void _internal_set_consumetype(::int32_t value);

  public:
  // optional uint32 num = 4;
  bool has_num() const;
  void clear_num() ;
  ::uint32_t num() const;
  void set_num(::uint32_t value);

  private:
  ::uint32_t _internal_num() const;
  void _internal_set_num(::uint32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskBuyGoods];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskBuyGoods)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t commondityid_;
    ::int32_t consumetype_;
    ::uint32_t num_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskAddToSNSListByID final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskAddToSNSListByID) */ {
 public:
  inline AskAddToSNSListByID() : AskAddToSNSListByID(nullptr) {}
  ~AskAddToSNSListByID() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskAddToSNSListByID(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskAddToSNSListByID(const AskAddToSNSListByID& from) : AskAddToSNSListByID(nullptr, from) {}
  inline AskAddToSNSListByID(AskAddToSNSListByID&& from) noexcept
      : AskAddToSNSListByID(nullptr, std::move(from)) {}
  inline AskAddToSNSListByID& operator=(const AskAddToSNSListByID& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskAddToSNSListByID& operator=(AskAddToSNSListByID&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskAddToSNSListByID& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskAddToSNSListByID* internal_default_instance() {
    return reinterpret_cast<const AskAddToSNSListByID*>(
        &_AskAddToSNSListByID_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(AskAddToSNSListByID& a, AskAddToSNSListByID& b) { a.Swap(&b); }
  inline void Swap(AskAddToSNSListByID* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskAddToSNSListByID* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskAddToSNSListByID* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskAddToSNSListByID>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskAddToSNSListByID& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskAddToSNSListByID& from) { AskAddToSNSListByID::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskAddToSNSListByID* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskAddToSNSListByID"; }

 protected:
  explicit AskAddToSNSListByID(::google::protobuf::Arena* arena);
  AskAddToSNSListByID(::google::protobuf::Arena* arena, const AskAddToSNSListByID& from);
  AskAddToSNSListByID(::google::protobuf::Arena* arena, AskAddToSNSListByID&& from) noexcept
      : AskAddToSNSListByID(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUseridFieldNumber = 2,
    kTypeFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional uint64 userid = 2;
  bool has_userid() const;
  void clear_userid() ;
  ::uint64_t userid() const;
  void set_userid(::uint64_t value);

  private:
  ::uint64_t _internal_userid() const;
  void _internal_set_userid(::uint64_t value);

  public:
  // optional int32 type = 3;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddToSNSListByID];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskAddToSNSListByID)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t userid_;
    ::int32_t type_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskAddToSNSList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskAddToSNSList) */ {
 public:
  inline AskAddToSNSList() : AskAddToSNSList(nullptr) {}
  ~AskAddToSNSList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskAddToSNSList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskAddToSNSList(const AskAddToSNSList& from) : AskAddToSNSList(nullptr, from) {}
  inline AskAddToSNSList(AskAddToSNSList&& from) noexcept
      : AskAddToSNSList(nullptr, std::move(from)) {}
  inline AskAddToSNSList& operator=(const AskAddToSNSList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskAddToSNSList& operator=(AskAddToSNSList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskAddToSNSList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskAddToSNSList* internal_default_instance() {
    return reinterpret_cast<const AskAddToSNSList*>(
        &_AskAddToSNSList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(AskAddToSNSList& a, AskAddToSNSList& b) { a.Swap(&b); }
  inline void Swap(AskAddToSNSList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskAddToSNSList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskAddToSNSList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskAddToSNSList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskAddToSNSList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskAddToSNSList& from) { AskAddToSNSList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskAddToSNSList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskAddToSNSList"; }

 protected:
  explicit AskAddToSNSList(::google::protobuf::Arena* arena);
  AskAddToSNSList(::google::protobuf::Arena* arena, const AskAddToSNSList& from);
  AskAddToSNSList(::google::protobuf::Arena* arena, AskAddToSNSList&& from) noexcept
      : AskAddToSNSList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kTypeFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional int32 type = 3;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddToSNSList];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskAddToSNSList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::int32_t type_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskAddRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskAddRoom) */ {
 public:
  inline AskAddRoom() : AskAddRoom(nullptr) {}
  ~AskAddRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskAddRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskAddRoom(const AskAddRoom& from) : AskAddRoom(nullptr, from) {}
  inline AskAddRoom(AskAddRoom&& from) noexcept
      : AskAddRoom(nullptr, std::move(from)) {}
  inline AskAddRoom& operator=(const AskAddRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskAddRoom& operator=(AskAddRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskAddRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskAddRoom* internal_default_instance() {
    return reinterpret_cast<const AskAddRoom*>(
        &_AskAddRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(AskAddRoom& a, AskAddRoom& b) { a.Swap(&b); }
  inline void Swap(AskAddRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskAddRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskAddRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskAddRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskAddRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskAddRoom& from) { AskAddRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskAddRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskAddRoom"; }

 protected:
  explicit AskAddRoom(::google::protobuf::Arena* arena);
  AskAddRoom(::google::protobuf::Arena* arena, const AskAddRoom& from);
  AskAddRoom(::google::protobuf::Arena* arena, AskAddRoom&& from) noexcept
      : AskAddRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPasswdFieldNumber = 3,
    kBattleidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string passwd = 3;
  bool has_passwd() const;
  void clear_passwd() ;
  const std::string& passwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passwd(Arg_&& arg, Args_... args);
  std::string* mutable_passwd();
  PROTOBUF_NODISCARD std::string* release_passwd();
  void set_allocated_passwd(std::string* value);

  private:
  const std::string& _internal_passwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passwd(
      const std::string& value);
  std::string* _internal_mutable_passwd();

  public:
  // optional uint64 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::uint64_t battleid() const;
  void set_battleid(::uint64_t value);

  private:
  ::uint64_t _internal_battleid() const;
  void _internal_set_battleid(::uint64_t value);

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddRoom];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskAddRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr passwd_;
    ::uint64_t battleid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AskAddMatchTeam final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AskAddMatchTeam) */ {
 public:
  inline AskAddMatchTeam() : AskAddMatchTeam(nullptr) {}
  ~AskAddMatchTeam() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskAddMatchTeam(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskAddMatchTeam(const AskAddMatchTeam& from) : AskAddMatchTeam(nullptr, from) {}
  inline AskAddMatchTeam(AskAddMatchTeam&& from) noexcept
      : AskAddMatchTeam(nullptr, std::move(from)) {}
  inline AskAddMatchTeam& operator=(const AskAddMatchTeam& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskAddMatchTeam& operator=(AskAddMatchTeam&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskAddMatchTeam& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskAddMatchTeam* internal_default_instance() {
    return reinterpret_cast<const AskAddMatchTeam*>(
        &_AskAddMatchTeam_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(AskAddMatchTeam& a, AskAddMatchTeam& b) { a.Swap(&b); }
  inline void Swap(AskAddMatchTeam* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskAddMatchTeam* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskAddMatchTeam* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskAddMatchTeam>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskAddMatchTeam& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskAddMatchTeam& from) { AskAddMatchTeam::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskAddMatchTeam* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AskAddMatchTeam"; }

 protected:
  explicit AskAddMatchTeam(::google::protobuf::Arena* arena);
  AskAddMatchTeam(::google::protobuf::Arena* arena, const AskAddMatchTeam& from);
  AskAddMatchTeam(::google::protobuf::Arena* arena, AskAddMatchTeam&& from) noexcept
      : AskAddMatchTeam(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFriendsNickNameFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string friendsNickName = 2;
  bool has_friendsnickname() const;
  void clear_friendsnickname() ;
  const std::string& friendsnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_friendsnickname(Arg_&& arg, Args_... args);
  std::string* mutable_friendsnickname();
  PROTOBUF_NODISCARD std::string* release_friendsnickname();
  void set_allocated_friendsnickname(std::string* value);

  private:
  const std::string& _internal_friendsnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friendsnickname(
      const std::string& value);
  std::string* _internal_mutable_friendsnickname();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddMatchTeam];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AskAddMatchTeam)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      46, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr friendsnickname_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class AddCSGMCmd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.AddCSGMCmd) */ {
 public:
  inline AddCSGMCmd() : AddCSGMCmd(nullptr) {}
  ~AddCSGMCmd() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddCSGMCmd(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddCSGMCmd(const AddCSGMCmd& from) : AddCSGMCmd(nullptr, from) {}
  inline AddCSGMCmd(AddCSGMCmd&& from) noexcept
      : AddCSGMCmd(nullptr, std::move(from)) {}
  inline AddCSGMCmd& operator=(const AddCSGMCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddCSGMCmd& operator=(AddCSGMCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddCSGMCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddCSGMCmd* internal_default_instance() {
    return reinterpret_cast<const AddCSGMCmd*>(
        &_AddCSGMCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AddCSGMCmd& a, AddCSGMCmd& b) { a.Swap(&b); }
  inline void Swap(AddCSGMCmd* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddCSGMCmd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddCSGMCmd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AddCSGMCmd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddCSGMCmd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddCSGMCmd& from) { AddCSGMCmd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddCSGMCmd* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.AddCSGMCmd"; }

 protected:
  explicit AddCSGMCmd(::google::protobuf::Arena* arena);
  AddCSGMCmd(::google::protobuf::Arena* arena, const AddCSGMCmd& from);
  AddCSGMCmd(::google::protobuf::Arena* arena, AddCSGMCmd&& from) noexcept
      : AddCSGMCmd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGmcmdFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string gmcmd = 2;
  bool has_gmcmd() const;
  void clear_gmcmd() ;
  const std::string& gmcmd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gmcmd(Arg_&& arg, Args_... args);
  std::string* mutable_gmcmd();
  PROTOBUF_NODISCARD std::string* release_gmcmd();
  void set_allocated_gmcmd(std::string* value);

  private:
  const std::string& _internal_gmcmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gmcmd(
      const std::string& value);
  std::string* _internal_mutable_gmcmd();

  public:
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_GmCmd];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.AddCSGMCmd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr gmcmd_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};
// -------------------------------------------------------------------

class CurtUIEvent final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToCS.CurtUIEvent) */ {
 public:
  inline CurtUIEvent() : CurtUIEvent(nullptr) {}
  ~CurtUIEvent() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurtUIEvent(
      ::google::protobuf::internal::ConstantInitialized);

  inline CurtUIEvent(const CurtUIEvent& from) : CurtUIEvent(nullptr, from) {}
  inline CurtUIEvent(CurtUIEvent&& from) noexcept
      : CurtUIEvent(nullptr, std::move(from)) {}
  inline CurtUIEvent& operator=(const CurtUIEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurtUIEvent& operator=(CurtUIEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurtUIEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurtUIEvent* internal_default_instance() {
    return reinterpret_cast<const CurtUIEvent*>(
        &_CurtUIEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(CurtUIEvent& a, CurtUIEvent& b) { a.Swap(&b); }
  inline void Swap(CurtUIEvent* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurtUIEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurtUIEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CurtUIEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurtUIEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CurtUIEvent& from) { CurtUIEvent::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurtUIEvent* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToCS.CurtUIEvent"; }

 protected:
  explicit CurtUIEvent(::google::protobuf::Arena* arena);
  CurtUIEvent(::google::protobuf::Arena* arena, const CurtUIEvent& from);
  CurtUIEvent(::google::protobuf::Arena* arena, CurtUIEvent&& from) noexcept
      : CurtUIEvent(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using UIEvent = CurtUIEvent_UIEvent;

  // accessors -------------------------------------------------------
  enum : int {
    kEventlistFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // repeated .GCToCS.CurtUIEvent.UIEvent eventlist = 2;
  int eventlist_size() const;
  private:
  int _internal_eventlist_size() const;

  public:
  void clear_eventlist() ;
  ::GCToCS::CurtUIEvent_UIEvent* mutable_eventlist(int index);
  ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>* mutable_eventlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>& _internal_eventlist() const;
  ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>* _internal_mutable_eventlist();
  public:
  const ::GCToCS::CurtUIEvent_UIEvent& eventlist(int index) const;
  ::GCToCS::CurtUIEvent_UIEvent* add_eventlist();
  const ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>& eventlist() const;
  // optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_UIEvent];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToCS::MsgNum msgnum() const;
  void set_msgnum(::GCToCS::MsgNum value);

  private:
  ::GCToCS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToCS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToCS.CurtUIEvent)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GCToCS::CurtUIEvent_UIEvent > eventlist_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToCS_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AskOneTaskRewards

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskOneTaskRewards];
inline bool AskOneTaskRewards::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskOneTaskRewards::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8290;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskOneTaskRewards::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskOneTaskRewards.msgnum)
  return _internal_msgnum();
}
inline void AskOneTaskRewards::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskOneTaskRewards.msgnum)
}
inline ::GCToCS::MsgNum AskOneTaskRewards::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskOneTaskRewards::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint32 task_guid = 2;
inline bool AskOneTaskRewards::has_task_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskOneTaskRewards::clear_task_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AskOneTaskRewards::task_guid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskOneTaskRewards.task_guid)
  return _internal_task_guid();
}
inline void AskOneTaskRewards::set_task_guid(::uint32_t value) {
  _internal_set_task_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskOneTaskRewards.task_guid)
}
inline ::uint32_t AskOneTaskRewards::_internal_task_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_guid_;
}
inline void AskOneTaskRewards::_internal_set_task_guid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = value;
}

// -------------------------------------------------------------------

// CDKReq

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_CDKReq];
inline bool CDKReq::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CDKReq::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8505;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum CDKReq::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.CDKReq.msgnum)
  return _internal_msgnum();
}
inline void CDKReq::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.CDKReq.msgnum)
}
inline ::GCToCS::MsgNum CDKReq::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void CDKReq::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string cdkstr = 2;
inline bool CDKReq::has_cdkstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CDKReq::clear_cdkstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cdkstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CDKReq::cdkstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.CDKReq.cdkstr)
  return _internal_cdkstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CDKReq::set_cdkstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cdkstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.CDKReq.cdkstr)
}
inline std::string* CDKReq::mutable_cdkstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cdkstr();
  // @@protoc_insertion_point(field_mutable:GCToCS.CDKReq.cdkstr)
  return _s;
}
inline const std::string& CDKReq::_internal_cdkstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cdkstr_.Get();
}
inline void CDKReq::_internal_set_cdkstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cdkstr_.Set(value, GetArena());
}
inline std::string* CDKReq::_internal_mutable_cdkstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cdkstr_.Mutable( GetArena());
}
inline std::string* CDKReq::release_cdkstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.CDKReq.cdkstr)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.cdkstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cdkstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CDKReq::set_allocated_cdkstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cdkstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cdkstr_.IsDefault()) {
          _impl_.cdkstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.CDKReq.cdkstr)
}

// -------------------------------------------------------------------

// CurtUIEvent_UIEvent

// optional uint32 uiidx = 2;
inline bool CurtUIEvent_UIEvent::has_uiidx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CurtUIEvent_UIEvent::clear_uiidx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uiidx_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t CurtUIEvent_UIEvent::uiidx() const {
  // @@protoc_insertion_point(field_get:GCToCS.CurtUIEvent.UIEvent.uiidx)
  return _internal_uiidx();
}
inline void CurtUIEvent_UIEvent::set_uiidx(::uint32_t value) {
  _internal_set_uiidx(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.CurtUIEvent.UIEvent.uiidx)
}
inline ::uint32_t CurtUIEvent_UIEvent::_internal_uiidx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uiidx_;
}
inline void CurtUIEvent_UIEvent::_internal_set_uiidx(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uiidx_ = value;
}

// optional uint32 eventNum = 3;
inline bool CurtUIEvent_UIEvent::has_eventnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CurtUIEvent_UIEvent::clear_eventnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.eventnum_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t CurtUIEvent_UIEvent::eventnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.CurtUIEvent.UIEvent.eventNum)
  return _internal_eventnum();
}
inline void CurtUIEvent_UIEvent::set_eventnum(::uint32_t value) {
  _internal_set_eventnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.CurtUIEvent.UIEvent.eventNum)
}
inline ::uint32_t CurtUIEvent_UIEvent::_internal_eventnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.eventnum_;
}
inline void CurtUIEvent_UIEvent::_internal_set_eventnum(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.eventnum_ = value;
}

// -------------------------------------------------------------------

// CurtUIEvent

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_UIEvent];
inline bool CurtUIEvent::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CurtUIEvent::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8550;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum CurtUIEvent::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.CurtUIEvent.msgnum)
  return _internal_msgnum();
}
inline void CurtUIEvent::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.CurtUIEvent.msgnum)
}
inline ::GCToCS::MsgNum CurtUIEvent::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void CurtUIEvent::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// repeated .GCToCS.CurtUIEvent.UIEvent eventlist = 2;
inline int CurtUIEvent::_internal_eventlist_size() const {
  return _internal_eventlist().size();
}
inline int CurtUIEvent::eventlist_size() const {
  return _internal_eventlist_size();
}
inline void CurtUIEvent::clear_eventlist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.eventlist_.Clear();
}
inline ::GCToCS::CurtUIEvent_UIEvent* CurtUIEvent::mutable_eventlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GCToCS.CurtUIEvent.eventlist)
  return _internal_mutable_eventlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>* CurtUIEvent::mutable_eventlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GCToCS.CurtUIEvent.eventlist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_eventlist();
}
inline const ::GCToCS::CurtUIEvent_UIEvent& CurtUIEvent::eventlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.CurtUIEvent.eventlist)
  return _internal_eventlist().Get(index);
}
inline ::GCToCS::CurtUIEvent_UIEvent* CurtUIEvent::add_eventlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GCToCS::CurtUIEvent_UIEvent* _add = _internal_mutable_eventlist()->Add();
  // @@protoc_insertion_point(field_add:GCToCS.CurtUIEvent.eventlist)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>& CurtUIEvent::eventlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GCToCS.CurtUIEvent.eventlist)
  return _internal_eventlist();
}
inline const ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>&
CurtUIEvent::_internal_eventlist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.eventlist_;
}
inline ::google::protobuf::RepeatedPtrField<::GCToCS::CurtUIEvent_UIEvent>*
CurtUIEvent::_internal_mutable_eventlist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.eventlist_;
}

// -------------------------------------------------------------------

// AskRecoinRune

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRecoinRune];
inline bool AskRecoinRune::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AskRecoinRune::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8503;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GCToCS::MsgNum AskRecoinRune::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRecoinRune.msgnum)
  return _internal_msgnum();
}
inline void AskRecoinRune::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRecoinRune.msgnum)
}
inline ::GCToCS::MsgNum AskRecoinRune::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskRecoinRune::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint32 rune_id = 2;
inline bool AskRecoinRune::has_rune_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRecoinRune::clear_rune_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rune_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AskRecoinRune::rune_id() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRecoinRune.rune_id)
  return _internal_rune_id();
}
inline void AskRecoinRune::set_rune_id(::uint32_t value) {
  _internal_set_rune_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRecoinRune.rune_id)
}
inline ::uint32_t AskRecoinRune::_internal_rune_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rune_id_;
}
inline void AskRecoinRune::_internal_set_rune_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rune_id_ = value;
}

// optional uint32 pay_type = 3;
inline bool AskRecoinRune::has_pay_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskRecoinRune::clear_pay_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pay_type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AskRecoinRune::pay_type() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRecoinRune.pay_type)
  return _internal_pay_type();
}
inline void AskRecoinRune::set_pay_type(::uint32_t value) {
  _internal_set_pay_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRecoinRune.pay_type)
}
inline ::uint32_t AskRecoinRune::_internal_pay_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pay_type_;
}
inline void AskRecoinRune::_internal_set_pay_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pay_type_ = value;
}

// optional uint32 cost = 4;
inline bool AskRecoinRune::has_cost() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskRecoinRune::clear_cost() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cost_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AskRecoinRune::cost() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRecoinRune.cost)
  return _internal_cost();
}
inline void AskRecoinRune::set_cost(::uint32_t value) {
  _internal_set_cost(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRecoinRune.cost)
}
inline ::uint32_t AskRecoinRune::_internal_cost() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cost_;
}
inline void AskRecoinRune::_internal_set_cost(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cost_ = value;
}

// -------------------------------------------------------------------

// BlackListOnlineInfo

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskBlackListOnlineInfo];
inline bool BlackListOnlineInfo::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BlackListOnlineInfo::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8502;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum BlackListOnlineInfo::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.BlackListOnlineInfo.msgnum)
  return _internal_msgnum();
}
inline void BlackListOnlineInfo::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.BlackListOnlineInfo.msgnum)
}
inline ::GCToCS::MsgNum BlackListOnlineInfo::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void BlackListOnlineInfo::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AddCSGMCmd

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_GmCmd];
inline bool AddCSGMCmd::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AddCSGMCmd::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8501;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AddCSGMCmd::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AddCSGMCmd.msgnum)
  return _internal_msgnum();
}
inline void AddCSGMCmd::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AddCSGMCmd.msgnum)
}
inline ::GCToCS::MsgNum AddCSGMCmd::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AddCSGMCmd::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string gmcmd = 2;
inline bool AddCSGMCmd::has_gmcmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AddCSGMCmd::clear_gmcmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gmcmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AddCSGMCmd::gmcmd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AddCSGMCmd.gmcmd)
  return _internal_gmcmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AddCSGMCmd::set_gmcmd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gmcmd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AddCSGMCmd.gmcmd)
}
inline std::string* AddCSGMCmd::mutable_gmcmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gmcmd();
  // @@protoc_insertion_point(field_mutable:GCToCS.AddCSGMCmd.gmcmd)
  return _s;
}
inline const std::string& AddCSGMCmd::_internal_gmcmd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gmcmd_.Get();
}
inline void AddCSGMCmd::_internal_set_gmcmd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.gmcmd_.Set(value, GetArena());
}
inline std::string* AddCSGMCmd::_internal_mutable_gmcmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.gmcmd_.Mutable( GetArena());
}
inline std::string* AddCSGMCmd::release_gmcmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AddCSGMCmd.gmcmd)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.gmcmd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gmcmd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AddCSGMCmd::set_allocated_gmcmd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.gmcmd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gmcmd_.IsDefault()) {
          _impl_.gmcmd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AddCSGMCmd.gmcmd)
}

// -------------------------------------------------------------------

// NotifyOneMatchNeedOneRet

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_NotifyOneMatchNeedOneRet];
inline bool NotifyOneMatchNeedOneRet::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyOneMatchNeedOneRet::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8288;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GCToCS::MsgNum NotifyOneMatchNeedOneRet::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.NotifyOneMatchNeedOneRet.msgnum)
  return _internal_msgnum();
}
inline void NotifyOneMatchNeedOneRet::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GCToCS.NotifyOneMatchNeedOneRet.msgnum)
}
inline ::GCToCS::MsgNum NotifyOneMatchNeedOneRet::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void NotifyOneMatchNeedOneRet::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint32 mapid = 2;
inline bool NotifyOneMatchNeedOneRet::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyOneMatchNeedOneRet::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyOneMatchNeedOneRet::mapid() const {
  // @@protoc_insertion_point(field_get:GCToCS.NotifyOneMatchNeedOneRet.mapid)
  return _internal_mapid();
}
inline void NotifyOneMatchNeedOneRet::set_mapid(::uint32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.NotifyOneMatchNeedOneRet.mapid)
}
inline ::uint32_t NotifyOneMatchNeedOneRet::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void NotifyOneMatchNeedOneRet::_internal_set_mapid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional uint32 fightid = 3;
inline bool NotifyOneMatchNeedOneRet::has_fightid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyOneMatchNeedOneRet::clear_fightid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fightid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyOneMatchNeedOneRet::fightid() const {
  // @@protoc_insertion_point(field_get:GCToCS.NotifyOneMatchNeedOneRet.fightid)
  return _internal_fightid();
}
inline void NotifyOneMatchNeedOneRet::set_fightid(::uint32_t value) {
  _internal_set_fightid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.NotifyOneMatchNeedOneRet.fightid)
}
inline ::uint32_t NotifyOneMatchNeedOneRet::_internal_fightid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fightid_;
}
inline void NotifyOneMatchNeedOneRet::_internal_set_fightid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fightid_ = value;
}

// optional bool isAccept = 4;
inline bool NotifyOneMatchNeedOneRet::has_isaccept() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyOneMatchNeedOneRet::clear_isaccept() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isaccept_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool NotifyOneMatchNeedOneRet::isaccept() const {
  // @@protoc_insertion_point(field_get:GCToCS.NotifyOneMatchNeedOneRet.isAccept)
  return _internal_isaccept();
}
inline void NotifyOneMatchNeedOneRet::set_isaccept(bool value) {
  _internal_set_isaccept(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.NotifyOneMatchNeedOneRet.isAccept)
}
inline bool NotifyOneMatchNeedOneRet::_internal_isaccept() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isaccept_;
}
inline void NotifyOneMatchNeedOneRet::_internal_set_isaccept(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isaccept_ = value;
}

// -------------------------------------------------------------------

// AskChangeheaderId

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChangeheaderId];
inline bool AskChangeheaderId::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskChangeheaderId::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8500;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskChangeheaderId::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskChangeheaderId.msgnum)
  return _internal_msgnum();
}
inline void AskChangeheaderId::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskChangeheaderId.msgnum)
}
inline ::GCToCS::MsgNum AskChangeheaderId::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskChangeheaderId::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint32 newheaderid = 2;
inline bool AskChangeheaderId::has_newheaderid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskChangeheaderId::clear_newheaderid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newheaderid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AskChangeheaderId::newheaderid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskChangeheaderId.newheaderid)
  return _internal_newheaderid();
}
inline void AskChangeheaderId::set_newheaderid(::uint32_t value) {
  _internal_set_newheaderid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskChangeheaderId.newheaderid)
}
inline ::uint32_t AskChangeheaderId::_internal_newheaderid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newheaderid_;
}
inline void AskChangeheaderId::_internal_set_newheaderid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newheaderid_ = value;
}

// -------------------------------------------------------------------

// ChangeNickName

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChangeNickName];
inline bool ChangeNickName::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChangeNickName::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8286;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum ChangeNickName::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.ChangeNickName.msgnum)
  return _internal_msgnum();
}
inline void ChangeNickName::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.ChangeNickName.msgnum)
}
inline ::GCToCS::MsgNum ChangeNickName::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void ChangeNickName::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string newnickname = 2;
inline bool ChangeNickName::has_newnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChangeNickName::clear_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeNickName::newnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.ChangeNickName.newnickname)
  return _internal_newnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangeNickName::set_newnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.ChangeNickName.newnickname)
}
inline std::string* ChangeNickName::mutable_newnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_newnickname();
  // @@protoc_insertion_point(field_mutable:GCToCS.ChangeNickName.newnickname)
  return _s;
}
inline const std::string& ChangeNickName::_internal_newnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newnickname_.Get();
}
inline void ChangeNickName::_internal_set_newnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(value, GetArena());
}
inline std::string* ChangeNickName::_internal_mutable_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.newnickname_.Mutable( GetArena());
}
inline std::string* ChangeNickName::release_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.ChangeNickName.newnickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.newnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.newnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChangeNickName::set_allocated_newnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.newnickname_.IsDefault()) {
          _impl_.newnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.ChangeNickName.newnickname)
}

// -------------------------------------------------------------------

// AskCreateMatchTeam

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCreateMatchTeam];
inline bool AskCreateMatchTeam::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskCreateMatchTeam::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8280;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskCreateMatchTeam::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCreateMatchTeam.msgnum)
  return _internal_msgnum();
}
inline void AskCreateMatchTeam::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCreateMatchTeam.msgnum)
}
inline ::GCToCS::MsgNum AskCreateMatchTeam::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskCreateMatchTeam::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint32 matchtype = 2;
inline bool AskCreateMatchTeam::has_matchtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskCreateMatchTeam::clear_matchtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matchtype_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t AskCreateMatchTeam::matchtype() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCreateMatchTeam.matchtype)
  return _internal_matchtype();
}
inline void AskCreateMatchTeam::set_matchtype(::uint32_t value) {
  _internal_set_matchtype(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCreateMatchTeam.matchtype)
}
inline ::uint32_t AskCreateMatchTeam::_internal_matchtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.matchtype_;
}
inline void AskCreateMatchTeam::_internal_set_matchtype(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matchtype_ = value;
}

// optional uint32 mapid = 3;
inline bool AskCreateMatchTeam::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskCreateMatchTeam::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t AskCreateMatchTeam::mapid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCreateMatchTeam.mapid)
  return _internal_mapid();
}
inline void AskCreateMatchTeam::set_mapid(::uint32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCreateMatchTeam.mapid)
}
inline ::uint32_t AskCreateMatchTeam::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void AskCreateMatchTeam::_internal_set_mapid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// -------------------------------------------------------------------

// AskAddMatchTeam

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddMatchTeam];
inline bool AskAddMatchTeam::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskAddMatchTeam::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8281;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskAddMatchTeam::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddMatchTeam.msgnum)
  return _internal_msgnum();
}
inline void AskAddMatchTeam::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddMatchTeam.msgnum)
}
inline ::GCToCS::MsgNum AskAddMatchTeam::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskAddMatchTeam::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string friendsNickName = 2;
inline bool AskAddMatchTeam::has_friendsnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskAddMatchTeam::clear_friendsnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.friendsnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskAddMatchTeam::friendsnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddMatchTeam.friendsNickName)
  return _internal_friendsnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddMatchTeam::set_friendsnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.friendsnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskAddMatchTeam.friendsNickName)
}
inline std::string* AskAddMatchTeam::mutable_friendsnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_friendsnickname();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskAddMatchTeam.friendsNickName)
  return _s;
}
inline const std::string& AskAddMatchTeam::_internal_friendsnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.friendsnickname_.Get();
}
inline void AskAddMatchTeam::_internal_set_friendsnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.friendsnickname_.Set(value, GetArena());
}
inline std::string* AskAddMatchTeam::_internal_mutable_friendsnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.friendsnickname_.Mutable( GetArena());
}
inline std::string* AskAddMatchTeam::release_friendsnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskAddMatchTeam.friendsNickName)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.friendsnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.friendsnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddMatchTeam::set_allocated_friendsnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.friendsnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.friendsnickname_.IsDefault()) {
          _impl_.friendsnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskAddMatchTeam.friendsNickName)
}

// -------------------------------------------------------------------

// AskRemoveMatchTeam

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRemoveMatchTeam];
inline bool AskRemoveMatchTeam::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRemoveMatchTeam::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8282;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskRemoveMatchTeam::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRemoveMatchTeam.msgnum)
  return _internal_msgnum();
}
inline void AskRemoveMatchTeam::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRemoveMatchTeam.msgnum)
}
inline ::GCToCS::MsgNum AskRemoveMatchTeam::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskRemoveMatchTeam::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskInviteJoinMatchTeam

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskInviteJoinMatchTeam];
inline bool AskInviteJoinMatchTeam::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskInviteJoinMatchTeam::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8283;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskInviteJoinMatchTeam::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskInviteJoinMatchTeam.msgnum)
  return _internal_msgnum();
}
inline void AskInviteJoinMatchTeam::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskInviteJoinMatchTeam.msgnum)
}
inline ::GCToCS::MsgNum AskInviteJoinMatchTeam::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskInviteJoinMatchTeam::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string friendsNickName = 2;
inline bool AskInviteJoinMatchTeam::has_friendsnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskInviteJoinMatchTeam::clear_friendsnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.friendsnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskInviteJoinMatchTeam::friendsnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskInviteJoinMatchTeam.friendsNickName)
  return _internal_friendsnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskInviteJoinMatchTeam::set_friendsnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.friendsnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskInviteJoinMatchTeam.friendsNickName)
}
inline std::string* AskInviteJoinMatchTeam::mutable_friendsnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_friendsnickname();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskInviteJoinMatchTeam.friendsNickName)
  return _s;
}
inline const std::string& AskInviteJoinMatchTeam::_internal_friendsnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.friendsnickname_.Get();
}
inline void AskInviteJoinMatchTeam::_internal_set_friendsnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.friendsnickname_.Set(value, GetArena());
}
inline std::string* AskInviteJoinMatchTeam::_internal_mutable_friendsnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.friendsnickname_.Mutable( GetArena());
}
inline std::string* AskInviteJoinMatchTeam::release_friendsnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskInviteJoinMatchTeam.friendsNickName)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.friendsnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.friendsnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskInviteJoinMatchTeam::set_allocated_friendsnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.friendsnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.friendsnickname_.IsDefault()) {
          _impl_.friendsnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskInviteJoinMatchTeam.friendsNickName)
}

// -------------------------------------------------------------------

// AskStartMatch

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStartMatch];
inline bool AskStartMatch::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskStartMatch::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8284;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskStartMatch::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskStartMatch.msgnum)
  return _internal_msgnum();
}
inline void AskStartMatch::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskStartMatch.msgnum)
}
inline ::GCToCS::MsgNum AskStartMatch::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskStartMatch::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskStopMatch

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStopMatch];
inline bool AskStopMatch::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskStopMatch::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8285;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskStopMatch::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskStopMatch.msgnum)
  return _internal_msgnum();
}
inline void AskStopMatch::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskStopMatch.msgnum)
}
inline ::GCToCS::MsgNum AskStopMatch::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskStopMatch::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// RequestMatchTeamList

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_RequestMatchTeamList];
inline bool RequestMatchTeamList::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RequestMatchTeamList::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8287;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum RequestMatchTeamList::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.RequestMatchTeamList.msgnum)
  return _internal_msgnum();
}
inline void RequestMatchTeamList::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.RequestMatchTeamList.msgnum)
}
inline ::GCToCS::MsgNum RequestMatchTeamList::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void RequestMatchTeamList::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskGoodscfg

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGoodscfg];
inline bool AskGoodscfg::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskGoodscfg::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8270;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskGoodscfg::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskGoodscfg.msgnum)
  return _internal_msgnum();
}
inline void AskGoodscfg::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskGoodscfg.msgnum)
}
inline ::GCToCS::MsgNum AskGoodscfg::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskGoodscfg::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskCSCreateGuideBattle

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGuideBattle];
inline bool AskCSCreateGuideBattle::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskCSCreateGuideBattle::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8240;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskCSCreateGuideBattle::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCSCreateGuideBattle.msgnum)
  return _internal_msgnum();
}
inline void AskCSCreateGuideBattle::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCSCreateGuideBattle.msgnum)
}
inline ::GCToCS::MsgNum AskCSCreateGuideBattle::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskCSCreateGuideBattle::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 mapid = 2;
inline bool AskCSCreateGuideBattle::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskCSCreateGuideBattle::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskCSCreateGuideBattle::mapid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCSCreateGuideBattle.mapid)
  return _internal_mapid();
}
inline void AskCSCreateGuideBattle::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCSCreateGuideBattle.mapid)
}
inline ::int32_t AskCSCreateGuideBattle::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void AskCSCreateGuideBattle::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional .GCToCS.AskCSCreateGuideBattle.guidetype ntype = 3;
inline bool AskCSCreateGuideBattle::has_ntype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskCSCreateGuideBattle::clear_ntype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ntype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::AskCSCreateGuideBattle_guidetype AskCSCreateGuideBattle::ntype() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCSCreateGuideBattle.ntype)
  return _internal_ntype();
}
inline void AskCSCreateGuideBattle::set_ntype(::GCToCS::AskCSCreateGuideBattle_guidetype value) {
  _internal_set_ntype(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCSCreateGuideBattle.ntype)
}
inline ::GCToCS::AskCSCreateGuideBattle_guidetype AskCSCreateGuideBattle::_internal_ntype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::AskCSCreateGuideBattle_guidetype>(_impl_.ntype_);
}
inline void AskCSCreateGuideBattle::_internal_set_ntype(::GCToCS::AskCSCreateGuideBattle_guidetype value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::AskCSCreateGuideBattle_guidetype_IsValid(value));
  _impl_.ntype_ = value;
}

// -------------------------------------------------------------------

// AskQuickBattle

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskQuickBattle];
inline bool AskQuickBattle::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskQuickBattle::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8250;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskQuickBattle::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskQuickBattle.msgnum)
  return _internal_msgnum();
}
inline void AskQuickBattle::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskQuickBattle.msgnum)
}
inline ::GCToCS::MsgNum AskQuickBattle::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskQuickBattle::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 mapid = 2;
inline bool AskQuickBattle::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskQuickBattle::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskQuickBattle::mapid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskQuickBattle.mapid)
  return _internal_mapid();
}
inline void AskQuickBattle::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskQuickBattle.mapid)
}
inline ::int32_t AskQuickBattle::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void AskQuickBattle::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// -------------------------------------------------------------------

// AskStopQuickBattle

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStopQuickBattle];
inline bool AskStopQuickBattle::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskStopQuickBattle::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8251;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskStopQuickBattle::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskStopQuickBattle.msgnum)
  return _internal_msgnum();
}
inline void AskStopQuickBattle::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskStopQuickBattle.msgnum)
}
inline ::GCToCS::MsgNum AskStopQuickBattle::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskStopQuickBattle::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskCreateRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCreateRoom];
inline bool AskCreateRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskCreateRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8260;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskCreateRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCreateRoom.msgnum)
  return _internal_msgnum();
}
inline void AskCreateRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCreateRoom.msgnum)
}
inline ::GCToCS::MsgNum AskCreateRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskCreateRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 mapid = 2;
inline bool AskCreateRoom::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskCreateRoom::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskCreateRoom::mapid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCreateRoom.mapid)
  return _internal_mapid();
}
inline void AskCreateRoom::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCreateRoom.mapid)
}
inline ::int32_t AskCreateRoom::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void AskCreateRoom::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional string passwd = 3;
inline bool AskCreateRoom::has_passwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskCreateRoom::clear_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passwd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskCreateRoom::passwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskCreateRoom.passwd)
  return _internal_passwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskCreateRoom::set_passwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.passwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskCreateRoom.passwd)
}
inline std::string* AskCreateRoom::mutable_passwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskCreateRoom.passwd)
  return _s;
}
inline const std::string& AskCreateRoom::_internal_passwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passwd_.Get();
}
inline void AskCreateRoom::_internal_set_passwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.passwd_.Set(value, GetArena());
}
inline std::string* AskCreateRoom::_internal_mutable_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.passwd_.Mutable( GetArena());
}
inline std::string* AskCreateRoom::release_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskCreateRoom.passwd)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.passwd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.passwd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskCreateRoom::set_allocated_passwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.passwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.passwd_.IsDefault()) {
          _impl_.passwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskCreateRoom.passwd)
}

// -------------------------------------------------------------------

// AskAddRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddRoom];
inline bool AskAddRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskAddRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8261;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskAddRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddRoom.msgnum)
  return _internal_msgnum();
}
inline void AskAddRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddRoom.msgnum)
}
inline ::GCToCS::MsgNum AskAddRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskAddRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 battleid = 2;
inline bool AskAddRoom::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskAddRoom::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t AskAddRoom::battleid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddRoom.battleid)
  return _internal_battleid();
}
inline void AskAddRoom::set_battleid(::uint64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddRoom.battleid)
}
inline ::uint64_t AskAddRoom::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void AskAddRoom::_internal_set_battleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional string passwd = 3;
inline bool AskAddRoom::has_passwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskAddRoom::clear_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passwd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskAddRoom::passwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddRoom.passwd)
  return _internal_passwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddRoom::set_passwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.passwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskAddRoom.passwd)
}
inline std::string* AskAddRoom::mutable_passwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskAddRoom.passwd)
  return _s;
}
inline const std::string& AskAddRoom::_internal_passwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passwd_.Get();
}
inline void AskAddRoom::_internal_set_passwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.passwd_.Set(value, GetArena());
}
inline std::string* AskAddRoom::_internal_mutable_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.passwd_.Mutable( GetArena());
}
inline std::string* AskAddRoom::release_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskAddRoom.passwd)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.passwd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.passwd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddRoom::set_allocated_passwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.passwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.passwd_.IsDefault()) {
          _impl_.passwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskAddRoom.passwd)
}

// -------------------------------------------------------------------

// AskLeaveRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskLeaveRoom];
inline bool AskLeaveRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskLeaveRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8262;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskLeaveRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskLeaveRoom.msgnum)
  return _internal_msgnum();
}
inline void AskLeaveRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskLeaveRoom.msgnum)
}
inline ::GCToCS::MsgNum AskLeaveRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskLeaveRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskChangeRoomSeat

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChangeRoomSeat];
inline bool AskChangeRoomSeat::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskChangeRoomSeat::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8263;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskChangeRoomSeat::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskChangeRoomSeat.msgnum)
  return _internal_msgnum();
}
inline void AskChangeRoomSeat::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskChangeRoomSeat.msgnum)
}
inline ::GCToCS::MsgNum AskChangeRoomSeat::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskChangeRoomSeat::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 newpos = 2;
inline bool AskChangeRoomSeat::has_newpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskChangeRoomSeat::clear_newpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newpos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskChangeRoomSeat::newpos() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskChangeRoomSeat.newpos)
  return _internal_newpos();
}
inline void AskChangeRoomSeat::set_newpos(::int32_t value) {
  _internal_set_newpos(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskChangeRoomSeat.newpos)
}
inline ::int32_t AskChangeRoomSeat::_internal_newpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newpos_;
}
inline void AskChangeRoomSeat::_internal_set_newpos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newpos_ = value;
}

// -------------------------------------------------------------------

// AskReadyRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskReadyRoom];
inline bool AskReadyRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskReadyRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8264;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskReadyRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskReadyRoom.msgnum)
  return _internal_msgnum();
}
inline void AskReadyRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskReadyRoom.msgnum)
}
inline ::GCToCS::MsgNum AskReadyRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskReadyRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskCancelRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCancelRoom];
inline bool AskCancelRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskCancelRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8265;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskCancelRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCancelRoom.msgnum)
  return _internal_msgnum();
}
inline void AskCancelRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCancelRoom.msgnum)
}
inline ::GCToCS::MsgNum AskCancelRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskCancelRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskStartRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskStartRoom];
inline bool AskStartRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskStartRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8266;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskStartRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskStartRoom.msgnum)
  return _internal_msgnum();
}
inline void AskStartRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskStartRoom.msgnum)
}
inline ::GCToCS::MsgNum AskStartRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskStartRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskReEnterRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskReEnterRoom];
inline bool AskReEnterRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskReEnterRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8268;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskReEnterRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskReEnterRoom.msgnum)
  return _internal_msgnum();
}
inline void AskReEnterRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskReEnterRoom.msgnum)
}
inline ::GCToCS::MsgNum AskReEnterRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskReEnterRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskChatInRoom

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskChatInRoom];
inline bool AskChatInRoom::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskChatInRoom::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8267;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskChatInRoom::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskChatInRoom.msgnum)
  return _internal_msgnum();
}
inline void AskChatInRoom::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskChatInRoom.msgnum)
}
inline ::GCToCS::MsgNum AskChatInRoom::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskChatInRoom::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string chat = 2;
inline bool AskChatInRoom::has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskChatInRoom::clear_chat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskChatInRoom::chat() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskChatInRoom.chat)
  return _internal_chat();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskChatInRoom::set_chat(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chat_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskChatInRoom.chat)
}
inline std::string* AskChatInRoom::mutable_chat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskChatInRoom.chat)
  return _s;
}
inline const std::string& AskChatInRoom::_internal_chat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chat_.Get();
}
inline void AskChatInRoom::_internal_set_chat(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chat_.Set(value, GetArena());
}
inline std::string* AskChatInRoom::_internal_mutable_chat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.chat_.Mutable( GetArena());
}
inline std::string* AskChatInRoom::release_chat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskChatInRoom.chat)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.chat_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chat_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskChatInRoom::set_allocated_chat(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chat_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chat_.IsDefault()) {
          _impl_.chat_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskChatInRoom.chat)
}

// -------------------------------------------------------------------

// AskGetMailGift

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGetMailGift];
inline bool AskGetMailGift::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskGetMailGift::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8231;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskGetMailGift::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskGetMailGift.msgnum)
  return _internal_msgnum();
}
inline void AskGetMailGift::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskGetMailGift.msgnum)
}
inline ::GCToCS::MsgNum AskGetMailGift::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskGetMailGift::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 mailId = 2;
inline bool AskGetMailGift::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskGetMailGift::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskGetMailGift::mailid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskGetMailGift.mailId)
  return _internal_mailid();
}
inline void AskGetMailGift::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskGetMailGift.mailId)
}
inline ::int32_t AskGetMailGift::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void AskGetMailGift::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// -------------------------------------------------------------------

// AskMailInfo

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskMailInfo];
inline bool AskMailInfo::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskMailInfo::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8230;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskMailInfo::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskMailInfo.msgnum)
  return _internal_msgnum();
}
inline void AskMailInfo::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskMailInfo.msgnum)
}
inline ::GCToCS::MsgNum AskMailInfo::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskMailInfo::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 mailId = 2;
inline bool AskMailInfo::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskMailInfo::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskMailInfo::mailid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskMailInfo.mailId)
  return _internal_mailid();
}
inline void AskMailInfo::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskMailInfo.mailId)
}
inline ::int32_t AskMailInfo::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void AskMailInfo::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// -------------------------------------------------------------------

// AskBuyGoods

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskBuyGoods];
inline bool AskBuyGoods::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AskBuyGoods::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8224;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GCToCS::MsgNum AskBuyGoods::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskBuyGoods.msgnum)
  return _internal_msgnum();
}
inline void AskBuyGoods::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GCToCS.AskBuyGoods.msgnum)
}
inline ::GCToCS::MsgNum AskBuyGoods::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskBuyGoods::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 commondityid = 2;
inline bool AskBuyGoods::has_commondityid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskBuyGoods::clear_commondityid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commondityid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskBuyGoods::commondityid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskBuyGoods.commondityid)
  return _internal_commondityid();
}
inline void AskBuyGoods::set_commondityid(::int32_t value) {
  _internal_set_commondityid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskBuyGoods.commondityid)
}
inline ::int32_t AskBuyGoods::_internal_commondityid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commondityid_;
}
inline void AskBuyGoods::_internal_set_commondityid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commondityid_ = value;
}

// optional int32 consumetype = 3;
inline bool AskBuyGoods::has_consumetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskBuyGoods::clear_consumetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskBuyGoods::consumetype() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskBuyGoods.consumetype)
  return _internal_consumetype();
}
inline void AskBuyGoods::set_consumetype(::int32_t value) {
  _internal_set_consumetype(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskBuyGoods.consumetype)
}
inline ::int32_t AskBuyGoods::_internal_consumetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumetype_;
}
inline void AskBuyGoods::_internal_set_consumetype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumetype_ = value;
}

// optional uint32 num = 4;
inline bool AskBuyGoods::has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskBuyGoods::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AskBuyGoods::num() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskBuyGoods.num)
  return _internal_num();
}
inline void AskBuyGoods::set_num(::uint32_t value) {
  _internal_set_num(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskBuyGoods.num)
}
inline ::uint32_t AskBuyGoods::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void AskBuyGoods::_internal_set_num(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = value;
}

// -------------------------------------------------------------------

// UserAskGetCLReward

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_UserAskGetCLReward];
inline bool UserAskGetCLReward::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserAskGetCLReward::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8197;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum UserAskGetCLReward::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.UserAskGetCLReward.msgnum)
  return _internal_msgnum();
}
inline void UserAskGetCLReward::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.UserAskGetCLReward.msgnum)
}
inline ::GCToCS::MsgNum UserAskGetCLReward::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void UserAskGetCLReward::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// Notice

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_Notice];
inline bool Notice::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Notice::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8200;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum Notice::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.Notice.msgnum)
  return _internal_msgnum();
}
inline void Notice::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.Notice.msgnum)
}
inline ::GCToCS::MsgNum Notice::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void Notice::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional .GCToCS.notice_type type = 2;
inline bool Notice::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Notice::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::notice_type Notice::type() const {
  // @@protoc_insertion_point(field_get:GCToCS.Notice.type)
  return _internal_type();
}
inline void Notice::set_type(::GCToCS::notice_type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.Notice.type)
}
inline ::GCToCS::notice_type Notice::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::notice_type>(_impl_.type_);
}
inline void Notice::_internal_set_type(::GCToCS::notice_type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::notice_type_IsValid(value));
  _impl_.type_ = value;
}

// optional string notice = 3;
inline bool Notice::has_notice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Notice::clear_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Notice::notice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.Notice.notice)
  return _internal_notice();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Notice::set_notice(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.notice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.Notice.notice)
}
inline std::string* Notice::mutable_notice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_notice();
  // @@protoc_insertion_point(field_mutable:GCToCS.Notice.notice)
  return _s;
}
inline const std::string& Notice::_internal_notice() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notice_.Get();
}
inline void Notice::_internal_set_notice(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.notice_.Set(value, GetArena());
}
inline std::string* Notice::_internal_mutable_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.notice_.Mutable( GetArena());
}
inline std::string* Notice::release_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.Notice.notice)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.notice_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.notice_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Notice::set_allocated_notice(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.notice_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.notice_.IsDefault()) {
          _impl_.notice_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.Notice.notice)
}

// -------------------------------------------------------------------

// AskCurtNotice

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCurtNotice];
inline bool AskCurtNotice::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskCurtNotice::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8201;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskCurtNotice::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCurtNotice.msgnum)
  return _internal_msgnum();
}
inline void AskCurtNotice::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCurtNotice.msgnum)
}
inline ::GCToCS::MsgNum AskCurtNotice::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskCurtNotice::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional .GCToCS.notice_type type = 2;
inline bool AskCurtNotice::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskCurtNotice::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::notice_type AskCurtNotice::type() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCurtNotice.type)
  return _internal_type();
}
inline void AskCurtNotice::set_type(::GCToCS::notice_type value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCurtNotice.type)
}
inline ::GCToCS::notice_type AskCurtNotice::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::notice_type>(_impl_.type_);
}
inline void AskCurtNotice::_internal_set_type(::GCToCS::notice_type value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::notice_type_IsValid(value));
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// CompleteInfo

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskComleteUserInfo];
inline bool CompleteInfo::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CompleteInfo::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8195;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GCToCS::MsgNum CompleteInfo::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.CompleteInfo.msgnum)
  return _internal_msgnum();
}
inline void CompleteInfo::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GCToCS.CompleteInfo.msgnum)
}
inline ::GCToCS::MsgNum CompleteInfo::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void CompleteInfo::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string nickname = 2;
inline bool CompleteInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CompleteInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompleteInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.CompleteInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CompleteInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.CompleteInfo.nickname)
}
inline std::string* CompleteInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GCToCS.CompleteInfo.nickname)
  return _s;
}
inline const std::string& CompleteInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void CompleteInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* CompleteInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* CompleteInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.CompleteInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CompleteInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.CompleteInfo.nickname)
}

// optional int32 headid = 3;
inline bool CompleteInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CompleteInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CompleteInfo::headid() const {
  // @@protoc_insertion_point(field_get:GCToCS.CompleteInfo.headid)
  return _internal_headid();
}
inline void CompleteInfo::set_headid(::int32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.CompleteInfo.headid)
}
inline ::int32_t CompleteInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void CompleteInfo::_internal_set_headid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional int32 sex = 4;
inline bool CompleteInfo::has_sex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CompleteInfo::clear_sex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CompleteInfo::sex() const {
  // @@protoc_insertion_point(field_get:GCToCS.CompleteInfo.sex)
  return _internal_sex();
}
inline void CompleteInfo::set_sex(::int32_t value) {
  _internal_set_sex(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.CompleteInfo.sex)
}
inline ::int32_t CompleteInfo::_internal_sex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sex_;
}
inline void CompleteInfo::_internal_set_sex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sex_ = value;
}

// -------------------------------------------------------------------

// AskAddToSNSList

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddToSNSList];
inline bool AskAddToSNSList::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskAddToSNSList::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8210;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskAddToSNSList::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddToSNSList.msgnum)
  return _internal_msgnum();
}
inline void AskAddToSNSList::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddToSNSList.msgnum)
}
inline ::GCToCS::MsgNum AskAddToSNSList::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskAddToSNSList::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string nickname = 2;
inline bool AskAddToSNSList::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskAddToSNSList::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskAddToSNSList::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddToSNSList.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskAddToSNSList::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskAddToSNSList.nickname)
}
inline std::string* AskAddToSNSList::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskAddToSNSList.nickname)
  return _s;
}
inline const std::string& AskAddToSNSList::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void AskAddToSNSList::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* AskAddToSNSList::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* AskAddToSNSList::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskAddToSNSList.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskAddToSNSList::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskAddToSNSList.nickname)
}

// optional int32 type = 3;
inline bool AskAddToSNSList::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskAddToSNSList::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskAddToSNSList::type() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddToSNSList.type)
  return _internal_type();
}
inline void AskAddToSNSList::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddToSNSList.type)
}
inline ::int32_t AskAddToSNSList::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void AskAddToSNSList::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// AskCanInviteFriends

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskCanInviteFriends];
inline bool AskCanInviteFriends::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskCanInviteFriends::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8218;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskCanInviteFriends::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskCanInviteFriends.msgnum)
  return _internal_msgnum();
}
inline void AskCanInviteFriends::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskCanInviteFriends.msgnum)
}
inline ::GCToCS::MsgNum AskCanInviteFriends::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskCanInviteFriends::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskAddToSNSListByID

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskAddToSNSListByID];
inline bool AskAddToSNSListByID::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskAddToSNSListByID::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8217;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskAddToSNSListByID::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddToSNSListByID.msgnum)
  return _internal_msgnum();
}
inline void AskAddToSNSListByID::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddToSNSListByID.msgnum)
}
inline ::GCToCS::MsgNum AskAddToSNSListByID::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskAddToSNSListByID::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 userid = 2;
inline bool AskAddToSNSListByID::has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskAddToSNSListByID::clear_userid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AskAddToSNSListByID::userid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddToSNSListByID.userid)
  return _internal_userid();
}
inline void AskAddToSNSListByID::set_userid(::uint64_t value) {
  _internal_set_userid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddToSNSListByID.userid)
}
inline ::uint64_t AskAddToSNSListByID::_internal_userid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userid_;
}
inline void AskAddToSNSListByID::_internal_set_userid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userid_ = value;
}

// optional int32 type = 3;
inline bool AskAddToSNSListByID::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskAddToSNSListByID::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskAddToSNSListByID::type() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskAddToSNSListByID.type)
  return _internal_type();
}
inline void AskAddToSNSListByID::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskAddToSNSListByID.type)
}
inline ::int32_t AskAddToSNSListByID::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void AskAddToSNSListByID::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// AskRemoveFromSNSList

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRemoveFromSNSList];
inline bool AskRemoveFromSNSList::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskRemoveFromSNSList::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8211;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskRemoveFromSNSList::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRemoveFromSNSList.msgnum)
  return _internal_msgnum();
}
inline void AskRemoveFromSNSList::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRemoveFromSNSList.msgnum)
}
inline ::GCToCS::MsgNum AskRemoveFromSNSList::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskRemoveFromSNSList::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 guididx = 2;
inline bool AskRemoveFromSNSList::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRemoveFromSNSList::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AskRemoveFromSNSList::guididx() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRemoveFromSNSList.guididx)
  return _internal_guididx();
}
inline void AskRemoveFromSNSList::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRemoveFromSNSList.guididx)
}
inline ::uint64_t AskRemoveFromSNSList::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void AskRemoveFromSNSList::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// optional int32 type = 3;
inline bool AskRemoveFromSNSList::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskRemoveFromSNSList::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskRemoveFromSNSList::type() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRemoveFromSNSList.type)
  return _internal_type();
}
inline void AskRemoveFromSNSList::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRemoveFromSNSList.type)
}
inline ::int32_t AskRemoveFromSNSList::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void AskRemoveFromSNSList::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// AskSendMsgToUser

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskSendMsgToUser];
inline bool AskSendMsgToUser::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskSendMsgToUser::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8212;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskSendMsgToUser::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskSendMsgToUser.msgnum)
  return _internal_msgnum();
}
inline void AskSendMsgToUser::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskSendMsgToUser.msgnum)
}
inline ::GCToCS::MsgNum AskSendMsgToUser::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskSendMsgToUser::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 guididx = 2;
inline bool AskSendMsgToUser::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskSendMsgToUser::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t AskSendMsgToUser::guididx() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskSendMsgToUser.guididx)
  return _internal_guididx();
}
inline void AskSendMsgToUser::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskSendMsgToUser.guididx)
}
inline ::uint64_t AskSendMsgToUser::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void AskSendMsgToUser::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// optional string contents = 3;
inline bool AskSendMsgToUser::has_contents() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSendMsgToUser::clear_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskSendMsgToUser::contents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskSendMsgToUser.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskSendMsgToUser::set_contents(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contents_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskSendMsgToUser.contents)
}
inline std::string* AskSendMsgToUser::mutable_contents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskSendMsgToUser.contents)
  return _s;
}
inline const std::string& AskSendMsgToUser::_internal_contents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contents_.Get();
}
inline void AskSendMsgToUser::_internal_set_contents(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.contents_.Set(value, GetArena());
}
inline std::string* AskSendMsgToUser::_internal_mutable_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.contents_.Mutable( GetArena());
}
inline std::string* AskSendMsgToUser::release_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskSendMsgToUser.contents)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.contents_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.contents_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskSendMsgToUser::set_allocated_contents(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.contents_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskSendMsgToUser.contents)
}

// -------------------------------------------------------------------

// AskInviteFriendsToBattle

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskInviteFriendsToBattle];
inline bool AskInviteFriendsToBattle::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskInviteFriendsToBattle::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8213;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum AskInviteFriendsToBattle::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskInviteFriendsToBattle.msgnum)
  return _internal_msgnum();
}
inline void AskInviteFriendsToBattle::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.AskInviteFriendsToBattle.msgnum)
}
inline ::GCToCS::MsgNum AskInviteFriendsToBattle::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskInviteFriendsToBattle::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 battleid = 2;
inline bool AskInviteFriendsToBattle::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskInviteFriendsToBattle::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskInviteFriendsToBattle::battleid() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskInviteFriendsToBattle.battleid)
  return _internal_battleid();
}
inline void AskInviteFriendsToBattle::set_battleid(::int32_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskInviteFriendsToBattle.battleid)
}
inline ::int32_t AskInviteFriendsToBattle::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void AskInviteFriendsToBattle::_internal_set_battleid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional uint64 guididx = 3;
inline bool AskInviteFriendsToBattle::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskInviteFriendsToBattle::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AskInviteFriendsToBattle::guididx() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskInviteFriendsToBattle.guididx)
  return _internal_guididx();
}
inline void AskInviteFriendsToBattle::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskInviteFriendsToBattle.guididx)
}
inline ::uint64_t AskInviteFriendsToBattle::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void AskInviteFriendsToBattle::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// -------------------------------------------------------------------

// AskQueryUserByNickName

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskQueryUserByNickName];
inline bool AskQueryUserByNickName::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskQueryUserByNickName::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8214;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum AskQueryUserByNickName::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskQueryUserByNickName.msgnum)
  return _internal_msgnum();
}
inline void AskQueryUserByNickName::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.AskQueryUserByNickName.msgnum)
}
inline ::GCToCS::MsgNum AskQueryUserByNickName::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskQueryUserByNickName::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string nickname = 2;
inline bool AskQueryUserByNickName::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskQueryUserByNickName::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskQueryUserByNickName::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.AskQueryUserByNickName.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskQueryUserByNickName::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.AskQueryUserByNickName.nickname)
}
inline std::string* AskQueryUserByNickName::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GCToCS.AskQueryUserByNickName.nickname)
  return _s;
}
inline const std::string& AskQueryUserByNickName::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void AskQueryUserByNickName::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* AskQueryUserByNickName::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* AskQueryUserByNickName::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.AskQueryUserByNickName.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskQueryUserByNickName::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.AskQueryUserByNickName.nickname)
}

// -------------------------------------------------------------------

// GCReplyAddFriendRequst

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_GCReplyAddFriendRequst];
inline bool GCReplyAddFriendRequst::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GCReplyAddFriendRequst::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8215;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum GCReplyAddFriendRequst::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.GCReplyAddFriendRequst.msgnum)
  return _internal_msgnum();
}
inline void GCReplyAddFriendRequst::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.GCReplyAddFriendRequst.msgnum)
}
inline ::GCToCS::MsgNum GCReplyAddFriendRequst::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void GCReplyAddFriendRequst::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 guididx = 2;
inline bool GCReplyAddFriendRequst::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GCReplyAddFriendRequst::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t GCReplyAddFriendRequst::guididx() const {
  // @@protoc_insertion_point(field_get:GCToCS.GCReplyAddFriendRequst.guididx)
  return _internal_guididx();
}
inline void GCReplyAddFriendRequst::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.GCReplyAddFriendRequst.guididx)
}
inline ::uint64_t GCReplyAddFriendRequst::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void GCReplyAddFriendRequst::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// optional int32 reply = 3;
inline bool GCReplyAddFriendRequst::has_reply() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GCReplyAddFriendRequst::clear_reply() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reply_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t GCReplyAddFriendRequst::reply() const {
  // @@protoc_insertion_point(field_get:GCToCS.GCReplyAddFriendRequst.reply)
  return _internal_reply();
}
inline void GCReplyAddFriendRequst::set_reply(::int32_t value) {
  _internal_set_reply(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.GCReplyAddFriendRequst.reply)
}
inline ::int32_t GCReplyAddFriendRequst::_internal_reply() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reply_;
}
inline void GCReplyAddFriendRequst::_internal_set_reply(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reply_ = value;
}

// -------------------------------------------------------------------

// GuideCSStepComp

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_CompCSGuideStepId];
inline bool GuideCSStepComp::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GuideCSStepComp::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8242;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum GuideCSStepComp::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.GuideCSStepComp.msgnum)
  return _internal_msgnum();
}
inline void GuideCSStepComp::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.GuideCSStepComp.msgnum)
}
inline ::GCToCS::MsgNum GuideCSStepComp::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void GuideCSStepComp::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 guidepart = 2;
inline bool GuideCSStepComp::has_guidepart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideCSStepComp::clear_guidepart() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guidepart_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t GuideCSStepComp::guidepart() const {
  // @@protoc_insertion_point(field_get:GCToCS.GuideCSStepComp.guidepart)
  return _internal_guidepart();
}
inline void GuideCSStepComp::set_guidepart(::int32_t value) {
  _internal_set_guidepart(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.GuideCSStepComp.guidepart)
}
inline ::int32_t GuideCSStepComp::_internal_guidepart() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guidepart_;
}
inline void GuideCSStepComp::_internal_set_guidepart(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guidepart_ = value;
}

// optional bool bcomp = 3;
inline bool GuideCSStepComp::has_bcomp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GuideCSStepComp::clear_bcomp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bcomp_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool GuideCSStepComp::bcomp() const {
  // @@protoc_insertion_point(field_get:GCToCS.GuideCSStepComp.bcomp)
  return _internal_bcomp();
}
inline void GuideCSStepComp::set_bcomp(bool value) {
  _internal_set_bcomp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.GuideCSStepComp.bcomp)
}
inline bool GuideCSStepComp::_internal_bcomp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bcomp_;
}
inline void GuideCSStepComp::_internal_set_bcomp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bcomp_ = value;
}

// -------------------------------------------------------------------

// GCReplyInviteToBattle

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_GCReplyInviteToBattle];
inline bool GCReplyInviteToBattle::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GCReplyInviteToBattle::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8216;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum GCReplyInviteToBattle::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.GCReplyInviteToBattle.msgnum)
  return _internal_msgnum();
}
inline void GCReplyInviteToBattle::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.GCReplyInviteToBattle.msgnum)
}
inline ::GCToCS::MsgNum GCReplyInviteToBattle::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void GCReplyInviteToBattle::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string nickname = 2;
inline bool GCReplyInviteToBattle::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GCReplyInviteToBattle::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GCReplyInviteToBattle::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.GCReplyInviteToBattle.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GCReplyInviteToBattle::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.GCReplyInviteToBattle.nickname)
}
inline std::string* GCReplyInviteToBattle::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GCToCS.GCReplyInviteToBattle.nickname)
  return _s;
}
inline const std::string& GCReplyInviteToBattle::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void GCReplyInviteToBattle::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* GCReplyInviteToBattle::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* GCReplyInviteToBattle::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.GCReplyInviteToBattle.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GCReplyInviteToBattle::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.GCReplyInviteToBattle.nickname)
}

// -------------------------------------------------------------------

// Login

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskLogin];
inline bool Login::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void Login::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8193;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::GCToCS::MsgNum Login::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.Login.msgnum)
  return _internal_msgnum();
}
inline void Login::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GCToCS.Login.msgnum)
}
inline ::GCToCS::MsgNum Login::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void Login::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 sdk = 2;
inline bool Login::has_sdk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void Login::clear_sdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdk_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t Login::sdk() const {
  // @@protoc_insertion_point(field_get:GCToCS.Login.sdk)
  return _internal_sdk();
}
inline void Login::set_sdk(::int32_t value) {
  _internal_set_sdk(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GCToCS.Login.sdk)
}
inline ::int32_t Login::_internal_sdk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdk_;
}
inline void Login::_internal_set_sdk(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdk_ = value;
}

// optional int32 platform = 3;
inline bool Login::has_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void Login::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t Login::platform() const {
  // @@protoc_insertion_point(field_get:GCToCS.Login.platform)
  return _internal_platform();
}
inline void Login::set_platform(::int32_t value) {
  _internal_set_platform(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GCToCS.Login.platform)
}
inline ::int32_t Login::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_;
}
inline void Login::_internal_set_platform(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = value;
}

// optional string name = 4;
inline bool Login::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Login::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Login::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.Login.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Login::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.Login.name)
}
inline std::string* Login::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GCToCS.Login.name)
  return _s;
}
inline const std::string& Login::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void Login::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Login::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Login::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.Login.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Login::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.Login.name)
}

// optional string passwd = 5;
inline bool Login::has_passwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Login::clear_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passwd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Login::passwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.Login.passwd)
  return _internal_passwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Login::set_passwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.passwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.Login.passwd)
}
inline std::string* Login::mutable_passwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:GCToCS.Login.passwd)
  return _s;
}
inline const std::string& Login::_internal_passwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passwd_.Get();
}
inline void Login::_internal_set_passwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.passwd_.Set(value, GetArena());
}
inline std::string* Login::_internal_mutable_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.passwd_.Mutable( GetArena());
}
inline std::string* Login::release_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.Login.passwd)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.passwd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.passwd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Login::set_allocated_passwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.passwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.passwd_.IsDefault()) {
          _impl_.passwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.Login.passwd)
}

// optional string ipaddress = 6;
inline bool Login::has_ipaddress() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Login::clear_ipaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ipaddress_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Login::ipaddress() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.Login.ipaddress)
  return _internal_ipaddress();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Login::set_ipaddress(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ipaddress_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.Login.ipaddress)
}
inline std::string* Login::mutable_ipaddress() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ipaddress();
  // @@protoc_insertion_point(field_mutable:GCToCS.Login.ipaddress)
  return _s;
}
inline const std::string& Login::_internal_ipaddress() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ipaddress_.Get();
}
inline void Login::_internal_set_ipaddress(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ipaddress_.Set(value, GetArena());
}
inline std::string* Login::_internal_mutable_ipaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.ipaddress_.Mutable( GetArena());
}
inline std::string* Login::release_ipaddress() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.Login.ipaddress)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.ipaddress_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ipaddress_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Login::set_allocated_ipaddress(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.ipaddress_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ipaddress_.IsDefault()) {
          _impl_.ipaddress_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.Login.ipaddress)
}

// optional string equimentid = 7;
inline bool Login::has_equimentid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void Login::clear_equimentid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.equimentid_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Login::equimentid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.Login.equimentid)
  return _internal_equimentid();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Login::set_equimentid(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.equimentid_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.Login.equimentid)
}
inline std::string* Login::mutable_equimentid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_equimentid();
  // @@protoc_insertion_point(field_mutable:GCToCS.Login.equimentid)
  return _s;
}
inline const std::string& Login::_internal_equimentid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.equimentid_.Get();
}
inline void Login::_internal_set_equimentid(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.equimentid_.Set(value, GetArena());
}
inline std::string* Login::_internal_mutable_equimentid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.equimentid_.Mutable( GetArena());
}
inline std::string* Login::release_equimentid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.Login.equimentid)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.equimentid_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.equimentid_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void Login::set_allocated_equimentid(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.equimentid_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.equimentid_.IsDefault()) {
          _impl_.equimentid_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.Login.equimentid)
}

// -------------------------------------------------------------------

// UserGameInfo

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskUserGameInfo];
inline bool UserGameInfo::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserGameInfo::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8196;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum UserGameInfo::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.UserGameInfo.msgnum)
  return _internal_msgnum();
}
inline void UserGameInfo::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.UserGameInfo.msgnum)
}
inline ::GCToCS::MsgNum UserGameInfo::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void UserGameInfo::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// BuyRunes

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_BUYRunes];
inline bool BuyRunes::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BuyRunes::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8220;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToCS::MsgNum BuyRunes::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.BuyRunes.msgnum)
  return _internal_msgnum();
}
inline void BuyRunes::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.BuyRunes.msgnum)
}
inline ::GCToCS::MsgNum BuyRunes::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void BuyRunes::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 typeid = 2;
inline bool BuyRunes::has_typeid_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BuyRunes::clear_typeid_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.typeid__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t BuyRunes::typeid_() const {
  // @@protoc_insertion_point(field_get:GCToCS.BuyRunes.typeid)
  return _internal_typeid_();
}
inline void BuyRunes::set_typeid_(::int32_t value) {
  _internal_set_typeid_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.BuyRunes.typeid)
}
inline ::int32_t BuyRunes::_internal_typeid_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.typeid__;
}
inline void BuyRunes::_internal_set_typeid_(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.typeid__ = value;
}

// -------------------------------------------------------------------

// EuipRunes

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_EuipRunes];
inline bool EuipRunes::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EuipRunes::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8221;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum EuipRunes::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.EuipRunes.msgnum)
  return _internal_msgnum();
}
inline void EuipRunes::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.EuipRunes.msgnum)
}
inline ::GCToCS::MsgNum EuipRunes::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void EuipRunes::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint32 runeid = 2;
inline bool EuipRunes::has_runeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void EuipRunes::clear_runeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t EuipRunes::runeid() const {
  // @@protoc_insertion_point(field_get:GCToCS.EuipRunes.runeid)
  return _internal_runeid();
}
inline void EuipRunes::set_runeid(::uint32_t value) {
  _internal_set_runeid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.EuipRunes.runeid)
}
inline ::uint32_t EuipRunes::_internal_runeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runeid_;
}
inline void EuipRunes::_internal_set_runeid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = value;
}

// optional int32 topos = 3;
inline bool EuipRunes::has_topos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void EuipRunes::clear_topos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t EuipRunes::topos() const {
  // @@protoc_insertion_point(field_get:GCToCS.EuipRunes.topos)
  return _internal_topos();
}
inline void EuipRunes::set_topos(::int32_t value) {
  _internal_set_topos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.EuipRunes.topos)
}
inline ::int32_t EuipRunes::_internal_topos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topos_;
}
inline void EuipRunes::_internal_set_topos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topos_ = value;
}

// -------------------------------------------------------------------

// UnEuipRunes

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_UnloadRunes];
inline bool UnEuipRunes::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UnEuipRunes::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8222;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum UnEuipRunes::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.UnEuipRunes.msgnum)
  return _internal_msgnum();
}
inline void UnEuipRunes::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.UnEuipRunes.msgnum)
}
inline ::GCToCS::MsgNum UnEuipRunes::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void UnEuipRunes::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 page = 2;
inline bool UnEuipRunes::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UnEuipRunes::clear_page() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UnEuipRunes::page() const {
  // @@protoc_insertion_point(field_get:GCToCS.UnEuipRunes.page)
  return _internal_page();
}
inline void UnEuipRunes::set_page(::int32_t value) {
  _internal_set_page(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.UnEuipRunes.page)
}
inline ::int32_t UnEuipRunes::_internal_page() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_;
}
inline void UnEuipRunes::_internal_set_page(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_ = value;
}

// optional int32 pos = 3;
inline bool UnEuipRunes::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UnEuipRunes::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t UnEuipRunes::pos() const {
  // @@protoc_insertion_point(field_get:GCToCS.UnEuipRunes.pos)
  return _internal_pos();
}
inline void UnEuipRunes::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.UnEuipRunes.pos)
}
inline ::int32_t UnEuipRunes::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void UnEuipRunes::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// -------------------------------------------------------------------

// ComposeRunes

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_ComposeRunes];
inline bool ComposeRunes::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ComposeRunes::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8223;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum ComposeRunes::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.ComposeRunes.msgnum)
  return _internal_msgnum();
}
inline void ComposeRunes::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.ComposeRunes.msgnum)
}
inline ::GCToCS::MsgNum ComposeRunes::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void ComposeRunes::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// repeated uint32 runesid = 2;
inline int ComposeRunes::_internal_runesid_size() const {
  return _internal_runesid().size();
}
inline int ComposeRunes::runesid_size() const {
  return _internal_runesid_size();
}
inline void ComposeRunes::clear_runesid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runesid_.Clear();
}
inline ::uint32_t ComposeRunes::runesid(int index) const {
  // @@protoc_insertion_point(field_get:GCToCS.ComposeRunes.runesid)
  return _internal_runesid().Get(index);
}
inline void ComposeRunes::set_runesid(int index, ::uint32_t value) {
  _internal_mutable_runesid()->Set(index, value);
  // @@protoc_insertion_point(field_set:GCToCS.ComposeRunes.runesid)
}
inline void ComposeRunes::add_runesid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_runesid()->Add(value);
  // @@protoc_insertion_point(field_add:GCToCS.ComposeRunes.runesid)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ComposeRunes::runesid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GCToCS.ComposeRunes.runesid)
  return _internal_runesid();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* ComposeRunes::mutable_runesid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GCToCS.ComposeRunes.runesid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_runesid();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& ComposeRunes::_internal_runesid()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runesid_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* ComposeRunes::_internal_mutable_runesid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.runesid_;
}

// -------------------------------------------------------------------

// ReconnectToGame

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskReconnectGame];
inline bool ReconnectToGame::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReconnectToGame::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8194;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToCS::MsgNum ReconnectToGame::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.ReconnectToGame.msgnum)
  return _internal_msgnum();
}
inline void ReconnectToGame::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.ReconnectToGame.msgnum)
}
inline ::GCToCS::MsgNum ReconnectToGame::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void ReconnectToGame::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string name = 2;
inline bool ReconnectToGame::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReconnectToGame::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReconnectToGame::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.ReconnectToGame.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReconnectToGame::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.ReconnectToGame.name)
}
inline std::string* ReconnectToGame::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GCToCS.ReconnectToGame.name)
  return _s;
}
inline const std::string& ReconnectToGame::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void ReconnectToGame::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ReconnectToGame::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ReconnectToGame::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.ReconnectToGame.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ReconnectToGame::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.ReconnectToGame.name)
}

// optional string passwd = 3;
inline bool ReconnectToGame::has_passwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReconnectToGame::clear_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passwd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReconnectToGame::passwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToCS.ReconnectToGame.passwd)
  return _internal_passwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReconnectToGame::set_passwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.passwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToCS.ReconnectToGame.passwd)
}
inline std::string* ReconnectToGame::mutable_passwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_passwd();
  // @@protoc_insertion_point(field_mutable:GCToCS.ReconnectToGame.passwd)
  return _s;
}
inline const std::string& ReconnectToGame::_internal_passwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passwd_.Get();
}
inline void ReconnectToGame::_internal_set_passwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.passwd_.Set(value, GetArena());
}
inline std::string* ReconnectToGame::_internal_mutable_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.passwd_.Mutable( GetArena());
}
inline std::string* ReconnectToGame::release_passwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToCS.ReconnectToGame.passwd)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.passwd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.passwd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ReconnectToGame::set_allocated_passwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.passwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.passwd_.IsDefault()) {
          _impl_.passwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToCS.ReconnectToGame.passwd)
}

// -------------------------------------------------------------------

// ComGuideStepID

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskGuideStepId];
inline bool ComGuideStepID::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ComGuideStepID::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8241;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GCToCS::MsgNum ComGuideStepID::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.ComGuideStepID.msgnum)
  return _internal_msgnum();
}
inline void ComGuideStepID::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GCToCS.ComGuideStepID.msgnum)
}
inline ::GCToCS::MsgNum ComGuideStepID::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void ComGuideStepID::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 type = 2;
inline bool ComGuideStepID::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ComGuideStepID::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ComGuideStepID::type() const {
  // @@protoc_insertion_point(field_get:GCToCS.ComGuideStepID.type)
  return _internal_type();
}
inline void ComGuideStepID::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.ComGuideStepID.type)
}
inline ::int32_t ComGuideStepID::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void ComGuideStepID::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional int32 step = 3;
inline bool ComGuideStepID::has_step() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ComGuideStepID::clear_step() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.step_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ComGuideStepID::step() const {
  // @@protoc_insertion_point(field_get:GCToCS.ComGuideStepID.step)
  return _internal_step();
}
inline void ComGuideStepID::set_step(::int32_t value) {
  _internal_set_step(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToCS.ComGuideStepID.step)
}
inline ::int32_t ComGuideStepID::_internal_step() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.step_;
}
inline void ComGuideStepID::_internal_set_step(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.step_ = value;
}

// optional int32 state = 4;
inline bool ComGuideStepID::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ComGuideStepID::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ComGuideStepID::state() const {
  // @@protoc_insertion_point(field_get:GCToCS.ComGuideStepID.state)
  return _internal_state();
}
inline void ComGuideStepID::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToCS.ComGuideStepID.state)
}
inline ::int32_t ComGuideStepID::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void ComGuideStepID::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// AskRoomList

// optional .GCToCS.MsgNum msgnum = 1 [default = eMsgToGSToCSFromGC_AskRoomList];
inline bool AskRoomList::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRoomList::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 8269;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToCS::MsgNum AskRoomList::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToCS.AskRoomList.msgnum)
  return _internal_msgnum();
}
inline void AskRoomList::set_msgnum(::GCToCS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToCS.AskRoomList.msgnum)
}
inline ::GCToCS::MsgNum AskRoomList::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToCS::MsgNum>(_impl_.msgnum_);
}
inline void AskRoomList::_internal_set_msgnum(::GCToCS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToCS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace GCToCS


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::GCToCS::AskCSCreateGuideBattle_guidetype> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GCToCS::AskCSCreateGuideBattle_guidetype>() {
  return ::GCToCS::AskCSCreateGuideBattle_guidetype_descriptor();
}
template <>
struct is_proto_enum<::GCToCS::MsgNum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GCToCS::MsgNum>() {
  return ::GCToCS::MsgNum_descriptor();
}
template <>
struct is_proto_enum<::GCToCS::notice_type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GCToCS::notice_type>() {
  return ::GCToCS::notice_type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_GCToCS_2eproto_2epb_2eh
