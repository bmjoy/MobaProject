// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSToDB.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_CSToDB_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_CSToDB_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_CSToDB_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_CSToDB_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_CSToDB_2eproto;
namespace CSToDB {
class AlterItem;
struct AlterItemDefaultTypeInternal;
extern AlterItemDefaultTypeInternal _AlterItem_default_instance_;
class AlterSNSList;
struct AlterSNSListDefaultTypeInternal;
extern AlterSNSListDefaultTypeInternal _AlterSNSList_default_instance_;
class BuyGoods;
struct BuyGoodsDefaultTypeInternal;
extern BuyGoodsDefaultTypeInternal _BuyGoods_default_instance_;
class CDKeyEvents;
struct CDKeyEventsDefaultTypeInternal;
extern CDKeyEventsDefaultTypeInternal _CDKeyEvents_default_instance_;
class ChangeNickName;
struct ChangeNickNameDefaultTypeInternal;
extern ChangeNickNameDefaultTypeInternal _ChangeNickName_default_instance_;
class CheckNameReq;
struct CheckNameReqDefaultTypeInternal;
extern CheckNameReqDefaultTypeInternal _CheckNameReq_default_instance_;
class DeleteNotice;
struct DeleteNoticeDefaultTypeInternal;
extern DeleteNoticeDefaultTypeInternal _DeleteNotice_default_instance_;
class ExeSQL_Call;
struct ExeSQL_CallDefaultTypeInternal;
extern ExeSQL_CallDefaultTypeInternal _ExeSQL_Call_default_instance_;
class GameMailInfo;
struct GameMailInfoDefaultTypeInternal;
extern GameMailInfoDefaultTypeInternal _GameMailInfo_default_instance_;
class InsertCDKeyInfo;
struct InsertCDKeyInfoDefaultTypeInternal;
extern InsertCDKeyInfoDefaultTypeInternal _InsertCDKeyInfo_default_instance_;
class InsertNotice;
struct InsertNoticeDefaultTypeInternal;
extern InsertNoticeDefaultTypeInternal _InsertNotice_default_instance_;
class InsertUser;
struct InsertUserDefaultTypeInternal;
extern InsertUserDefaultTypeInternal _InsertUser_default_instance_;
class NicknameConflict;
struct NicknameConflictDefaultTypeInternal;
extern NicknameConflictDefaultTypeInternal _NicknameConflict_default_instance_;
class QueryNotice;
struct QueryNoticeDefaultTypeInternal;
extern QueryNoticeDefaultTypeInternal _QueryNotice_default_instance_;
class QueryObjIdxReq;
struct QueryObjIdxReqDefaultTypeInternal;
extern QueryObjIdxReqDefaultTypeInternal _QueryObjIdxReq_default_instance_;
class QueryUserReq;
struct QueryUserReqDefaultTypeInternal;
extern QueryUserReqDefaultTypeInternal _QueryUserReq_default_instance_;
class StoreUserdata;
struct StoreUserdataDefaultTypeInternal;
extern StoreUserdataDefaultTypeInternal _StoreUserdata_default_instance_;
class StoreUserdata_SUserHeroDBData;
struct StoreUserdata_SUserHeroDBDataDefaultTypeInternal;
extern StoreUserdata_SUserHeroDBDataDefaultTypeInternal _StoreUserdata_SUserHeroDBData_default_instance_;
class StoreUserdata_SUserItemInfo;
struct StoreUserdata_SUserItemInfoDefaultTypeInternal;
extern StoreUserdata_SUserItemInfoDefaultTypeInternal _StoreUserdata_SUserItemInfo_default_instance_;
class StoreUserdata_SUserRelationshipInfo;
struct StoreUserdata_SUserRelationshipInfoDefaultTypeInternal;
extern StoreUserdata_SUserRelationshipInfoDefaultTypeInternal _StoreUserdata_SUserRelationshipInfo_default_instance_;
class StoreUserdata_UserMailDBData;
struct StoreUserdata_UserMailDBDataDefaultTypeInternal;
extern StoreUserdata_UserMailDBDataDefaultTypeInternal _StoreUserdata_UserMailDBData_default_instance_;
class UpdateCDKeyInfo;
struct UpdateCDKeyInfoDefaultTypeInternal;
extern UpdateCDKeyInfoDefaultTypeInternal _UpdateCDKeyInfo_default_instance_;
class UpdateGameMail;
struct UpdateGameMailDefaultTypeInternal;
extern UpdateGameMailDefaultTypeInternal _UpdateGameMail_default_instance_;
class UpdateUser;
struct UpdateUserDefaultTypeInternal;
extern UpdateUserDefaultTypeInternal _UpdateUser_default_instance_;
class UpdateUserMail;
struct UpdateUserMailDefaultTypeInternal;
extern UpdateUserMailDefaultTypeInternal _UpdateUserMail_default_instance_;
}  // namespace CSToDB
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace CSToDB {
enum MsgID : int {
  eCheckNickNameDBCallBack = 100,
  eQueryUser_DBCallBack = 101,
  eLogStore_DBCallBack = 102,
  eUpdateUser_DBCallBack = 103,
  eInsertUser_DBCallBack = 104,
  eUpdateGameMail_DBCallBack = 105,
  eBuyGoods_DBCallBack = 106,
  eNicknameConflict_DBCallBack = 107,
  eQueryObjId_DBCallBack = 108,
  eAlterSNSList_DBCall = 109,
  eInsertNotice_DBCall = 110,
  eDeleteNotice_DBCall = 111,
  eAlterItem_DBCall = 112,
  eChangeNickName_DBCall = 113,
  eExeSQL_Call = 114,
  eQueryNotice_DBCall = 115,
  eStoreUserData = 116,
  eUpdateUserGameMail_DBCallBack = 117,
  eInsertCDKeyEvents = 118,
  eInsertCDKeyInfo = 119,
  eUpdateCDKeyInfo = 120,
};

bool MsgID_IsValid(int value);
extern const uint32_t MsgID_internal_data_[];
constexpr MsgID MsgID_MIN = static_cast<MsgID>(100);
constexpr MsgID MsgID_MAX = static_cast<MsgID>(120);
constexpr int MsgID_ARRAYSIZE = 120 + 1;
const ::google::protobuf::EnumDescriptor*
MsgID_descriptor();
template <typename T>
const std::string& MsgID_Name(T value) {
  static_assert(std::is_same<T, MsgID>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgID_Name().");
  return MsgID_Name(static_cast<MsgID>(value));
}
template <>
inline const std::string& MsgID_Name(MsgID value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MsgID_descriptor,
                                                 100, 120>(
      static_cast<int>(value));
}
inline bool MsgID_Parse(absl::string_view name, MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgID>(
      MsgID_descriptor(), name, value);
}
enum MailType : int {
  mailType_None = 0,
  mailType_1 = 1,
  mailType_2 = 2,
  mailType_3 = 3,
  mailType_4 = 4,
};

bool MailType_IsValid(int value);
extern const uint32_t MailType_internal_data_[];
constexpr MailType MailType_MIN = static_cast<MailType>(0);
constexpr MailType MailType_MAX = static_cast<MailType>(4);
constexpr int MailType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
MailType_descriptor();
template <typename T>
const std::string& MailType_Name(T value) {
  static_assert(std::is_same<T, MailType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MailType_Name().");
  return MailType_Name(static_cast<MailType>(value));
}
template <>
inline const std::string& MailType_Name(MailType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MailType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool MailType_Parse(absl::string_view name, MailType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MailType>(
      MailType_descriptor(), name, value);
}
enum EMailCurtState : int {
  eMailState_None = 0,
  eMailState_New = 1,
  eMailState_LookedButNotGotGift = 2,
  eMailState_Look = 3,
  eMailState_Del = 4,
};

bool EMailCurtState_IsValid(int value);
extern const uint32_t EMailCurtState_internal_data_[];
constexpr EMailCurtState EMailCurtState_MIN = static_cast<EMailCurtState>(0);
constexpr EMailCurtState EMailCurtState_MAX = static_cast<EMailCurtState>(4);
constexpr int EMailCurtState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
EMailCurtState_descriptor();
template <typename T>
const std::string& EMailCurtState_Name(T value) {
  static_assert(std::is_same<T, EMailCurtState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EMailCurtState_Name().");
  return EMailCurtState_Name(static_cast<EMailCurtState>(value));
}
template <>
inline const std::string& EMailCurtState_Name(EMailCurtState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EMailCurtState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool EMailCurtState_Parse(absl::string_view name, EMailCurtState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMailCurtState>(
      EMailCurtState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateUserMail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.UpdateUserMail) */ {
 public:
  inline UpdateUserMail() : UpdateUserMail(nullptr) {}
  ~UpdateUserMail() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateUserMail(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateUserMail(const UpdateUserMail& from) : UpdateUserMail(nullptr, from) {}
  inline UpdateUserMail(UpdateUserMail&& from) noexcept
      : UpdateUserMail(nullptr, std::move(from)) {}
  inline UpdateUserMail& operator=(const UpdateUserMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUserMail& operator=(UpdateUserMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUserMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUserMail* internal_default_instance() {
    return reinterpret_cast<const UpdateUserMail*>(
        &_UpdateUserMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(UpdateUserMail& a, UpdateUserMail& b) { a.Swap(&b); }
  inline void Swap(UpdateUserMail* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUserMail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUserMail* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateUserMail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateUserMail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateUserMail& from) { UpdateUserMail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateUserMail* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.UpdateUserMail"; }

 protected:
  explicit UpdateUserMail(::google::protobuf::Arena* arena);
  UpdateUserMail(::google::protobuf::Arena* arena, const UpdateUserMail& from);
  UpdateUserMail(::google::protobuf::Arena* arena, UpdateUserMail&& from) noexcept
      : UpdateUserMail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjidFieldNumber = 2,
    kMailidFieldNumber = 3,
    kCstateFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional int64 objid = 2;
  bool has_objid() const;
  void clear_objid() ;
  ::int64_t objid() const;
  void set_objid(::int64_t value);

  private:
  ::int64_t _internal_objid() const;
  void _internal_set_objid(::int64_t value);

  public:
  // optional int32 mailid = 3;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional int32 cstate = 4;
  bool has_cstate() const;
  void clear_cstate() ;
  ::int32_t cstate() const;
  void set_cstate(::int32_t value);

  private:
  ::int32_t _internal_cstate() const;
  void _internal_set_cstate(::int32_t value);

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eUpdateUserGameMail_DBCallBack];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.UpdateUserMail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t objid_;
    ::int32_t mailid_;
    ::int32_t cstate_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class UpdateUser final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.UpdateUser) */ {
 public:
  inline UpdateUser() : UpdateUser(nullptr) {}
  ~UpdateUser() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateUser(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateUser(const UpdateUser& from) : UpdateUser(nullptr, from) {}
  inline UpdateUser(UpdateUser&& from) noexcept
      : UpdateUser(nullptr, std::move(from)) {}
  inline UpdateUser& operator=(const UpdateUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateUser& operator=(UpdateUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateUser* internal_default_instance() {
    return reinterpret_cast<const UpdateUser*>(
        &_UpdateUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(UpdateUser& a, UpdateUser& b) { a.Swap(&b); }
  inline void Swap(UpdateUser* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateUser* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateUser* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateUser>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateUser& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateUser& from) { UpdateUser::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateUser* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.UpdateUser"; }

 protected:
  explicit UpdateUser(::google::protobuf::Arena* arena);
  UpdateUser(::google::protobuf::Arena* arena, const UpdateUser& from);
  UpdateUser(::google::protobuf::Arena* arena, UpdateUser&& from) noexcept
      : UpdateUser(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlstrFieldNumber = 3,
    kGuidFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional string sqlstr = 3;
  bool has_sqlstr() const;
  void clear_sqlstr() ;
  const std::string& sqlstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sqlstr(Arg_&& arg, Args_... args);
  std::string* mutable_sqlstr();
  PROTOBUF_NODISCARD std::string* release_sqlstr();
  void set_allocated_sqlstr(std::string* value);

  private:
  const std::string& _internal_sqlstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sqlstr(
      const std::string& value);
  std::string* _internal_mutable_sqlstr();

  public:
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eUpdateUser_DBCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.UpdateUser)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sqlstr_;
    ::int64_t guid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class UpdateCDKeyInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.UpdateCDKeyInfo) */ {
 public:
  inline UpdateCDKeyInfo() : UpdateCDKeyInfo(nullptr) {}
  ~UpdateCDKeyInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateCDKeyInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateCDKeyInfo(const UpdateCDKeyInfo& from) : UpdateCDKeyInfo(nullptr, from) {}
  inline UpdateCDKeyInfo(UpdateCDKeyInfo&& from) noexcept
      : UpdateCDKeyInfo(nullptr, std::move(from)) {}
  inline UpdateCDKeyInfo& operator=(const UpdateCDKeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateCDKeyInfo& operator=(UpdateCDKeyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateCDKeyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateCDKeyInfo* internal_default_instance() {
    return reinterpret_cast<const UpdateCDKeyInfo*>(
        &_UpdateCDKeyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(UpdateCDKeyInfo& a, UpdateCDKeyInfo& b) { a.Swap(&b); }
  inline void Swap(UpdateCDKeyInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateCDKeyInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateCDKeyInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateCDKeyInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateCDKeyInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateCDKeyInfo& from) { UpdateCDKeyInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateCDKeyInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.UpdateCDKeyInfo"; }

 protected:
  explicit UpdateCDKeyInfo(::google::protobuf::Arena* arena);
  UpdateCDKeyInfo(::google::protobuf::Arena* arena, const UpdateCDKeyInfo& from);
  UpdateCDKeyInfo(::google::protobuf::Arena* arena, UpdateCDKeyInfo&& from) noexcept
      : UpdateCDKeyInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlStrFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string sql_str = 2;
  bool has_sql_str() const;
  void clear_sql_str() ;
  const std::string& sql_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sql_str(Arg_&& arg, Args_... args);
  std::string* mutable_sql_str();
  PROTOBUF_NODISCARD std::string* release_sql_str();
  void set_allocated_sql_str(std::string* value);

  private:
  const std::string& _internal_sql_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql_str(
      const std::string& value);
  std::string* _internal_mutable_sql_str();

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eUpdateCDKeyInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.UpdateCDKeyInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sql_str_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class StoreUserdata_UserMailDBData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.StoreUserdata.UserMailDBData) */ {
 public:
  inline StoreUserdata_UserMailDBData() : StoreUserdata_UserMailDBData(nullptr) {}
  ~StoreUserdata_UserMailDBData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StoreUserdata_UserMailDBData(
      ::google::protobuf::internal::ConstantInitialized);

  inline StoreUserdata_UserMailDBData(const StoreUserdata_UserMailDBData& from) : StoreUserdata_UserMailDBData(nullptr, from) {}
  inline StoreUserdata_UserMailDBData(StoreUserdata_UserMailDBData&& from) noexcept
      : StoreUserdata_UserMailDBData(nullptr, std::move(from)) {}
  inline StoreUserdata_UserMailDBData& operator=(const StoreUserdata_UserMailDBData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreUserdata_UserMailDBData& operator=(StoreUserdata_UserMailDBData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreUserdata_UserMailDBData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreUserdata_UserMailDBData* internal_default_instance() {
    return reinterpret_cast<const StoreUserdata_UserMailDBData*>(
        &_StoreUserdata_UserMailDBData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(StoreUserdata_UserMailDBData& a, StoreUserdata_UserMailDBData& b) { a.Swap(&b); }
  inline void Swap(StoreUserdata_UserMailDBData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreUserdata_UserMailDBData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreUserdata_UserMailDBData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StoreUserdata_UserMailDBData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StoreUserdata_UserMailDBData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StoreUserdata_UserMailDBData& from) { StoreUserdata_UserMailDBData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StoreUserdata_UserMailDBData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.StoreUserdata.UserMailDBData"; }

 protected:
  explicit StoreUserdata_UserMailDBData(::google::protobuf::Arena* arena);
  StoreUserdata_UserMailDBData(::google::protobuf::Arena* arena, const StoreUserdata_UserMailDBData& from);
  StoreUserdata_UserMailDBData(::google::protobuf::Arena* arena, StoreUserdata_UserMailDBData&& from) noexcept
      : StoreUserdata_UserMailDBData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailIdFieldNumber = 1,
    kMStateFieldNumber = 2,
  };
  // optional int32 mailId = 1;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional int32 mState = 2;
  bool has_mstate() const;
  void clear_mstate() ;
  ::int32_t mstate() const;
  void set_mstate(::int32_t value);

  private:
  ::int32_t _internal_mstate() const;
  void _internal_set_mstate(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.StoreUserdata.UserMailDBData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mailid_;
    ::int32_t mstate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class StoreUserdata_SUserRelationshipInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.StoreUserdata.SUserRelationshipInfo) */ {
 public:
  inline StoreUserdata_SUserRelationshipInfo() : StoreUserdata_SUserRelationshipInfo(nullptr) {}
  ~StoreUserdata_SUserRelationshipInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StoreUserdata_SUserRelationshipInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline StoreUserdata_SUserRelationshipInfo(const StoreUserdata_SUserRelationshipInfo& from) : StoreUserdata_SUserRelationshipInfo(nullptr, from) {}
  inline StoreUserdata_SUserRelationshipInfo(StoreUserdata_SUserRelationshipInfo&& from) noexcept
      : StoreUserdata_SUserRelationshipInfo(nullptr, std::move(from)) {}
  inline StoreUserdata_SUserRelationshipInfo& operator=(const StoreUserdata_SUserRelationshipInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreUserdata_SUserRelationshipInfo& operator=(StoreUserdata_SUserRelationshipInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreUserdata_SUserRelationshipInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreUserdata_SUserRelationshipInfo* internal_default_instance() {
    return reinterpret_cast<const StoreUserdata_SUserRelationshipInfo*>(
        &_StoreUserdata_SUserRelationshipInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(StoreUserdata_SUserRelationshipInfo& a, StoreUserdata_SUserRelationshipInfo& b) { a.Swap(&b); }
  inline void Swap(StoreUserdata_SUserRelationshipInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreUserdata_SUserRelationshipInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreUserdata_SUserRelationshipInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StoreUserdata_SUserRelationshipInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StoreUserdata_SUserRelationshipInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StoreUserdata_SUserRelationshipInfo& from) { StoreUserdata_SUserRelationshipInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StoreUserdata_SUserRelationshipInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.StoreUserdata.SUserRelationshipInfo"; }

 protected:
  explicit StoreUserdata_SUserRelationshipInfo(::google::protobuf::Arena* arena);
  StoreUserdata_SUserRelationshipInfo(::google::protobuf::Arena* arena, const StoreUserdata_SUserRelationshipInfo& from);
  StoreUserdata_SUserRelationshipInfo(::google::protobuf::Arena* arena, StoreUserdata_SUserRelationshipInfo&& from) noexcept
      : StoreUserdata_SUserRelationshipInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStNickNameFieldNumber = 1,
    kGuididxFieldNumber = 3,
    kNHeadIdFieldNumber = 2,
    kERelationShipFieldNumber = 4,
    kTMilSecFieldNumber = 5,
  };
  // optional string stNickName = 1;
  bool has_stnickname() const;
  void clear_stnickname() ;
  const std::string& stnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_stnickname(Arg_&& arg, Args_... args);
  std::string* mutable_stnickname();
  PROTOBUF_NODISCARD std::string* release_stnickname();
  void set_allocated_stnickname(std::string* value);

  private:
  const std::string& _internal_stnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stnickname(
      const std::string& value);
  std::string* _internal_mutable_stnickname();

  public:
  // optional int64 guididx = 3;
  bool has_guididx() const;
  void clear_guididx() ;
  ::int64_t guididx() const;
  void set_guididx(::int64_t value);

  private:
  ::int64_t _internal_guididx() const;
  void _internal_set_guididx(::int64_t value);

  public:
  // optional int32 nHeadId = 2;
  bool has_nheadid() const;
  void clear_nheadid() ;
  ::int32_t nheadid() const;
  void set_nheadid(::int32_t value);

  private:
  ::int32_t _internal_nheadid() const;
  void _internal_set_nheadid(::int32_t value);

  public:
  // optional int32 eRelationShip = 4;
  bool has_erelationship() const;
  void clear_erelationship() ;
  ::int32_t erelationship() const;
  void set_erelationship(::int32_t value);

  private:
  ::int32_t _internal_erelationship() const;
  void _internal_set_erelationship(::int32_t value);

  public:
  // optional int64 tMilSec = 5;
  bool has_tmilsec() const;
  void clear_tmilsec() ;
  ::int64_t tmilsec() const;
  void set_tmilsec(::int64_t value);

  private:
  ::int64_t _internal_tmilsec() const;
  void _internal_set_tmilsec(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.StoreUserdata.SUserRelationshipInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr stnickname_;
    ::int64_t guididx_;
    ::int32_t nheadid_;
    ::int32_t erelationship_;
    ::int64_t tmilsec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class StoreUserdata_SUserItemInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.StoreUserdata.SUserItemInfo) */ {
 public:
  inline StoreUserdata_SUserItemInfo() : StoreUserdata_SUserItemInfo(nullptr) {}
  ~StoreUserdata_SUserItemInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StoreUserdata_SUserItemInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline StoreUserdata_SUserItemInfo(const StoreUserdata_SUserItemInfo& from) : StoreUserdata_SUserItemInfo(nullptr, from) {}
  inline StoreUserdata_SUserItemInfo(StoreUserdata_SUserItemInfo&& from) noexcept
      : StoreUserdata_SUserItemInfo(nullptr, std::move(from)) {}
  inline StoreUserdata_SUserItemInfo& operator=(const StoreUserdata_SUserItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreUserdata_SUserItemInfo& operator=(StoreUserdata_SUserItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreUserdata_SUserItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreUserdata_SUserItemInfo* internal_default_instance() {
    return reinterpret_cast<const StoreUserdata_SUserItemInfo*>(
        &_StoreUserdata_SUserItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(StoreUserdata_SUserItemInfo& a, StoreUserdata_SUserItemInfo& b) { a.Swap(&b); }
  inline void Swap(StoreUserdata_SUserItemInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreUserdata_SUserItemInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreUserdata_SUserItemInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StoreUserdata_SUserItemInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StoreUserdata_SUserItemInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StoreUserdata_SUserItemInfo& from) { StoreUserdata_SUserItemInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StoreUserdata_SUserItemInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.StoreUserdata.SUserItemInfo"; }

 protected:
  explicit StoreUserdata_SUserItemInfo(::google::protobuf::Arena* arena);
  StoreUserdata_SUserItemInfo(::google::protobuf::Arena* arena, const StoreUserdata_SUserItemInfo& from);
  StoreUserdata_SUserItemInfo(::google::protobuf::Arena* arena, StoreUserdata_SUserItemInfo&& from) noexcept
      : StoreUserdata_SUserItemInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kIfusingFieldNumber = 2,
    kBuyTimeFieldNumber = 4,
    kItemNumFieldNumber = 3,
    kN32EffectValueFieldNumber = 7,
    kEndTimeFieldNumber = 6,
    kN32EffectIDFieldNumber = 8,
  };
  // optional int32 item_id = 1;
  bool has_item_id() const;
  void clear_item_id() ;
  ::int32_t item_id() const;
  void set_item_id(::int32_t value);

  private:
  ::int32_t _internal_item_id() const;
  void _internal_set_item_id(::int32_t value);

  public:
  // optional bool ifusing = 2;
  bool has_ifusing() const;
  void clear_ifusing() ;
  bool ifusing() const;
  void set_ifusing(bool value);

  private:
  bool _internal_ifusing() const;
  void _internal_set_ifusing(bool value);

  public:
  // optional int64 buy_time = 4;
  bool has_buy_time() const;
  void clear_buy_time() ;
  ::int64_t buy_time() const;
  void set_buy_time(::int64_t value);

  private:
  ::int64_t _internal_buy_time() const;
  void _internal_set_buy_time(::int64_t value);

  public:
  // optional int32 item_num = 3;
  bool has_item_num() const;
  void clear_item_num() ;
  ::int32_t item_num() const;
  void set_item_num(::int32_t value);

  private:
  ::int32_t _internal_item_num() const;
  void _internal_set_item_num(::int32_t value);

  public:
  // optional int32 n32EffectValue = 7;
  bool has_n32effectvalue() const;
  void clear_n32effectvalue() ;
  ::int32_t n32effectvalue() const;
  void set_n32effectvalue(::int32_t value);

  private:
  ::int32_t _internal_n32effectvalue() const;
  void _internal_set_n32effectvalue(::int32_t value);

  public:
  // optional int64 end_time = 6;
  bool has_end_time() const;
  void clear_end_time() ;
  ::int64_t end_time() const;
  void set_end_time(::int64_t value);

  private:
  ::int64_t _internal_end_time() const;
  void _internal_set_end_time(::int64_t value);

  public:
  // optional int32 n32EffectID = 8;
  bool has_n32effectid() const;
  void clear_n32effectid() ;
  ::int32_t n32effectid() const;
  void set_n32effectid(::int32_t value);

  private:
  ::int32_t _internal_n32effectid() const;
  void _internal_set_n32effectid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.StoreUserdata.SUserItemInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t item_id_;
    bool ifusing_;
    ::int64_t buy_time_;
    ::int32_t item_num_;
    ::int32_t n32effectvalue_;
    ::int64_t end_time_;
    ::int32_t n32effectid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class StoreUserdata_SUserHeroDBData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.StoreUserdata.SUserHeroDBData) */ {
 public:
  inline StoreUserdata_SUserHeroDBData() : StoreUserdata_SUserHeroDBData(nullptr) {}
  ~StoreUserdata_SUserHeroDBData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StoreUserdata_SUserHeroDBData(
      ::google::protobuf::internal::ConstantInitialized);

  inline StoreUserdata_SUserHeroDBData(const StoreUserdata_SUserHeroDBData& from) : StoreUserdata_SUserHeroDBData(nullptr, from) {}
  inline StoreUserdata_SUserHeroDBData(StoreUserdata_SUserHeroDBData&& from) noexcept
      : StoreUserdata_SUserHeroDBData(nullptr, std::move(from)) {}
  inline StoreUserdata_SUserHeroDBData& operator=(const StoreUserdata_SUserHeroDBData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreUserdata_SUserHeroDBData& operator=(StoreUserdata_SUserHeroDBData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreUserdata_SUserHeroDBData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreUserdata_SUserHeroDBData* internal_default_instance() {
    return reinterpret_cast<const StoreUserdata_SUserHeroDBData*>(
        &_StoreUserdata_SUserHeroDBData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(StoreUserdata_SUserHeroDBData& a, StoreUserdata_SUserHeroDBData& b) { a.Swap(&b); }
  inline void Swap(StoreUserdata_SUserHeroDBData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreUserdata_SUserHeroDBData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreUserdata_SUserHeroDBData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StoreUserdata_SUserHeroDBData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StoreUserdata_SUserHeroDBData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StoreUserdata_SUserHeroDBData& from) { StoreUserdata_SUserHeroDBData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StoreUserdata_SUserHeroDBData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.StoreUserdata.SUserHeroDBData"; }

 protected:
  explicit StoreUserdata_SUserHeroDBData(::google::protobuf::Arena* arena);
  StoreUserdata_SUserHeroDBData(::google::protobuf::Arena* arena, const StoreUserdata_SUserHeroDBData& from);
  StoreUserdata_SUserHeroDBData(::google::protobuf::Arena* arena, StoreUserdata_SUserHeroDBData&& from) noexcept
      : StoreUserdata_SUserHeroDBData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEndTimeFieldNumber = 2,
    kBuyTimeFieldNumber = 3,
    kUn32HeroIDFieldNumber = 1,
  };
  // optional int64 endTime = 2;
  bool has_endtime() const;
  void clear_endtime() ;
  ::int64_t endtime() const;
  void set_endtime(::int64_t value);

  private:
  ::int64_t _internal_endtime() const;
  void _internal_set_endtime(::int64_t value);

  public:
  // optional int64 buyTime = 3;
  bool has_buytime() const;
  void clear_buytime() ;
  ::int64_t buytime() const;
  void set_buytime(::int64_t value);

  private:
  ::int64_t _internal_buytime() const;
  void _internal_set_buytime(::int64_t value);

  public:
  // optional int32 un32HeroID = 1;
  bool has_un32heroid() const;
  void clear_un32heroid() ;
  ::int32_t un32heroid() const;
  void set_un32heroid(::int32_t value);

  private:
  ::int32_t _internal_un32heroid() const;
  void _internal_set_un32heroid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.StoreUserdata.SUserHeroDBData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t endtime_;
    ::int64_t buytime_;
    ::int32_t un32heroid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class QueryUserReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.QueryUserReq) */ {
 public:
  inline QueryUserReq() : QueryUserReq(nullptr) {}
  ~QueryUserReq() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryUserReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryUserReq(const QueryUserReq& from) : QueryUserReq(nullptr, from) {}
  inline QueryUserReq(QueryUserReq&& from) noexcept
      : QueryUserReq(nullptr, std::move(from)) {}
  inline QueryUserReq& operator=(const QueryUserReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUserReq& operator=(QueryUserReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryUserReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryUserReq* internal_default_instance() {
    return reinterpret_cast<const QueryUserReq*>(
        &_QueryUserReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(QueryUserReq& a, QueryUserReq& b) { a.Swap(&b); }
  inline void Swap(QueryUserReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUserReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryUserReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryUserReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryUserReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryUserReq& from) { QueryUserReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryUserReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.QueryUserReq"; }

 protected:
  explicit QueryUserReq(::google::protobuf::Arena* arena);
  QueryUserReq(::google::protobuf::Arena* arena, const QueryUserReq& from);
  QueryUserReq(::google::protobuf::Arena* arena, QueryUserReq&& from) noexcept
      : QueryUserReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogininfoFieldNumber = 2,
    kUnameFieldNumber = 7,
    kGsidFieldNumber = 3,
    kGcnetidFieldNumber = 4,
    kObjidFieldNumber = 6,
    kCsidFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional string Logininfo = 2;
  bool has_logininfo() const;
  void clear_logininfo() ;
  const std::string& logininfo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_logininfo(Arg_&& arg, Args_... args);
  std::string* mutable_logininfo();
  PROTOBUF_NODISCARD std::string* release_logininfo();
  void set_allocated_logininfo(std::string* value);

  private:
  const std::string& _internal_logininfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logininfo(
      const std::string& value);
  std::string* _internal_mutable_logininfo();

  public:
  // optional string uname = 7;
  bool has_uname() const;
  void clear_uname() ;
  const std::string& uname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_uname(Arg_&& arg, Args_... args);
  std::string* mutable_uname();
  PROTOBUF_NODISCARD std::string* release_uname();
  void set_allocated_uname(std::string* value);

  private:
  const std::string& _internal_uname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uname(
      const std::string& value);
  std::string* _internal_mutable_uname();

  public:
  // optional int32 gsid = 3;
  bool has_gsid() const;
  void clear_gsid() ;
  ::int32_t gsid() const;
  void set_gsid(::int32_t value);

  private:
  ::int32_t _internal_gsid() const;
  void _internal_set_gsid(::int32_t value);

  public:
  // optional int32 gcnetid = 4;
  bool has_gcnetid() const;
  void clear_gcnetid() ;
  ::int32_t gcnetid() const;
  void set_gcnetid(::int32_t value);

  private:
  ::int32_t _internal_gcnetid() const;
  void _internal_set_gcnetid(::int32_t value);

  public:
  // optional int64 objid = 6;
  bool has_objid() const;
  void clear_objid() ;
  ::int64_t objid() const;
  void set_objid(::int64_t value);

  private:
  ::int64_t _internal_objid() const;
  void _internal_set_objid(::int64_t value);

  public:
  // optional int32 csid = 5;
  bool has_csid() const;
  void clear_csid() ;
  ::int32_t csid() const;
  void set_csid(::int32_t value);

  private:
  ::int32_t _internal_csid() const;
  void _internal_set_csid(::int32_t value);

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eQueryUser_DBCallBack];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.QueryUserReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr logininfo_;
    ::google::protobuf::internal::ArenaStringPtr uname_;
    ::int32_t gsid_;
    ::int32_t gcnetid_;
    ::int64_t objid_;
    ::int32_t csid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class QueryObjIdxReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.QueryObjIdxReq) */ {
 public:
  inline QueryObjIdxReq() : QueryObjIdxReq(nullptr) {}
  ~QueryObjIdxReq() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryObjIdxReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryObjIdxReq(const QueryObjIdxReq& from) : QueryObjIdxReq(nullptr, from) {}
  inline QueryObjIdxReq(QueryObjIdxReq&& from) noexcept
      : QueryObjIdxReq(nullptr, std::move(from)) {}
  inline QueryObjIdxReq& operator=(const QueryObjIdxReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryObjIdxReq& operator=(QueryObjIdxReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryObjIdxReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryObjIdxReq* internal_default_instance() {
    return reinterpret_cast<const QueryObjIdxReq*>(
        &_QueryObjIdxReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(QueryObjIdxReq& a, QueryObjIdxReq& b) { a.Swap(&b); }
  inline void Swap(QueryObjIdxReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryObjIdxReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryObjIdxReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryObjIdxReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryObjIdxReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryObjIdxReq& from) { QueryObjIdxReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryObjIdxReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.QueryObjIdxReq"; }

 protected:
  explicit QueryObjIdxReq(::google::protobuf::Arena* arena);
  QueryObjIdxReq(::google::protobuf::Arena* arena, const QueryObjIdxReq& from);
  QueryObjIdxReq(::google::protobuf::Arena* arena, QueryObjIdxReq&& from) noexcept
      : QueryObjIdxReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogininfoFieldNumber = 2,
    kGsidFieldNumber = 3,
    kGcnetidFieldNumber = 4,
    kCsidFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional string Logininfo = 2;
  bool has_logininfo() const;
  void clear_logininfo() ;
  const std::string& logininfo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_logininfo(Arg_&& arg, Args_... args);
  std::string* mutable_logininfo();
  PROTOBUF_NODISCARD std::string* release_logininfo();
  void set_allocated_logininfo(std::string* value);

  private:
  const std::string& _internal_logininfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logininfo(
      const std::string& value);
  std::string* _internal_mutable_logininfo();

  public:
  // optional int32 gsid = 3;
  bool has_gsid() const;
  void clear_gsid() ;
  ::int32_t gsid() const;
  void set_gsid(::int32_t value);

  private:
  ::int32_t _internal_gsid() const;
  void _internal_set_gsid(::int32_t value);

  public:
  // optional int32 gcnetid = 4;
  bool has_gcnetid() const;
  void clear_gcnetid() ;
  ::int32_t gcnetid() const;
  void set_gcnetid(::int32_t value);

  private:
  ::int32_t _internal_gcnetid() const;
  void _internal_set_gcnetid(::int32_t value);

  public:
  // optional int32 csid = 5;
  bool has_csid() const;
  void clear_csid() ;
  ::int32_t csid() const;
  void set_csid(::int32_t value);

  private:
  ::int32_t _internal_csid() const;
  void _internal_set_csid(::int32_t value);

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eQueryObjId_DBCallBack];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.QueryObjIdxReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      39, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr logininfo_;
    ::int32_t gsid_;
    ::int32_t gcnetid_;
    ::int32_t csid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class QueryNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.QueryNotice) */ {
 public:
  inline QueryNotice() : QueryNotice(nullptr) {}
  ~QueryNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryNotice(const QueryNotice& from) : QueryNotice(nullptr, from) {}
  inline QueryNotice(QueryNotice&& from) noexcept
      : QueryNotice(nullptr, std::move(from)) {}
  inline QueryNotice& operator=(const QueryNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryNotice& operator=(QueryNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryNotice* internal_default_instance() {
    return reinterpret_cast<const QueryNotice*>(
        &_QueryNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(QueryNotice& a, QueryNotice& b) { a.Swap(&b); }
  inline void Swap(QueryNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryNotice& from) { QueryNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.QueryNotice"; }

 protected:
  explicit QueryNotice(::google::protobuf::Arena* arena);
  QueryNotice(::google::protobuf::Arena* arena, const QueryNotice& from);
  QueryNotice(::google::protobuf::Arena* arena, QueryNotice&& from) noexcept
      : QueryNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .CSToDB.MsgID msgid = 1 [default = eQueryNotice_DBCall];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.QueryNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class NicknameConflict final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.NicknameConflict) */ {
 public:
  inline NicknameConflict() : NicknameConflict(nullptr) {}
  ~NicknameConflict() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NicknameConflict(
      ::google::protobuf::internal::ConstantInitialized);

  inline NicknameConflict(const NicknameConflict& from) : NicknameConflict(nullptr, from) {}
  inline NicknameConflict(NicknameConflict&& from) noexcept
      : NicknameConflict(nullptr, std::move(from)) {}
  inline NicknameConflict& operator=(const NicknameConflict& from) {
    CopyFrom(from);
    return *this;
  }
  inline NicknameConflict& operator=(NicknameConflict&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NicknameConflict& default_instance() {
    return *internal_default_instance();
  }
  static inline const NicknameConflict* internal_default_instance() {
    return reinterpret_cast<const NicknameConflict*>(
        &_NicknameConflict_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(NicknameConflict& a, NicknameConflict& b) { a.Swap(&b); }
  inline void Swap(NicknameConflict* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NicknameConflict* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NicknameConflict* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NicknameConflict>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NicknameConflict& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NicknameConflict& from) { NicknameConflict::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NicknameConflict* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.NicknameConflict"; }

 protected:
  explicit NicknameConflict(::google::protobuf::Arena* arena);
  NicknameConflict(::google::protobuf::Arena* arena, const NicknameConflict& from);
  NicknameConflict(::google::protobuf::Arena* arena, NicknameConflict&& from) noexcept
      : NicknameConflict(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewnicknameFieldNumber = 2,
    kCdkFieldNumber = 8,
    kOldnicknameFieldNumber = 9,
    kGsidFieldNumber = 3,
    kGcnetidFieldNumber = 4,
    kGuidFieldNumber = 5,
    kSdkidFieldNumber = 6,
    kCsidFieldNumber = 7,
    kMgsidFieldNumber = 1,
  };
  // optional string newnickname = 2;
  bool has_newnickname() const;
  void clear_newnickname() ;
  const std::string& newnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_newnickname(Arg_&& arg, Args_... args);
  std::string* mutable_newnickname();
  PROTOBUF_NODISCARD std::string* release_newnickname();
  void set_allocated_newnickname(std::string* value);

  private:
  const std::string& _internal_newnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newnickname(
      const std::string& value);
  std::string* _internal_mutable_newnickname();

  public:
  // optional string cdk = 8;
  bool has_cdk() const;
  void clear_cdk() ;
  const std::string& cdk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cdk(Arg_&& arg, Args_... args);
  std::string* mutable_cdk();
  PROTOBUF_NODISCARD std::string* release_cdk();
  void set_allocated_cdk(std::string* value);

  private:
  const std::string& _internal_cdk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cdk(
      const std::string& value);
  std::string* _internal_mutable_cdk();

  public:
  // optional string oldnickname = 9;
  bool has_oldnickname() const;
  void clear_oldnickname() ;
  const std::string& oldnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oldnickname(Arg_&& arg, Args_... args);
  std::string* mutable_oldnickname();
  PROTOBUF_NODISCARD std::string* release_oldnickname();
  void set_allocated_oldnickname(std::string* value);

  private:
  const std::string& _internal_oldnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldnickname(
      const std::string& value);
  std::string* _internal_mutable_oldnickname();

  public:
  // optional int32 gsid = 3;
  bool has_gsid() const;
  void clear_gsid() ;
  ::int32_t gsid() const;
  void set_gsid(::int32_t value);

  private:
  ::int32_t _internal_gsid() const;
  void _internal_set_gsid(::int32_t value);

  public:
  // optional int32 gcnetid = 4;
  bool has_gcnetid() const;
  void clear_gcnetid() ;
  ::int32_t gcnetid() const;
  void set_gcnetid(::int32_t value);

  private:
  ::int32_t _internal_gcnetid() const;
  void _internal_set_gcnetid(::int32_t value);

  public:
  // optional uint64 guid = 5;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 sdkid = 6;
  bool has_sdkid() const;
  void clear_sdkid() ;
  ::int32_t sdkid() const;
  void set_sdkid(::int32_t value);

  private:
  ::int32_t _internal_sdkid() const;
  void _internal_set_sdkid(::int32_t value);

  public:
  // optional int32 csid = 7;
  bool has_csid() const;
  void clear_csid() ;
  ::int32_t csid() const;
  void set_csid(::int32_t value);

  private:
  ::int32_t _internal_csid() const;
  void _internal_set_csid(::int32_t value);

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eNicknameConflict_DBCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.NicknameConflict)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      65, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr newnickname_;
    ::google::protobuf::internal::ArenaStringPtr cdk_;
    ::google::protobuf::internal::ArenaStringPtr oldnickname_;
    ::int32_t gsid_;
    ::int32_t gcnetid_;
    ::uint64_t guid_;
    ::int32_t sdkid_;
    ::int32_t csid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class InsertUser final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.InsertUser) */ {
 public:
  inline InsertUser() : InsertUser(nullptr) {}
  ~InsertUser() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InsertUser(
      ::google::protobuf::internal::ConstantInitialized);

  inline InsertUser(const InsertUser& from) : InsertUser(nullptr, from) {}
  inline InsertUser(InsertUser&& from) noexcept
      : InsertUser(nullptr, std::move(from)) {}
  inline InsertUser& operator=(const InsertUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertUser& operator=(InsertUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertUser* internal_default_instance() {
    return reinterpret_cast<const InsertUser*>(
        &_InsertUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(InsertUser& a, InsertUser& b) { a.Swap(&b); }
  inline void Swap(InsertUser* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertUser* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertUser* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InsertUser>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InsertUser& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InsertUser& from) { InsertUser::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InsertUser* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.InsertUser"; }

 protected:
  explicit InsertUser(::google::protobuf::Arena* arena);
  InsertUser(::google::protobuf::Arena* arena, const InsertUser& from);
  InsertUser(::google::protobuf::Arena* arena, InsertUser&& from) noexcept
      : InsertUser(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlstrFieldNumber = 3,
    kGuidFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional string sqlstr = 3;
  bool has_sqlstr() const;
  void clear_sqlstr() ;
  const std::string& sqlstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sqlstr(Arg_&& arg, Args_... args);
  std::string* mutable_sqlstr();
  PROTOBUF_NODISCARD std::string* release_sqlstr();
  void set_allocated_sqlstr(std::string* value);

  private:
  const std::string& _internal_sqlstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sqlstr(
      const std::string& value);
  std::string* _internal_mutable_sqlstr();

  public:
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eInsertUser_DBCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.InsertUser)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sqlstr_;
    ::int64_t guid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class InsertNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.InsertNotice) */ {
 public:
  inline InsertNotice() : InsertNotice(nullptr) {}
  ~InsertNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InsertNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline InsertNotice(const InsertNotice& from) : InsertNotice(nullptr, from) {}
  inline InsertNotice(InsertNotice&& from) noexcept
      : InsertNotice(nullptr, std::move(from)) {}
  inline InsertNotice& operator=(const InsertNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertNotice& operator=(InsertNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertNotice* internal_default_instance() {
    return reinterpret_cast<const InsertNotice*>(
        &_InsertNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(InsertNotice& a, InsertNotice& b) { a.Swap(&b); }
  inline void Swap(InsertNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InsertNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InsertNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InsertNotice& from) { InsertNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InsertNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.InsertNotice"; }

 protected:
  explicit InsertNotice(::google::protobuf::Arena* arena);
  InsertNotice(::google::protobuf::Arena* arena, const InsertNotice& from);
  InsertNotice(::google::protobuf::Arena* arena, InsertNotice&& from) noexcept
      : InsertNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlStrFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional string sql_str = 2;
  bool has_sql_str() const;
  void clear_sql_str() ;
  const std::string& sql_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sql_str(Arg_&& arg, Args_... args);
  std::string* mutable_sql_str();
  PROTOBUF_NODISCARD std::string* release_sql_str();
  void set_allocated_sql_str(std::string* value);

  private:
  const std::string& _internal_sql_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql_str(
      const std::string& value);
  std::string* _internal_mutable_sql_str();

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eInsertNotice_DBCall];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.InsertNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sql_str_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class InsertCDKeyInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.InsertCDKeyInfo) */ {
 public:
  inline InsertCDKeyInfo() : InsertCDKeyInfo(nullptr) {}
  ~InsertCDKeyInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InsertCDKeyInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline InsertCDKeyInfo(const InsertCDKeyInfo& from) : InsertCDKeyInfo(nullptr, from) {}
  inline InsertCDKeyInfo(InsertCDKeyInfo&& from) noexcept
      : InsertCDKeyInfo(nullptr, std::move(from)) {}
  inline InsertCDKeyInfo& operator=(const InsertCDKeyInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertCDKeyInfo& operator=(InsertCDKeyInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertCDKeyInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertCDKeyInfo* internal_default_instance() {
    return reinterpret_cast<const InsertCDKeyInfo*>(
        &_InsertCDKeyInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(InsertCDKeyInfo& a, InsertCDKeyInfo& b) { a.Swap(&b); }
  inline void Swap(InsertCDKeyInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertCDKeyInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertCDKeyInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InsertCDKeyInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InsertCDKeyInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InsertCDKeyInfo& from) { InsertCDKeyInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InsertCDKeyInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.InsertCDKeyInfo"; }

 protected:
  explicit InsertCDKeyInfo(::google::protobuf::Arena* arena);
  InsertCDKeyInfo(::google::protobuf::Arena* arena, const InsertCDKeyInfo& from);
  InsertCDKeyInfo(::google::protobuf::Arena* arena, InsertCDKeyInfo&& from) noexcept
      : InsertCDKeyInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlStrFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string sql_str = 2;
  bool has_sql_str() const;
  void clear_sql_str() ;
  const std::string& sql_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sql_str(Arg_&& arg, Args_... args);
  std::string* mutable_sql_str();
  PROTOBUF_NODISCARD std::string* release_sql_str();
  void set_allocated_sql_str(std::string* value);

  private:
  const std::string& _internal_sql_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql_str(
      const std::string& value);
  std::string* _internal_mutable_sql_str();

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eInsertCDKeyInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.InsertCDKeyInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sql_str_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class GameMailInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.GameMailInfo) */ {
 public:
  inline GameMailInfo() : GameMailInfo(nullptr) {}
  ~GameMailInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameMailInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GameMailInfo(const GameMailInfo& from) : GameMailInfo(nullptr, from) {}
  inline GameMailInfo(GameMailInfo&& from) noexcept
      : GameMailInfo(nullptr, std::move(from)) {}
  inline GameMailInfo& operator=(const GameMailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMailInfo& operator=(GameMailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameMailInfo* internal_default_instance() {
    return reinterpret_cast<const GameMailInfo*>(
        &_GameMailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(GameMailInfo& a, GameMailInfo& b) { a.Swap(&b); }
  inline void Swap(GameMailInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMailInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMailInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GameMailInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameMailInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GameMailInfo& from) { GameMailInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameMailInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.GameMailInfo"; }

 protected:
  explicit GameMailInfo(::google::protobuf::Arena* arena);
  GameMailInfo(::google::protobuf::Arena* arena, const GameMailInfo& from);
  GameMailInfo(::google::protobuf::Arena* arena, GameMailInfo&& from) noexcept
      : GameMailInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTitleFieldNumber = 6,
    kContentFieldNumber = 7,
    kGiftstrFieldNumber = 8,
    kCreatetimeFieldNumber = 9,
    kOvertimeFieldNumber = 10,
    kSenderFieldNumber = 11,
    kTypeFieldNumber = 1,
    kMailIdFieldNumber = 2,
    kUseridFieldNumber = 3,
    kCurtstateFieldNumber = 4,
    kSdkidxFieldNumber = 5,
  };
  // optional string title = 6;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string content = 7;
  bool has_content() const;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // optional string giftstr = 8;
  bool has_giftstr() const;
  void clear_giftstr() ;
  const std::string& giftstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_giftstr(Arg_&& arg, Args_... args);
  std::string* mutable_giftstr();
  PROTOBUF_NODISCARD std::string* release_giftstr();
  void set_allocated_giftstr(std::string* value);

  private:
  const std::string& _internal_giftstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_giftstr(
      const std::string& value);
  std::string* _internal_mutable_giftstr();

  public:
  // optional string createtime = 9;
  bool has_createtime() const;
  void clear_createtime() ;
  const std::string& createtime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_createtime(Arg_&& arg, Args_... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* value);

  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(
      const std::string& value);
  std::string* _internal_mutable_createtime();

  public:
  // optional string overtime = 10;
  bool has_overtime() const;
  void clear_overtime() ;
  const std::string& overtime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_overtime(Arg_&& arg, Args_... args);
  std::string* mutable_overtime();
  PROTOBUF_NODISCARD std::string* release_overtime();
  void set_allocated_overtime(std::string* value);

  private:
  const std::string& _internal_overtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_overtime(
      const std::string& value);
  std::string* _internal_mutable_overtime();

  public:
  // optional string sender = 11;
  bool has_sender() const;
  void clear_sender() ;
  const std::string& sender() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* value);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // optional .CSToDB.MailType type = 1;
  bool has_type() const;
  void clear_type() ;
  ::CSToDB::MailType type() const;
  void set_type(::CSToDB::MailType value);

  private:
  ::CSToDB::MailType _internal_type() const;
  void _internal_set_type(::CSToDB::MailType value);

  public:
  // optional int32 mailId = 2;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional int64 userid = 3;
  bool has_userid() const;
  void clear_userid() ;
  ::int64_t userid() const;
  void set_userid(::int64_t value);

  private:
  ::int64_t _internal_userid() const;
  void _internal_set_userid(::int64_t value);

  public:
  // optional .CSToDB.EMailCurtState curtstate = 4;
  bool has_curtstate() const;
  void clear_curtstate() ;
  ::CSToDB::EMailCurtState curtstate() const;
  void set_curtstate(::CSToDB::EMailCurtState value);

  private:
  ::CSToDB::EMailCurtState _internal_curtstate() const;
  void _internal_set_curtstate(::CSToDB::EMailCurtState value);

  public:
  // optional int32 sdkidx = 5;
  bool has_sdkidx() const;
  void clear_sdkidx() ;
  ::int32_t sdkidx() const;
  void set_sdkidx(::int32_t value);

  private:
  ::int32_t _internal_sdkidx() const;
  void _internal_set_sdkidx(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.GameMailInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 2,
      79, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr giftstr_;
    ::google::protobuf::internal::ArenaStringPtr createtime_;
    ::google::protobuf::internal::ArenaStringPtr overtime_;
    ::google::protobuf::internal::ArenaStringPtr sender_;
    int type_;
    ::int32_t mailid_;
    ::int64_t userid_;
    int curtstate_;
    ::int32_t sdkidx_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class ExeSQL_Call final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.ExeSQL_Call) */ {
 public:
  inline ExeSQL_Call() : ExeSQL_Call(nullptr) {}
  ~ExeSQL_Call() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExeSQL_Call(
      ::google::protobuf::internal::ConstantInitialized);

  inline ExeSQL_Call(const ExeSQL_Call& from) : ExeSQL_Call(nullptr, from) {}
  inline ExeSQL_Call(ExeSQL_Call&& from) noexcept
      : ExeSQL_Call(nullptr, std::move(from)) {}
  inline ExeSQL_Call& operator=(const ExeSQL_Call& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExeSQL_Call& operator=(ExeSQL_Call&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExeSQL_Call& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExeSQL_Call* internal_default_instance() {
    return reinterpret_cast<const ExeSQL_Call*>(
        &_ExeSQL_Call_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(ExeSQL_Call& a, ExeSQL_Call& b) { a.Swap(&b); }
  inline void Swap(ExeSQL_Call* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExeSQL_Call* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExeSQL_Call* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ExeSQL_Call>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExeSQL_Call& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExeSQL_Call& from) { ExeSQL_Call::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExeSQL_Call* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.ExeSQL_Call"; }

 protected:
  explicit ExeSQL_Call(::google::protobuf::Arena* arena);
  ExeSQL_Call(::google::protobuf::Arena* arena, const ExeSQL_Call& from);
  ExeSQL_Call(::google::protobuf::Arena* arena, ExeSQL_Call&& from) noexcept
      : ExeSQL_Call(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string sql = 2;
  bool has_sql() const;
  void clear_sql() ;
  const std::string& sql() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sql(Arg_&& arg, Args_... args);
  std::string* mutable_sql();
  PROTOBUF_NODISCARD std::string* release_sql();
  void set_allocated_sql(std::string* value);

  private:
  const std::string& _internal_sql() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql(
      const std::string& value);
  std::string* _internal_mutable_sql();

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eExeSQL_Call];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.ExeSQL_Call)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sql_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class DeleteNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.DeleteNotice) */ {
 public:
  inline DeleteNotice() : DeleteNotice(nullptr) {}
  ~DeleteNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteNotice(const DeleteNotice& from) : DeleteNotice(nullptr, from) {}
  inline DeleteNotice(DeleteNotice&& from) noexcept
      : DeleteNotice(nullptr, std::move(from)) {}
  inline DeleteNotice& operator=(const DeleteNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteNotice& operator=(DeleteNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteNotice* internal_default_instance() {
    return reinterpret_cast<const DeleteNotice*>(
        &_DeleteNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(DeleteNotice& a, DeleteNotice& b) { a.Swap(&b); }
  inline void Swap(DeleteNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DeleteNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteNotice& from) { DeleteNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.DeleteNotice"; }

 protected:
  explicit DeleteNotice(::google::protobuf::Arena* arena);
  DeleteNotice(::google::protobuf::Arena* arena, const DeleteNotice& from);
  DeleteNotice(::google::protobuf::Arena* arena, DeleteNotice&& from) noexcept
      : DeleteNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional uint32 id = 2;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eDeleteNotice_DBCall];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.DeleteNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t id_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class CheckNameReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.CheckNameReq) */ {
 public:
  inline CheckNameReq() : CheckNameReq(nullptr) {}
  ~CheckNameReq() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckNameReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline CheckNameReq(const CheckNameReq& from) : CheckNameReq(nullptr, from) {}
  inline CheckNameReq(CheckNameReq&& from) noexcept
      : CheckNameReq(nullptr, std::move(from)) {}
  inline CheckNameReq& operator=(const CheckNameReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckNameReq& operator=(CheckNameReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckNameReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckNameReq* internal_default_instance() {
    return reinterpret_cast<const CheckNameReq*>(
        &_CheckNameReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(CheckNameReq& a, CheckNameReq& b) { a.Swap(&b); }
  inline void Swap(CheckNameReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckNameReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckNameReq* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CheckNameReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckNameReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckNameReq& from) { CheckNameReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckNameReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.CheckNameReq"; }

 protected:
  explicit CheckNameReq(::google::protobuf::Arena* arena);
  CheckNameReq(::google::protobuf::Arena* arena, const CheckNameReq& from);
  CheckNameReq(::google::protobuf::Arena* arena, CheckNameReq&& from) noexcept
      : CheckNameReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCdkFieldNumber = 7,
    kCompleteInfoFieldNumber = 8,
    kGsidFieldNumber = 2,
    kGcnetidFieldNumber = 3,
    kGsnetidFieldNumber = 4,
    kSdkidFieldNumber = 5,
    kCsidFieldNumber = 6,
    kMgsidFieldNumber = 1,
  };
  // optional string cdk = 7;
  bool has_cdk() const;
  void clear_cdk() ;
  const std::string& cdk() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cdk(Arg_&& arg, Args_... args);
  std::string* mutable_cdk();
  PROTOBUF_NODISCARD std::string* release_cdk();
  void set_allocated_cdk(std::string* value);

  private:
  const std::string& _internal_cdk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cdk(
      const std::string& value);
  std::string* _internal_mutable_cdk();

  public:
  // optional string completeInfo = 8;
  bool has_completeinfo() const;
  void clear_completeinfo() ;
  const std::string& completeinfo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_completeinfo(Arg_&& arg, Args_... args);
  std::string* mutable_completeinfo();
  PROTOBUF_NODISCARD std::string* release_completeinfo();
  void set_allocated_completeinfo(std::string* value);

  private:
  const std::string& _internal_completeinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completeinfo(
      const std::string& value);
  std::string* _internal_mutable_completeinfo();

  public:
  // optional int32 gsid = 2;
  bool has_gsid() const;
  void clear_gsid() ;
  ::int32_t gsid() const;
  void set_gsid(::int32_t value);

  private:
  ::int32_t _internal_gsid() const;
  void _internal_set_gsid(::int32_t value);

  public:
  // optional int32 gcnetid = 3;
  bool has_gcnetid() const;
  void clear_gcnetid() ;
  ::int32_t gcnetid() const;
  void set_gcnetid(::int32_t value);

  private:
  ::int32_t _internal_gcnetid() const;
  void _internal_set_gcnetid(::int32_t value);

  public:
  // optional int32 gsnetid = 4;
  bool has_gsnetid() const;
  void clear_gsnetid() ;
  ::int32_t gsnetid() const;
  void set_gsnetid(::int32_t value);

  private:
  ::int32_t _internal_gsnetid() const;
  void _internal_set_gsnetid(::int32_t value);

  public:
  // optional int32 sdkid = 5;
  bool has_sdkid() const;
  void clear_sdkid() ;
  ::int32_t sdkid() const;
  void set_sdkid(::int32_t value);

  private:
  ::int32_t _internal_sdkid() const;
  void _internal_set_sdkid(::int32_t value);

  public:
  // optional int32 csid = 6;
  bool has_csid() const;
  void clear_csid() ;
  ::int32_t csid() const;
  void set_csid(::int32_t value);

  private:
  ::int32_t _internal_csid() const;
  void _internal_set_csid(::int32_t value);

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eCheckNickNameDBCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.CheckNameReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 1,
      51, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr cdk_;
    ::google::protobuf::internal::ArenaStringPtr completeinfo_;
    ::int32_t gsid_;
    ::int32_t gcnetid_;
    ::int32_t gsnetid_;
    ::int32_t sdkid_;
    ::int32_t csid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class ChangeNickName final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.ChangeNickName) */ {
 public:
  inline ChangeNickName() : ChangeNickName(nullptr) {}
  ~ChangeNickName() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeNickName(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChangeNickName(const ChangeNickName& from) : ChangeNickName(nullptr, from) {}
  inline ChangeNickName(ChangeNickName&& from) noexcept
      : ChangeNickName(nullptr, std::move(from)) {}
  inline ChangeNickName& operator=(const ChangeNickName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeNickName& operator=(ChangeNickName&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeNickName& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeNickName* internal_default_instance() {
    return reinterpret_cast<const ChangeNickName*>(
        &_ChangeNickName_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(ChangeNickName& a, ChangeNickName& b) { a.Swap(&b); }
  inline void Swap(ChangeNickName* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeNickName* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeNickName* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChangeNickName>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangeNickName& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChangeNickName& from) { ChangeNickName::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangeNickName* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.ChangeNickName"; }

 protected:
  explicit ChangeNickName(::google::protobuf::Arena* arena);
  ChangeNickName(::google::protobuf::Arena* arena, const ChangeNickName& from);
  ChangeNickName(::google::protobuf::Arena* arena, ChangeNickName&& from) noexcept
      : ChangeNickName(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kGuidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional int64 guid = 3;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eChangeNickName_DBCall];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.ChangeNickName)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::int64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class CDKeyEvents final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.CDKeyEvents) */ {
 public:
  inline CDKeyEvents() : CDKeyEvents(nullptr) {}
  ~CDKeyEvents() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CDKeyEvents(
      ::google::protobuf::internal::ConstantInitialized);

  inline CDKeyEvents(const CDKeyEvents& from) : CDKeyEvents(nullptr, from) {}
  inline CDKeyEvents(CDKeyEvents&& from) noexcept
      : CDKeyEvents(nullptr, std::move(from)) {}
  inline CDKeyEvents& operator=(const CDKeyEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDKeyEvents& operator=(CDKeyEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDKeyEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDKeyEvents* internal_default_instance() {
    return reinterpret_cast<const CDKeyEvents*>(
        &_CDKeyEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(CDKeyEvents& a, CDKeyEvents& b) { a.Swap(&b); }
  inline void Swap(CDKeyEvents* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDKeyEvents* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDKeyEvents* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CDKeyEvents>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CDKeyEvents& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CDKeyEvents& from) { CDKeyEvents::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CDKeyEvents* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.CDKeyEvents"; }

 protected:
  explicit CDKeyEvents(::google::protobuf::Arena* arena);
  CDKeyEvents(::google::protobuf::Arena* arena, const CDKeyEvents& from);
  CDKeyEvents(::google::protobuf::Arena* arena, CDKeyEvents&& from) noexcept
      : CDKeyEvents(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlStrFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string sql_str = 2;
  bool has_sql_str() const;
  void clear_sql_str() ;
  const std::string& sql_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sql_str(Arg_&& arg, Args_... args);
  std::string* mutable_sql_str();
  PROTOBUF_NODISCARD std::string* release_sql_str();
  void set_allocated_sql_str(std::string* value);

  private:
  const std::string& _internal_sql_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql_str(
      const std::string& value);
  std::string* _internal_mutable_sql_str();

  public:
  // optional .CSToDB.MsgID msgid = 1 [default = eInsertCDKeyEvents];
  bool has_msgid() const;
  void clear_msgid() ;
  ::CSToDB::MsgID msgid() const;
  void set_msgid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_msgid() const;
  void _internal_set_msgid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.CDKeyEvents)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sql_str_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class BuyGoods final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.BuyGoods) */ {
 public:
  inline BuyGoods() : BuyGoods(nullptr) {}
  ~BuyGoods() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuyGoods(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuyGoods(const BuyGoods& from) : BuyGoods(nullptr, from) {}
  inline BuyGoods(BuyGoods&& from) noexcept
      : BuyGoods(nullptr, std::move(from)) {}
  inline BuyGoods& operator=(const BuyGoods& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyGoods& operator=(BuyGoods&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyGoods& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyGoods* internal_default_instance() {
    return reinterpret_cast<const BuyGoods*>(
        &_BuyGoods_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(BuyGoods& a, BuyGoods& b) { a.Swap(&b); }
  inline void Swap(BuyGoods* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyGoods* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyGoods* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BuyGoods>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuyGoods& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuyGoods& from) { BuyGoods::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuyGoods* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.BuyGoods"; }

 protected:
  explicit BuyGoods(::google::protobuf::Arena* arena);
  BuyGoods(::google::protobuf::Arena* arena, const BuyGoods& from);
  BuyGoods(::google::protobuf::Arena* arena, BuyGoods&& from) noexcept
      : BuyGoods(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBuygoodsmagFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional string buygoodsmag = 2;
  bool has_buygoodsmag() const;
  void clear_buygoodsmag() ;
  const std::string& buygoodsmag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_buygoodsmag(Arg_&& arg, Args_... args);
  std::string* mutable_buygoodsmag();
  PROTOBUF_NODISCARD std::string* release_buygoodsmag();
  void set_allocated_buygoodsmag(std::string* value);

  private:
  const std::string& _internal_buygoodsmag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buygoodsmag(
      const std::string& value);
  std::string* _internal_mutable_buygoodsmag();

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eBuyGoods_DBCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.BuyGoods)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr buygoodsmag_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class AlterSNSList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.AlterSNSList) */ {
 public:
  inline AlterSNSList() : AlterSNSList(nullptr) {}
  ~AlterSNSList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AlterSNSList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AlterSNSList(const AlterSNSList& from) : AlterSNSList(nullptr, from) {}
  inline AlterSNSList(AlterSNSList&& from) noexcept
      : AlterSNSList(nullptr, std::move(from)) {}
  inline AlterSNSList& operator=(const AlterSNSList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterSNSList& operator=(AlterSNSList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterSNSList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlterSNSList* internal_default_instance() {
    return reinterpret_cast<const AlterSNSList*>(
        &_AlterSNSList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(AlterSNSList& a, AlterSNSList& b) { a.Swap(&b); }
  inline void Swap(AlterSNSList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterSNSList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterSNSList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AlterSNSList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AlterSNSList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AlterSNSList& from) { AlterSNSList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AlterSNSList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.AlterSNSList"; }

 protected:
  explicit AlterSNSList(::google::protobuf::Arena* arena);
  AlterSNSList(::google::protobuf::Arena* arena, const AlterSNSList& from);
  AlterSNSList(::google::protobuf::Arena* arena, AlterSNSList&& from) noexcept
      : AlterSNSList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserIdFieldNumber = 2,
    kRelatedIdFieldNumber = 3,
    kRelatedFieldNumber = 4,
    kOprationFieldNumber = 5,
    kMgsidFieldNumber = 1,
  };
  // optional uint64 user_id = 2;
  bool has_user_id() const;
  void clear_user_id() ;
  ::uint64_t user_id() const;
  void set_user_id(::uint64_t value);

  private:
  ::uint64_t _internal_user_id() const;
  void _internal_set_user_id(::uint64_t value);

  public:
  // optional uint64 related_id = 3;
  bool has_related_id() const;
  void clear_related_id() ;
  ::uint64_t related_id() const;
  void set_related_id(::uint64_t value);

  private:
  ::uint64_t _internal_related_id() const;
  void _internal_set_related_id(::uint64_t value);

  public:
  // optional uint32 related = 4;
  bool has_related() const;
  void clear_related() ;
  ::uint32_t related() const;
  void set_related(::uint32_t value);

  private:
  ::uint32_t _internal_related() const;
  void _internal_set_related(::uint32_t value);

  public:
  // optional uint32 opration = 5;
  bool has_opration() const;
  void clear_opration() ;
  ::uint32_t opration() const;
  void set_opration(::uint32_t value);

  private:
  ::uint32_t _internal_opration() const;
  void _internal_set_opration(::uint32_t value);

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eAlterSNSList_DBCall];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.AlterSNSList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t user_id_;
    ::uint64_t related_id_;
    ::uint32_t related_;
    ::uint32_t opration_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class AlterItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.AlterItem) */ {
 public:
  inline AlterItem() : AlterItem(nullptr) {}
  ~AlterItem() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AlterItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline AlterItem(const AlterItem& from) : AlterItem(nullptr, from) {}
  inline AlterItem(AlterItem&& from) noexcept
      : AlterItem(nullptr, std::move(from)) {}
  inline AlterItem& operator=(const AlterItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlterItem& operator=(AlterItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlterItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlterItem* internal_default_instance() {
    return reinterpret_cast<const AlterItem*>(
        &_AlterItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(AlterItem& a, AlterItem& b) { a.Swap(&b); }
  inline void Swap(AlterItem* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlterItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlterItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AlterItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AlterItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AlterItem& from) { AlterItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AlterItem* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.AlterItem"; }

 protected:
  explicit AlterItem(::google::protobuf::Arena* arena);
  AlterItem(::google::protobuf::Arena* arena, const AlterItem& from);
  AlterItem(::google::protobuf::Arena* arena, AlterItem&& from) noexcept
      : AlterItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSqlStrFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional string sql_str = 2;
  bool has_sql_str() const;
  void clear_sql_str() ;
  const std::string& sql_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sql_str(Arg_&& arg, Args_... args);
  std::string* mutable_sql_str();
  PROTOBUF_NODISCARD std::string* release_sql_str();
  void set_allocated_sql_str(std::string* value);

  private:
  const std::string& _internal_sql_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sql_str(
      const std::string& value);
  std::string* _internal_mutable_sql_str();

  public:
  // optional .CSToDB.MsgID mgsid = 1 [default = eAlterItem_DBCall];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.AlterItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sql_str_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class UpdateGameMail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.UpdateGameMail) */ {
 public:
  inline UpdateGameMail() : UpdateGameMail(nullptr) {}
  ~UpdateGameMail() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateGameMail(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateGameMail(const UpdateGameMail& from) : UpdateGameMail(nullptr, from) {}
  inline UpdateGameMail(UpdateGameMail&& from) noexcept
      : UpdateGameMail(nullptr, std::move(from)) {}
  inline UpdateGameMail& operator=(const UpdateGameMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateGameMail& operator=(UpdateGameMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateGameMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateGameMail* internal_default_instance() {
    return reinterpret_cast<const UpdateGameMail*>(
        &_UpdateGameMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(UpdateGameMail& a, UpdateGameMail& b) { a.Swap(&b); }
  inline void Swap(UpdateGameMail* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateGameMail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateGameMail* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpdateGameMail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateGameMail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateGameMail& from) { UpdateGameMail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateGameMail* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.UpdateGameMail"; }

 protected:
  explicit UpdateGameMail(::google::protobuf::Arena* arena);
  UpdateGameMail(::google::protobuf::Arena* arena, const UpdateGameMail& from);
  UpdateGameMail(::google::protobuf::Arena* arena, UpdateGameMail&& from) noexcept
      : UpdateGameMail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMaillistFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // repeated .CSToDB.GameMailInfo maillist = 2;
  int maillist_size() const;
  private:
  int _internal_maillist_size() const;

  public:
  void clear_maillist() ;
  ::CSToDB::GameMailInfo* mutable_maillist(int index);
  ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>* mutable_maillist();

  private:
  const ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>& _internal_maillist() const;
  ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>* _internal_mutable_maillist();
  public:
  const ::CSToDB::GameMailInfo& maillist(int index) const;
  ::CSToDB::GameMailInfo* add_maillist();
  const ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>& maillist() const;
  // optional .CSToDB.MsgID mgsid = 1 [default = eUpdateGameMail_DBCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::CSToDB::MsgID mgsid() const;
  void set_mgsid(::CSToDB::MsgID value);

  private:
  ::CSToDB::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::CSToDB::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.UpdateGameMail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::CSToDB::GameMailInfo > maillist_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};
// -------------------------------------------------------------------

class StoreUserdata final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:CSToDB.StoreUserdata) */ {
 public:
  inline StoreUserdata() : StoreUserdata(nullptr) {}
  ~StoreUserdata() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StoreUserdata(
      ::google::protobuf::internal::ConstantInitialized);

  inline StoreUserdata(const StoreUserdata& from) : StoreUserdata(nullptr, from) {}
  inline StoreUserdata(StoreUserdata&& from) noexcept
      : StoreUserdata(nullptr, std::move(from)) {}
  inline StoreUserdata& operator=(const StoreUserdata& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreUserdata& operator=(StoreUserdata&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreUserdata& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreUserdata* internal_default_instance() {
    return reinterpret_cast<const StoreUserdata*>(
        &_StoreUserdata_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(StoreUserdata& a, StoreUserdata& b) { a.Swap(&b); }
  inline void Swap(StoreUserdata* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreUserdata* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreUserdata* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StoreUserdata>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StoreUserdata& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StoreUserdata& from) { StoreUserdata::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StoreUserdata* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "CSToDB.StoreUserdata"; }

 protected:
  explicit StoreUserdata(::google::protobuf::Arena* arena);
  StoreUserdata(::google::protobuf::Arena* arena, const StoreUserdata& from);
  StoreUserdata(::google::protobuf::Arena* arena, StoreUserdata&& from) noexcept
      : StoreUserdata(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using SUserHeroDBData = StoreUserdata_SUserHeroDBData;
  using SUserRelationshipInfo = StoreUserdata_SUserRelationshipInfo;
  using SUserItemInfo = StoreUserdata_SUserItemInfo;
  using UserMailDBData = StoreUserdata_UserMailDBData;

  // accessors -------------------------------------------------------
  enum : int {
    kSSUserHeroDBDataFieldNumber = 25,
    kFriendListFieldNumber = 26,
    kBlackListFieldNumber = 27,
    kItemlistFieldNumber = 28,
    kMailListFieldNumber = 29,
    kTLastGetLoginRewardFieldNumber = 21,
    kMGuideStepsFieldNumber = 24,
    kNicknameFieldNumber = 30,
    kUsernameFieldNumber = 31,
    kPwdFieldNumber = 32,
    kRunestrFieldNumber = 33,
    kSlotstrFieldNumber = 34,
    kUn64ObjIdxFieldNumber = 1,
    kEUserPlatformFieldNumber = 2,
    kUn32HeaderIDFieldNumber = 3,
    kN64DiamondFieldNumber = 5,
    kN64GoldFieldNumber = 6,
    kTRegisteUTCMillisecFieldNumber = 7,
    kN8SexFieldNumber = 4,
    kUn32TotalGameInnsFieldNumber = 11,
    kTLastLoginUTCMillisecFieldNumber = 8,
    kTLastLogOutUTCTimeFieldNumber = 9,
    kN64ScoreFieldNumber = 10,
    kUn32TotalWinInnsFieldNumber = 12,
    kUn32TotalHeroKillsFieldNumber = 13,
    kUn32TotalDestoryBuildingsFieldNumber = 14,
    kUn32TotalDeadTimesFieldNumber = 15,
    kUn32TotalAssistFieldNumber = 16,
    kUn16UserLvFieldNumber = 17,
    kTLastFirstWinTimeFieldNumber = 19,
    kUn32UserCurLvExpFieldNumber = 18,
    kUn16CldaysFieldNumber = 20,
    kUn16VipLvFieldNumber = 22,
    kVipScoreFieldNumber = 23,
  };
  // repeated .CSToDB.StoreUserdata.SUserHeroDBData sSUserHeroDBData = 25;
  int ssuserherodbdata_size() const;
  private:
  int _internal_ssuserherodbdata_size() const;

  public:
  void clear_ssuserherodbdata() ;
  ::CSToDB::StoreUserdata_SUserHeroDBData* mutable_ssuserherodbdata(int index);
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>* mutable_ssuserherodbdata();

  private:
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>& _internal_ssuserherodbdata() const;
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>* _internal_mutable_ssuserherodbdata();
  public:
  const ::CSToDB::StoreUserdata_SUserHeroDBData& ssuserherodbdata(int index) const;
  ::CSToDB::StoreUserdata_SUserHeroDBData* add_ssuserherodbdata();
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>& ssuserherodbdata() const;
  // repeated .CSToDB.StoreUserdata.SUserRelationshipInfo friendList = 26;
  int friendlist_size() const;
  private:
  int _internal_friendlist_size() const;

  public:
  void clear_friendlist() ;
  ::CSToDB::StoreUserdata_SUserRelationshipInfo* mutable_friendlist(int index);
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>* mutable_friendlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>& _internal_friendlist() const;
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>* _internal_mutable_friendlist();
  public:
  const ::CSToDB::StoreUserdata_SUserRelationshipInfo& friendlist(int index) const;
  ::CSToDB::StoreUserdata_SUserRelationshipInfo* add_friendlist();
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>& friendlist() const;
  // repeated .CSToDB.StoreUserdata.SUserRelationshipInfo blackList = 27;
  int blacklist_size() const;
  private:
  int _internal_blacklist_size() const;

  public:
  void clear_blacklist() ;
  ::CSToDB::StoreUserdata_SUserRelationshipInfo* mutable_blacklist(int index);
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>* mutable_blacklist();

  private:
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>& _internal_blacklist() const;
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>* _internal_mutable_blacklist();
  public:
  const ::CSToDB::StoreUserdata_SUserRelationshipInfo& blacklist(int index) const;
  ::CSToDB::StoreUserdata_SUserRelationshipInfo* add_blacklist();
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>& blacklist() const;
  // repeated .CSToDB.StoreUserdata.SUserItemInfo itemlist = 28;
  int itemlist_size() const;
  private:
  int _internal_itemlist_size() const;

  public:
  void clear_itemlist() ;
  ::CSToDB::StoreUserdata_SUserItemInfo* mutable_itemlist(int index);
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>* mutable_itemlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>& _internal_itemlist() const;
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>* _internal_mutable_itemlist();
  public:
  const ::CSToDB::StoreUserdata_SUserItemInfo& itemlist(int index) const;
  ::CSToDB::StoreUserdata_SUserItemInfo* add_itemlist();
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>& itemlist() const;
  // repeated .CSToDB.StoreUserdata.UserMailDBData mailList = 29;
  int maillist_size() const;
  private:
  int _internal_maillist_size() const;

  public:
  void clear_maillist() ;
  ::CSToDB::StoreUserdata_UserMailDBData* mutable_maillist(int index);
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>* mutable_maillist();

  private:
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>& _internal_maillist() const;
  ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>* _internal_mutable_maillist();
  public:
  const ::CSToDB::StoreUserdata_UserMailDBData& maillist(int index) const;
  ::CSToDB::StoreUserdata_UserMailDBData* add_maillist();
  const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>& maillist() const;
  // optional string tLastGetLoginReward = 21;
  bool has_tlastgetloginreward() const;
  void clear_tlastgetloginreward() ;
  const std::string& tlastgetloginreward() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tlastgetloginreward(Arg_&& arg, Args_... args);
  std::string* mutable_tlastgetloginreward();
  PROTOBUF_NODISCARD std::string* release_tlastgetloginreward();
  void set_allocated_tlastgetloginreward(std::string* value);

  private:
  const std::string& _internal_tlastgetloginreward() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tlastgetloginreward(
      const std::string& value);
  std::string* _internal_mutable_tlastgetloginreward();

  public:
  // optional string mGuideSteps = 24;
  bool has_mguidesteps() const;
  void clear_mguidesteps() ;
  const std::string& mguidesteps() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mguidesteps(Arg_&& arg, Args_... args);
  std::string* mutable_mguidesteps();
  PROTOBUF_NODISCARD std::string* release_mguidesteps();
  void set_allocated_mguidesteps(std::string* value);

  private:
  const std::string& _internal_mguidesteps() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mguidesteps(
      const std::string& value);
  std::string* _internal_mutable_mguidesteps();

  public:
  // optional string nickname = 30;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional string username = 31;
  bool has_username() const;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // optional string pwd = 32;
  bool has_pwd() const;
  void clear_pwd() ;
  const std::string& pwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pwd(Arg_&& arg, Args_... args);
  std::string* mutable_pwd();
  PROTOBUF_NODISCARD std::string* release_pwd();
  void set_allocated_pwd(std::string* value);

  private:
  const std::string& _internal_pwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pwd(
      const std::string& value);
  std::string* _internal_mutable_pwd();

  public:
  // optional string runestr = 33;
  bool has_runestr() const;
  void clear_runestr() ;
  const std::string& runestr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_runestr(Arg_&& arg, Args_... args);
  std::string* mutable_runestr();
  PROTOBUF_NODISCARD std::string* release_runestr();
  void set_allocated_runestr(std::string* value);

  private:
  const std::string& _internal_runestr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_runestr(
      const std::string& value);
  std::string* _internal_mutable_runestr();

  public:
  // optional string slotstr = 34;
  bool has_slotstr() const;
  void clear_slotstr() ;
  const std::string& slotstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_slotstr(Arg_&& arg, Args_... args);
  std::string* mutable_slotstr();
  PROTOBUF_NODISCARD std::string* release_slotstr();
  void set_allocated_slotstr(std::string* value);

  private:
  const std::string& _internal_slotstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slotstr(
      const std::string& value);
  std::string* _internal_mutable_slotstr();

  public:
  // optional int64 un64ObjIdx = 1;
  bool has_un64objidx() const;
  void clear_un64objidx() ;
  ::int64_t un64objidx() const;
  void set_un64objidx(::int64_t value);

  private:
  ::int64_t _internal_un64objidx() const;
  void _internal_set_un64objidx(::int64_t value);

  public:
  // optional int32 eUserPlatform = 2;
  bool has_euserplatform() const;
  void clear_euserplatform() ;
  ::int32_t euserplatform() const;
  void set_euserplatform(::int32_t value);

  private:
  ::int32_t _internal_euserplatform() const;
  void _internal_set_euserplatform(::int32_t value);

  public:
  // optional int32 un32HeaderID = 3;
  bool has_un32headerid() const;
  void clear_un32headerid() ;
  ::int32_t un32headerid() const;
  void set_un32headerid(::int32_t value);

  private:
  ::int32_t _internal_un32headerid() const;
  void _internal_set_un32headerid(::int32_t value);

  public:
  // optional int64 n64Diamond = 5;
  bool has_n64diamond() const;
  void clear_n64diamond() ;
  ::int64_t n64diamond() const;
  void set_n64diamond(::int64_t value);

  private:
  ::int64_t _internal_n64diamond() const;
  void _internal_set_n64diamond(::int64_t value);

  public:
  // optional int64 n64Gold = 6;
  bool has_n64gold() const;
  void clear_n64gold() ;
  ::int64_t n64gold() const;
  void set_n64gold(::int64_t value);

  private:
  ::int64_t _internal_n64gold() const;
  void _internal_set_n64gold(::int64_t value);

  public:
  // optional int64 tRegisteUTCMillisec = 7;
  bool has_tregisteutcmillisec() const;
  void clear_tregisteutcmillisec() ;
  ::int64_t tregisteutcmillisec() const;
  void set_tregisteutcmillisec(::int64_t value);

  private:
  ::int64_t _internal_tregisteutcmillisec() const;
  void _internal_set_tregisteutcmillisec(::int64_t value);

  public:
  // optional int32 n8Sex = 4;
  bool has_n8sex() const;
  void clear_n8sex() ;
  ::int32_t n8sex() const;
  void set_n8sex(::int32_t value);

  private:
  ::int32_t _internal_n8sex() const;
  void _internal_set_n8sex(::int32_t value);

  public:
  // optional int32 un32TotalGameInns = 11;
  bool has_un32totalgameinns() const;
  void clear_un32totalgameinns() ;
  ::int32_t un32totalgameinns() const;
  void set_un32totalgameinns(::int32_t value);

  private:
  ::int32_t _internal_un32totalgameinns() const;
  void _internal_set_un32totalgameinns(::int32_t value);

  public:
  // optional int64 tLastLoginUTCMillisec = 8;
  bool has_tlastloginutcmillisec() const;
  void clear_tlastloginutcmillisec() ;
  ::int64_t tlastloginutcmillisec() const;
  void set_tlastloginutcmillisec(::int64_t value);

  private:
  ::int64_t _internal_tlastloginutcmillisec() const;
  void _internal_set_tlastloginutcmillisec(::int64_t value);

  public:
  // optional int64 tLastLogOutUTCTime = 9;
  bool has_tlastlogoututctime() const;
  void clear_tlastlogoututctime() ;
  ::int64_t tlastlogoututctime() const;
  void set_tlastlogoututctime(::int64_t value);

  private:
  ::int64_t _internal_tlastlogoututctime() const;
  void _internal_set_tlastlogoututctime(::int64_t value);

  public:
  // optional int64 n64Score = 10;
  bool has_n64score() const;
  void clear_n64score() ;
  ::int64_t n64score() const;
  void set_n64score(::int64_t value);

  private:
  ::int64_t _internal_n64score() const;
  void _internal_set_n64score(::int64_t value);

  public:
  // optional int32 un32TotalWinInns = 12;
  bool has_un32totalwininns() const;
  void clear_un32totalwininns() ;
  ::int32_t un32totalwininns() const;
  void set_un32totalwininns(::int32_t value);

  private:
  ::int32_t _internal_un32totalwininns() const;
  void _internal_set_un32totalwininns(::int32_t value);

  public:
  // optional int32 un32TotalHeroKills = 13;
  bool has_un32totalherokills() const;
  void clear_un32totalherokills() ;
  ::int32_t un32totalherokills() const;
  void set_un32totalherokills(::int32_t value);

  private:
  ::int32_t _internal_un32totalherokills() const;
  void _internal_set_un32totalherokills(::int32_t value);

  public:
  // optional int32 un32TotalDestoryBuildings = 14;
  bool has_un32totaldestorybuildings() const;
  void clear_un32totaldestorybuildings() ;
  ::int32_t un32totaldestorybuildings() const;
  void set_un32totaldestorybuildings(::int32_t value);

  private:
  ::int32_t _internal_un32totaldestorybuildings() const;
  void _internal_set_un32totaldestorybuildings(::int32_t value);

  public:
  // optional int32 un32TotalDeadTimes = 15;
  bool has_un32totaldeadtimes() const;
  void clear_un32totaldeadtimes() ;
  ::int32_t un32totaldeadtimes() const;
  void set_un32totaldeadtimes(::int32_t value);

  private:
  ::int32_t _internal_un32totaldeadtimes() const;
  void _internal_set_un32totaldeadtimes(::int32_t value);

  public:
  // optional int32 un32TotalAssist = 16;
  bool has_un32totalassist() const;
  void clear_un32totalassist() ;
  ::int32_t un32totalassist() const;
  void set_un32totalassist(::int32_t value);

  private:
  ::int32_t _internal_un32totalassist() const;
  void _internal_set_un32totalassist(::int32_t value);

  public:
  // optional int32 un16UserLv = 17;
  bool has_un16userlv() const;
  void clear_un16userlv() ;
  ::int32_t un16userlv() const;
  void set_un16userlv(::int32_t value);

  private:
  ::int32_t _internal_un16userlv() const;
  void _internal_set_un16userlv(::int32_t value);

  public:
  // optional int64 tLastFirstWinTime = 19;
  bool has_tlastfirstwintime() const;
  void clear_tlastfirstwintime() ;
  ::int64_t tlastfirstwintime() const;
  void set_tlastfirstwintime(::int64_t value);

  private:
  ::int64_t _internal_tlastfirstwintime() const;
  void _internal_set_tlastfirstwintime(::int64_t value);

  public:
  // optional int32 un32UserCurLvExp = 18;
  bool has_un32usercurlvexp() const;
  void clear_un32usercurlvexp() ;
  ::int32_t un32usercurlvexp() const;
  void set_un32usercurlvexp(::int32_t value);

  private:
  ::int32_t _internal_un32usercurlvexp() const;
  void _internal_set_un32usercurlvexp(::int32_t value);

  public:
  // optional int32 un16Cldays = 20;
  bool has_un16cldays() const;
  void clear_un16cldays() ;
  ::int32_t un16cldays() const;
  void set_un16cldays(::int32_t value);

  private:
  ::int32_t _internal_un16cldays() const;
  void _internal_set_un16cldays(::int32_t value);

  public:
  // optional int32 un16VipLv = 22;
  bool has_un16viplv() const;
  void clear_un16viplv() ;
  ::int32_t un16viplv() const;
  void set_un16viplv(::int32_t value);

  private:
  ::int32_t _internal_un16viplv() const;
  void _internal_set_un16viplv(::int32_t value);

  public:
  // optional int32 vipScore = 23;
  bool has_vipscore() const;
  void clear_vipscore() ;
  ::int32_t vipscore() const;
  void set_vipscore(::int32_t value);

  private:
  ::int32_t _internal_vipscore() const;
  void _internal_set_vipscore(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:CSToDB.StoreUserdata)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 34, 5,
      124, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::CSToDB::StoreUserdata_SUserHeroDBData > ssuserherodbdata_;
    ::google::protobuf::RepeatedPtrField< ::CSToDB::StoreUserdata_SUserRelationshipInfo > friendlist_;
    ::google::protobuf::RepeatedPtrField< ::CSToDB::StoreUserdata_SUserRelationshipInfo > blacklist_;
    ::google::protobuf::RepeatedPtrField< ::CSToDB::StoreUserdata_SUserItemInfo > itemlist_;
    ::google::protobuf::RepeatedPtrField< ::CSToDB::StoreUserdata_UserMailDBData > maillist_;
    ::google::protobuf::internal::ArenaStringPtr tlastgetloginreward_;
    ::google::protobuf::internal::ArenaStringPtr mguidesteps_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr pwd_;
    ::google::protobuf::internal::ArenaStringPtr runestr_;
    ::google::protobuf::internal::ArenaStringPtr slotstr_;
    ::int64_t un64objidx_;
    ::int32_t euserplatform_;
    ::int32_t un32headerid_;
    ::int64_t n64diamond_;
    ::int64_t n64gold_;
    ::int64_t tregisteutcmillisec_;
    ::int32_t n8sex_;
    ::int32_t un32totalgameinns_;
    ::int64_t tlastloginutcmillisec_;
    ::int64_t tlastlogoututctime_;
    ::int64_t n64score_;
    ::int32_t un32totalwininns_;
    ::int32_t un32totalherokills_;
    ::int32_t un32totaldestorybuildings_;
    ::int32_t un32totaldeadtimes_;
    ::int32_t un32totalassist_;
    ::int32_t un16userlv_;
    ::int64_t tlastfirstwintime_;
    ::int32_t un32usercurlvexp_;
    ::int32_t un16cldays_;
    ::int32_t un16viplv_;
    ::int32_t vipscore_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CSToDB_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// UpdateCDKeyInfo

// optional .CSToDB.MsgID msgid = 1 [default = eUpdateCDKeyInfo];
inline bool UpdateCDKeyInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UpdateCDKeyInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 120;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID UpdateCDKeyInfo::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateCDKeyInfo.msgid)
  return _internal_msgid();
}
inline void UpdateCDKeyInfo::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateCDKeyInfo.msgid)
}
inline ::CSToDB::MsgID UpdateCDKeyInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void UpdateCDKeyInfo::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string sql_str = 2;
inline bool UpdateCDKeyInfo::has_sql_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UpdateCDKeyInfo::clear_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sql_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateCDKeyInfo::sql_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateCDKeyInfo.sql_str)
  return _internal_sql_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateCDKeyInfo::set_sql_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.UpdateCDKeyInfo.sql_str)
}
inline std::string* UpdateCDKeyInfo::mutable_sql_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sql_str();
  // @@protoc_insertion_point(field_mutable:CSToDB.UpdateCDKeyInfo.sql_str)
  return _s;
}
inline const std::string& UpdateCDKeyInfo::_internal_sql_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sql_str_.Get();
}
inline void UpdateCDKeyInfo::_internal_set_sql_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(value, GetArena());
}
inline std::string* UpdateCDKeyInfo::_internal_mutable_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sql_str_.Mutable( GetArena());
}
inline std::string* UpdateCDKeyInfo::release_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.UpdateCDKeyInfo.sql_str)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sql_str_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_str_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UpdateCDKeyInfo::set_allocated_sql_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sql_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sql_str_.IsDefault()) {
          _impl_.sql_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.UpdateCDKeyInfo.sql_str)
}

// -------------------------------------------------------------------

// InsertCDKeyInfo

// optional .CSToDB.MsgID msgid = 1 [default = eInsertCDKeyInfo];
inline bool InsertCDKeyInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InsertCDKeyInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 119;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID InsertCDKeyInfo::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.InsertCDKeyInfo.msgid)
  return _internal_msgid();
}
inline void InsertCDKeyInfo::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.InsertCDKeyInfo.msgid)
}
inline ::CSToDB::MsgID InsertCDKeyInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void InsertCDKeyInfo::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string sql_str = 2;
inline bool InsertCDKeyInfo::has_sql_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InsertCDKeyInfo::clear_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sql_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InsertCDKeyInfo::sql_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.InsertCDKeyInfo.sql_str)
  return _internal_sql_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsertCDKeyInfo::set_sql_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.InsertCDKeyInfo.sql_str)
}
inline std::string* InsertCDKeyInfo::mutable_sql_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sql_str();
  // @@protoc_insertion_point(field_mutable:CSToDB.InsertCDKeyInfo.sql_str)
  return _s;
}
inline const std::string& InsertCDKeyInfo::_internal_sql_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sql_str_.Get();
}
inline void InsertCDKeyInfo::_internal_set_sql_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(value, GetArena());
}
inline std::string* InsertCDKeyInfo::_internal_mutable_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sql_str_.Mutable( GetArena());
}
inline std::string* InsertCDKeyInfo::release_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.InsertCDKeyInfo.sql_str)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sql_str_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_str_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InsertCDKeyInfo::set_allocated_sql_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sql_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sql_str_.IsDefault()) {
          _impl_.sql_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.InsertCDKeyInfo.sql_str)
}

// -------------------------------------------------------------------

// CDKeyEvents

// optional .CSToDB.MsgID msgid = 1 [default = eInsertCDKeyEvents];
inline bool CDKeyEvents::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CDKeyEvents::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 118;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID CDKeyEvents::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.CDKeyEvents.msgid)
  return _internal_msgid();
}
inline void CDKeyEvents::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.CDKeyEvents.msgid)
}
inline ::CSToDB::MsgID CDKeyEvents::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void CDKeyEvents::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string sql_str = 2;
inline bool CDKeyEvents::has_sql_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CDKeyEvents::clear_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sql_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CDKeyEvents::sql_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.CDKeyEvents.sql_str)
  return _internal_sql_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CDKeyEvents::set_sql_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.CDKeyEvents.sql_str)
}
inline std::string* CDKeyEvents::mutable_sql_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sql_str();
  // @@protoc_insertion_point(field_mutable:CSToDB.CDKeyEvents.sql_str)
  return _s;
}
inline const std::string& CDKeyEvents::_internal_sql_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sql_str_.Get();
}
inline void CDKeyEvents::_internal_set_sql_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(value, GetArena());
}
inline std::string* CDKeyEvents::_internal_mutable_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sql_str_.Mutable( GetArena());
}
inline std::string* CDKeyEvents::release_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.CDKeyEvents.sql_str)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sql_str_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_str_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CDKeyEvents::set_allocated_sql_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sql_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sql_str_.IsDefault()) {
          _impl_.sql_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.CDKeyEvents.sql_str)
}

// -------------------------------------------------------------------

// UpdateUserMail

// optional .CSToDB.MsgID msgid = 1 [default = eUpdateUserGameMail_DBCallBack];
inline bool UpdateUserMail::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UpdateUserMail::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 117;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::CSToDB::MsgID UpdateUserMail::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateUserMail.msgid)
  return _internal_msgid();
}
inline void UpdateUserMail::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateUserMail.msgid)
}
inline ::CSToDB::MsgID UpdateUserMail::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void UpdateUserMail::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 objid = 2;
inline bool UpdateUserMail::has_objid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UpdateUserMail::clear_objid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t UpdateUserMail::objid() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateUserMail.objid)
  return _internal_objid();
}
inline void UpdateUserMail::set_objid(::int64_t value) {
  _internal_set_objid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateUserMail.objid)
}
inline ::int64_t UpdateUserMail::_internal_objid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objid_;
}
inline void UpdateUserMail::_internal_set_objid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objid_ = value;
}

// optional int32 mailid = 3;
inline bool UpdateUserMail::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UpdateUserMail::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t UpdateUserMail::mailid() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateUserMail.mailid)
  return _internal_mailid();
}
inline void UpdateUserMail::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateUserMail.mailid)
}
inline ::int32_t UpdateUserMail::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void UpdateUserMail::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional int32 cstate = 4;
inline bool UpdateUserMail::has_cstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UpdateUserMail::clear_cstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t UpdateUserMail::cstate() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateUserMail.cstate)
  return _internal_cstate();
}
inline void UpdateUserMail::set_cstate(::int32_t value) {
  _internal_set_cstate(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateUserMail.cstate)
}
inline ::int32_t UpdateUserMail::_internal_cstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cstate_;
}
inline void UpdateUserMail::_internal_set_cstate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cstate_ = value;
}

// -------------------------------------------------------------------

// StoreUserdata_SUserHeroDBData

// optional int32 un32HeroID = 1;
inline bool StoreUserdata_SUserHeroDBData::has_un32heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StoreUserdata_SUserHeroDBData::clear_un32heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t StoreUserdata_SUserHeroDBData::un32heroid() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserHeroDBData.un32HeroID)
  return _internal_un32heroid();
}
inline void StoreUserdata_SUserHeroDBData::set_un32heroid(::int32_t value) {
  _internal_set_un32heroid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserHeroDBData.un32HeroID)
}
inline ::int32_t StoreUserdata_SUserHeroDBData::_internal_un32heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32heroid_;
}
inline void StoreUserdata_SUserHeroDBData::_internal_set_un32heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32heroid_ = value;
}

// optional int64 endTime = 2;
inline bool StoreUserdata_SUserHeroDBData::has_endtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StoreUserdata_SUserHeroDBData::clear_endtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endtime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t StoreUserdata_SUserHeroDBData::endtime() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserHeroDBData.endTime)
  return _internal_endtime();
}
inline void StoreUserdata_SUserHeroDBData::set_endtime(::int64_t value) {
  _internal_set_endtime(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserHeroDBData.endTime)
}
inline ::int64_t StoreUserdata_SUserHeroDBData::_internal_endtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.endtime_;
}
inline void StoreUserdata_SUserHeroDBData::_internal_set_endtime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.endtime_ = value;
}

// optional int64 buyTime = 3;
inline bool StoreUserdata_SUserHeroDBData::has_buytime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StoreUserdata_SUserHeroDBData::clear_buytime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buytime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t StoreUserdata_SUserHeroDBData::buytime() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserHeroDBData.buyTime)
  return _internal_buytime();
}
inline void StoreUserdata_SUserHeroDBData::set_buytime(::int64_t value) {
  _internal_set_buytime(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserHeroDBData.buyTime)
}
inline ::int64_t StoreUserdata_SUserHeroDBData::_internal_buytime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buytime_;
}
inline void StoreUserdata_SUserHeroDBData::_internal_set_buytime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buytime_ = value;
}

// -------------------------------------------------------------------

// StoreUserdata_SUserRelationshipInfo

// optional string stNickName = 1;
inline bool StoreUserdata_SUserRelationshipInfo::has_stnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StoreUserdata_SUserRelationshipInfo::clear_stnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreUserdata_SUserRelationshipInfo::stnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserRelationshipInfo.stNickName)
  return _internal_stnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata_SUserRelationshipInfo::set_stnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserRelationshipInfo.stNickName)
}
inline std::string* StoreUserdata_SUserRelationshipInfo::mutable_stnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_stnickname();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.SUserRelationshipInfo.stNickName)
  return _s;
}
inline const std::string& StoreUserdata_SUserRelationshipInfo::_internal_stnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stnickname_.Get();
}
inline void StoreUserdata_SUserRelationshipInfo::_internal_set_stnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.stnickname_.Set(value, GetArena());
}
inline std::string* StoreUserdata_SUserRelationshipInfo::_internal_mutable_stnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.stnickname_.Mutable( GetArena());
}
inline std::string* StoreUserdata_SUserRelationshipInfo::release_stnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.SUserRelationshipInfo.stNickName)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.stnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.stnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata_SUserRelationshipInfo::set_allocated_stnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.stnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.stnickname_.IsDefault()) {
          _impl_.stnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.SUserRelationshipInfo.stNickName)
}

// optional int32 nHeadId = 2;
inline bool StoreUserdata_SUserRelationshipInfo::has_nheadid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StoreUserdata_SUserRelationshipInfo::clear_nheadid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nheadid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t StoreUserdata_SUserRelationshipInfo::nheadid() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserRelationshipInfo.nHeadId)
  return _internal_nheadid();
}
inline void StoreUserdata_SUserRelationshipInfo::set_nheadid(::int32_t value) {
  _internal_set_nheadid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserRelationshipInfo.nHeadId)
}
inline ::int32_t StoreUserdata_SUserRelationshipInfo::_internal_nheadid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nheadid_;
}
inline void StoreUserdata_SUserRelationshipInfo::_internal_set_nheadid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nheadid_ = value;
}

// optional int64 guididx = 3;
inline bool StoreUserdata_SUserRelationshipInfo::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StoreUserdata_SUserRelationshipInfo::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t StoreUserdata_SUserRelationshipInfo::guididx() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserRelationshipInfo.guididx)
  return _internal_guididx();
}
inline void StoreUserdata_SUserRelationshipInfo::set_guididx(::int64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserRelationshipInfo.guididx)
}
inline ::int64_t StoreUserdata_SUserRelationshipInfo::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void StoreUserdata_SUserRelationshipInfo::_internal_set_guididx(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// optional int32 eRelationShip = 4;
inline bool StoreUserdata_SUserRelationshipInfo::has_erelationship() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StoreUserdata_SUserRelationshipInfo::clear_erelationship() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.erelationship_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t StoreUserdata_SUserRelationshipInfo::erelationship() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserRelationshipInfo.eRelationShip)
  return _internal_erelationship();
}
inline void StoreUserdata_SUserRelationshipInfo::set_erelationship(::int32_t value) {
  _internal_set_erelationship(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserRelationshipInfo.eRelationShip)
}
inline ::int32_t StoreUserdata_SUserRelationshipInfo::_internal_erelationship() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.erelationship_;
}
inline void StoreUserdata_SUserRelationshipInfo::_internal_set_erelationship(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.erelationship_ = value;
}

// optional int64 tMilSec = 5;
inline bool StoreUserdata_SUserRelationshipInfo::has_tmilsec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StoreUserdata_SUserRelationshipInfo::clear_tmilsec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tmilsec_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t StoreUserdata_SUserRelationshipInfo::tmilsec() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserRelationshipInfo.tMilSec)
  return _internal_tmilsec();
}
inline void StoreUserdata_SUserRelationshipInfo::set_tmilsec(::int64_t value) {
  _internal_set_tmilsec(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserRelationshipInfo.tMilSec)
}
inline ::int64_t StoreUserdata_SUserRelationshipInfo::_internal_tmilsec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tmilsec_;
}
inline void StoreUserdata_SUserRelationshipInfo::_internal_set_tmilsec(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tmilsec_ = value;
}

// -------------------------------------------------------------------

// StoreUserdata_SUserItemInfo

// optional int32 item_id = 1;
inline bool StoreUserdata_SUserItemInfo::has_item_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StoreUserdata_SUserItemInfo::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t StoreUserdata_SUserItemInfo::item_id() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserItemInfo.item_id)
  return _internal_item_id();
}
inline void StoreUserdata_SUserItemInfo::set_item_id(::int32_t value) {
  _internal_set_item_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserItemInfo.item_id)
}
inline ::int32_t StoreUserdata_SUserItemInfo::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_;
}
inline void StoreUserdata_SUserItemInfo::_internal_set_item_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = value;
}

// optional bool ifusing = 2;
inline bool StoreUserdata_SUserItemInfo::has_ifusing() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StoreUserdata_SUserItemInfo::clear_ifusing() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifusing_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool StoreUserdata_SUserItemInfo::ifusing() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserItemInfo.ifusing)
  return _internal_ifusing();
}
inline void StoreUserdata_SUserItemInfo::set_ifusing(bool value) {
  _internal_set_ifusing(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserItemInfo.ifusing)
}
inline bool StoreUserdata_SUserItemInfo::_internal_ifusing() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifusing_;
}
inline void StoreUserdata_SUserItemInfo::_internal_set_ifusing(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifusing_ = value;
}

// optional int32 item_num = 3;
inline bool StoreUserdata_SUserItemInfo::has_item_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StoreUserdata_SUserItemInfo::clear_item_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t StoreUserdata_SUserItemInfo::item_num() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserItemInfo.item_num)
  return _internal_item_num();
}
inline void StoreUserdata_SUserItemInfo::set_item_num(::int32_t value) {
  _internal_set_item_num(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserItemInfo.item_num)
}
inline ::int32_t StoreUserdata_SUserItemInfo::_internal_item_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_num_;
}
inline void StoreUserdata_SUserItemInfo::_internal_set_item_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = value;
}

// optional int64 buy_time = 4;
inline bool StoreUserdata_SUserItemInfo::has_buy_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StoreUserdata_SUserItemInfo::clear_buy_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buy_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t StoreUserdata_SUserItemInfo::buy_time() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserItemInfo.buy_time)
  return _internal_buy_time();
}
inline void StoreUserdata_SUserItemInfo::set_buy_time(::int64_t value) {
  _internal_set_buy_time(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserItemInfo.buy_time)
}
inline ::int64_t StoreUserdata_SUserItemInfo::_internal_buy_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buy_time_;
}
inline void StoreUserdata_SUserItemInfo::_internal_set_buy_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buy_time_ = value;
}

// optional int64 end_time = 6;
inline bool StoreUserdata_SUserItemInfo::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void StoreUserdata_SUserItemInfo::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t StoreUserdata_SUserItemInfo::end_time() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserItemInfo.end_time)
  return _internal_end_time();
}
inline void StoreUserdata_SUserItemInfo::set_end_time(::int64_t value) {
  _internal_set_end_time(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserItemInfo.end_time)
}
inline ::int64_t StoreUserdata_SUserItemInfo::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void StoreUserdata_SUserItemInfo::_internal_set_end_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = value;
}

// optional int32 n32EffectValue = 7;
inline bool StoreUserdata_SUserItemInfo::has_n32effectvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StoreUserdata_SUserItemInfo::clear_n32effectvalue() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n32effectvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t StoreUserdata_SUserItemInfo::n32effectvalue() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserItemInfo.n32EffectValue)
  return _internal_n32effectvalue();
}
inline void StoreUserdata_SUserItemInfo::set_n32effectvalue(::int32_t value) {
  _internal_set_n32effectvalue(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserItemInfo.n32EffectValue)
}
inline ::int32_t StoreUserdata_SUserItemInfo::_internal_n32effectvalue() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.n32effectvalue_;
}
inline void StoreUserdata_SUserItemInfo::_internal_set_n32effectvalue(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n32effectvalue_ = value;
}

// optional int32 n32EffectID = 8;
inline bool StoreUserdata_SUserItemInfo::has_n32effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void StoreUserdata_SUserItemInfo::clear_n32effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n32effectid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t StoreUserdata_SUserItemInfo::n32effectid() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.SUserItemInfo.n32EffectID)
  return _internal_n32effectid();
}
inline void StoreUserdata_SUserItemInfo::set_n32effectid(::int32_t value) {
  _internal_set_n32effectid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.SUserItemInfo.n32EffectID)
}
inline ::int32_t StoreUserdata_SUserItemInfo::_internal_n32effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.n32effectid_;
}
inline void StoreUserdata_SUserItemInfo::_internal_set_n32effectid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n32effectid_ = value;
}

// -------------------------------------------------------------------

// StoreUserdata_UserMailDBData

// optional int32 mailId = 1;
inline bool StoreUserdata_UserMailDBData::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StoreUserdata_UserMailDBData::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t StoreUserdata_UserMailDBData::mailid() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.UserMailDBData.mailId)
  return _internal_mailid();
}
inline void StoreUserdata_UserMailDBData::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.UserMailDBData.mailId)
}
inline ::int32_t StoreUserdata_UserMailDBData::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void StoreUserdata_UserMailDBData::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional int32 mState = 2;
inline bool StoreUserdata_UserMailDBData::has_mstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StoreUserdata_UserMailDBData::clear_mstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t StoreUserdata_UserMailDBData::mstate() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.UserMailDBData.mState)
  return _internal_mstate();
}
inline void StoreUserdata_UserMailDBData::set_mstate(::int32_t value) {
  _internal_set_mstate(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.UserMailDBData.mState)
}
inline ::int32_t StoreUserdata_UserMailDBData::_internal_mstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mstate_;
}
inline void StoreUserdata_UserMailDBData::_internal_set_mstate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mstate_ = value;
}

// -------------------------------------------------------------------

// StoreUserdata

// optional int64 un64ObjIdx = 1;
inline bool StoreUserdata::has_un64objidx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void StoreUserdata::clear_un64objidx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un64objidx_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t StoreUserdata::un64objidx() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un64ObjIdx)
  return _internal_un64objidx();
}
inline void StoreUserdata::set_un64objidx(::int64_t value) {
  _internal_set_un64objidx(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un64ObjIdx)
}
inline ::int64_t StoreUserdata::_internal_un64objidx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un64objidx_;
}
inline void StoreUserdata::_internal_set_un64objidx(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un64objidx_ = value;
}

// optional int32 eUserPlatform = 2;
inline bool StoreUserdata::has_euserplatform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void StoreUserdata::clear_euserplatform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.euserplatform_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t StoreUserdata::euserplatform() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.eUserPlatform)
  return _internal_euserplatform();
}
inline void StoreUserdata::set_euserplatform(::int32_t value) {
  _internal_set_euserplatform(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.eUserPlatform)
}
inline ::int32_t StoreUserdata::_internal_euserplatform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.euserplatform_;
}
inline void StoreUserdata::_internal_set_euserplatform(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.euserplatform_ = value;
}

// optional int32 un32HeaderID = 3;
inline bool StoreUserdata::has_un32headerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32headerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32headerid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t StoreUserdata::un32headerid() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32HeaderID)
  return _internal_un32headerid();
}
inline void StoreUserdata::set_un32headerid(::int32_t value) {
  _internal_set_un32headerid(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32HeaderID)
}
inline ::int32_t StoreUserdata::_internal_un32headerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32headerid_;
}
inline void StoreUserdata::_internal_set_un32headerid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32headerid_ = value;
}

// optional int32 n8Sex = 4;
inline bool StoreUserdata::has_n8sex() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void StoreUserdata::clear_n8sex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n8sex_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t StoreUserdata::n8sex() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.n8Sex)
  return _internal_n8sex();
}
inline void StoreUserdata::set_n8sex(::int32_t value) {
  _internal_set_n8sex(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.n8Sex)
}
inline ::int32_t StoreUserdata::_internal_n8sex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.n8sex_;
}
inline void StoreUserdata::_internal_set_n8sex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n8sex_ = value;
}

// optional int64 n64Diamond = 5;
inline bool StoreUserdata::has_n64diamond() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void StoreUserdata::clear_n64diamond() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n64diamond_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int64_t StoreUserdata::n64diamond() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.n64Diamond)
  return _internal_n64diamond();
}
inline void StoreUserdata::set_n64diamond(::int64_t value) {
  _internal_set_n64diamond(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.n64Diamond)
}
inline ::int64_t StoreUserdata::_internal_n64diamond() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.n64diamond_;
}
inline void StoreUserdata::_internal_set_n64diamond(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n64diamond_ = value;
}

// optional int64 n64Gold = 6;
inline bool StoreUserdata::has_n64gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void StoreUserdata::clear_n64gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n64gold_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int64_t StoreUserdata::n64gold() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.n64Gold)
  return _internal_n64gold();
}
inline void StoreUserdata::set_n64gold(::int64_t value) {
  _internal_set_n64gold(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.n64Gold)
}
inline ::int64_t StoreUserdata::_internal_n64gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.n64gold_;
}
inline void StoreUserdata::_internal_set_n64gold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n64gold_ = value;
}

// optional int64 tRegisteUTCMillisec = 7;
inline bool StoreUserdata::has_tregisteutcmillisec() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void StoreUserdata::clear_tregisteutcmillisec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tregisteutcmillisec_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int64_t StoreUserdata::tregisteutcmillisec() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.tRegisteUTCMillisec)
  return _internal_tregisteutcmillisec();
}
inline void StoreUserdata::set_tregisteutcmillisec(::int64_t value) {
  _internal_set_tregisteutcmillisec(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.tRegisteUTCMillisec)
}
inline ::int64_t StoreUserdata::_internal_tregisteutcmillisec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tregisteutcmillisec_;
}
inline void StoreUserdata::_internal_set_tregisteutcmillisec(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tregisteutcmillisec_ = value;
}

// optional int64 tLastLoginUTCMillisec = 8;
inline bool StoreUserdata::has_tlastloginutcmillisec() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void StoreUserdata::clear_tlastloginutcmillisec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tlastloginutcmillisec_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::int64_t StoreUserdata::tlastloginutcmillisec() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.tLastLoginUTCMillisec)
  return _internal_tlastloginutcmillisec();
}
inline void StoreUserdata::set_tlastloginutcmillisec(::int64_t value) {
  _internal_set_tlastloginutcmillisec(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.tLastLoginUTCMillisec)
}
inline ::int64_t StoreUserdata::_internal_tlastloginutcmillisec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tlastloginutcmillisec_;
}
inline void StoreUserdata::_internal_set_tlastloginutcmillisec(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tlastloginutcmillisec_ = value;
}

// optional int64 tLastLogOutUTCTime = 9;
inline bool StoreUserdata::has_tlastlogoututctime() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void StoreUserdata::clear_tlastlogoututctime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tlastlogoututctime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::int64_t StoreUserdata::tlastlogoututctime() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.tLastLogOutUTCTime)
  return _internal_tlastlogoututctime();
}
inline void StoreUserdata::set_tlastlogoututctime(::int64_t value) {
  _internal_set_tlastlogoututctime(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.tLastLogOutUTCTime)
}
inline ::int64_t StoreUserdata::_internal_tlastlogoututctime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tlastlogoututctime_;
}
inline void StoreUserdata::_internal_set_tlastlogoututctime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tlastlogoututctime_ = value;
}

// optional int64 n64Score = 10;
inline bool StoreUserdata::has_n64score() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void StoreUserdata::clear_n64score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n64score_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::int64_t StoreUserdata::n64score() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.n64Score)
  return _internal_n64score();
}
inline void StoreUserdata::set_n64score(::int64_t value) {
  _internal_set_n64score(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.n64Score)
}
inline ::int64_t StoreUserdata::_internal_n64score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.n64score_;
}
inline void StoreUserdata::_internal_set_n64score(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.n64score_ = value;
}

// optional int32 un32TotalGameInns = 11;
inline bool StoreUserdata::has_un32totalgameinns() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32totalgameinns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalgameinns_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t StoreUserdata::un32totalgameinns() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32TotalGameInns)
  return _internal_un32totalgameinns();
}
inline void StoreUserdata::set_un32totalgameinns(::int32_t value) {
  _internal_set_un32totalgameinns(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32TotalGameInns)
}
inline ::int32_t StoreUserdata::_internal_un32totalgameinns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32totalgameinns_;
}
inline void StoreUserdata::_internal_set_un32totalgameinns(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalgameinns_ = value;
}

// optional int32 un32TotalWinInns = 12;
inline bool StoreUserdata::has_un32totalwininns() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32totalwininns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalwininns_ = 0;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::int32_t StoreUserdata::un32totalwininns() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32TotalWinInns)
  return _internal_un32totalwininns();
}
inline void StoreUserdata::set_un32totalwininns(::int32_t value) {
  _internal_set_un32totalwininns(value);
  _impl_._has_bits_[0] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32TotalWinInns)
}
inline ::int32_t StoreUserdata::_internal_un32totalwininns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32totalwininns_;
}
inline void StoreUserdata::_internal_set_un32totalwininns(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalwininns_ = value;
}

// optional int32 un32TotalHeroKills = 13;
inline bool StoreUserdata::has_un32totalherokills() const {
  bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32totalherokills() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalherokills_ = 0;
  _impl_._has_bits_[0] &= ~0x00080000u;
}
inline ::int32_t StoreUserdata::un32totalherokills() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32TotalHeroKills)
  return _internal_un32totalherokills();
}
inline void StoreUserdata::set_un32totalherokills(::int32_t value) {
  _internal_set_un32totalherokills(value);
  _impl_._has_bits_[0] |= 0x00080000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32TotalHeroKills)
}
inline ::int32_t StoreUserdata::_internal_un32totalherokills() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32totalherokills_;
}
inline void StoreUserdata::_internal_set_un32totalherokills(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalherokills_ = value;
}

// optional int32 un32TotalDestoryBuildings = 14;
inline bool StoreUserdata::has_un32totaldestorybuildings() const {
  bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32totaldestorybuildings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totaldestorybuildings_ = 0;
  _impl_._has_bits_[0] &= ~0x00100000u;
}
inline ::int32_t StoreUserdata::un32totaldestorybuildings() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32TotalDestoryBuildings)
  return _internal_un32totaldestorybuildings();
}
inline void StoreUserdata::set_un32totaldestorybuildings(::int32_t value) {
  _internal_set_un32totaldestorybuildings(value);
  _impl_._has_bits_[0] |= 0x00100000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32TotalDestoryBuildings)
}
inline ::int32_t StoreUserdata::_internal_un32totaldestorybuildings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32totaldestorybuildings_;
}
inline void StoreUserdata::_internal_set_un32totaldestorybuildings(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totaldestorybuildings_ = value;
}

// optional int32 un32TotalDeadTimes = 15;
inline bool StoreUserdata::has_un32totaldeadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32totaldeadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totaldeadtimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::int32_t StoreUserdata::un32totaldeadtimes() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32TotalDeadTimes)
  return _internal_un32totaldeadtimes();
}
inline void StoreUserdata::set_un32totaldeadtimes(::int32_t value) {
  _internal_set_un32totaldeadtimes(value);
  _impl_._has_bits_[0] |= 0x00200000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32TotalDeadTimes)
}
inline ::int32_t StoreUserdata::_internal_un32totaldeadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32totaldeadtimes_;
}
inline void StoreUserdata::_internal_set_un32totaldeadtimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totaldeadtimes_ = value;
}

// optional int32 un32TotalAssist = 16;
inline bool StoreUserdata::has_un32totalassist() const {
  bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32totalassist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalassist_ = 0;
  _impl_._has_bits_[0] &= ~0x00400000u;
}
inline ::int32_t StoreUserdata::un32totalassist() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32TotalAssist)
  return _internal_un32totalassist();
}
inline void StoreUserdata::set_un32totalassist(::int32_t value) {
  _internal_set_un32totalassist(value);
  _impl_._has_bits_[0] |= 0x00400000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32TotalAssist)
}
inline ::int32_t StoreUserdata::_internal_un32totalassist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32totalassist_;
}
inline void StoreUserdata::_internal_set_un32totalassist(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32totalassist_ = value;
}

// optional int32 un16UserLv = 17;
inline bool StoreUserdata::has_un16userlv() const {
  bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un16userlv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un16userlv_ = 0;
  _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::int32_t StoreUserdata::un16userlv() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un16UserLv)
  return _internal_un16userlv();
}
inline void StoreUserdata::set_un16userlv(::int32_t value) {
  _internal_set_un16userlv(value);
  _impl_._has_bits_[0] |= 0x00800000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un16UserLv)
}
inline ::int32_t StoreUserdata::_internal_un16userlv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un16userlv_;
}
inline void StoreUserdata::_internal_set_un16userlv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un16userlv_ = value;
}

// optional int32 un32UserCurLvExp = 18;
inline bool StoreUserdata::has_un32usercurlvexp() const {
  bool value = (_impl_._has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un32usercurlvexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32usercurlvexp_ = 0;
  _impl_._has_bits_[0] &= ~0x02000000u;
}
inline ::int32_t StoreUserdata::un32usercurlvexp() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un32UserCurLvExp)
  return _internal_un32usercurlvexp();
}
inline void StoreUserdata::set_un32usercurlvexp(::int32_t value) {
  _internal_set_un32usercurlvexp(value);
  _impl_._has_bits_[0] |= 0x02000000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un32UserCurLvExp)
}
inline ::int32_t StoreUserdata::_internal_un32usercurlvexp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un32usercurlvexp_;
}
inline void StoreUserdata::_internal_set_un32usercurlvexp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un32usercurlvexp_ = value;
}

// optional int64 tLastFirstWinTime = 19;
inline bool StoreUserdata::has_tlastfirstwintime() const {
  bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline void StoreUserdata::clear_tlastfirstwintime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tlastfirstwintime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::int64_t StoreUserdata::tlastfirstwintime() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.tLastFirstWinTime)
  return _internal_tlastfirstwintime();
}
inline void StoreUserdata::set_tlastfirstwintime(::int64_t value) {
  _internal_set_tlastfirstwintime(value);
  _impl_._has_bits_[0] |= 0x01000000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.tLastFirstWinTime)
}
inline ::int64_t StoreUserdata::_internal_tlastfirstwintime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tlastfirstwintime_;
}
inline void StoreUserdata::_internal_set_tlastfirstwintime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tlastfirstwintime_ = value;
}

// optional int32 un16Cldays = 20;
inline bool StoreUserdata::has_un16cldays() const {
  bool value = (_impl_._has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un16cldays() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un16cldays_ = 0;
  _impl_._has_bits_[0] &= ~0x04000000u;
}
inline ::int32_t StoreUserdata::un16cldays() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un16Cldays)
  return _internal_un16cldays();
}
inline void StoreUserdata::set_un16cldays(::int32_t value) {
  _internal_set_un16cldays(value);
  _impl_._has_bits_[0] |= 0x04000000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un16Cldays)
}
inline ::int32_t StoreUserdata::_internal_un16cldays() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un16cldays_;
}
inline void StoreUserdata::_internal_set_un16cldays(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un16cldays_ = value;
}

// optional string tLastGetLoginReward = 21;
inline bool StoreUserdata::has_tlastgetloginreward() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StoreUserdata::clear_tlastgetloginreward() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tlastgetloginreward_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreUserdata::tlastgetloginreward() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.tLastGetLoginReward)
  return _internal_tlastgetloginreward();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata::set_tlastgetloginreward(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tlastgetloginreward_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.tLastGetLoginReward)
}
inline std::string* StoreUserdata::mutable_tlastgetloginreward() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tlastgetloginreward();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.tLastGetLoginReward)
  return _s;
}
inline const std::string& StoreUserdata::_internal_tlastgetloginreward() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tlastgetloginreward_.Get();
}
inline void StoreUserdata::_internal_set_tlastgetloginreward(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.tlastgetloginreward_.Set(value, GetArena());
}
inline std::string* StoreUserdata::_internal_mutable_tlastgetloginreward() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.tlastgetloginreward_.Mutable( GetArena());
}
inline std::string* StoreUserdata::release_tlastgetloginreward() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.tLastGetLoginReward)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.tlastgetloginreward_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.tlastgetloginreward_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata::set_allocated_tlastgetloginreward(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.tlastgetloginreward_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tlastgetloginreward_.IsDefault()) {
          _impl_.tlastgetloginreward_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.tLastGetLoginReward)
}

// optional int32 un16VipLv = 22;
inline bool StoreUserdata::has_un16viplv() const {
  bool value = (_impl_._has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline void StoreUserdata::clear_un16viplv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un16viplv_ = 0;
  _impl_._has_bits_[0] &= ~0x08000000u;
}
inline ::int32_t StoreUserdata::un16viplv() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.un16VipLv)
  return _internal_un16viplv();
}
inline void StoreUserdata::set_un16viplv(::int32_t value) {
  _internal_set_un16viplv(value);
  _impl_._has_bits_[0] |= 0x08000000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.un16VipLv)
}
inline ::int32_t StoreUserdata::_internal_un16viplv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.un16viplv_;
}
inline void StoreUserdata::_internal_set_un16viplv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.un16viplv_ = value;
}

// optional int32 vipScore = 23;
inline bool StoreUserdata::has_vipscore() const {
  bool value = (_impl_._has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline void StoreUserdata::clear_vipscore() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vipscore_ = 0;
  _impl_._has_bits_[0] &= ~0x10000000u;
}
inline ::int32_t StoreUserdata::vipscore() const {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.vipScore)
  return _internal_vipscore();
}
inline void StoreUserdata::set_vipscore(::int32_t value) {
  _internal_set_vipscore(value);
  _impl_._has_bits_[0] |= 0x10000000u;
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.vipScore)
}
inline ::int32_t StoreUserdata::_internal_vipscore() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vipscore_;
}
inline void StoreUserdata::_internal_set_vipscore(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vipscore_ = value;
}

// optional string mGuideSteps = 24;
inline bool StoreUserdata::has_mguidesteps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StoreUserdata::clear_mguidesteps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mguidesteps_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreUserdata::mguidesteps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.mGuideSteps)
  return _internal_mguidesteps();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata::set_mguidesteps(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mguidesteps_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.mGuideSteps)
}
inline std::string* StoreUserdata::mutable_mguidesteps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mguidesteps();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.mGuideSteps)
  return _s;
}
inline const std::string& StoreUserdata::_internal_mguidesteps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mguidesteps_.Get();
}
inline void StoreUserdata::_internal_set_mguidesteps(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mguidesteps_.Set(value, GetArena());
}
inline std::string* StoreUserdata::_internal_mutable_mguidesteps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mguidesteps_.Mutable( GetArena());
}
inline std::string* StoreUserdata::release_mguidesteps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.mGuideSteps)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.mguidesteps_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mguidesteps_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata::set_allocated_mguidesteps(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mguidesteps_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mguidesteps_.IsDefault()) {
          _impl_.mguidesteps_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.mGuideSteps)
}

// repeated .CSToDB.StoreUserdata.SUserHeroDBData sSUserHeroDBData = 25;
inline int StoreUserdata::_internal_ssuserherodbdata_size() const {
  return _internal_ssuserherodbdata().size();
}
inline int StoreUserdata::ssuserherodbdata_size() const {
  return _internal_ssuserherodbdata_size();
}
inline void StoreUserdata::clear_ssuserherodbdata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssuserherodbdata_.Clear();
}
inline ::CSToDB::StoreUserdata_SUserHeroDBData* StoreUserdata::mutable_ssuserherodbdata(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.sSUserHeroDBData)
  return _internal_mutable_ssuserherodbdata()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>* StoreUserdata::mutable_ssuserherodbdata()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:CSToDB.StoreUserdata.sSUserHeroDBData)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ssuserherodbdata();
}
inline const ::CSToDB::StoreUserdata_SUserHeroDBData& StoreUserdata::ssuserherodbdata(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.sSUserHeroDBData)
  return _internal_ssuserherodbdata().Get(index);
}
inline ::CSToDB::StoreUserdata_SUserHeroDBData* StoreUserdata::add_ssuserherodbdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CSToDB::StoreUserdata_SUserHeroDBData* _add = _internal_mutable_ssuserherodbdata()->Add();
  // @@protoc_insertion_point(field_add:CSToDB.StoreUserdata.sSUserHeroDBData)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>& StoreUserdata::ssuserherodbdata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:CSToDB.StoreUserdata.sSUserHeroDBData)
  return _internal_ssuserherodbdata();
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>&
StoreUserdata::_internal_ssuserherodbdata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssuserherodbdata_;
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserHeroDBData>*
StoreUserdata::_internal_mutable_ssuserherodbdata() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ssuserherodbdata_;
}

// repeated .CSToDB.StoreUserdata.SUserRelationshipInfo friendList = 26;
inline int StoreUserdata::_internal_friendlist_size() const {
  return _internal_friendlist().size();
}
inline int StoreUserdata::friendlist_size() const {
  return _internal_friendlist_size();
}
inline void StoreUserdata::clear_friendlist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.friendlist_.Clear();
}
inline ::CSToDB::StoreUserdata_SUserRelationshipInfo* StoreUserdata::mutable_friendlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.friendList)
  return _internal_mutable_friendlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>* StoreUserdata::mutable_friendlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:CSToDB.StoreUserdata.friendList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_friendlist();
}
inline const ::CSToDB::StoreUserdata_SUserRelationshipInfo& StoreUserdata::friendlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.friendList)
  return _internal_friendlist().Get(index);
}
inline ::CSToDB::StoreUserdata_SUserRelationshipInfo* StoreUserdata::add_friendlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CSToDB::StoreUserdata_SUserRelationshipInfo* _add = _internal_mutable_friendlist()->Add();
  // @@protoc_insertion_point(field_add:CSToDB.StoreUserdata.friendList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>& StoreUserdata::friendlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:CSToDB.StoreUserdata.friendList)
  return _internal_friendlist();
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>&
StoreUserdata::_internal_friendlist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.friendlist_;
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>*
StoreUserdata::_internal_mutable_friendlist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.friendlist_;
}

// repeated .CSToDB.StoreUserdata.SUserRelationshipInfo blackList = 27;
inline int StoreUserdata::_internal_blacklist_size() const {
  return _internal_blacklist().size();
}
inline int StoreUserdata::blacklist_size() const {
  return _internal_blacklist_size();
}
inline void StoreUserdata::clear_blacklist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blacklist_.Clear();
}
inline ::CSToDB::StoreUserdata_SUserRelationshipInfo* StoreUserdata::mutable_blacklist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.blackList)
  return _internal_mutable_blacklist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>* StoreUserdata::mutable_blacklist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:CSToDB.StoreUserdata.blackList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_blacklist();
}
inline const ::CSToDB::StoreUserdata_SUserRelationshipInfo& StoreUserdata::blacklist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.blackList)
  return _internal_blacklist().Get(index);
}
inline ::CSToDB::StoreUserdata_SUserRelationshipInfo* StoreUserdata::add_blacklist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CSToDB::StoreUserdata_SUserRelationshipInfo* _add = _internal_mutable_blacklist()->Add();
  // @@protoc_insertion_point(field_add:CSToDB.StoreUserdata.blackList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>& StoreUserdata::blacklist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:CSToDB.StoreUserdata.blackList)
  return _internal_blacklist();
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>&
StoreUserdata::_internal_blacklist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blacklist_;
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserRelationshipInfo>*
StoreUserdata::_internal_mutable_blacklist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.blacklist_;
}

// repeated .CSToDB.StoreUserdata.SUserItemInfo itemlist = 28;
inline int StoreUserdata::_internal_itemlist_size() const {
  return _internal_itemlist().size();
}
inline int StoreUserdata::itemlist_size() const {
  return _internal_itemlist_size();
}
inline void StoreUserdata::clear_itemlist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.itemlist_.Clear();
}
inline ::CSToDB::StoreUserdata_SUserItemInfo* StoreUserdata::mutable_itemlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.itemlist)
  return _internal_mutable_itemlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>* StoreUserdata::mutable_itemlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:CSToDB.StoreUserdata.itemlist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_itemlist();
}
inline const ::CSToDB::StoreUserdata_SUserItemInfo& StoreUserdata::itemlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.itemlist)
  return _internal_itemlist().Get(index);
}
inline ::CSToDB::StoreUserdata_SUserItemInfo* StoreUserdata::add_itemlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CSToDB::StoreUserdata_SUserItemInfo* _add = _internal_mutable_itemlist()->Add();
  // @@protoc_insertion_point(field_add:CSToDB.StoreUserdata.itemlist)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>& StoreUserdata::itemlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:CSToDB.StoreUserdata.itemlist)
  return _internal_itemlist();
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>&
StoreUserdata::_internal_itemlist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.itemlist_;
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_SUserItemInfo>*
StoreUserdata::_internal_mutable_itemlist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.itemlist_;
}

// repeated .CSToDB.StoreUserdata.UserMailDBData mailList = 29;
inline int StoreUserdata::_internal_maillist_size() const {
  return _internal_maillist().size();
}
inline int StoreUserdata::maillist_size() const {
  return _internal_maillist_size();
}
inline void StoreUserdata::clear_maillist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maillist_.Clear();
}
inline ::CSToDB::StoreUserdata_UserMailDBData* StoreUserdata::mutable_maillist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.mailList)
  return _internal_mutable_maillist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>* StoreUserdata::mutable_maillist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:CSToDB.StoreUserdata.mailList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_maillist();
}
inline const ::CSToDB::StoreUserdata_UserMailDBData& StoreUserdata::maillist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.mailList)
  return _internal_maillist().Get(index);
}
inline ::CSToDB::StoreUserdata_UserMailDBData* StoreUserdata::add_maillist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CSToDB::StoreUserdata_UserMailDBData* _add = _internal_mutable_maillist()->Add();
  // @@protoc_insertion_point(field_add:CSToDB.StoreUserdata.mailList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>& StoreUserdata::maillist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:CSToDB.StoreUserdata.mailList)
  return _internal_maillist();
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>&
StoreUserdata::_internal_maillist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maillist_;
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::StoreUserdata_UserMailDBData>*
StoreUserdata::_internal_mutable_maillist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.maillist_;
}

// optional string nickname = 30;
inline bool StoreUserdata::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StoreUserdata::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StoreUserdata::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.nickname)
}
inline std::string* StoreUserdata::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.nickname)
  return _s;
}
inline const std::string& StoreUserdata::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void StoreUserdata::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* StoreUserdata::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* StoreUserdata::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.nickname)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.nickname)
}

// optional string username = 31;
inline bool StoreUserdata::has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void StoreUserdata::clear_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StoreUserdata::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata::set_username(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.username)
}
inline std::string* StoreUserdata::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.username)
  return _s;
}
inline const std::string& StoreUserdata::_internal_username() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_.Get();
}
inline void StoreUserdata::_internal_set_username(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* StoreUserdata::_internal_mutable_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* StoreUserdata::release_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.username)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.username_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.username_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata::set_allocated_username(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.username)
}

// optional string pwd = 32;
inline bool StoreUserdata::has_pwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void StoreUserdata::clear_pwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pwd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StoreUserdata::pwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.pwd)
  return _internal_pwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata::set_pwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.pwd)
}
inline std::string* StoreUserdata::mutable_pwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pwd();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.pwd)
  return _s;
}
inline const std::string& StoreUserdata::_internal_pwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pwd_.Get();
}
inline void StoreUserdata::_internal_set_pwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.pwd_.Set(value, GetArena());
}
inline std::string* StoreUserdata::_internal_mutable_pwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.pwd_.Mutable( GetArena());
}
inline std::string* StoreUserdata::release_pwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.pwd)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.pwd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pwd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata::set_allocated_pwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.pwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pwd_.IsDefault()) {
          _impl_.pwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.pwd)
}

// optional string runestr = 33;
inline bool StoreUserdata::has_runestr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void StoreUserdata::clear_runestr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runestr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& StoreUserdata::runestr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.runestr)
  return _internal_runestr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata::set_runestr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.runestr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.runestr)
}
inline std::string* StoreUserdata::mutable_runestr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_runestr();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.runestr)
  return _s;
}
inline const std::string& StoreUserdata::_internal_runestr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runestr_.Get();
}
inline void StoreUserdata::_internal_set_runestr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.runestr_.Set(value, GetArena());
}
inline std::string* StoreUserdata::_internal_mutable_runestr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.runestr_.Mutable( GetArena());
}
inline std::string* StoreUserdata::release_runestr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.runestr)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.runestr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.runestr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata::set_allocated_runestr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.runestr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.runestr_.IsDefault()) {
          _impl_.runestr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.runestr)
}

// optional string slotstr = 34;
inline bool StoreUserdata::has_slotstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void StoreUserdata::clear_slotstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slotstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& StoreUserdata::slotstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.StoreUserdata.slotstr)
  return _internal_slotstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StoreUserdata::set_slotstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.slotstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.StoreUserdata.slotstr)
}
inline std::string* StoreUserdata::mutable_slotstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_slotstr();
  // @@protoc_insertion_point(field_mutable:CSToDB.StoreUserdata.slotstr)
  return _s;
}
inline const std::string& StoreUserdata::_internal_slotstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slotstr_.Get();
}
inline void StoreUserdata::_internal_set_slotstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.slotstr_.Set(value, GetArena());
}
inline std::string* StoreUserdata::_internal_mutable_slotstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.slotstr_.Mutable( GetArena());
}
inline std::string* StoreUserdata::release_slotstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.StoreUserdata.slotstr)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.slotstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.slotstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void StoreUserdata::set_allocated_slotstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.slotstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.slotstr_.IsDefault()) {
          _impl_.slotstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.StoreUserdata.slotstr)
}

// -------------------------------------------------------------------

// QueryNotice

// optional .CSToDB.MsgID msgid = 1 [default = eQueryNotice_DBCall];
inline bool QueryNotice::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryNotice::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 115;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CSToDB::MsgID QueryNotice::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryNotice.msgid)
  return _internal_msgid();
}
inline void QueryNotice::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryNotice.msgid)
}
inline ::CSToDB::MsgID QueryNotice::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void QueryNotice::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// ExeSQL_Call

// optional .CSToDB.MsgID msgid = 1 [default = eExeSQL_Call];
inline bool ExeSQL_Call::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ExeSQL_Call::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 114;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID ExeSQL_Call::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.ExeSQL_Call.msgid)
  return _internal_msgid();
}
inline void ExeSQL_Call::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.ExeSQL_Call.msgid)
}
inline ::CSToDB::MsgID ExeSQL_Call::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void ExeSQL_Call::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string sql = 2;
inline bool ExeSQL_Call::has_sql() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ExeSQL_Call::clear_sql() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sql_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExeSQL_Call::sql() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.ExeSQL_Call.sql)
  return _internal_sql();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExeSQL_Call::set_sql(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.ExeSQL_Call.sql)
}
inline std::string* ExeSQL_Call::mutable_sql() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:CSToDB.ExeSQL_Call.sql)
  return _s;
}
inline const std::string& ExeSQL_Call::_internal_sql() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sql_.Get();
}
inline void ExeSQL_Call::_internal_set_sql(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_.Set(value, GetArena());
}
inline std::string* ExeSQL_Call::_internal_mutable_sql() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sql_.Mutable( GetArena());
}
inline std::string* ExeSQL_Call::release_sql() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.ExeSQL_Call.sql)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sql_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ExeSQL_Call::set_allocated_sql(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sql_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sql_.IsDefault()) {
          _impl_.sql_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.ExeSQL_Call.sql)
}

// -------------------------------------------------------------------

// ChangeNickName

// optional .CSToDB.MsgID msgid = 1 [default = eChangeNickName_DBCall];
inline bool ChangeNickName::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChangeNickName::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 113;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::CSToDB::MsgID ChangeNickName::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.ChangeNickName.msgid)
  return _internal_msgid();
}
inline void ChangeNickName::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.ChangeNickName.msgid)
}
inline ::CSToDB::MsgID ChangeNickName::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void ChangeNickName::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string nickname = 2;
inline bool ChangeNickName::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChangeNickName::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeNickName::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.ChangeNickName.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangeNickName::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.ChangeNickName.nickname)
}
inline std::string* ChangeNickName::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:CSToDB.ChangeNickName.nickname)
  return _s;
}
inline const std::string& ChangeNickName::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void ChangeNickName::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* ChangeNickName::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* ChangeNickName::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.ChangeNickName.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChangeNickName::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.ChangeNickName.nickname)
}

// optional int64 guid = 3;
inline bool ChangeNickName::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChangeNickName::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t ChangeNickName::guid() const {
  // @@protoc_insertion_point(field_get:CSToDB.ChangeNickName.guid)
  return _internal_guid();
}
inline void ChangeNickName::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.ChangeNickName.guid)
}
inline ::int64_t ChangeNickName::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void ChangeNickName::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// -------------------------------------------------------------------

// AlterItem

// optional .CSToDB.MsgID mgsid = 1 [default = eAlterItem_DBCall];
inline bool AlterItem::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AlterItem::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 112;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID AlterItem::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.AlterItem.mgsid)
  return _internal_mgsid();
}
inline void AlterItem::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.AlterItem.mgsid)
}
inline ::CSToDB::MsgID AlterItem::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void AlterItem::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional string sql_str = 2;
inline bool AlterItem::has_sql_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AlterItem::clear_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sql_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AlterItem::sql_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.AlterItem.sql_str)
  return _internal_sql_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AlterItem::set_sql_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.AlterItem.sql_str)
}
inline std::string* AlterItem::mutable_sql_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sql_str();
  // @@protoc_insertion_point(field_mutable:CSToDB.AlterItem.sql_str)
  return _s;
}
inline const std::string& AlterItem::_internal_sql_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sql_str_.Get();
}
inline void AlterItem::_internal_set_sql_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(value, GetArena());
}
inline std::string* AlterItem::_internal_mutable_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sql_str_.Mutable( GetArena());
}
inline std::string* AlterItem::release_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.AlterItem.sql_str)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sql_str_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_str_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AlterItem::set_allocated_sql_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sql_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sql_str_.IsDefault()) {
          _impl_.sql_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.AlterItem.sql_str)
}

// -------------------------------------------------------------------

// DeleteNotice

// optional .CSToDB.MsgID mgsid = 1 [default = eDeleteNotice_DBCall];
inline bool DeleteNotice::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DeleteNotice::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 111;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID DeleteNotice::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.DeleteNotice.mgsid)
  return _internal_mgsid();
}
inline void DeleteNotice::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.DeleteNotice.mgsid)
}
inline ::CSToDB::MsgID DeleteNotice::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void DeleteNotice::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint32 id = 2;
inline bool DeleteNotice::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DeleteNotice::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t DeleteNotice::id() const {
  // @@protoc_insertion_point(field_get:CSToDB.DeleteNotice.id)
  return _internal_id();
}
inline void DeleteNotice::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.DeleteNotice.id)
}
inline ::uint32_t DeleteNotice::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void DeleteNotice::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// InsertNotice

// optional .CSToDB.MsgID mgsid = 1 [default = eInsertNotice_DBCall];
inline bool InsertNotice::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InsertNotice::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 110;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID InsertNotice::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.InsertNotice.mgsid)
  return _internal_mgsid();
}
inline void InsertNotice::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.InsertNotice.mgsid)
}
inline ::CSToDB::MsgID InsertNotice::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void InsertNotice::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional string sql_str = 2;
inline bool InsertNotice::has_sql_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InsertNotice::clear_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sql_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InsertNotice::sql_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.InsertNotice.sql_str)
  return _internal_sql_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsertNotice::set_sql_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.InsertNotice.sql_str)
}
inline std::string* InsertNotice::mutable_sql_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sql_str();
  // @@protoc_insertion_point(field_mutable:CSToDB.InsertNotice.sql_str)
  return _s;
}
inline const std::string& InsertNotice::_internal_sql_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sql_str_.Get();
}
inline void InsertNotice::_internal_set_sql_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sql_str_.Set(value, GetArena());
}
inline std::string* InsertNotice::_internal_mutable_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sql_str_.Mutable( GetArena());
}
inline std::string* InsertNotice::release_sql_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.InsertNotice.sql_str)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sql_str_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sql_str_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InsertNotice::set_allocated_sql_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sql_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sql_str_.IsDefault()) {
          _impl_.sql_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.InsertNotice.sql_str)
}

// -------------------------------------------------------------------

// AlterSNSList

// optional .CSToDB.MsgID mgsid = 1 [default = eAlterSNSList_DBCall];
inline bool AlterSNSList::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AlterSNSList::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 109;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::CSToDB::MsgID AlterSNSList::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.AlterSNSList.mgsid)
  return _internal_mgsid();
}
inline void AlterSNSList::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:CSToDB.AlterSNSList.mgsid)
}
inline ::CSToDB::MsgID AlterSNSList::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void AlterSNSList::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 user_id = 2;
inline bool AlterSNSList::has_user_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AlterSNSList::clear_user_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AlterSNSList::user_id() const {
  // @@protoc_insertion_point(field_get:CSToDB.AlterSNSList.user_id)
  return _internal_user_id();
}
inline void AlterSNSList::set_user_id(::uint64_t value) {
  _internal_set_user_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.AlterSNSList.user_id)
}
inline ::uint64_t AlterSNSList::_internal_user_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_id_;
}
inline void AlterSNSList::_internal_set_user_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_id_ = value;
}

// optional uint64 related_id = 3;
inline bool AlterSNSList::has_related_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AlterSNSList::clear_related_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t AlterSNSList::related_id() const {
  // @@protoc_insertion_point(field_get:CSToDB.AlterSNSList.related_id)
  return _internal_related_id();
}
inline void AlterSNSList::set_related_id(::uint64_t value) {
  _internal_set_related_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.AlterSNSList.related_id)
}
inline ::uint64_t AlterSNSList::_internal_related_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.related_id_;
}
inline void AlterSNSList::_internal_set_related_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_id_ = value;
}

// optional uint32 related = 4;
inline bool AlterSNSList::has_related() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AlterSNSList::clear_related() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t AlterSNSList::related() const {
  // @@protoc_insertion_point(field_get:CSToDB.AlterSNSList.related)
  return _internal_related();
}
inline void AlterSNSList::set_related(::uint32_t value) {
  _internal_set_related(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.AlterSNSList.related)
}
inline ::uint32_t AlterSNSList::_internal_related() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.related_;
}
inline void AlterSNSList::_internal_set_related(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_ = value;
}

// optional uint32 opration = 5;
inline bool AlterSNSList::has_opration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AlterSNSList::clear_opration() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.opration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t AlterSNSList::opration() const {
  // @@protoc_insertion_point(field_get:CSToDB.AlterSNSList.opration)
  return _internal_opration();
}
inline void AlterSNSList::set_opration(::uint32_t value) {
  _internal_set_opration(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.AlterSNSList.opration)
}
inline ::uint32_t AlterSNSList::_internal_opration() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.opration_;
}
inline void AlterSNSList::_internal_set_opration(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.opration_ = value;
}

// -------------------------------------------------------------------

// QueryObjIdxReq

// optional .CSToDB.MsgID msgid = 1 [default = eQueryObjId_DBCallBack];
inline bool QueryObjIdxReq::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QueryObjIdxReq::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 108;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::CSToDB::MsgID QueryObjIdxReq::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryObjIdxReq.msgid)
  return _internal_msgid();
}
inline void QueryObjIdxReq::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryObjIdxReq.msgid)
}
inline ::CSToDB::MsgID QueryObjIdxReq::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void QueryObjIdxReq::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string Logininfo = 2;
inline bool QueryObjIdxReq::has_logininfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryObjIdxReq::clear_logininfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.logininfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryObjIdxReq::logininfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.QueryObjIdxReq.Logininfo)
  return _internal_logininfo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryObjIdxReq::set_logininfo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.logininfo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.QueryObjIdxReq.Logininfo)
}
inline std::string* QueryObjIdxReq::mutable_logininfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_logininfo();
  // @@protoc_insertion_point(field_mutable:CSToDB.QueryObjIdxReq.Logininfo)
  return _s;
}
inline const std::string& QueryObjIdxReq::_internal_logininfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.logininfo_.Get();
}
inline void QueryObjIdxReq::_internal_set_logininfo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.logininfo_.Set(value, GetArena());
}
inline std::string* QueryObjIdxReq::_internal_mutable_logininfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.logininfo_.Mutable( GetArena());
}
inline std::string* QueryObjIdxReq::release_logininfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.QueryObjIdxReq.Logininfo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.logininfo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.logininfo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryObjIdxReq::set_allocated_logininfo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.logininfo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.logininfo_.IsDefault()) {
          _impl_.logininfo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.QueryObjIdxReq.Logininfo)
}

// optional int32 gsid = 3;
inline bool QueryObjIdxReq::has_gsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryObjIdxReq::clear_gsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t QueryObjIdxReq::gsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryObjIdxReq.gsid)
  return _internal_gsid();
}
inline void QueryObjIdxReq::set_gsid(::int32_t value) {
  _internal_set_gsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryObjIdxReq.gsid)
}
inline ::int32_t QueryObjIdxReq::_internal_gsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsid_;
}
inline void QueryObjIdxReq::_internal_set_gsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = value;
}

// optional int32 gcnetid = 4;
inline bool QueryObjIdxReq::has_gcnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryObjIdxReq::clear_gcnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t QueryObjIdxReq::gcnetid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryObjIdxReq.gcnetid)
  return _internal_gcnetid();
}
inline void QueryObjIdxReq::set_gcnetid(::int32_t value) {
  _internal_set_gcnetid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryObjIdxReq.gcnetid)
}
inline ::int32_t QueryObjIdxReq::_internal_gcnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gcnetid_;
}
inline void QueryObjIdxReq::_internal_set_gcnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = value;
}

// optional int32 csid = 5;
inline bool QueryObjIdxReq::has_csid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryObjIdxReq::clear_csid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t QueryObjIdxReq::csid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryObjIdxReq.csid)
  return _internal_csid();
}
inline void QueryObjIdxReq::set_csid(::int32_t value) {
  _internal_set_csid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryObjIdxReq.csid)
}
inline ::int32_t QueryObjIdxReq::_internal_csid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.csid_;
}
inline void QueryObjIdxReq::_internal_set_csid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = value;
}

// -------------------------------------------------------------------

// NicknameConflict

// optional .CSToDB.MsgID mgsid = 1 [default = eNicknameConflict_DBCallBack];
inline bool NicknameConflict::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void NicknameConflict::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 107;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::CSToDB::MsgID NicknameConflict::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.mgsid)
  return _internal_mgsid();
}
inline void NicknameConflict::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.mgsid)
}
inline ::CSToDB::MsgID NicknameConflict::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void NicknameConflict::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional string newnickname = 2;
inline bool NicknameConflict::has_newnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NicknameConflict::clear_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NicknameConflict::newnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.newnickname)
  return _internal_newnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NicknameConflict::set_newnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.newnickname)
}
inline std::string* NicknameConflict::mutable_newnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_newnickname();
  // @@protoc_insertion_point(field_mutable:CSToDB.NicknameConflict.newnickname)
  return _s;
}
inline const std::string& NicknameConflict::_internal_newnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newnickname_.Get();
}
inline void NicknameConflict::_internal_set_newnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(value, GetArena());
}
inline std::string* NicknameConflict::_internal_mutable_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.newnickname_.Mutable( GetArena());
}
inline std::string* NicknameConflict::release_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.NicknameConflict.newnickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.newnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.newnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NicknameConflict::set_allocated_newnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.newnickname_.IsDefault()) {
          _impl_.newnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.NicknameConflict.newnickname)
}

// optional int32 gsid = 3;
inline bool NicknameConflict::has_gsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NicknameConflict::clear_gsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NicknameConflict::gsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.gsid)
  return _internal_gsid();
}
inline void NicknameConflict::set_gsid(::int32_t value) {
  _internal_set_gsid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.gsid)
}
inline ::int32_t NicknameConflict::_internal_gsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsid_;
}
inline void NicknameConflict::_internal_set_gsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = value;
}

// optional int32 gcnetid = 4;
inline bool NicknameConflict::has_gcnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NicknameConflict::clear_gcnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NicknameConflict::gcnetid() const {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.gcnetid)
  return _internal_gcnetid();
}
inline void NicknameConflict::set_gcnetid(::int32_t value) {
  _internal_set_gcnetid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.gcnetid)
}
inline ::int32_t NicknameConflict::_internal_gcnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gcnetid_;
}
inline void NicknameConflict::_internal_set_gcnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = value;
}

// optional uint64 guid = 5;
inline bool NicknameConflict::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NicknameConflict::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t NicknameConflict::guid() const {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.guid)
  return _internal_guid();
}
inline void NicknameConflict::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.guid)
}
inline ::uint64_t NicknameConflict::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NicknameConflict::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 sdkid = 6;
inline bool NicknameConflict::has_sdkid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void NicknameConflict::clear_sdkid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t NicknameConflict::sdkid() const {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.sdkid)
  return _internal_sdkid();
}
inline void NicknameConflict::set_sdkid(::int32_t value) {
  _internal_set_sdkid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.sdkid)
}
inline ::int32_t NicknameConflict::_internal_sdkid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdkid_;
}
inline void NicknameConflict::_internal_set_sdkid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkid_ = value;
}

// optional int32 csid = 7;
inline bool NicknameConflict::has_csid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void NicknameConflict::clear_csid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t NicknameConflict::csid() const {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.csid)
  return _internal_csid();
}
inline void NicknameConflict::set_csid(::int32_t value) {
  _internal_set_csid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.csid)
}
inline ::int32_t NicknameConflict::_internal_csid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.csid_;
}
inline void NicknameConflict::_internal_set_csid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = value;
}

// optional string cdk = 8;
inline bool NicknameConflict::has_cdk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NicknameConflict::clear_cdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cdk_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NicknameConflict::cdk() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.cdk)
  return _internal_cdk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NicknameConflict::set_cdk(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cdk_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.cdk)
}
inline std::string* NicknameConflict::mutable_cdk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cdk();
  // @@protoc_insertion_point(field_mutable:CSToDB.NicknameConflict.cdk)
  return _s;
}
inline const std::string& NicknameConflict::_internal_cdk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cdk_.Get();
}
inline void NicknameConflict::_internal_set_cdk(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.cdk_.Set(value, GetArena());
}
inline std::string* NicknameConflict::_internal_mutable_cdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.cdk_.Mutable( GetArena());
}
inline std::string* NicknameConflict::release_cdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.NicknameConflict.cdk)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.cdk_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cdk_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NicknameConflict::set_allocated_cdk(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.cdk_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cdk_.IsDefault()) {
          _impl_.cdk_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.NicknameConflict.cdk)
}

// optional string oldnickname = 9;
inline bool NicknameConflict::has_oldnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NicknameConflict::clear_oldnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oldnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NicknameConflict::oldnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.NicknameConflict.oldnickname)
  return _internal_oldnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NicknameConflict::set_oldnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.oldnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.NicknameConflict.oldnickname)
}
inline std::string* NicknameConflict::mutable_oldnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_oldnickname();
  // @@protoc_insertion_point(field_mutable:CSToDB.NicknameConflict.oldnickname)
  return _s;
}
inline const std::string& NicknameConflict::_internal_oldnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.oldnickname_.Get();
}
inline void NicknameConflict::_internal_set_oldnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.oldnickname_.Set(value, GetArena());
}
inline std::string* NicknameConflict::_internal_mutable_oldnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.oldnickname_.Mutable( GetArena());
}
inline std::string* NicknameConflict::release_oldnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.NicknameConflict.oldnickname)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.oldnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oldnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NicknameConflict::set_allocated_oldnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.oldnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oldnickname_.IsDefault()) {
          _impl_.oldnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.NicknameConflict.oldnickname)
}

// -------------------------------------------------------------------

// BuyGoods

// optional .CSToDB.MsgID mgsid = 1 [default = eBuyGoods_DBCallBack];
inline bool BuyGoods::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BuyGoods::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 106;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::CSToDB::MsgID BuyGoods::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.BuyGoods.mgsid)
  return _internal_mgsid();
}
inline void BuyGoods::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.BuyGoods.mgsid)
}
inline ::CSToDB::MsgID BuyGoods::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void BuyGoods::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional string buygoodsmag = 2;
inline bool BuyGoods::has_buygoodsmag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BuyGoods::clear_buygoodsmag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buygoodsmag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BuyGoods::buygoodsmag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.BuyGoods.buygoodsmag)
  return _internal_buygoodsmag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BuyGoods::set_buygoodsmag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buygoodsmag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.BuyGoods.buygoodsmag)
}
inline std::string* BuyGoods::mutable_buygoodsmag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_buygoodsmag();
  // @@protoc_insertion_point(field_mutable:CSToDB.BuyGoods.buygoodsmag)
  return _s;
}
inline const std::string& BuyGoods::_internal_buygoodsmag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buygoodsmag_.Get();
}
inline void BuyGoods::_internal_set_buygoodsmag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buygoodsmag_.Set(value, GetArena());
}
inline std::string* BuyGoods::_internal_mutable_buygoodsmag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.buygoodsmag_.Mutable( GetArena());
}
inline std::string* BuyGoods::release_buygoodsmag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.BuyGoods.buygoodsmag)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.buygoodsmag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.buygoodsmag_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BuyGoods::set_allocated_buygoodsmag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buygoodsmag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.buygoodsmag_.IsDefault()) {
          _impl_.buygoodsmag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.BuyGoods.buygoodsmag)
}

// -------------------------------------------------------------------

// GameMailInfo

// optional .CSToDB.MailType type = 1;
inline bool GameMailInfo::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GameMailInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::CSToDB::MailType GameMailInfo::type() const {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.type)
  return _internal_type();
}
inline void GameMailInfo::set_type(::CSToDB::MailType value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.type)
}
inline ::CSToDB::MailType GameMailInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MailType>(_impl_.type_);
}
inline void GameMailInfo::_internal_set_type(::CSToDB::MailType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MailType_IsValid(value));
  _impl_.type_ = value;
}

// optional int32 mailId = 2;
inline bool GameMailInfo::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void GameMailInfo::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t GameMailInfo::mailid() const {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.mailId)
  return _internal_mailid();
}
inline void GameMailInfo::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.mailId)
}
inline ::int32_t GameMailInfo::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void GameMailInfo::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional int64 userid = 3;
inline bool GameMailInfo::has_userid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void GameMailInfo::clear_userid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int64_t GameMailInfo::userid() const {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.userid)
  return _internal_userid();
}
inline void GameMailInfo::set_userid(::int64_t value) {
  _internal_set_userid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.userid)
}
inline ::int64_t GameMailInfo::_internal_userid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userid_;
}
inline void GameMailInfo::_internal_set_userid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userid_ = value;
}

// optional .CSToDB.EMailCurtState curtstate = 4;
inline bool GameMailInfo::has_curtstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void GameMailInfo::clear_curtstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curtstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::CSToDB::EMailCurtState GameMailInfo::curtstate() const {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.curtstate)
  return _internal_curtstate();
}
inline void GameMailInfo::set_curtstate(::CSToDB::EMailCurtState value) {
  _internal_set_curtstate(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.curtstate)
}
inline ::CSToDB::EMailCurtState GameMailInfo::_internal_curtstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::EMailCurtState>(_impl_.curtstate_);
}
inline void GameMailInfo::_internal_set_curtstate(::CSToDB::EMailCurtState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::EMailCurtState_IsValid(value));
  _impl_.curtstate_ = value;
}

// optional int32 sdkidx = 5;
inline bool GameMailInfo::has_sdkidx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void GameMailInfo::clear_sdkidx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkidx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t GameMailInfo::sdkidx() const {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.sdkidx)
  return _internal_sdkidx();
}
inline void GameMailInfo::set_sdkidx(::int32_t value) {
  _internal_set_sdkidx(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.sdkidx)
}
inline ::int32_t GameMailInfo::_internal_sdkidx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdkidx_;
}
inline void GameMailInfo::_internal_set_sdkidx(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkidx_ = value;
}

// optional string title = 6;
inline bool GameMailInfo::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GameMailInfo::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameMailInfo::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameMailInfo::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.title)
}
inline std::string* GameMailInfo::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSToDB.GameMailInfo.title)
  return _s;
}
inline const std::string& GameMailInfo::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void GameMailInfo::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* GameMailInfo::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* GameMailInfo::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.GameMailInfo.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameMailInfo::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.GameMailInfo.title)
}

// optional string content = 7;
inline bool GameMailInfo::has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GameMailInfo::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GameMailInfo::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameMailInfo::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.content)
}
inline std::string* GameMailInfo::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:CSToDB.GameMailInfo.content)
  return _s;
}
inline const std::string& GameMailInfo::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void GameMailInfo::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* GameMailInfo::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* GameMailInfo::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.GameMailInfo.content)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.content_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameMailInfo::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.GameMailInfo.content)
}

// optional string giftstr = 8;
inline bool GameMailInfo::has_giftstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GameMailInfo::clear_giftstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.giftstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GameMailInfo::giftstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.giftstr)
  return _internal_giftstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameMailInfo::set_giftstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.giftstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.giftstr)
}
inline std::string* GameMailInfo::mutable_giftstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_giftstr();
  // @@protoc_insertion_point(field_mutable:CSToDB.GameMailInfo.giftstr)
  return _s;
}
inline const std::string& GameMailInfo::_internal_giftstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.giftstr_.Get();
}
inline void GameMailInfo::_internal_set_giftstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.giftstr_.Set(value, GetArena());
}
inline std::string* GameMailInfo::_internal_mutable_giftstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.giftstr_.Mutable( GetArena());
}
inline std::string* GameMailInfo::release_giftstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.GameMailInfo.giftstr)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.giftstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.giftstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameMailInfo::set_allocated_giftstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.giftstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.giftstr_.IsDefault()) {
          _impl_.giftstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.GameMailInfo.giftstr)
}

// optional string createtime = 9;
inline bool GameMailInfo::has_createtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GameMailInfo::clear_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GameMailInfo::createtime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.createtime)
  return _internal_createtime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameMailInfo::set_createtime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.createtime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.createtime)
}
inline std::string* GameMailInfo::mutable_createtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:CSToDB.GameMailInfo.createtime)
  return _s;
}
inline const std::string& GameMailInfo::_internal_createtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.createtime_.Get();
}
inline void GameMailInfo::_internal_set_createtime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.createtime_.Set(value, GetArena());
}
inline std::string* GameMailInfo::_internal_mutable_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.createtime_.Mutable( GetArena());
}
inline std::string* GameMailInfo::release_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.GameMailInfo.createtime)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.createtime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.createtime_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameMailInfo::set_allocated_createtime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.createtime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.createtime_.IsDefault()) {
          _impl_.createtime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.GameMailInfo.createtime)
}

// optional string overtime = 10;
inline bool GameMailInfo::has_overtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GameMailInfo::clear_overtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.overtime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& GameMailInfo::overtime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.overtime)
  return _internal_overtime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameMailInfo::set_overtime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.overtime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.overtime)
}
inline std::string* GameMailInfo::mutable_overtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_overtime();
  // @@protoc_insertion_point(field_mutable:CSToDB.GameMailInfo.overtime)
  return _s;
}
inline const std::string& GameMailInfo::_internal_overtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.overtime_.Get();
}
inline void GameMailInfo::_internal_set_overtime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.overtime_.Set(value, GetArena());
}
inline std::string* GameMailInfo::_internal_mutable_overtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.overtime_.Mutable( GetArena());
}
inline std::string* GameMailInfo::release_overtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.GameMailInfo.overtime)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.overtime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.overtime_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameMailInfo::set_allocated_overtime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.overtime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.overtime_.IsDefault()) {
          _impl_.overtime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.GameMailInfo.overtime)
}

// optional string sender = 11;
inline bool GameMailInfo::has_sender() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GameMailInfo::clear_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& GameMailInfo::sender() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.GameMailInfo.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameMailInfo::set_sender(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.GameMailInfo.sender)
}
inline std::string* GameMailInfo::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:CSToDB.GameMailInfo.sender)
  return _s;
}
inline const std::string& GameMailInfo::_internal_sender() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_.Get();
}
inline void GameMailInfo::_internal_set_sender(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.sender_.Set(value, GetArena());
}
inline std::string* GameMailInfo::_internal_mutable_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.sender_.Mutable( GetArena());
}
inline std::string* GameMailInfo::release_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.GameMailInfo.sender)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.sender_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sender_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameMailInfo::set_allocated_sender(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.sender_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.GameMailInfo.sender)
}

// -------------------------------------------------------------------

// UpdateGameMail

// optional .CSToDB.MsgID mgsid = 1 [default = eUpdateGameMail_DBCallBack];
inline bool UpdateGameMail::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UpdateGameMail::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 105;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::CSToDB::MsgID UpdateGameMail::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateGameMail.mgsid)
  return _internal_mgsid();
}
inline void UpdateGameMail::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateGameMail.mgsid)
}
inline ::CSToDB::MsgID UpdateGameMail::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void UpdateGameMail::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// repeated .CSToDB.GameMailInfo maillist = 2;
inline int UpdateGameMail::_internal_maillist_size() const {
  return _internal_maillist().size();
}
inline int UpdateGameMail::maillist_size() const {
  return _internal_maillist_size();
}
inline void UpdateGameMail::clear_maillist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maillist_.Clear();
}
inline ::CSToDB::GameMailInfo* UpdateGameMail::mutable_maillist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:CSToDB.UpdateGameMail.maillist)
  return _internal_mutable_maillist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>* UpdateGameMail::mutable_maillist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:CSToDB.UpdateGameMail.maillist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_maillist();
}
inline const ::CSToDB::GameMailInfo& UpdateGameMail::maillist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateGameMail.maillist)
  return _internal_maillist().Get(index);
}
inline ::CSToDB::GameMailInfo* UpdateGameMail::add_maillist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::CSToDB::GameMailInfo* _add = _internal_mutable_maillist()->Add();
  // @@protoc_insertion_point(field_add:CSToDB.UpdateGameMail.maillist)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>& UpdateGameMail::maillist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:CSToDB.UpdateGameMail.maillist)
  return _internal_maillist();
}
inline const ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>&
UpdateGameMail::_internal_maillist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maillist_;
}
inline ::google::protobuf::RepeatedPtrField<::CSToDB::GameMailInfo>*
UpdateGameMail::_internal_mutable_maillist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.maillist_;
}

// -------------------------------------------------------------------

// InsertUser

// optional .CSToDB.MsgID mgsid = 1 [default = eInsertUser_DBCallBack];
inline bool InsertUser::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void InsertUser::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 104;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::CSToDB::MsgID InsertUser::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.InsertUser.mgsid)
  return _internal_mgsid();
}
inline void InsertUser::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.InsertUser.mgsid)
}
inline ::CSToDB::MsgID InsertUser::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void InsertUser::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 guid = 2;
inline bool InsertUser::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InsertUser::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t InsertUser::guid() const {
  // @@protoc_insertion_point(field_get:CSToDB.InsertUser.guid)
  return _internal_guid();
}
inline void InsertUser::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.InsertUser.guid)
}
inline ::int64_t InsertUser::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void InsertUser::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional string sqlstr = 3;
inline bool InsertUser::has_sqlstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void InsertUser::clear_sqlstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sqlstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InsertUser::sqlstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.InsertUser.sqlstr)
  return _internal_sqlstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InsertUser::set_sqlstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sqlstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.InsertUser.sqlstr)
}
inline std::string* InsertUser::mutable_sqlstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sqlstr();
  // @@protoc_insertion_point(field_mutable:CSToDB.InsertUser.sqlstr)
  return _s;
}
inline const std::string& InsertUser::_internal_sqlstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sqlstr_.Get();
}
inline void InsertUser::_internal_set_sqlstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sqlstr_.Set(value, GetArena());
}
inline std::string* InsertUser::_internal_mutable_sqlstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sqlstr_.Mutable( GetArena());
}
inline std::string* InsertUser::release_sqlstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.InsertUser.sqlstr)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sqlstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sqlstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void InsertUser::set_allocated_sqlstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sqlstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sqlstr_.IsDefault()) {
          _impl_.sqlstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.InsertUser.sqlstr)
}

// -------------------------------------------------------------------

// UpdateUser

// optional .CSToDB.MsgID mgsid = 1 [default = eUpdateUser_DBCallBack];
inline bool UpdateUser::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UpdateUser::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 103;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::CSToDB::MsgID UpdateUser::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateUser.mgsid)
  return _internal_mgsid();
}
inline void UpdateUser::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateUser.mgsid)
}
inline ::CSToDB::MsgID UpdateUser::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void UpdateUser::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 guid = 2;
inline bool UpdateUser::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UpdateUser::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t UpdateUser::guid() const {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateUser.guid)
  return _internal_guid();
}
inline void UpdateUser::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:CSToDB.UpdateUser.guid)
}
inline ::int64_t UpdateUser::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void UpdateUser::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional string sqlstr = 3;
inline bool UpdateUser::has_sqlstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UpdateUser::clear_sqlstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sqlstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UpdateUser::sqlstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.UpdateUser.sqlstr)
  return _internal_sqlstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateUser::set_sqlstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sqlstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.UpdateUser.sqlstr)
}
inline std::string* UpdateUser::mutable_sqlstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sqlstr();
  // @@protoc_insertion_point(field_mutable:CSToDB.UpdateUser.sqlstr)
  return _s;
}
inline const std::string& UpdateUser::_internal_sqlstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sqlstr_.Get();
}
inline void UpdateUser::_internal_set_sqlstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sqlstr_.Set(value, GetArena());
}
inline std::string* UpdateUser::_internal_mutable_sqlstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sqlstr_.Mutable( GetArena());
}
inline std::string* UpdateUser::release_sqlstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.UpdateUser.sqlstr)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sqlstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sqlstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UpdateUser::set_allocated_sqlstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sqlstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sqlstr_.IsDefault()) {
          _impl_.sqlstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.UpdateUser.sqlstr)
}

// -------------------------------------------------------------------

// CheckNameReq

// optional .CSToDB.MsgID mgsid = 1 [default = eCheckNickNameDBCallBack];
inline bool CheckNameReq::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CheckNameReq::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 100;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::CSToDB::MsgID CheckNameReq::mgsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.mgsid)
  return _internal_mgsid();
}
inline void CheckNameReq::set_mgsid(::CSToDB::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.mgsid)
}
inline ::CSToDB::MsgID CheckNameReq::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.mgsid_);
}
inline void CheckNameReq::_internal_set_mgsid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int32 gsid = 2;
inline bool CheckNameReq::has_gsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CheckNameReq::clear_gsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CheckNameReq::gsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.gsid)
  return _internal_gsid();
}
inline void CheckNameReq::set_gsid(::int32_t value) {
  _internal_set_gsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.gsid)
}
inline ::int32_t CheckNameReq::_internal_gsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsid_;
}
inline void CheckNameReq::_internal_set_gsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = value;
}

// optional int32 gcnetid = 3;
inline bool CheckNameReq::has_gcnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CheckNameReq::clear_gcnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t CheckNameReq::gcnetid() const {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.gcnetid)
  return _internal_gcnetid();
}
inline void CheckNameReq::set_gcnetid(::int32_t value) {
  _internal_set_gcnetid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.gcnetid)
}
inline ::int32_t CheckNameReq::_internal_gcnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gcnetid_;
}
inline void CheckNameReq::_internal_set_gcnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = value;
}

// optional int32 gsnetid = 4;
inline bool CheckNameReq::has_gsnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CheckNameReq::clear_gsnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t CheckNameReq::gsnetid() const {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.gsnetid)
  return _internal_gsnetid();
}
inline void CheckNameReq::set_gsnetid(::int32_t value) {
  _internal_set_gsnetid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.gsnetid)
}
inline ::int32_t CheckNameReq::_internal_gsnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsnetid_;
}
inline void CheckNameReq::_internal_set_gsnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsnetid_ = value;
}

// optional int32 sdkid = 5;
inline bool CheckNameReq::has_sdkid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CheckNameReq::clear_sdkid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t CheckNameReq::sdkid() const {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.sdkid)
  return _internal_sdkid();
}
inline void CheckNameReq::set_sdkid(::int32_t value) {
  _internal_set_sdkid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.sdkid)
}
inline ::int32_t CheckNameReq::_internal_sdkid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdkid_;
}
inline void CheckNameReq::_internal_set_sdkid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkid_ = value;
}

// optional int32 csid = 6;
inline bool CheckNameReq::has_csid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CheckNameReq::clear_csid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t CheckNameReq::csid() const {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.csid)
  return _internal_csid();
}
inline void CheckNameReq::set_csid(::int32_t value) {
  _internal_set_csid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.csid)
}
inline ::int32_t CheckNameReq::_internal_csid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.csid_;
}
inline void CheckNameReq::_internal_set_csid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = value;
}

// optional string cdk = 7;
inline bool CheckNameReq::has_cdk() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CheckNameReq::clear_cdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cdk_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckNameReq::cdk() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.cdk)
  return _internal_cdk();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckNameReq::set_cdk(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cdk_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.cdk)
}
inline std::string* CheckNameReq::mutable_cdk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cdk();
  // @@protoc_insertion_point(field_mutable:CSToDB.CheckNameReq.cdk)
  return _s;
}
inline const std::string& CheckNameReq::_internal_cdk() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cdk_.Get();
}
inline void CheckNameReq::_internal_set_cdk(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cdk_.Set(value, GetArena());
}
inline std::string* CheckNameReq::_internal_mutable_cdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cdk_.Mutable( GetArena());
}
inline std::string* CheckNameReq::release_cdk() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.CheckNameReq.cdk)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.cdk_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cdk_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CheckNameReq::set_allocated_cdk(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cdk_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cdk_.IsDefault()) {
          _impl_.cdk_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.CheckNameReq.cdk)
}

// optional string completeInfo = 8;
inline bool CheckNameReq::has_completeinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CheckNameReq::clear_completeinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.completeinfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CheckNameReq::completeinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.CheckNameReq.completeInfo)
  return _internal_completeinfo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckNameReq::set_completeinfo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.completeinfo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.CheckNameReq.completeInfo)
}
inline std::string* CheckNameReq::mutable_completeinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_completeinfo();
  // @@protoc_insertion_point(field_mutable:CSToDB.CheckNameReq.completeInfo)
  return _s;
}
inline const std::string& CheckNameReq::_internal_completeinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.completeinfo_.Get();
}
inline void CheckNameReq::_internal_set_completeinfo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.completeinfo_.Set(value, GetArena());
}
inline std::string* CheckNameReq::_internal_mutable_completeinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.completeinfo_.Mutable( GetArena());
}
inline std::string* CheckNameReq::release_completeinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.CheckNameReq.completeInfo)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.completeinfo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.completeinfo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CheckNameReq::set_allocated_completeinfo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.completeinfo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.completeinfo_.IsDefault()) {
          _impl_.completeinfo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.CheckNameReq.completeInfo)
}

// -------------------------------------------------------------------

// QueryUserReq

// optional .CSToDB.MsgID msgid = 1 [default = eQueryUser_DBCallBack];
inline bool QueryUserReq::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void QueryUserReq::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 101;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::CSToDB::MsgID QueryUserReq::msgid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryUserReq.msgid)
  return _internal_msgid();
}
inline void QueryUserReq::set_msgid(::CSToDB::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryUserReq.msgid)
}
inline ::CSToDB::MsgID QueryUserReq::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::CSToDB::MsgID>(_impl_.msgid_);
}
inline void QueryUserReq::_internal_set_msgid(::CSToDB::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::CSToDB::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string Logininfo = 2;
inline bool QueryUserReq::has_logininfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryUserReq::clear_logininfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.logininfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryUserReq::logininfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.QueryUserReq.Logininfo)
  return _internal_logininfo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUserReq::set_logininfo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.logininfo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.QueryUserReq.Logininfo)
}
inline std::string* QueryUserReq::mutable_logininfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_logininfo();
  // @@protoc_insertion_point(field_mutable:CSToDB.QueryUserReq.Logininfo)
  return _s;
}
inline const std::string& QueryUserReq::_internal_logininfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.logininfo_.Get();
}
inline void QueryUserReq::_internal_set_logininfo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.logininfo_.Set(value, GetArena());
}
inline std::string* QueryUserReq::_internal_mutable_logininfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.logininfo_.Mutable( GetArena());
}
inline std::string* QueryUserReq::release_logininfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.QueryUserReq.Logininfo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.logininfo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.logininfo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUserReq::set_allocated_logininfo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.logininfo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.logininfo_.IsDefault()) {
          _impl_.logininfo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.QueryUserReq.Logininfo)
}

// optional int32 gsid = 3;
inline bool QueryUserReq::has_gsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryUserReq::clear_gsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t QueryUserReq::gsid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryUserReq.gsid)
  return _internal_gsid();
}
inline void QueryUserReq::set_gsid(::int32_t value) {
  _internal_set_gsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryUserReq.gsid)
}
inline ::int32_t QueryUserReq::_internal_gsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsid_;
}
inline void QueryUserReq::_internal_set_gsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = value;
}

// optional int32 gcnetid = 4;
inline bool QueryUserReq::has_gcnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryUserReq::clear_gcnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t QueryUserReq::gcnetid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryUserReq.gcnetid)
  return _internal_gcnetid();
}
inline void QueryUserReq::set_gcnetid(::int32_t value) {
  _internal_set_gcnetid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryUserReq.gcnetid)
}
inline ::int32_t QueryUserReq::_internal_gcnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gcnetid_;
}
inline void QueryUserReq::_internal_set_gcnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = value;
}

// optional int32 csid = 5;
inline bool QueryUserReq::has_csid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void QueryUserReq::clear_csid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t QueryUserReq::csid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryUserReq.csid)
  return _internal_csid();
}
inline void QueryUserReq::set_csid(::int32_t value) {
  _internal_set_csid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryUserReq.csid)
}
inline ::int32_t QueryUserReq::_internal_csid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.csid_;
}
inline void QueryUserReq::_internal_set_csid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = value;
}

// optional int64 objid = 6;
inline bool QueryUserReq::has_objid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QueryUserReq::clear_objid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t QueryUserReq::objid() const {
  // @@protoc_insertion_point(field_get:CSToDB.QueryUserReq.objid)
  return _internal_objid();
}
inline void QueryUserReq::set_objid(::int64_t value) {
  _internal_set_objid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:CSToDB.QueryUserReq.objid)
}
inline ::int64_t QueryUserReq::_internal_objid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objid_;
}
inline void QueryUserReq::_internal_set_objid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objid_ = value;
}

// optional string uname = 7;
inline bool QueryUserReq::has_uname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryUserReq::clear_uname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryUserReq::uname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:CSToDB.QueryUserReq.uname)
  return _internal_uname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUserReq::set_uname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:CSToDB.QueryUserReq.uname)
}
inline std::string* QueryUserReq::mutable_uname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_uname();
  // @@protoc_insertion_point(field_mutable:CSToDB.QueryUserReq.uname)
  return _s;
}
inline const std::string& QueryUserReq::_internal_uname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uname_.Get();
}
inline void QueryUserReq::_internal_set_uname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.uname_.Set(value, GetArena());
}
inline std::string* QueryUserReq::_internal_mutable_uname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.uname_.Mutable( GetArena());
}
inline std::string* QueryUserReq::release_uname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:CSToDB.QueryUserReq.uname)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.uname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.uname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUserReq::set_allocated_uname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.uname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.uname_.IsDefault()) {
          _impl_.uname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSToDB.QueryUserReq.uname)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace CSToDB


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::CSToDB::MsgID> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::CSToDB::MsgID>() {
  return ::CSToDB::MsgID_descriptor();
}
template <>
struct is_proto_enum<::CSToDB::MailType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::CSToDB::MailType>() {
  return ::CSToDB::MailType_descriptor();
}
template <>
struct is_proto_enum<::CSToDB::EMailCurtState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::CSToDB::EMailCurtState>() {
  return ::CSToDB::EMailCurtState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_CSToDB_2eproto_2epb_2eh
