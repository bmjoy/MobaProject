// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GCToSS.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_GCToSS_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_GCToSS_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_GCToSS_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_GCToSS_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_GCToSS_2eproto;
namespace GCToSS {
class Absorb;
struct AbsorbDefaultTypeInternal;
extern AbsorbDefaultTypeInternal _Absorb_default_instance_;
class AlwaysAutoAtk;
struct AlwaysAutoAtkDefaultTypeInternal;
extern AlwaysAutoAtkDefaultTypeInternal _AlwaysAutoAtk_default_instance_;
class AskBornNPC;
struct AskBornNPCDefaultTypeInternal;
extern AskBornNPCDefaultTypeInternal _AskBornNPC_default_instance_;
class AskEnterBattle;
struct AskEnterBattleDefaultTypeInternal;
extern AskEnterBattleDefaultTypeInternal _AskEnterBattle_default_instance_;
class AskHeroAttributesInfo;
struct AskHeroAttributesInfoDefaultTypeInternal;
extern AskHeroAttributesInfoDefaultTypeInternal _AskHeroAttributesInfo_default_instance_;
class AskPingSS;
struct AskPingSSDefaultTypeInternal;
extern AskPingSSDefaultTypeInternal _AskPingSS_default_instance_;
class AskQuickBattleEnd;
struct AskQuickBattleEndDefaultTypeInternal;
extern AskQuickBattleEndDefaultTypeInternal _AskQuickBattleEnd_default_instance_;
class AskReconnect;
struct AskReconnectDefaultTypeInternal;
extern AskReconnectDefaultTypeInternal _AskReconnect_default_instance_;
class AskSSGuideStepComp;
struct AskSSGuideStepCompDefaultTypeInternal;
extern AskSSGuideStepCompDefaultTypeInternal _AskSSGuideStepComp_default_instance_;
class AskSSGuideStepComp_taskinfo;
struct AskSSGuideStepComp_taskinfoDefaultTypeInternal;
extern AskSSGuideStepComp_taskinfoDefaultTypeInternal _AskSSGuideStepComp_taskinfo_default_instance_;
class AutoAtk;
struct AutoAtkDefaultTypeInternal;
extern AutoAtkDefaultTypeInternal _AutoAtk_default_instance_;
class BuReborn;
struct BuRebornDefaultTypeInternal;
extern BuRebornDefaultTypeInternal _BuReborn_default_instance_;
class BuyGoods;
struct BuyGoodsDefaultTypeInternal;
extern BuyGoodsDefaultTypeInternal _BuyGoods_default_instance_;
class Dir;
struct DirDefaultTypeInternal;
extern DirDefaultTypeInternal _Dir_default_instance_;
class GMCmd;
struct GMCmdDefaultTypeInternal;
extern GMCmdDefaultTypeInternal _GMCmd_default_instance_;
class GasExplosion;
struct GasExplosionDefaultTypeInternal;
extern GasExplosionDefaultTypeInternal _GasExplosion_default_instance_;
class GuideJumpToHall;
struct GuideJumpToHallDefaultTypeInternal;
extern GuideJumpToHallDefaultTypeInternal _GuideJumpToHall_default_instance_;
class HerosBattleInfo;
struct HerosBattleInfoDefaultTypeInternal;
extern HerosBattleInfoDefaultTypeInternal _HerosBattleInfo_default_instance_;
class LoadComplete;
struct LoadCompleteDefaultTypeInternal;
extern LoadCompleteDefaultTypeInternal _LoadComplete_default_instance_;
class LockTar;
struct LockTarDefaultTypeInternal;
extern LockTarDefaultTypeInternal _LockTar_default_instance_;
class MoveDir;
struct MoveDirDefaultTypeInternal;
extern MoveDirDefaultTypeInternal _MoveDir_default_instance_;
class MoveGoods;
struct MoveGoodsDefaultTypeInternal;
extern MoveGoodsDefaultTypeInternal _MoveGoods_default_instance_;
class MoveTar;
struct MoveTarDefaultTypeInternal;
extern MoveTarDefaultTypeInternal _MoveTar_default_instance_;
class Pos;
struct PosDefaultTypeInternal;
extern PosDefaultTypeInternal _Pos_default_instance_;
class ReportAltarStrawSolder;
struct ReportAltarStrawSolderDefaultTypeInternal;
extern ReportAltarStrawSolderDefaultTypeInternal _ReportAltarStrawSolder_default_instance_;
class ReportBattleLoadingState;
struct ReportBattleLoadingStateDefaultTypeInternal;
extern ReportBattleLoadingStateDefaultTypeInternal _ReportBattleLoadingState_default_instance_;
class SelectHero;
struct SelectHeroDefaultTypeInternal;
extern SelectHeroDefaultTypeInternal _SelectHero_default_instance_;
class SelectRunePage;
struct SelectRunePageDefaultTypeInternal;
extern SelectRunePageDefaultTypeInternal _SelectRunePage_default_instance_;
class SellGoods;
struct SellGoodsDefaultTypeInternal;
extern SellGoodsDefaultTypeInternal _SellGoods_default_instance_;
class StepID;
struct StepIDDefaultTypeInternal;
extern StepIDDefaultTypeInternal _StepID_default_instance_;
class StopMove;
struct StopMoveDefaultTypeInternal;
extern StopMoveDefaultTypeInternal _StopMove_default_instance_;
class TrySeleceHero;
struct TrySeleceHeroDefaultTypeInternal;
extern TrySeleceHeroDefaultTypeInternal _TrySeleceHero_default_instance_;
class UseGoods;
struct UseGoodsDefaultTypeInternal;
extern UseGoodsDefaultTypeInternal _UseGoods_default_instance_;
class UseSkill;
struct UseSkillDefaultTypeInternal;
extern UseSkillDefaultTypeInternal _UseSkill_default_instance_;
}  // namespace GCToSS
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace GCToSS {
enum AskSSGuideStepComp_edotype : int {
  AskSSGuideStepComp_edotype_ecomptask = 1,
  AskSSGuideStepComp_edotype_ebuygoods = 2,
  AskSSGuideStepComp_edotype_ebornsolder = 3,
  AskSSGuideStepComp_edotype_ebornhero = 4,
  AskSSGuideStepComp_edotype_nextstep = 5,
};

bool AskSSGuideStepComp_edotype_IsValid(int value);
extern const uint32_t AskSSGuideStepComp_edotype_internal_data_[];
constexpr AskSSGuideStepComp_edotype AskSSGuideStepComp_edotype_edotype_MIN = static_cast<AskSSGuideStepComp_edotype>(1);
constexpr AskSSGuideStepComp_edotype AskSSGuideStepComp_edotype_edotype_MAX = static_cast<AskSSGuideStepComp_edotype>(5);
constexpr int AskSSGuideStepComp_edotype_edotype_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
AskSSGuideStepComp_edotype_descriptor();
template <typename T>
const std::string& AskSSGuideStepComp_edotype_Name(T value) {
  static_assert(std::is_same<T, AskSSGuideStepComp_edotype>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to edotype_Name().");
  return AskSSGuideStepComp_edotype_Name(static_cast<AskSSGuideStepComp_edotype>(value));
}
template <>
inline const std::string& AskSSGuideStepComp_edotype_Name(AskSSGuideStepComp_edotype value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AskSSGuideStepComp_edotype_descriptor,
                                                 1, 5>(
      static_cast<int>(value));
}
inline bool AskSSGuideStepComp_edotype_Parse(absl::string_view name, AskSSGuideStepComp_edotype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AskSSGuideStepComp_edotype>(
      AskSSGuideStepComp_edotype_descriptor(), name, value);
}
enum MsgNum : int {
  eMsgToGSToSSFromGC_Begin = 16384,
  eMsgToGSToSSFromGC_AskPingSS = 16385,
  eMsgToGSToSSFromGC_AskEnterBattle = 16386,
  eMsgToGSToSSFromGC_AskMoveDir = 16387,
  eMsgToGSToSSFromGC_AskStopMove = 16388,
  eMsgToGSToSSFromGC_AskBuyGoods = 16389,
  eMsgToGSToSSFromGC_AskUseGoods = 16390,
  eMsgToGSToSSFromGC_AskSellGoods = 16391,
  eMsgToGSToSSFromGC_AskMoveGoods = 16392,
  eMsgToGSToSSFromGC_ReportBattleLoadingState = 16393,
  eMsgToGSToSSFromGC_AskAttack = 16394,
  eMsgToGSToSSFromGC_AskUseSkill = 16395,
  eMsgToGSToSSFromGC_AskLockTarget = 16396,
  eMsgToGSToSSFromGC_ReportAltarStrawSolder = 16397,
  eMsgToGSToSSFromGC_AskAbsorbMonster = 16398,
  eMsgToGSToSSFromGC_AskCancelAbsorbSkill = 16399,
  eMsgToGSToSSFromGC_AskGasExplosion = 16400,
  eMsgToGSToSSFromGC_AskBuyRebornHero = 16401,
  eMsgToGSToSSFromGC_GMCmd = 16402,
  eMsgToGSToSSFromGC_AskOBBattle = 16403,
  eMsgToGSToSSFromGC_StepId = 16404,
  eMsgToGSToSSFromGC_AskBornNPC = 16405,
  eMsgToGSToSSFromGC_AskAutoAttack = 16406,
  eMsgToGSToSSFromGC_AskGuideEndJumpToHall = 16407,
  eMsgToGSToSSFromGC_AskReconnect = 16408,
  eMsgToGSToSSFromGC_AskMovePos = 16409,
  eMsgToGSToSSFromGC_AskAlwaysAutoAtk = 16410,
  eMsgToSSFromGS_ReportSSMsg = 16411,
  eMsgToSSFromGS_AskQuickBattleEnd = 16412,
  eMsgToGSToSSFromGC_AskTrySelectHero = 16505,
  eMsgToGSToSSFromGC_AskSelectHero = 16506,
  eMsgToGSToSSFromGC_AskSelectRunePage = 16507,
  eMsgToGSToSSFromGC_ReportLoadBattleComplete = 16520,
  eMsgToGSToSSFromGC_AskHeroAttributesInfo = 16521,
  eMsgToGSToSSFromGC_AskHerosBattleInfo = 16522,
  eMsgToGSToSSFromGC_AskGuideStepComp = 16540,
  eMsgToGSToSSFromGC_End = 17000,
};

bool MsgNum_IsValid(int value);
extern const uint32_t MsgNum_internal_data_[];
constexpr MsgNum MsgNum_MIN = static_cast<MsgNum>(16384);
constexpr MsgNum MsgNum_MAX = static_cast<MsgNum>(17000);
constexpr int MsgNum_ARRAYSIZE = 17000 + 1;
const ::google::protobuf::EnumDescriptor*
MsgNum_descriptor();
template <typename T>
const std::string& MsgNum_Name(T value) {
  static_assert(std::is_same<T, MsgNum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgNum_Name().");
  return ::google::protobuf::internal::NameOfEnum(MsgNum_descriptor(), value);
}
inline bool MsgNum_Parse(absl::string_view name, MsgNum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgNum>(
      MsgNum_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UseSkill final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.UseSkill) */ {
 public:
  inline UseSkill() : UseSkill(nullptr) {}
  ~UseSkill() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseSkill(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseSkill(const UseSkill& from) : UseSkill(nullptr, from) {}
  inline UseSkill(UseSkill&& from) noexcept
      : UseSkill(nullptr, std::move(from)) {}
  inline UseSkill& operator=(const UseSkill& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseSkill& operator=(UseSkill&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseSkill& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseSkill* internal_default_instance() {
    return reinterpret_cast<const UseSkill*>(
        &_UseSkill_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(UseSkill& a, UseSkill& b) { a.Swap(&b); }
  inline void Swap(UseSkill* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseSkill* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseSkill* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UseSkill>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UseSkill& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UseSkill& from) { UseSkill::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UseSkill* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.UseSkill"; }

 protected:
  explicit UseSkill(::google::protobuf::Arena* arena);
  UseSkill(::google::protobuf::Arena* arena, const UseSkill& from);
  UseSkill(::google::protobuf::Arena* arena, UseSkill&& from) noexcept
      : UseSkill(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkillidFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskUseSkill];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.UseSkill)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t skillid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class UseGoods final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.UseGoods) */ {
 public:
  inline UseGoods() : UseGoods(nullptr) {}
  ~UseGoods() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UseGoods(
      ::google::protobuf::internal::ConstantInitialized);

  inline UseGoods(const UseGoods& from) : UseGoods(nullptr, from) {}
  inline UseGoods(UseGoods&& from) noexcept
      : UseGoods(nullptr, std::move(from)) {}
  inline UseGoods& operator=(const UseGoods& from) {
    CopyFrom(from);
    return *this;
  }
  inline UseGoods& operator=(UseGoods&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UseGoods& default_instance() {
    return *internal_default_instance();
  }
  static inline const UseGoods* internal_default_instance() {
    return reinterpret_cast<const UseGoods*>(
        &_UseGoods_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(UseGoods& a, UseGoods& b) { a.Swap(&b); }
  inline void Swap(UseGoods* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UseGoods* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UseGoods* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UseGoods>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UseGoods& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UseGoods& from) { UseGoods::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UseGoods* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.UseGoods"; }

 protected:
  explicit UseGoods(::google::protobuf::Arena* arena);
  UseGoods(::google::protobuf::Arena* arena, const UseGoods& from);
  UseGoods(::google::protobuf::Arena* arena, UseGoods&& from) noexcept
      : UseGoods(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGoodsposFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 goodspos = 3;
  bool has_goodspos() const;
  void clear_goodspos() ;
  ::int32_t goodspos() const;
  void set_goodspos(::int32_t value);

  private:
  ::int32_t _internal_goodspos() const;
  void _internal_set_goodspos(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskUseGoods];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.UseGoods)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t goodspos_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class TrySeleceHero final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.TrySeleceHero) */ {
 public:
  inline TrySeleceHero() : TrySeleceHero(nullptr) {}
  ~TrySeleceHero() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TrySeleceHero(
      ::google::protobuf::internal::ConstantInitialized);

  inline TrySeleceHero(const TrySeleceHero& from) : TrySeleceHero(nullptr, from) {}
  inline TrySeleceHero(TrySeleceHero&& from) noexcept
      : TrySeleceHero(nullptr, std::move(from)) {}
  inline TrySeleceHero& operator=(const TrySeleceHero& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrySeleceHero& operator=(TrySeleceHero&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrySeleceHero& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrySeleceHero* internal_default_instance() {
    return reinterpret_cast<const TrySeleceHero*>(
        &_TrySeleceHero_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(TrySeleceHero& a, TrySeleceHero& b) { a.Swap(&b); }
  inline void Swap(TrySeleceHero* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrySeleceHero* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrySeleceHero* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TrySeleceHero>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TrySeleceHero& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TrySeleceHero& from) { TrySeleceHero::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TrySeleceHero* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.TrySeleceHero"; }

 protected:
  explicit TrySeleceHero(::google::protobuf::Arena* arena);
  TrySeleceHero(::google::protobuf::Arena* arena, const TrySeleceHero& from);
  TrySeleceHero(::google::protobuf::Arena* arena, TrySeleceHero&& from) noexcept
      : TrySeleceHero(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeroidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional uint32 heroid = 2;
  bool has_heroid() const;
  void clear_heroid() ;
  ::uint32_t heroid() const;
  void set_heroid(::uint32_t value);

  private:
  ::uint32_t _internal_heroid() const;
  void _internal_set_heroid(::uint32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskTrySelectHero];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.TrySeleceHero)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t heroid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class StopMove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.StopMove) */ {
 public:
  inline StopMove() : StopMove(nullptr) {}
  ~StopMove() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StopMove(
      ::google::protobuf::internal::ConstantInitialized);

  inline StopMove(const StopMove& from) : StopMove(nullptr, from) {}
  inline StopMove(StopMove&& from) noexcept
      : StopMove(nullptr, std::move(from)) {}
  inline StopMove& operator=(const StopMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopMove& operator=(StopMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopMove* internal_default_instance() {
    return reinterpret_cast<const StopMove*>(
        &_StopMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(StopMove& a, StopMove& b) { a.Swap(&b); }
  inline void Swap(StopMove* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopMove* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StopMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StopMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StopMove& from) { StopMove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StopMove* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.StopMove"; }

 protected:
  explicit StopMove(::google::protobuf::Arena* arena);
  StopMove(::google::protobuf::Arena* arena, const StopMove& from);
  StopMove(::google::protobuf::Arena* arena, StopMove&& from) noexcept
      : StopMove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskStopMove];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.StopMove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class StepID final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.StepID) */ {
 public:
  inline StepID() : StepID(nullptr) {}
  ~StepID() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StepID(
      ::google::protobuf::internal::ConstantInitialized);

  inline StepID(const StepID& from) : StepID(nullptr, from) {}
  inline StepID(StepID&& from) noexcept
      : StepID(nullptr, std::move(from)) {}
  inline StepID& operator=(const StepID& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepID& operator=(StepID&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepID& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepID* internal_default_instance() {
    return reinterpret_cast<const StepID*>(
        &_StepID_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(StepID& a, StepID& b) { a.Swap(&b); }
  inline void Swap(StepID* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepID* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepID* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StepID>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StepID& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StepID& from) { StepID::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StepID* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.StepID"; }

 protected:
  explicit StepID(::google::protobuf::Arena* arena);
  StepID(::google::protobuf::Arena* arena, const StepID& from);
  StepID(::google::protobuf::Arena* arena, StepID&& from) noexcept
      : StepID(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStepidFieldNumber = 3,
    kTypeFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 stepid = 3;
  bool has_stepid() const;
  void clear_stepid() ;
  ::int32_t stepid() const;
  void set_stepid(::int32_t value);

  private:
  ::int32_t _internal_stepid() const;
  void _internal_set_stepid(::int32_t value);

  public:
  // optional int32 type = 4;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_StepId];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.StepID)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t stepid_;
    ::int32_t type_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class SellGoods final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.SellGoods) */ {
 public:
  inline SellGoods() : SellGoods(nullptr) {}
  ~SellGoods() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SellGoods(
      ::google::protobuf::internal::ConstantInitialized);

  inline SellGoods(const SellGoods& from) : SellGoods(nullptr, from) {}
  inline SellGoods(SellGoods&& from) noexcept
      : SellGoods(nullptr, std::move(from)) {}
  inline SellGoods& operator=(const SellGoods& from) {
    CopyFrom(from);
    return *this;
  }
  inline SellGoods& operator=(SellGoods&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SellGoods& default_instance() {
    return *internal_default_instance();
  }
  static inline const SellGoods* internal_default_instance() {
    return reinterpret_cast<const SellGoods*>(
        &_SellGoods_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SellGoods& a, SellGoods& b) { a.Swap(&b); }
  inline void Swap(SellGoods* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SellGoods* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SellGoods* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SellGoods>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SellGoods& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SellGoods& from) { SellGoods::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SellGoods* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.SellGoods"; }

 protected:
  explicit SellGoods(::google::protobuf::Arena* arena);
  SellGoods(::google::protobuf::Arena* arena, const SellGoods& from);
  SellGoods(::google::protobuf::Arena* arena, SellGoods&& from) noexcept
      : SellGoods(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGoodsposFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 goodspos = 3;
  bool has_goodspos() const;
  void clear_goodspos() ;
  ::int32_t goodspos() const;
  void set_goodspos(::int32_t value);

  private:
  ::int32_t _internal_goodspos() const;
  void _internal_set_goodspos(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskSellGoods];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.SellGoods)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t goodspos_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class SelectRunePage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.SelectRunePage) */ {
 public:
  inline SelectRunePage() : SelectRunePage(nullptr) {}
  ~SelectRunePage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SelectRunePage(
      ::google::protobuf::internal::ConstantInitialized);

  inline SelectRunePage(const SelectRunePage& from) : SelectRunePage(nullptr, from) {}
  inline SelectRunePage(SelectRunePage&& from) noexcept
      : SelectRunePage(nullptr, std::move(from)) {}
  inline SelectRunePage& operator=(const SelectRunePage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectRunePage& operator=(SelectRunePage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectRunePage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectRunePage* internal_default_instance() {
    return reinterpret_cast<const SelectRunePage*>(
        &_SelectRunePage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(SelectRunePage& a, SelectRunePage& b) { a.Swap(&b); }
  inline void Swap(SelectRunePage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectRunePage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectRunePage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SelectRunePage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SelectRunePage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SelectRunePage& from) { SelectRunePage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SelectRunePage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.SelectRunePage"; }

 protected:
  explicit SelectRunePage(::google::protobuf::Arena* arena);
  SelectRunePage(::google::protobuf::Arena* arena, const SelectRunePage& from);
  SelectRunePage(::google::protobuf::Arena* arena, SelectRunePage&& from) noexcept
      : SelectRunePage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageindexFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 pageindex = 2;
  bool has_pageindex() const;
  void clear_pageindex() ;
  ::int32_t pageindex() const;
  void set_pageindex(::int32_t value);

  private:
  ::int32_t _internal_pageindex() const;
  void _internal_set_pageindex(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskSelectRunePage];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.SelectRunePage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t pageindex_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class SelectHero final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.SelectHero) */ {
 public:
  inline SelectHero() : SelectHero(nullptr) {}
  ~SelectHero() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SelectHero(
      ::google::protobuf::internal::ConstantInitialized);

  inline SelectHero(const SelectHero& from) : SelectHero(nullptr, from) {}
  inline SelectHero(SelectHero&& from) noexcept
      : SelectHero(nullptr, std::move(from)) {}
  inline SelectHero& operator=(const SelectHero& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectHero& operator=(SelectHero&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectHero& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectHero* internal_default_instance() {
    return reinterpret_cast<const SelectHero*>(
        &_SelectHero_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(SelectHero& a, SelectHero& b) { a.Swap(&b); }
  inline void Swap(SelectHero* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectHero* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectHero* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SelectHero>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SelectHero& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SelectHero& from) { SelectHero::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SelectHero* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.SelectHero"; }

 protected:
  explicit SelectHero(::google::protobuf::Arena* arena);
  SelectHero(::google::protobuf::Arena* arena, const SelectHero& from);
  SelectHero(::google::protobuf::Arena* arena, SelectHero&& from) noexcept
      : SelectHero(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeroidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 heroid = 2;
  bool has_heroid() const;
  void clear_heroid() ;
  ::int32_t heroid() const;
  void set_heroid(::int32_t value);

  private:
  ::int32_t _internal_heroid() const;
  void _internal_set_heroid(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskSelectHero];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.SelectHero)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t heroid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class ReportBattleLoadingState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.ReportBattleLoadingState) */ {
 public:
  inline ReportBattleLoadingState() : ReportBattleLoadingState(nullptr) {}
  ~ReportBattleLoadingState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportBattleLoadingState(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportBattleLoadingState(const ReportBattleLoadingState& from) : ReportBattleLoadingState(nullptr, from) {}
  inline ReportBattleLoadingState(ReportBattleLoadingState&& from) noexcept
      : ReportBattleLoadingState(nullptr, std::move(from)) {}
  inline ReportBattleLoadingState& operator=(const ReportBattleLoadingState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBattleLoadingState& operator=(ReportBattleLoadingState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBattleLoadingState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBattleLoadingState* internal_default_instance() {
    return reinterpret_cast<const ReportBattleLoadingState*>(
        &_ReportBattleLoadingState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ReportBattleLoadingState& a, ReportBattleLoadingState& b) { a.Swap(&b); }
  inline void Swap(ReportBattleLoadingState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBattleLoadingState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBattleLoadingState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReportBattleLoadingState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportBattleLoadingState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportBattleLoadingState& from) { ReportBattleLoadingState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportBattleLoadingState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.ReportBattleLoadingState"; }

 protected:
  explicit ReportBattleLoadingState(::google::protobuf::Arena* arena);
  ReportBattleLoadingState(::google::protobuf::Arena* arena, const ReportBattleLoadingState& from);
  ReportBattleLoadingState(::google::protobuf::Arena* arena, ReportBattleLoadingState&& from) noexcept
      : ReportBattleLoadingState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLoadingnumFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 loadingnum = 3;
  bool has_loadingnum() const;
  void clear_loadingnum() ;
  ::int32_t loadingnum() const;
  void set_loadingnum(::int32_t value);

  private:
  ::int32_t _internal_loadingnum() const;
  void _internal_set_loadingnum(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_ReportBattleLoadingState];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.ReportBattleLoadingState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t loadingnum_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class ReportAltarStrawSolder final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.ReportAltarStrawSolder) */ {
 public:
  inline ReportAltarStrawSolder() : ReportAltarStrawSolder(nullptr) {}
  ~ReportAltarStrawSolder() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportAltarStrawSolder(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportAltarStrawSolder(const ReportAltarStrawSolder& from) : ReportAltarStrawSolder(nullptr, from) {}
  inline ReportAltarStrawSolder(ReportAltarStrawSolder&& from) noexcept
      : ReportAltarStrawSolder(nullptr, std::move(from)) {}
  inline ReportAltarStrawSolder& operator=(const ReportAltarStrawSolder& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportAltarStrawSolder& operator=(ReportAltarStrawSolder&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportAltarStrawSolder& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportAltarStrawSolder* internal_default_instance() {
    return reinterpret_cast<const ReportAltarStrawSolder*>(
        &_ReportAltarStrawSolder_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(ReportAltarStrawSolder& a, ReportAltarStrawSolder& b) { a.Swap(&b); }
  inline void Swap(ReportAltarStrawSolder* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportAltarStrawSolder* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportAltarStrawSolder* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReportAltarStrawSolder>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportAltarStrawSolder& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportAltarStrawSolder& from) { ReportAltarStrawSolder::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportAltarStrawSolder* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.ReportAltarStrawSolder"; }

 protected:
  explicit ReportAltarStrawSolder(::google::protobuf::Arena* arena);
  ReportAltarStrawSolder(::google::protobuf::Arena* arena, const ReportAltarStrawSolder& from);
  ReportAltarStrawSolder(::google::protobuf::Arena* arena, ReportAltarStrawSolder&& from) noexcept
      : ReportAltarStrawSolder(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 2,
    kIndexFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 type = 2;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional int32 index = 3;
  bool has_index() const;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_ReportAltarStrawSolder];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.ReportAltarStrawSolder)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t type_;
    ::int32_t index_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class Pos final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.Pos) */ {
 public:
  inline Pos() : Pos(nullptr) {}
  ~Pos() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pos(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pos(const Pos& from) : Pos(nullptr, from) {}
  inline Pos(Pos&& from) noexcept
      : Pos(nullptr, std::move(from)) {}
  inline Pos& operator=(const Pos& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pos& operator=(Pos&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pos& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pos* internal_default_instance() {
    return reinterpret_cast<const Pos*>(
        &_Pos_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(Pos& a, Pos& b) { a.Swap(&b); }
  inline void Swap(Pos* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pos* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pos* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Pos>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pos& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pos& from) { Pos::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pos* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.Pos"; }

 protected:
  explicit Pos(::google::protobuf::Arena* arena);
  Pos(::google::protobuf::Arena* arena, const Pos& from);
  Pos(::google::protobuf::Arena* arena, Pos&& from) noexcept
      : Pos(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kZFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // optional float z = 2;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.Pos)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class MoveGoods final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.MoveGoods) */ {
 public:
  inline MoveGoods() : MoveGoods(nullptr) {}
  ~MoveGoods() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveGoods(
      ::google::protobuf::internal::ConstantInitialized);

  inline MoveGoods(const MoveGoods& from) : MoveGoods(nullptr, from) {}
  inline MoveGoods(MoveGoods&& from) noexcept
      : MoveGoods(nullptr, std::move(from)) {}
  inline MoveGoods& operator=(const MoveGoods& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveGoods& operator=(MoveGoods&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveGoods& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveGoods* internal_default_instance() {
    return reinterpret_cast<const MoveGoods*>(
        &_MoveGoods_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(MoveGoods& a, MoveGoods& b) { a.Swap(&b); }
  inline void Swap(MoveGoods* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveGoods* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveGoods* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MoveGoods>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveGoods& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveGoods& from) { MoveGoods::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveGoods* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.MoveGoods"; }

 protected:
  explicit MoveGoods(::google::protobuf::Arena* arena);
  MoveGoods(::google::protobuf::Arena* arena, const MoveGoods& from);
  MoveGoods(::google::protobuf::Arena* arena, MoveGoods&& from) noexcept
      : MoveGoods(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromposFieldNumber = 3,
    kToposFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 frompos = 3;
  bool has_frompos() const;
  void clear_frompos() ;
  ::int32_t frompos() const;
  void set_frompos(::int32_t value);

  private:
  ::int32_t _internal_frompos() const;
  void _internal_set_frompos(::int32_t value);

  public:
  // optional int32 topos = 4;
  bool has_topos() const;
  void clear_topos() ;
  ::int32_t topos() const;
  void set_topos(::int32_t value);

  private:
  ::int32_t _internal_topos() const;
  void _internal_set_topos(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskMoveGoods];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.MoveGoods)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t frompos_;
    ::int32_t topos_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class LockTar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.LockTar) */ {
 public:
  inline LockTar() : LockTar(nullptr) {}
  ~LockTar() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LockTar(
      ::google::protobuf::internal::ConstantInitialized);

  inline LockTar(const LockTar& from) : LockTar(nullptr, from) {}
  inline LockTar(LockTar&& from) noexcept
      : LockTar(nullptr, std::move(from)) {}
  inline LockTar& operator=(const LockTar& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockTar& operator=(LockTar&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LockTar& default_instance() {
    return *internal_default_instance();
  }
  static inline const LockTar* internal_default_instance() {
    return reinterpret_cast<const LockTar*>(
        &_LockTar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(LockTar& a, LockTar& b) { a.Swap(&b); }
  inline void Swap(LockTar* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockTar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LockTar* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LockTar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LockTar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LockTar& from) { LockTar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LockTar* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.LockTar"; }

 protected:
  explicit LockTar(::google::protobuf::Arena* arena);
  LockTar(::google::protobuf::Arena* arena, const LockTar& from);
  LockTar(::google::protobuf::Arena* arena, LockTar&& from) noexcept
      : LockTar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int64 guid = 3;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskLockTarget];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.LockTar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t guid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class LoadComplete final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.LoadComplete) */ {
 public:
  inline LoadComplete() : LoadComplete(nullptr) {}
  ~LoadComplete() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LoadComplete(
      ::google::protobuf::internal::ConstantInitialized);

  inline LoadComplete(const LoadComplete& from) : LoadComplete(nullptr, from) {}
  inline LoadComplete(LoadComplete&& from) noexcept
      : LoadComplete(nullptr, std::move(from)) {}
  inline LoadComplete& operator=(const LoadComplete& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoadComplete& operator=(LoadComplete&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoadComplete& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoadComplete* internal_default_instance() {
    return reinterpret_cast<const LoadComplete*>(
        &_LoadComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(LoadComplete& a, LoadComplete& b) { a.Swap(&b); }
  inline void Swap(LoadComplete* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoadComplete* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoadComplete* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LoadComplete>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoadComplete& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LoadComplete& from) { LoadComplete::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoadComplete* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.LoadComplete"; }

 protected:
  explicit LoadComplete(::google::protobuf::Arena* arena);
  LoadComplete(::google::protobuf::Arena* arena, const LoadComplete& from);
  LoadComplete(::google::protobuf::Arena* arena, LoadComplete&& from) noexcept
      : LoadComplete(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_ReportLoadBattleComplete];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.LoadComplete)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class HerosBattleInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.HerosBattleInfo) */ {
 public:
  inline HerosBattleInfo() : HerosBattleInfo(nullptr) {}
  ~HerosBattleInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HerosBattleInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline HerosBattleInfo(const HerosBattleInfo& from) : HerosBattleInfo(nullptr, from) {}
  inline HerosBattleInfo(HerosBattleInfo&& from) noexcept
      : HerosBattleInfo(nullptr, std::move(from)) {}
  inline HerosBattleInfo& operator=(const HerosBattleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HerosBattleInfo& operator=(HerosBattleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HerosBattleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HerosBattleInfo* internal_default_instance() {
    return reinterpret_cast<const HerosBattleInfo*>(
        &_HerosBattleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(HerosBattleInfo& a, HerosBattleInfo& b) { a.Swap(&b); }
  inline void Swap(HerosBattleInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HerosBattleInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HerosBattleInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HerosBattleInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HerosBattleInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HerosBattleInfo& from) { HerosBattleInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HerosBattleInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.HerosBattleInfo"; }

 protected:
  explicit HerosBattleInfo(::google::protobuf::Arena* arena);
  HerosBattleInfo(::google::protobuf::Arena* arena, const HerosBattleInfo& from);
  HerosBattleInfo(::google::protobuf::Arena* arena, HerosBattleInfo&& from) noexcept
      : HerosBattleInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgid = 1 [default = eMsgToGSToSSFromGC_AskHerosBattleInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GCToSS::MsgNum msgid() const;
  void set_msgid(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgid() const;
  void _internal_set_msgid(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.HerosBattleInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class GuideJumpToHall final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.GuideJumpToHall) */ {
 public:
  inline GuideJumpToHall() : GuideJumpToHall(nullptr) {}
  ~GuideJumpToHall() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideJumpToHall(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideJumpToHall(const GuideJumpToHall& from) : GuideJumpToHall(nullptr, from) {}
  inline GuideJumpToHall(GuideJumpToHall&& from) noexcept
      : GuideJumpToHall(nullptr, std::move(from)) {}
  inline GuideJumpToHall& operator=(const GuideJumpToHall& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideJumpToHall& operator=(GuideJumpToHall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideJumpToHall& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideJumpToHall* internal_default_instance() {
    return reinterpret_cast<const GuideJumpToHall*>(
        &_GuideJumpToHall_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(GuideJumpToHall& a, GuideJumpToHall& b) { a.Swap(&b); }
  inline void Swap(GuideJumpToHall* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideJumpToHall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideJumpToHall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideJumpToHall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideJumpToHall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideJumpToHall& from) { GuideJumpToHall::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideJumpToHall* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.GuideJumpToHall"; }

 protected:
  explicit GuideJumpToHall(::google::protobuf::Arena* arena);
  GuideJumpToHall(::google::protobuf::Arena* arena, const GuideJumpToHall& from);
  GuideJumpToHall(::google::protobuf::Arena* arena, GuideJumpToHall&& from) noexcept
      : GuideJumpToHall(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskGuideEndJumpToHall];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.GuideJumpToHall)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class GasExplosion final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.GasExplosion) */ {
 public:
  inline GasExplosion() : GasExplosion(nullptr) {}
  ~GasExplosion() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GasExplosion(
      ::google::protobuf::internal::ConstantInitialized);

  inline GasExplosion(const GasExplosion& from) : GasExplosion(nullptr, from) {}
  inline GasExplosion(GasExplosion&& from) noexcept
      : GasExplosion(nullptr, std::move(from)) {}
  inline GasExplosion& operator=(const GasExplosion& from) {
    CopyFrom(from);
    return *this;
  }
  inline GasExplosion& operator=(GasExplosion&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GasExplosion& default_instance() {
    return *internal_default_instance();
  }
  static inline const GasExplosion* internal_default_instance() {
    return reinterpret_cast<const GasExplosion*>(
        &_GasExplosion_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(GasExplosion& a, GasExplosion& b) { a.Swap(&b); }
  inline void Swap(GasExplosion* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GasExplosion* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GasExplosion* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GasExplosion>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GasExplosion& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GasExplosion& from) { GasExplosion::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GasExplosion* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.GasExplosion"; }

 protected:
  explicit GasExplosion(::google::protobuf::Arena* arena);
  GasExplosion(::google::protobuf::Arena* arena, const GasExplosion& from);
  GasExplosion(::google::protobuf::Arena* arena, GasExplosion&& from) noexcept
      : GasExplosion(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskGasExplosion];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.GasExplosion)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class GMCmd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.GMCmd) */ {
 public:
  inline GMCmd() : GMCmd(nullptr) {}
  ~GMCmd() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GMCmd(
      ::google::protobuf::internal::ConstantInitialized);

  inline GMCmd(const GMCmd& from) : GMCmd(nullptr, from) {}
  inline GMCmd(GMCmd&& from) noexcept
      : GMCmd(nullptr, std::move(from)) {}
  inline GMCmd& operator=(const GMCmd& from) {
    CopyFrom(from);
    return *this;
  }
  inline GMCmd& operator=(GMCmd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GMCmd& default_instance() {
    return *internal_default_instance();
  }
  static inline const GMCmd* internal_default_instance() {
    return reinterpret_cast<const GMCmd*>(
        &_GMCmd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(GMCmd& a, GMCmd& b) { a.Swap(&b); }
  inline void Swap(GMCmd* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GMCmd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GMCmd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GMCmd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GMCmd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GMCmd& from) { GMCmd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GMCmd* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.GMCmd"; }

 protected:
  explicit GMCmd(::google::protobuf::Arena* arena);
  GMCmd(::google::protobuf::Arena* arena, const GMCmd& from);
  GMCmd(::google::protobuf::Arena* arena, GMCmd&& from) noexcept
      : GMCmd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCmdFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string cmd = 2;
  bool has_cmd() const;
  void clear_cmd() ;
  const std::string& cmd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cmd(Arg_&& arg, Args_... args);
  std::string* mutable_cmd();
  PROTOBUF_NODISCARD std::string* release_cmd();
  void set_allocated_cmd(std::string* value);

  private:
  const std::string& _internal_cmd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cmd(
      const std::string& value);
  std::string* _internal_mutable_cmd();

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_GMCmd];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.GMCmd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      24, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr cmd_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class Dir final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.Dir) */ {
 public:
  inline Dir() : Dir(nullptr) {}
  ~Dir() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Dir(
      ::google::protobuf::internal::ConstantInitialized);

  inline Dir(const Dir& from) : Dir(nullptr, from) {}
  inline Dir(Dir&& from) noexcept
      : Dir(nullptr, std::move(from)) {}
  inline Dir& operator=(const Dir& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dir& operator=(Dir&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dir& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dir* internal_default_instance() {
    return reinterpret_cast<const Dir*>(
        &_Dir_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Dir& a, Dir& b) { a.Swap(&b); }
  inline void Swap(Dir* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dir* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dir* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Dir>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dir& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Dir& from) { Dir::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Dir* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.Dir"; }

 protected:
  explicit Dir(::google::protobuf::Arena* arena);
  Dir(::google::protobuf::Arena* arena, const Dir& from);
  Dir(::google::protobuf::Arena* arena, Dir&& from) noexcept
      : Dir(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kZFieldNumber = 2,
    kAngleFieldNumber = 3,
  };
  // optional float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // optional float z = 2;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // optional float angle = 3;
  bool has_angle() const;
  void clear_angle() ;
  float angle() const;
  void set_angle(float value);

  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.Dir)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float z_;
    float angle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class BuyGoods final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.BuyGoods) */ {
 public:
  inline BuyGoods() : BuyGoods(nullptr) {}
  ~BuyGoods() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuyGoods(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuyGoods(const BuyGoods& from) : BuyGoods(nullptr, from) {}
  inline BuyGoods(BuyGoods&& from) noexcept
      : BuyGoods(nullptr, std::move(from)) {}
  inline BuyGoods& operator=(const BuyGoods& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyGoods& operator=(BuyGoods&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyGoods& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyGoods* internal_default_instance() {
    return reinterpret_cast<const BuyGoods*>(
        &_BuyGoods_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(BuyGoods& a, BuyGoods& b) { a.Swap(&b); }
  inline void Swap(BuyGoods* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyGoods* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyGoods* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BuyGoods>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuyGoods& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuyGoods& from) { BuyGoods::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuyGoods* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.BuyGoods"; }

 protected:
  explicit BuyGoods(::google::protobuf::Arena* arena);
  BuyGoods(::google::protobuf::Arena* arena, const BuyGoods& from);
  BuyGoods(::google::protobuf::Arena* arena, BuyGoods&& from) noexcept
      : BuyGoods(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeidFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 typeid = 3;
  bool has_typeid_() const;
  void clear_typeid_() ;
  ::int32_t typeid_() const;
  void set_typeid_(::int32_t value);

  private:
  ::int32_t _internal_typeid_() const;
  void _internal_set_typeid_(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskBuyGoods];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.BuyGoods)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t typeid__;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class BuReborn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.BuReborn) */ {
 public:
  inline BuReborn() : BuReborn(nullptr) {}
  ~BuReborn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuReborn(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuReborn(const BuReborn& from) : BuReborn(nullptr, from) {}
  inline BuReborn(BuReborn&& from) noexcept
      : BuReborn(nullptr, std::move(from)) {}
  inline BuReborn& operator=(const BuReborn& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuReborn& operator=(BuReborn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuReborn& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuReborn* internal_default_instance() {
    return reinterpret_cast<const BuReborn*>(
        &_BuReborn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(BuReborn& a, BuReborn& b) { a.Swap(&b); }
  inline void Swap(BuReborn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuReborn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuReborn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BuReborn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuReborn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuReborn& from) { BuReborn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuReborn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.BuReborn"; }

 protected:
  explicit BuReborn(::google::protobuf::Arena* arena);
  BuReborn(::google::protobuf::Arena* arena, const BuReborn& from);
  BuReborn(::google::protobuf::Arena* arena, BuReborn&& from) noexcept
      : BuReborn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskBuyRebornHero];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.BuReborn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AutoAtk final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AutoAtk) */ {
 public:
  inline AutoAtk() : AutoAtk(nullptr) {}
  ~AutoAtk() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AutoAtk(
      ::google::protobuf::internal::ConstantInitialized);

  inline AutoAtk(const AutoAtk& from) : AutoAtk(nullptr, from) {}
  inline AutoAtk(AutoAtk&& from) noexcept
      : AutoAtk(nullptr, std::move(from)) {}
  inline AutoAtk& operator=(const AutoAtk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoAtk& operator=(AutoAtk&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoAtk& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoAtk* internal_default_instance() {
    return reinterpret_cast<const AutoAtk*>(
        &_AutoAtk_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(AutoAtk& a, AutoAtk& b) { a.Swap(&b); }
  inline void Swap(AutoAtk* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoAtk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoAtk* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AutoAtk>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AutoAtk& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AutoAtk& from) { AutoAtk::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AutoAtk* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AutoAtk"; }

 protected:
  explicit AutoAtk(::google::protobuf::Arena* arena);
  AutoAtk(::google::protobuf::Arena* arena, const AutoAtk& from);
  AutoAtk(::google::protobuf::Arena* arena, AutoAtk&& from) noexcept
      : AutoAtk(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskAutoAttack];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AutoAtk)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskSSGuideStepComp_taskinfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskSSGuideStepComp.taskinfo) */ {
 public:
  inline AskSSGuideStepComp_taskinfo() : AskSSGuideStepComp_taskinfo(nullptr) {}
  ~AskSSGuideStepComp_taskinfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSSGuideStepComp_taskinfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSSGuideStepComp_taskinfo(const AskSSGuideStepComp_taskinfo& from) : AskSSGuideStepComp_taskinfo(nullptr, from) {}
  inline AskSSGuideStepComp_taskinfo(AskSSGuideStepComp_taskinfo&& from) noexcept
      : AskSSGuideStepComp_taskinfo(nullptr, std::move(from)) {}
  inline AskSSGuideStepComp_taskinfo& operator=(const AskSSGuideStepComp_taskinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSSGuideStepComp_taskinfo& operator=(AskSSGuideStepComp_taskinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSSGuideStepComp_taskinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSSGuideStepComp_taskinfo* internal_default_instance() {
    return reinterpret_cast<const AskSSGuideStepComp_taskinfo*>(
        &_AskSSGuideStepComp_taskinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(AskSSGuideStepComp_taskinfo& a, AskSSGuideStepComp_taskinfo& b) { a.Swap(&b); }
  inline void Swap(AskSSGuideStepComp_taskinfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSSGuideStepComp_taskinfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSSGuideStepComp_taskinfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSSGuideStepComp_taskinfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSSGuideStepComp_taskinfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSSGuideStepComp_taskinfo& from) { AskSSGuideStepComp_taskinfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSSGuideStepComp_taskinfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskSSGuideStepComp.taskinfo"; }

 protected:
  explicit AskSSGuideStepComp_taskinfo(::google::protobuf::Arena* arena);
  AskSSGuideStepComp_taskinfo(::google::protobuf::Arena* arena, const AskSSGuideStepComp_taskinfo& from);
  AskSSGuideStepComp_taskinfo(::google::protobuf::Arena* arena, AskSSGuideStepComp_taskinfo&& from) noexcept
      : AskSSGuideStepComp_taskinfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStepidFieldNumber = 2,
    kDtypeFieldNumber = 1,
  };
  // optional int32 stepid = 2;
  bool has_stepid() const;
  void clear_stepid() ;
  ::int32_t stepid() const;
  void set_stepid(::int32_t value);

  private:
  ::int32_t _internal_stepid() const;
  void _internal_set_stepid(::int32_t value);

  public:
  // optional .GCToSS.AskSSGuideStepComp.edotype dtype = 1;
  bool has_dtype() const;
  void clear_dtype() ;
  ::GCToSS::AskSSGuideStepComp_edotype dtype() const;
  void set_dtype(::GCToSS::AskSSGuideStepComp_edotype value);

  private:
  ::GCToSS::AskSSGuideStepComp_edotype _internal_dtype() const;
  void _internal_set_dtype(::GCToSS::AskSSGuideStepComp_edotype value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskSSGuideStepComp.taskinfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t stepid_;
    int dtype_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskReconnect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskReconnect) */ {
 public:
  inline AskReconnect() : AskReconnect(nullptr) {}
  ~AskReconnect() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskReconnect(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskReconnect(const AskReconnect& from) : AskReconnect(nullptr, from) {}
  inline AskReconnect(AskReconnect&& from) noexcept
      : AskReconnect(nullptr, std::move(from)) {}
  inline AskReconnect& operator=(const AskReconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskReconnect& operator=(AskReconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskReconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskReconnect* internal_default_instance() {
    return reinterpret_cast<const AskReconnect*>(
        &_AskReconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(AskReconnect& a, AskReconnect& b) { a.Swap(&b); }
  inline void Swap(AskReconnect* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskReconnect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskReconnect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskReconnect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskReconnect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskReconnect& from) { AskReconnect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskReconnect* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskReconnect"; }

 protected:
  explicit AskReconnect(::google::protobuf::Arena* arena);
  AskReconnect(::google::protobuf::Arena* arena, const AskReconnect& from);
  AskReconnect(::google::protobuf::Arena* arena, AskReconnect&& from) noexcept
      : AskReconnect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskReconnect];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskReconnect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskQuickBattleEnd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskQuickBattleEnd) */ {
 public:
  inline AskQuickBattleEnd() : AskQuickBattleEnd(nullptr) {}
  ~AskQuickBattleEnd() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskQuickBattleEnd(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskQuickBattleEnd(const AskQuickBattleEnd& from) : AskQuickBattleEnd(nullptr, from) {}
  inline AskQuickBattleEnd(AskQuickBattleEnd&& from) noexcept
      : AskQuickBattleEnd(nullptr, std::move(from)) {}
  inline AskQuickBattleEnd& operator=(const AskQuickBattleEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskQuickBattleEnd& operator=(AskQuickBattleEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskQuickBattleEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskQuickBattleEnd* internal_default_instance() {
    return reinterpret_cast<const AskQuickBattleEnd*>(
        &_AskQuickBattleEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AskQuickBattleEnd& a, AskQuickBattleEnd& b) { a.Swap(&b); }
  inline void Swap(AskQuickBattleEnd* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskQuickBattleEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskQuickBattleEnd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskQuickBattleEnd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskQuickBattleEnd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskQuickBattleEnd& from) { AskQuickBattleEnd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskQuickBattleEnd* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskQuickBattleEnd"; }

 protected:
  explicit AskQuickBattleEnd(::google::protobuf::Arena* arena);
  AskQuickBattleEnd(::google::protobuf::Arena* arena, const AskQuickBattleEnd& from);
  AskQuickBattleEnd(::google::protobuf::Arena* arena, AskQuickBattleEnd&& from) noexcept
      : AskQuickBattleEnd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOtherFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int32 other = 2;
  bool has_other() const;
  void clear_other() ;
  ::int32_t other() const;
  void set_other(::int32_t value);

  private:
  ::int32_t _internal_other() const;
  void _internal_set_other(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgid = 1 [default = eMsgToSSFromGS_AskQuickBattleEnd];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GCToSS::MsgNum msgid() const;
  void set_msgid(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgid() const;
  void _internal_set_msgid(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskQuickBattleEnd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t other_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskPingSS final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskPingSS) */ {
 public:
  inline AskPingSS() : AskPingSS(nullptr) {}
  ~AskPingSS() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskPingSS(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskPingSS(const AskPingSS& from) : AskPingSS(nullptr, from) {}
  inline AskPingSS(AskPingSS&& from) noexcept
      : AskPingSS(nullptr, std::move(from)) {}
  inline AskPingSS& operator=(const AskPingSS& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskPingSS& operator=(AskPingSS&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskPingSS& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskPingSS* internal_default_instance() {
    return reinterpret_cast<const AskPingSS*>(
        &_AskPingSS_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(AskPingSS& a, AskPingSS& b) { a.Swap(&b); }
  inline void Swap(AskPingSS* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskPingSS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskPingSS* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskPingSS>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskPingSS& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskPingSS& from) { AskPingSS::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskPingSS* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskPingSS"; }

 protected:
  explicit AskPingSS(::google::protobuf::Arena* arena);
  AskPingSS(::google::protobuf::Arena* arena, const AskPingSS& from);
  AskPingSS(::google::protobuf::Arena* arena, AskPingSS&& from) noexcept
      : AskPingSS(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional int64 time = 2;
  bool has_time() const;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskPingSS];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskPingSS)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t time_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskHeroAttributesInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskHeroAttributesInfo) */ {
 public:
  inline AskHeroAttributesInfo() : AskHeroAttributesInfo(nullptr) {}
  ~AskHeroAttributesInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskHeroAttributesInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskHeroAttributesInfo(const AskHeroAttributesInfo& from) : AskHeroAttributesInfo(nullptr, from) {}
  inline AskHeroAttributesInfo(AskHeroAttributesInfo&& from) noexcept
      : AskHeroAttributesInfo(nullptr, std::move(from)) {}
  inline AskHeroAttributesInfo& operator=(const AskHeroAttributesInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskHeroAttributesInfo& operator=(AskHeroAttributesInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskHeroAttributesInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskHeroAttributesInfo* internal_default_instance() {
    return reinterpret_cast<const AskHeroAttributesInfo*>(
        &_AskHeroAttributesInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AskHeroAttributesInfo& a, AskHeroAttributesInfo& b) { a.Swap(&b); }
  inline void Swap(AskHeroAttributesInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskHeroAttributesInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskHeroAttributesInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskHeroAttributesInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskHeroAttributesInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskHeroAttributesInfo& from) { AskHeroAttributesInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskHeroAttributesInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskHeroAttributesInfo"; }

 protected:
  explicit AskHeroAttributesInfo(::google::protobuf::Arena* arena);
  AskHeroAttributesInfo(::google::protobuf::Arena* arena, const AskHeroAttributesInfo& from);
  AskHeroAttributesInfo(::google::protobuf::Arena* arena, AskHeroAttributesInfo&& from) noexcept
      : AskHeroAttributesInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GCToSS.MsgNum msgid = 1 [default = eMsgToGSToSSFromGC_AskHeroAttributesInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GCToSS::MsgNum msgid() const;
  void set_msgid(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgid() const;
  void _internal_set_msgid(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskHeroAttributesInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskEnterBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskEnterBattle) */ {
 public:
  inline AskEnterBattle() : AskEnterBattle(nullptr) {}
  ~AskEnterBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskEnterBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskEnterBattle(const AskEnterBattle& from) : AskEnterBattle(nullptr, from) {}
  inline AskEnterBattle(AskEnterBattle&& from) noexcept
      : AskEnterBattle(nullptr, std::move(from)) {}
  inline AskEnterBattle& operator=(const AskEnterBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskEnterBattle& operator=(AskEnterBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskEnterBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskEnterBattle* internal_default_instance() {
    return reinterpret_cast<const AskEnterBattle*>(
        &_AskEnterBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AskEnterBattle& a, AskEnterBattle& b) { a.Swap(&b); }
  inline void Swap(AskEnterBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskEnterBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskEnterBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskEnterBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskEnterBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskEnterBattle& from) { AskEnterBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskEnterBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskEnterBattle"; }

 protected:
  explicit AskEnterBattle(::google::protobuf::Arena* arena);
  AskEnterBattle(::google::protobuf::Arena* arena, const AskEnterBattle& from);
  AskEnterBattle(::google::protobuf::Arena* arena, AskEnterBattle&& from) noexcept
      : AskEnterBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kClientTimeFieldNumber = 2,
    kBattleidFieldNumber = 3,
    kObuserstateFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional int64 clientTime = 2;
  bool has_clienttime() const;
  void clear_clienttime() ;
  ::int64_t clienttime() const;
  void set_clienttime(::int64_t value);

  private:
  ::int64_t _internal_clienttime() const;
  void _internal_set_clienttime(::int64_t value);

  public:
  // optional uint64 battleid = 3;
  bool has_battleid() const;
  void clear_battleid() ;
  ::uint64_t battleid() const;
  void set_battleid(::uint64_t value);

  private:
  ::uint64_t _internal_battleid() const;
  void _internal_set_battleid(::uint64_t value);

  public:
  // optional int32 obuserstate = 4;
  bool has_obuserstate() const;
  void clear_obuserstate() ;
  ::int32_t obuserstate() const;
  void set_obuserstate(::int32_t value);

  private:
  ::int32_t _internal_obuserstate() const;
  void _internal_set_obuserstate(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskEnterBattle];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskEnterBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t clienttime_;
    ::uint64_t battleid_;
    ::int32_t obuserstate_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskBornNPC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskBornNPC) */ {
 public:
  inline AskBornNPC() : AskBornNPC(nullptr) {}
  ~AskBornNPC() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskBornNPC(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskBornNPC(const AskBornNPC& from) : AskBornNPC(nullptr, from) {}
  inline AskBornNPC(AskBornNPC&& from) noexcept
      : AskBornNPC(nullptr, std::move(from)) {}
  inline AskBornNPC& operator=(const AskBornNPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskBornNPC& operator=(AskBornNPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskBornNPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskBornNPC* internal_default_instance() {
    return reinterpret_cast<const AskBornNPC*>(
        &_AskBornNPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(AskBornNPC& a, AskBornNPC& b) { a.Swap(&b); }
  inline void Swap(AskBornNPC* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskBornNPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskBornNPC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskBornNPC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskBornNPC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskBornNPC& from) { AskBornNPC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskBornNPC* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskBornNPC"; }

 protected:
  explicit AskBornNPC(::google::protobuf::Arena* arena);
  AskBornNPC(::google::protobuf::Arena* arena, const AskBornNPC& from);
  AskBornNPC(::google::protobuf::Arena* arena, AskBornNPC&& from) noexcept
      : AskBornNPC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStepidFieldNumber = 2,
    kStateFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional int32 stepid = 2;
  bool has_stepid() const;
  void clear_stepid() ;
  ::int32_t stepid() const;
  void set_stepid(::int32_t value);

  private:
  ::int32_t _internal_stepid() const;
  void _internal_set_stepid(::int32_t value);

  public:
  // optional int32 state = 3;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskBornNPC];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskBornNPC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t stepid_;
    ::int32_t state_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AlwaysAutoAtk final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AlwaysAutoAtk) */ {
 public:
  inline AlwaysAutoAtk() : AlwaysAutoAtk(nullptr) {}
  ~AlwaysAutoAtk() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AlwaysAutoAtk(
      ::google::protobuf::internal::ConstantInitialized);

  inline AlwaysAutoAtk(const AlwaysAutoAtk& from) : AlwaysAutoAtk(nullptr, from) {}
  inline AlwaysAutoAtk(AlwaysAutoAtk&& from) noexcept
      : AlwaysAutoAtk(nullptr, std::move(from)) {}
  inline AlwaysAutoAtk& operator=(const AlwaysAutoAtk& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlwaysAutoAtk& operator=(AlwaysAutoAtk&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AlwaysAutoAtk& default_instance() {
    return *internal_default_instance();
  }
  static inline const AlwaysAutoAtk* internal_default_instance() {
    return reinterpret_cast<const AlwaysAutoAtk*>(
        &_AlwaysAutoAtk_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(AlwaysAutoAtk& a, AlwaysAutoAtk& b) { a.Swap(&b); }
  inline void Swap(AlwaysAutoAtk* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlwaysAutoAtk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AlwaysAutoAtk* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AlwaysAutoAtk>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AlwaysAutoAtk& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AlwaysAutoAtk& from) { AlwaysAutoAtk::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AlwaysAutoAtk* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AlwaysAutoAtk"; }

 protected:
  explicit AlwaysAutoAtk(::google::protobuf::Arena* arena);
  AlwaysAutoAtk(::google::protobuf::Arena* arena, const AlwaysAutoAtk& from);
  AlwaysAutoAtk(::google::protobuf::Arena* arena, AlwaysAutoAtk&& from) noexcept
      : AlwaysAutoAtk(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFlagFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional bool flag = 2;
  bool has_flag() const;
  void clear_flag() ;
  bool flag() const;
  void set_flag(bool value);

  private:
  bool _internal_flag() const;
  void _internal_set_flag(bool value);

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskAlwaysAutoAtk];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AlwaysAutoAtk)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool flag_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class Absorb final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.Absorb) */ {
 public:
  inline Absorb() : Absorb(nullptr) {}
  ~Absorb() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Absorb(
      ::google::protobuf::internal::ConstantInitialized);

  inline Absorb(const Absorb& from) : Absorb(nullptr, from) {}
  inline Absorb(Absorb&& from) noexcept
      : Absorb(nullptr, std::move(from)) {}
  inline Absorb& operator=(const Absorb& from) {
    CopyFrom(from);
    return *this;
  }
  inline Absorb& operator=(Absorb&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Absorb& default_instance() {
    return *internal_default_instance();
  }
  static inline const Absorb* internal_default_instance() {
    return reinterpret_cast<const Absorb*>(
        &_Absorb_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(Absorb& a, Absorb& b) { a.Swap(&b); }
  inline void Swap(Absorb* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Absorb* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Absorb* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Absorb>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Absorb& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Absorb& from) { Absorb::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Absorb* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.Absorb"; }

 protected:
  explicit Absorb(::google::protobuf::Arena* arena);
  Absorb(::google::protobuf::Arena* arena, const Absorb& from);
  Absorb(::google::protobuf::Arena* arena, Absorb&& from) noexcept
      : Absorb(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgnumFieldNumber = 1,
    kRemoveidFieldNumber = 2,
  };
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskAbsorbMonster];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // optional int32 removeid = 2 [default = -1];
  bool has_removeid() const;
  void clear_removeid() ;
  ::int32_t removeid() const;
  void set_removeid(::int32_t value);

  private:
  ::int32_t _internal_removeid() const;
  void _internal_set_removeid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.Absorb)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgnum_;
    ::int32_t removeid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class MoveTar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.MoveTar) */ {
 public:
  inline MoveTar() : MoveTar(nullptr) {}
  ~MoveTar() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveTar(
      ::google::protobuf::internal::ConstantInitialized);

  inline MoveTar(const MoveTar& from) : MoveTar(nullptr, from) {}
  inline MoveTar(MoveTar&& from) noexcept
      : MoveTar(nullptr, std::move(from)) {}
  inline MoveTar& operator=(const MoveTar& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveTar& operator=(MoveTar&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveTar& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveTar* internal_default_instance() {
    return reinterpret_cast<const MoveTar*>(
        &_MoveTar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(MoveTar& a, MoveTar& b) { a.Swap(&b); }
  inline void Swap(MoveTar* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveTar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveTar* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MoveTar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveTar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveTar& from) { MoveTar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveTar* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.MoveTar"; }

 protected:
  explicit MoveTar(::google::protobuf::Arena* arena);
  MoveTar(::google::protobuf::Arena* arena, const MoveTar& from);
  MoveTar(::google::protobuf::Arena* arena, MoveTar&& from) noexcept
      : MoveTar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.Pos pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  const ::GCToSS::Pos& pos() const;
  PROTOBUF_NODISCARD ::GCToSS::Pos* release_pos();
  ::GCToSS::Pos* mutable_pos();
  void set_allocated_pos(::GCToSS::Pos* value);
  void unsafe_arena_set_allocated_pos(::GCToSS::Pos* value);
  ::GCToSS::Pos* unsafe_arena_release_pos();

  private:
  const ::GCToSS::Pos& _internal_pos() const;
  ::GCToSS::Pos* _internal_mutable_pos();

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskMovePos];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.MoveTar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GCToSS::Pos* pos_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class MoveDir final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.MoveDir) */ {
 public:
  inline MoveDir() : MoveDir(nullptr) {}
  ~MoveDir() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MoveDir(
      ::google::protobuf::internal::ConstantInitialized);

  inline MoveDir(const MoveDir& from) : MoveDir(nullptr, from) {}
  inline MoveDir(MoveDir&& from) noexcept
      : MoveDir(nullptr, std::move(from)) {}
  inline MoveDir& operator=(const MoveDir& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveDir& operator=(MoveDir&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveDir& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveDir* internal_default_instance() {
    return reinterpret_cast<const MoveDir*>(
        &_MoveDir_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(MoveDir& a, MoveDir& b) { a.Swap(&b); }
  inline void Swap(MoveDir* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveDir* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveDir* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MoveDir>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveDir& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MoveDir& from) { MoveDir::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveDir* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.MoveDir"; }

 protected:
  explicit MoveDir(::google::protobuf::Arena* arena);
  MoveDir(::google::protobuf::Arena* arena, const MoveDir& from);
  MoveDir(::google::protobuf::Arena* arena, MoveDir&& from) noexcept
      : MoveDir(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional .GCToSS.Dir dir = 3;
  bool has_dir() const;
  void clear_dir() ;
  const ::GCToSS::Dir& dir() const;
  PROTOBUF_NODISCARD ::GCToSS::Dir* release_dir();
  ::GCToSS::Dir* mutable_dir();
  void set_allocated_dir(::GCToSS::Dir* value);
  void unsafe_arena_set_allocated_dir(::GCToSS::Dir* value);
  ::GCToSS::Dir* unsafe_arena_release_dir();

  private:
  const ::GCToSS::Dir& _internal_dir() const;
  ::GCToSS::Dir* _internal_mutable_dir();

  public:
  // optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskMoveDir];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GCToSS::MsgNum msgnum() const;
  void set_msgnum(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgnum() const;
  void _internal_set_msgnum(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.MoveDir)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GCToSS::Dir* dir_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};
// -------------------------------------------------------------------

class AskSSGuideStepComp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GCToSS.AskSSGuideStepComp) */ {
 public:
  inline AskSSGuideStepComp() : AskSSGuideStepComp(nullptr) {}
  ~AskSSGuideStepComp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSSGuideStepComp(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSSGuideStepComp(const AskSSGuideStepComp& from) : AskSSGuideStepComp(nullptr, from) {}
  inline AskSSGuideStepComp(AskSSGuideStepComp&& from) noexcept
      : AskSSGuideStepComp(nullptr, std::move(from)) {}
  inline AskSSGuideStepComp& operator=(const AskSSGuideStepComp& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSSGuideStepComp& operator=(AskSSGuideStepComp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSSGuideStepComp& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSSGuideStepComp* internal_default_instance() {
    return reinterpret_cast<const AskSSGuideStepComp*>(
        &_AskSSGuideStepComp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(AskSSGuideStepComp& a, AskSSGuideStepComp& b) { a.Swap(&b); }
  inline void Swap(AskSSGuideStepComp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSSGuideStepComp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSSGuideStepComp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSSGuideStepComp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSSGuideStepComp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSSGuideStepComp& from) { AskSSGuideStepComp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSSGuideStepComp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GCToSS.AskSSGuideStepComp"; }

 protected:
  explicit AskSSGuideStepComp(::google::protobuf::Arena* arena);
  AskSSGuideStepComp(::google::protobuf::Arena* arena, const AskSSGuideStepComp& from);
  AskSSGuideStepComp(::google::protobuf::Arena* arena, AskSSGuideStepComp&& from) noexcept
      : AskSSGuideStepComp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using taskinfo = AskSSGuideStepComp_taskinfo;
  using edotype = AskSSGuideStepComp_edotype;
  static constexpr edotype ecomptask = AskSSGuideStepComp_edotype_ecomptask;
  static constexpr edotype ebuygoods = AskSSGuideStepComp_edotype_ebuygoods;
  static constexpr edotype ebornsolder = AskSSGuideStepComp_edotype_ebornsolder;
  static constexpr edotype ebornhero = AskSSGuideStepComp_edotype_ebornhero;
  static constexpr edotype nextstep = AskSSGuideStepComp_edotype_nextstep;
  static inline bool edotype_IsValid(int value) {
    return AskSSGuideStepComp_edotype_IsValid(value);
  }
  static constexpr edotype edotype_MIN = AskSSGuideStepComp_edotype_edotype_MIN;
  static constexpr edotype edotype_MAX = AskSSGuideStepComp_edotype_edotype_MAX;
  static constexpr int edotype_ARRAYSIZE = AskSSGuideStepComp_edotype_edotype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* edotype_descriptor() {
    return AskSSGuideStepComp_edotype_descriptor();
  }
  template <typename T>
  static inline const std::string& edotype_Name(T value) {
    return AskSSGuideStepComp_edotype_Name(value);
  }
  static inline bool edotype_Parse(absl::string_view name, edotype* value) {
    return AskSSGuideStepComp_edotype_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // repeated .GCToSS.AskSSGuideStepComp.taskinfo info = 3;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GCToSS::AskSSGuideStepComp_taskinfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>* _internal_mutable_info();
  public:
  const ::GCToSS::AskSSGuideStepComp_taskinfo& info(int index) const;
  ::GCToSS::AskSSGuideStepComp_taskinfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>& info() const;
  // optional .GCToSS.MsgNum msgid = 1 [default = eMsgToGSToSSFromGC_AskGuideStepComp];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GCToSS::MsgNum msgid() const;
  void set_msgid(::GCToSS::MsgNum value);

  private:
  ::GCToSS::MsgNum _internal_msgid() const;
  void _internal_set_msgid(::GCToSS::MsgNum value);

  public:
  // @@protoc_insertion_point(class_scope:GCToSS.AskSSGuideStepComp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GCToSS::AskSSGuideStepComp_taskinfo > info_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GCToSS_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// AskSSGuideStepComp_taskinfo

// optional .GCToSS.AskSSGuideStepComp.edotype dtype = 1;
inline bool AskSSGuideStepComp_taskinfo::has_dtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskSSGuideStepComp_taskinfo::clear_dtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dtype_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::AskSSGuideStepComp_edotype AskSSGuideStepComp_taskinfo::dtype() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskSSGuideStepComp.taskinfo.dtype)
  return _internal_dtype();
}
inline void AskSSGuideStepComp_taskinfo::set_dtype(::GCToSS::AskSSGuideStepComp_edotype value) {
  _internal_set_dtype(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.AskSSGuideStepComp.taskinfo.dtype)
}
inline ::GCToSS::AskSSGuideStepComp_edotype AskSSGuideStepComp_taskinfo::_internal_dtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::AskSSGuideStepComp_edotype>(_impl_.dtype_);
}
inline void AskSSGuideStepComp_taskinfo::_internal_set_dtype(::GCToSS::AskSSGuideStepComp_edotype value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::AskSSGuideStepComp_edotype_IsValid(value));
  _impl_.dtype_ = value;
}

// optional int32 stepid = 2;
inline bool AskSSGuideStepComp_taskinfo::has_stepid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSSGuideStepComp_taskinfo::clear_stepid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskSSGuideStepComp_taskinfo::stepid() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskSSGuideStepComp.taskinfo.stepid)
  return _internal_stepid();
}
inline void AskSSGuideStepComp_taskinfo::set_stepid(::int32_t value) {
  _internal_set_stepid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskSSGuideStepComp.taskinfo.stepid)
}
inline ::int32_t AskSSGuideStepComp_taskinfo::_internal_stepid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stepid_;
}
inline void AskSSGuideStepComp_taskinfo::_internal_set_stepid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = value;
}

// -------------------------------------------------------------------

// AskSSGuideStepComp

// optional .GCToSS.MsgNum msgid = 1 [default = eMsgToGSToSSFromGC_AskGuideStepComp];
inline bool AskSSGuideStepComp::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSSGuideStepComp::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 16540;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum AskSSGuideStepComp::msgid() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskSSGuideStepComp.msgid)
  return _internal_msgid();
}
inline void AskSSGuideStepComp::set_msgid(::GCToSS::MsgNum value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskSSGuideStepComp.msgid)
}
inline ::GCToSS::MsgNum AskSSGuideStepComp::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgid_);
}
inline void AskSSGuideStepComp::_internal_set_msgid(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GCToSS.AskSSGuideStepComp.taskinfo info = 3;
inline int AskSSGuideStepComp::_internal_info_size() const {
  return _internal_info().size();
}
inline int AskSSGuideStepComp::info_size() const {
  return _internal_info_size();
}
inline void AskSSGuideStepComp::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GCToSS::AskSSGuideStepComp_taskinfo* AskSSGuideStepComp::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GCToSS.AskSSGuideStepComp.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>* AskSSGuideStepComp::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GCToSS.AskSSGuideStepComp.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GCToSS::AskSSGuideStepComp_taskinfo& AskSSGuideStepComp::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToSS.AskSSGuideStepComp.info)
  return _internal_info().Get(index);
}
inline ::GCToSS::AskSSGuideStepComp_taskinfo* AskSSGuideStepComp::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GCToSS::AskSSGuideStepComp_taskinfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GCToSS.AskSSGuideStepComp.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>& AskSSGuideStepComp::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GCToSS.AskSSGuideStepComp.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>&
AskSSGuideStepComp::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GCToSS::AskSSGuideStepComp_taskinfo>*
AskSSGuideStepComp::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// HerosBattleInfo

// optional .GCToSS.MsgNum msgid = 1 [default = eMsgToGSToSSFromGC_AskHerosBattleInfo];
inline bool HerosBattleInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HerosBattleInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 16522;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum HerosBattleInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GCToSS.HerosBattleInfo.msgid)
  return _internal_msgid();
}
inline void HerosBattleInfo::set_msgid(::GCToSS::MsgNum value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.HerosBattleInfo.msgid)
}
inline ::GCToSS::MsgNum HerosBattleInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgid_);
}
inline void HerosBattleInfo::_internal_set_msgid(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// AskHeroAttributesInfo

// optional .GCToSS.MsgNum msgid = 1 [default = eMsgToGSToSSFromGC_AskHeroAttributesInfo];
inline bool AskHeroAttributesInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskHeroAttributesInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 16521;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum AskHeroAttributesInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskHeroAttributesInfo.msgid)
  return _internal_msgid();
}
inline void AskHeroAttributesInfo::set_msgid(::GCToSS::MsgNum value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskHeroAttributesInfo.msgid)
}
inline ::GCToSS::MsgNum AskHeroAttributesInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgid_);
}
inline void AskHeroAttributesInfo::_internal_set_msgid(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// AskQuickBattleEnd

// optional .GCToSS.MsgNum msgid = 1 [default = eMsgToSSFromGS_AskQuickBattleEnd];
inline bool AskQuickBattleEnd::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskQuickBattleEnd::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 16412;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum AskQuickBattleEnd::msgid() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskQuickBattleEnd.msgid)
  return _internal_msgid();
}
inline void AskQuickBattleEnd::set_msgid(::GCToSS::MsgNum value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.AskQuickBattleEnd.msgid)
}
inline ::GCToSS::MsgNum AskQuickBattleEnd::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgid_);
}
inline void AskQuickBattleEnd::_internal_set_msgid(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 other = 2;
inline bool AskQuickBattleEnd::has_other() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskQuickBattleEnd::clear_other() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.other_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskQuickBattleEnd::other() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskQuickBattleEnd.other)
  return _internal_other();
}
inline void AskQuickBattleEnd::set_other(::int32_t value) {
  _internal_set_other(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskQuickBattleEnd.other)
}
inline ::int32_t AskQuickBattleEnd::_internal_other() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.other_;
}
inline void AskQuickBattleEnd::_internal_set_other(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.other_ = value;
}

// -------------------------------------------------------------------

// AskPingSS

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskPingSS];
inline bool AskPingSS::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskPingSS::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16385;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum AskPingSS::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskPingSS.msgnum)
  return _internal_msgnum();
}
inline void AskPingSS::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.AskPingSS.msgnum)
}
inline ::GCToSS::MsgNum AskPingSS::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void AskPingSS::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int64 time = 2;
inline bool AskPingSS::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskPingSS::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t AskPingSS::time() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskPingSS.time)
  return _internal_time();
}
inline void AskPingSS::set_time(::int64_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskPingSS.time)
}
inline ::int64_t AskPingSS::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void AskPingSS::_internal_set_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// AskEnterBattle

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskEnterBattle];
inline bool AskEnterBattle::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AskEnterBattle::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16386;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GCToSS::MsgNum AskEnterBattle::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskEnterBattle.msgnum)
  return _internal_msgnum();
}
inline void AskEnterBattle::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GCToSS.AskEnterBattle.msgnum)
}
inline ::GCToSS::MsgNum AskEnterBattle::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void AskEnterBattle::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int64 clientTime = 2;
inline bool AskEnterBattle::has_clienttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskEnterBattle::clear_clienttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clienttime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t AskEnterBattle::clienttime() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskEnterBattle.clientTime)
  return _internal_clienttime();
}
inline void AskEnterBattle::set_clienttime(::int64_t value) {
  _internal_set_clienttime(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskEnterBattle.clientTime)
}
inline ::int64_t AskEnterBattle::_internal_clienttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.clienttime_;
}
inline void AskEnterBattle::_internal_set_clienttime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.clienttime_ = value;
}

// optional uint64 battleid = 3;
inline bool AskEnterBattle::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskEnterBattle::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t AskEnterBattle::battleid() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskEnterBattle.battleid)
  return _internal_battleid();
}
inline void AskEnterBattle::set_battleid(::uint64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.AskEnterBattle.battleid)
}
inline ::uint64_t AskEnterBattle::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void AskEnterBattle::_internal_set_battleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional int32 obuserstate = 4;
inline bool AskEnterBattle::has_obuserstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskEnterBattle::clear_obuserstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obuserstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AskEnterBattle::obuserstate() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskEnterBattle.obuserstate)
  return _internal_obuserstate();
}
inline void AskEnterBattle::set_obuserstate(::int32_t value) {
  _internal_set_obuserstate(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToSS.AskEnterBattle.obuserstate)
}
inline ::int32_t AskEnterBattle::_internal_obuserstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.obuserstate_;
}
inline void AskEnterBattle::_internal_set_obuserstate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obuserstate_ = value;
}

// -------------------------------------------------------------------

// Dir

// optional float x = 1;
inline bool Dir::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Dir::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Dir::x() const {
  // @@protoc_insertion_point(field_get:GCToSS.Dir.x)
  return _internal_x();
}
inline void Dir::set_x(float value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.Dir.x)
}
inline float Dir::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Dir::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = value;
}

// optional float z = 2;
inline bool Dir::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Dir::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Dir::z() const {
  // @@protoc_insertion_point(field_get:GCToSS.Dir.z)
  return _internal_z();
}
inline void Dir::set_z(float value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.Dir.z)
}
inline float Dir::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Dir::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = value;
}

// optional float angle = 3;
inline bool Dir::has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Dir::clear_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Dir::angle() const {
  // @@protoc_insertion_point(field_get:GCToSS.Dir.angle)
  return _internal_angle();
}
inline void Dir::set_angle(float value) {
  _internal_set_angle(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToSS.Dir.angle)
}
inline float Dir::_internal_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_;
}
inline void Dir::_internal_set_angle(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// MoveDir

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskMoveDir];
inline bool MoveDir::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MoveDir::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16387;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum MoveDir::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.MoveDir.msgnum)
  return _internal_msgnum();
}
inline void MoveDir::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.MoveDir.msgnum)
}
inline ::GCToSS::MsgNum MoveDir::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void MoveDir::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional .GCToSS.Dir dir = 3;
inline bool MoveDir::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void MoveDir::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GCToSS::Dir& MoveDir::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GCToSS::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GCToSS::Dir&>(::GCToSS::_Dir_default_instance_);
}
inline const ::GCToSS::Dir& MoveDir::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToSS.MoveDir.dir)
  return _internal_dir();
}
inline void MoveDir::unsafe_arena_set_allocated_dir(::GCToSS::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GCToSS::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GCToSS.MoveDir.dir)
}
inline ::GCToSS::Dir* MoveDir::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GCToSS::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GCToSS::Dir* MoveDir::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToSS.MoveDir.dir)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GCToSS::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GCToSS::Dir* MoveDir::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GCToSS::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GCToSS::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GCToSS::Dir* MoveDir::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GCToSS::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GCToSS.MoveDir.dir)
  return _msg;
}
inline void MoveDir::set_allocated_dir(::GCToSS::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dir_ = reinterpret_cast<::GCToSS::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GCToSS.MoveDir.dir)
}

// -------------------------------------------------------------------

// StopMove

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskStopMove];
inline bool StopMove::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StopMove::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16388;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum StopMove::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.StopMove.msgnum)
  return _internal_msgnum();
}
inline void StopMove::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.StopMove.msgnum)
}
inline ::GCToSS::MsgNum StopMove::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void StopMove::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// BuyGoods

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskBuyGoods];
inline bool BuyGoods::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BuyGoods::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16389;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum BuyGoods::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.BuyGoods.msgnum)
  return _internal_msgnum();
}
inline void BuyGoods::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.BuyGoods.msgnum)
}
inline ::GCToSS::MsgNum BuyGoods::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void BuyGoods::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 typeid = 3;
inline bool BuyGoods::has_typeid_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BuyGoods::clear_typeid_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.typeid__ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t BuyGoods::typeid_() const {
  // @@protoc_insertion_point(field_get:GCToSS.BuyGoods.typeid)
  return _internal_typeid_();
}
inline void BuyGoods::set_typeid_(::int32_t value) {
  _internal_set_typeid_(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.BuyGoods.typeid)
}
inline ::int32_t BuyGoods::_internal_typeid_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.typeid__;
}
inline void BuyGoods::_internal_set_typeid_(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.typeid__ = value;
}

// -------------------------------------------------------------------

// UseGoods

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskUseGoods];
inline bool UseGoods::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UseGoods::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16390;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum UseGoods::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.UseGoods.msgnum)
  return _internal_msgnum();
}
inline void UseGoods::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.UseGoods.msgnum)
}
inline ::GCToSS::MsgNum UseGoods::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void UseGoods::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 goodspos = 3;
inline bool UseGoods::has_goodspos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UseGoods::clear_goodspos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodspos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UseGoods::goodspos() const {
  // @@protoc_insertion_point(field_get:GCToSS.UseGoods.goodspos)
  return _internal_goodspos();
}
inline void UseGoods::set_goodspos(::int32_t value) {
  _internal_set_goodspos(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.UseGoods.goodspos)
}
inline ::int32_t UseGoods::_internal_goodspos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goodspos_;
}
inline void UseGoods::_internal_set_goodspos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodspos_ = value;
}

// -------------------------------------------------------------------

// SellGoods

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskSellGoods];
inline bool SellGoods::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SellGoods::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16391;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum SellGoods::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.SellGoods.msgnum)
  return _internal_msgnum();
}
inline void SellGoods::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.SellGoods.msgnum)
}
inline ::GCToSS::MsgNum SellGoods::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void SellGoods::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 goodspos = 3;
inline bool SellGoods::has_goodspos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SellGoods::clear_goodspos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodspos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SellGoods::goodspos() const {
  // @@protoc_insertion_point(field_get:GCToSS.SellGoods.goodspos)
  return _internal_goodspos();
}
inline void SellGoods::set_goodspos(::int32_t value) {
  _internal_set_goodspos(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.SellGoods.goodspos)
}
inline ::int32_t SellGoods::_internal_goodspos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goodspos_;
}
inline void SellGoods::_internal_set_goodspos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodspos_ = value;
}

// -------------------------------------------------------------------

// MoveGoods

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskMoveGoods];
inline bool MoveGoods::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MoveGoods::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16392;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToSS::MsgNum MoveGoods::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.MoveGoods.msgnum)
  return _internal_msgnum();
}
inline void MoveGoods::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToSS.MoveGoods.msgnum)
}
inline ::GCToSS::MsgNum MoveGoods::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void MoveGoods::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 frompos = 3;
inline bool MoveGoods::has_frompos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MoveGoods::clear_frompos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frompos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MoveGoods::frompos() const {
  // @@protoc_insertion_point(field_get:GCToSS.MoveGoods.frompos)
  return _internal_frompos();
}
inline void MoveGoods::set_frompos(::int32_t value) {
  _internal_set_frompos(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.MoveGoods.frompos)
}
inline ::int32_t MoveGoods::_internal_frompos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.frompos_;
}
inline void MoveGoods::_internal_set_frompos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.frompos_ = value;
}

// optional int32 topos = 4;
inline bool MoveGoods::has_topos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MoveGoods::clear_topos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MoveGoods::topos() const {
  // @@protoc_insertion_point(field_get:GCToSS.MoveGoods.topos)
  return _internal_topos();
}
inline void MoveGoods::set_topos(::int32_t value) {
  _internal_set_topos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.MoveGoods.topos)
}
inline ::int32_t MoveGoods::_internal_topos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.topos_;
}
inline void MoveGoods::_internal_set_topos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.topos_ = value;
}

// -------------------------------------------------------------------

// ReportBattleLoadingState

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_ReportBattleLoadingState];
inline bool ReportBattleLoadingState::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReportBattleLoadingState::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16393;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum ReportBattleLoadingState::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.ReportBattleLoadingState.msgnum)
  return _internal_msgnum();
}
inline void ReportBattleLoadingState::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.ReportBattleLoadingState.msgnum)
}
inline ::GCToSS::MsgNum ReportBattleLoadingState::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void ReportBattleLoadingState::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 loadingnum = 3;
inline bool ReportBattleLoadingState::has_loadingnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReportBattleLoadingState::clear_loadingnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loadingnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ReportBattleLoadingState::loadingnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.ReportBattleLoadingState.loadingnum)
  return _internal_loadingnum();
}
inline void ReportBattleLoadingState::set_loadingnum(::int32_t value) {
  _internal_set_loadingnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.ReportBattleLoadingState.loadingnum)
}
inline ::int32_t ReportBattleLoadingState::_internal_loadingnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loadingnum_;
}
inline void ReportBattleLoadingState::_internal_set_loadingnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loadingnum_ = value;
}

// -------------------------------------------------------------------

// UseSkill

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskUseSkill];
inline bool UseSkill::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UseSkill::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16395;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum UseSkill::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.UseSkill.msgnum)
  return _internal_msgnum();
}
inline void UseSkill::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.UseSkill.msgnum)
}
inline ::GCToSS::MsgNum UseSkill::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void UseSkill::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 skillid = 3;
inline bool UseSkill::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UseSkill::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UseSkill::skillid() const {
  // @@protoc_insertion_point(field_get:GCToSS.UseSkill.skillid)
  return _internal_skillid();
}
inline void UseSkill::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.UseSkill.skillid)
}
inline ::int32_t UseSkill::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void UseSkill::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// -------------------------------------------------------------------

// LockTar

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskLockTarget];
inline bool LockTar::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LockTar::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16396;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum LockTar::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.LockTar.msgnum)
  return _internal_msgnum();
}
inline void LockTar::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.LockTar.msgnum)
}
inline ::GCToSS::MsgNum LockTar::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void LockTar::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int64 guid = 3;
inline bool LockTar::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LockTar::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t LockTar::guid() const {
  // @@protoc_insertion_point(field_get:GCToSS.LockTar.guid)
  return _internal_guid();
}
inline void LockTar::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.LockTar.guid)
}
inline ::int64_t LockTar::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void LockTar::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// -------------------------------------------------------------------

// ReportAltarStrawSolder

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_ReportAltarStrawSolder];
inline bool ReportAltarStrawSolder::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReportAltarStrawSolder::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16397;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToSS::MsgNum ReportAltarStrawSolder::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.ReportAltarStrawSolder.msgnum)
  return _internal_msgnum();
}
inline void ReportAltarStrawSolder::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToSS.ReportAltarStrawSolder.msgnum)
}
inline ::GCToSS::MsgNum ReportAltarStrawSolder::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void ReportAltarStrawSolder::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 type = 2;
inline bool ReportAltarStrawSolder::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReportAltarStrawSolder::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ReportAltarStrawSolder::type() const {
  // @@protoc_insertion_point(field_get:GCToSS.ReportAltarStrawSolder.type)
  return _internal_type();
}
inline void ReportAltarStrawSolder::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.ReportAltarStrawSolder.type)
}
inline ::int32_t ReportAltarStrawSolder::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void ReportAltarStrawSolder::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional int32 index = 3;
inline bool ReportAltarStrawSolder::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReportAltarStrawSolder::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ReportAltarStrawSolder::index() const {
  // @@protoc_insertion_point(field_get:GCToSS.ReportAltarStrawSolder.index)
  return _internal_index();
}
inline void ReportAltarStrawSolder::set_index(::int32_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.ReportAltarStrawSolder.index)
}
inline ::int32_t ReportAltarStrawSolder::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void ReportAltarStrawSolder::_internal_set_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// Absorb

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskAbsorbMonster];
inline bool Absorb::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Absorb::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16398;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum Absorb::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.Absorb.msgnum)
  return _internal_msgnum();
}
inline void Absorb::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.Absorb.msgnum)
}
inline ::GCToSS::MsgNum Absorb::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void Absorb::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 removeid = 2 [default = -1];
inline bool Absorb::has_removeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Absorb::clear_removeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.removeid_ = -1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Absorb::removeid() const {
  // @@protoc_insertion_point(field_get:GCToSS.Absorb.removeid)
  return _internal_removeid();
}
inline void Absorb::set_removeid(::int32_t value) {
  _internal_set_removeid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.Absorb.removeid)
}
inline ::int32_t Absorb::_internal_removeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.removeid_;
}
inline void Absorb::_internal_set_removeid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.removeid_ = value;
}

// -------------------------------------------------------------------

// GasExplosion

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskGasExplosion];
inline bool GasExplosion::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GasExplosion::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16400;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum GasExplosion::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.GasExplosion.msgnum)
  return _internal_msgnum();
}
inline void GasExplosion::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.GasExplosion.msgnum)
}
inline ::GCToSS::MsgNum GasExplosion::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void GasExplosion::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// BuReborn

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskBuyRebornHero];
inline bool BuReborn::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BuReborn::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16401;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum BuReborn::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.BuReborn.msgnum)
  return _internal_msgnum();
}
inline void BuReborn::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.BuReborn.msgnum)
}
inline ::GCToSS::MsgNum BuReborn::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void BuReborn::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// GMCmd

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_GMCmd];
inline bool GMCmd::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GMCmd::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16402;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum GMCmd::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.GMCmd.msgnum)
  return _internal_msgnum();
}
inline void GMCmd::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.GMCmd.msgnum)
}
inline ::GCToSS::MsgNum GMCmd::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void GMCmd::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string cmd = 2;
inline bool GMCmd::has_cmd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GMCmd::clear_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cmd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GMCmd::cmd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToSS.GMCmd.cmd)
  return _internal_cmd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GMCmd::set_cmd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cmd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GCToSS.GMCmd.cmd)
}
inline std::string* GMCmd::mutable_cmd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_cmd();
  // @@protoc_insertion_point(field_mutable:GCToSS.GMCmd.cmd)
  return _s;
}
inline const std::string& GMCmd::_internal_cmd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cmd_.Get();
}
inline void GMCmd::_internal_set_cmd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.cmd_.Set(value, GetArena());
}
inline std::string* GMCmd::_internal_mutable_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.cmd_.Mutable( GetArena());
}
inline std::string* GMCmd::release_cmd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToSS.GMCmd.cmd)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.cmd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.cmd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GMCmd::set_allocated_cmd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.cmd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.cmd_.IsDefault()) {
          _impl_.cmd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GCToSS.GMCmd.cmd)
}

// -------------------------------------------------------------------

// StepID

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_StepId];
inline bool StepID::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void StepID::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16404;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToSS::MsgNum StepID::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.StepID.msgnum)
  return _internal_msgnum();
}
inline void StepID::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToSS.StepID.msgnum)
}
inline ::GCToSS::MsgNum StepID::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void StepID::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 stepid = 3;
inline bool StepID::has_stepid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void StepID::clear_stepid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t StepID::stepid() const {
  // @@protoc_insertion_point(field_get:GCToSS.StepID.stepid)
  return _internal_stepid();
}
inline void StepID::set_stepid(::int32_t value) {
  _internal_set_stepid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.StepID.stepid)
}
inline ::int32_t StepID::_internal_stepid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stepid_;
}
inline void StepID::_internal_set_stepid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = value;
}

// optional int32 type = 4;
inline bool StepID::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void StepID::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t StepID::type() const {
  // @@protoc_insertion_point(field_get:GCToSS.StepID.type)
  return _internal_type();
}
inline void StepID::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.StepID.type)
}
inline ::int32_t StepID::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void StepID::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// AutoAtk

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskAutoAttack];
inline bool AutoAtk::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AutoAtk::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16406;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum AutoAtk::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.AutoAtk.msgnum)
  return _internal_msgnum();
}
inline void AutoAtk::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AutoAtk.msgnum)
}
inline ::GCToSS::MsgNum AutoAtk::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void AutoAtk::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// GuideJumpToHall

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskGuideEndJumpToHall];
inline bool GuideJumpToHall::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideJumpToHall::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16407;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum GuideJumpToHall::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.GuideJumpToHall.msgnum)
  return _internal_msgnum();
}
inline void GuideJumpToHall::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.GuideJumpToHall.msgnum)
}
inline ::GCToSS::MsgNum GuideJumpToHall::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void GuideJumpToHall::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// AskReconnect

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskReconnect];
inline bool AskReconnect::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskReconnect::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16408;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum AskReconnect::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskReconnect.msgnum)
  return _internal_msgnum();
}
inline void AskReconnect::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskReconnect.msgnum)
}
inline ::GCToSS::MsgNum AskReconnect::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void AskReconnect::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// -------------------------------------------------------------------

// Pos

// optional float x = 1;
inline bool Pos::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Pos::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Pos::x() const {
  // @@protoc_insertion_point(field_get:GCToSS.Pos.x)
  return _internal_x();
}
inline void Pos::set_x(float value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.Pos.x)
}
inline float Pos::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Pos::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = value;
}

// optional float z = 2;
inline bool Pos::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Pos::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Pos::z() const {
  // @@protoc_insertion_point(field_get:GCToSS.Pos.z)
  return _internal_z();
}
inline void Pos::set_z(float value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.Pos.z)
}
inline float Pos::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Pos::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// MoveTar

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskMovePos];
inline bool MoveTar::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MoveTar::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16409;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum MoveTar::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.MoveTar.msgnum)
  return _internal_msgnum();
}
inline void MoveTar::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.MoveTar.msgnum)
}
inline ::GCToSS::MsgNum MoveTar::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void MoveTar::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional .GCToSS.Pos pos = 3;
inline bool MoveTar::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void MoveTar::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GCToSS::Pos& MoveTar::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GCToSS::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GCToSS::Pos&>(::GCToSS::_Pos_default_instance_);
}
inline const ::GCToSS::Pos& MoveTar::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GCToSS.MoveTar.pos)
  return _internal_pos();
}
inline void MoveTar::unsafe_arena_set_allocated_pos(::GCToSS::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GCToSS::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GCToSS.MoveTar.pos)
}
inline ::GCToSS::Pos* MoveTar::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GCToSS::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GCToSS::Pos* MoveTar::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GCToSS.MoveTar.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GCToSS::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GCToSS::Pos* MoveTar::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GCToSS::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GCToSS::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GCToSS::Pos* MoveTar::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GCToSS::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GCToSS.MoveTar.pos)
  return _msg;
}
inline void MoveTar::set_allocated_pos(::GCToSS::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GCToSS::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GCToSS.MoveTar.pos)
}

// -------------------------------------------------------------------

// AskBornNPC

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskBornNPC];
inline bool AskBornNPC::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskBornNPC::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16405;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GCToSS::MsgNum AskBornNPC::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskBornNPC.msgnum)
  return _internal_msgnum();
}
inline void AskBornNPC::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GCToSS.AskBornNPC.msgnum)
}
inline ::GCToSS::MsgNum AskBornNPC::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void AskBornNPC::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 stepid = 2;
inline bool AskBornNPC::has_stepid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskBornNPC::clear_stepid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskBornNPC::stepid() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskBornNPC.stepid)
  return _internal_stepid();
}
inline void AskBornNPC::set_stepid(::int32_t value) {
  _internal_set_stepid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AskBornNPC.stepid)
}
inline ::int32_t AskBornNPC::_internal_stepid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stepid_;
}
inline void AskBornNPC::_internal_set_stepid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = value;
}

// optional int32 state = 3;
inline bool AskBornNPC::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskBornNPC::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskBornNPC::state() const {
  // @@protoc_insertion_point(field_get:GCToSS.AskBornNPC.state)
  return _internal_state();
}
inline void AskBornNPC::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.AskBornNPC.state)
}
inline ::int32_t AskBornNPC::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void AskBornNPC::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// AlwaysAutoAtk

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskAlwaysAutoAtk];
inline bool AlwaysAutoAtk::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AlwaysAutoAtk::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16410;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum AlwaysAutoAtk::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.AlwaysAutoAtk.msgnum)
  return _internal_msgnum();
}
inline void AlwaysAutoAtk::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.AlwaysAutoAtk.msgnum)
}
inline ::GCToSS::MsgNum AlwaysAutoAtk::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void AlwaysAutoAtk::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional bool flag = 2;
inline bool AlwaysAutoAtk::has_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AlwaysAutoAtk::clear_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool AlwaysAutoAtk::flag() const {
  // @@protoc_insertion_point(field_get:GCToSS.AlwaysAutoAtk.flag)
  return _internal_flag();
}
inline void AlwaysAutoAtk::set_flag(bool value) {
  _internal_set_flag(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.AlwaysAutoAtk.flag)
}
inline bool AlwaysAutoAtk::_internal_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_;
}
inline void AlwaysAutoAtk::_internal_set_flag(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = value;
}

// -------------------------------------------------------------------

// TrySeleceHero

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskTrySelectHero];
inline bool TrySeleceHero::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TrySeleceHero::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16505;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum TrySeleceHero::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.TrySeleceHero.msgnum)
  return _internal_msgnum();
}
inline void TrySeleceHero::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.TrySeleceHero.msgnum)
}
inline ::GCToSS::MsgNum TrySeleceHero::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void TrySeleceHero::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint32 heroid = 2;
inline bool TrySeleceHero::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TrySeleceHero::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TrySeleceHero::heroid() const {
  // @@protoc_insertion_point(field_get:GCToSS.TrySeleceHero.heroid)
  return _internal_heroid();
}
inline void TrySeleceHero::set_heroid(::uint32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.TrySeleceHero.heroid)
}
inline ::uint32_t TrySeleceHero::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void TrySeleceHero::_internal_set_heroid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// -------------------------------------------------------------------

// SelectHero

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskSelectHero];
inline bool SelectHero::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SelectHero::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16506;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum SelectHero::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.SelectHero.msgnum)
  return _internal_msgnum();
}
inline void SelectHero::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.SelectHero.msgnum)
}
inline ::GCToSS::MsgNum SelectHero::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void SelectHero::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 heroid = 2;
inline bool SelectHero::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SelectHero::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SelectHero::heroid() const {
  // @@protoc_insertion_point(field_get:GCToSS.SelectHero.heroid)
  return _internal_heroid();
}
inline void SelectHero::set_heroid(::int32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.SelectHero.heroid)
}
inline ::int32_t SelectHero::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void SelectHero::_internal_set_heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// -------------------------------------------------------------------

// SelectRunePage

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_AskSelectRunePage];
inline bool SelectRunePage::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SelectRunePage::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16507;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GCToSS::MsgNum SelectRunePage::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.SelectRunePage.msgnum)
  return _internal_msgnum();
}
inline void SelectRunePage::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GCToSS.SelectRunePage.msgnum)
}
inline ::GCToSS::MsgNum SelectRunePage::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void SelectRunePage::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 pageindex = 2;
inline bool SelectRunePage::has_pageindex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SelectRunePage::clear_pageindex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pageindex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SelectRunePage::pageindex() const {
  // @@protoc_insertion_point(field_get:GCToSS.SelectRunePage.pageindex)
  return _internal_pageindex();
}
inline void SelectRunePage::set_pageindex(::int32_t value) {
  _internal_set_pageindex(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.SelectRunePage.pageindex)
}
inline ::int32_t SelectRunePage::_internal_pageindex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pageindex_;
}
inline void SelectRunePage::_internal_set_pageindex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pageindex_ = value;
}

// -------------------------------------------------------------------

// LoadComplete

// optional .GCToSS.MsgNum msgnum = 1 [default = eMsgToGSToSSFromGC_ReportLoadBattleComplete];
inline bool LoadComplete::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LoadComplete::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 16520;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GCToSS::MsgNum LoadComplete::msgnum() const {
  // @@protoc_insertion_point(field_get:GCToSS.LoadComplete.msgnum)
  return _internal_msgnum();
}
inline void LoadComplete::set_msgnum(::GCToSS::MsgNum value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GCToSS.LoadComplete.msgnum)
}
inline ::GCToSS::MsgNum LoadComplete::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GCToSS::MsgNum>(_impl_.msgnum_);
}
inline void LoadComplete::_internal_set_msgnum(::GCToSS::MsgNum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GCToSS::MsgNum_IsValid(value));
  _impl_.msgnum_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace GCToSS


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::GCToSS::AskSSGuideStepComp_edotype> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GCToSS::AskSSGuideStepComp_edotype>() {
  return ::GCToSS::AskSSGuideStepComp_edotype_descriptor();
}
template <>
struct is_proto_enum<::GCToSS::MsgNum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GCToSS::MsgNum>() {
  return ::GCToSS::MsgNum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_GCToSS_2eproto_2epb_2eh
