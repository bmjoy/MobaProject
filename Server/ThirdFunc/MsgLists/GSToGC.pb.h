// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GSToGC.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_GSToGC_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_GSToGC_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_GSToGC_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_GSToGC_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_GSToGC_2eproto;
namespace GSToGC {
class AbsorbBegin;
struct AbsorbBeginDefaultTypeInternal;
extern AbsorbBeginDefaultTypeInternal _AbsorbBegin_default_instance_;
class AbsorbRes;
struct AbsorbResDefaultTypeInternal;
extern AbsorbResDefaultTypeInternal _AbsorbRes_default_instance_;
class AltarBSIco;
struct AltarBSIcoDefaultTypeInternal;
extern AltarBSIcoDefaultTypeInternal _AltarBSIco_default_instance_;
class AskRet;
struct AskRetDefaultTypeInternal;
extern AskRetDefaultTypeInternal _AskRet_default_instance_;
class AskRoomListRet;
struct AskRoomListRetDefaultTypeInternal;
extern AskRoomListRetDefaultTypeInternal _AskRoomListRet_default_instance_;
class BattleBaseInfo;
struct BattleBaseInfoDefaultTypeInternal;
extern BattleBaseInfoDefaultTypeInternal _BattleBaseInfo_default_instance_;
class BattleDelayTime;
struct BattleDelayTimeDefaultTypeInternal;
extern BattleDelayTimeDefaultTypeInternal _BattleDelayTime_default_instance_;
class BattleFinish;
struct BattleFinishDefaultTypeInternal;
extern BattleFinishDefaultTypeInternal _BattleFinish_default_instance_;
class BattleLoadingState;
struct BattleLoadingStateDefaultTypeInternal;
extern BattleLoadingStateDefaultTypeInternal _BattleLoadingState_default_instance_;
class BattleMatcherCount;
struct BattleMatcherCountDefaultTypeInternal;
extern BattleMatcherCountDefaultTypeInternal _BattleMatcherCount_default_instance_;
class BattleSeatPosInfo;
struct BattleSeatPosInfoDefaultTypeInternal;
extern BattleSeatPosInfoDefaultTypeInternal _BattleSeatPosInfo_default_instance_;
class BattleSeatPosInfo_PosInfo;
struct BattleSeatPosInfo_PosInfoDefaultTypeInternal;
extern BattleSeatPosInfo_PosInfoDefaultTypeInternal _BattleSeatPosInfo_PosInfo_default_instance_;
class BattleSpanTime;
struct BattleSpanTimeDefaultTypeInternal;
extern BattleSpanTimeDefaultTypeInternal _BattleSpanTime_default_instance_;
class BattleStateChange;
struct BattleStateChangeDefaultTypeInternal;
extern BattleStateChangeDefaultTypeInternal _BattleStateChange_default_instance_;
class BornSoler;
struct BornSolerDefaultTypeInternal;
extern BornSolerDefaultTypeInternal _BornSoler_default_instance_;
class BroadcastBattelePersonalRes;
struct BroadcastBattelePersonalResDefaultTypeInternal;
extern BroadcastBattelePersonalResDefaultTypeInternal _BroadcastBattelePersonalRes_default_instance_;
class BroadcastBatteleRes;
struct BroadcastBatteleResDefaultTypeInternal;
extern BroadcastBatteleResDefaultTypeInternal _BroadcastBatteleRes_default_instance_;
class BroadcastBatteleRes_ResInfo;
struct BroadcastBatteleRes_ResInfoDefaultTypeInternal;
extern BroadcastBatteleRes_ResInfoDefaultTypeInternal _BroadcastBatteleRes_ResInfo_default_instance_;
class BroadcastBattleHeroInfo;
struct BroadcastBattleHeroInfoDefaultTypeInternal;
extern BroadcastBattleHeroInfoDefaultTypeInternal _BroadcastBattleHeroInfo_default_instance_;
class BroadcastBattleHeroInfo_BaseGoodsInfo;
struct BroadcastBattleHeroInfo_BaseGoodsInfoDefaultTypeInternal;
extern BroadcastBattleHeroInfo_BaseGoodsInfoDefaultTypeInternal _BroadcastBattleHeroInfo_BaseGoodsInfo_default_instance_;
class BroadcastBattleHeroInfo_HeroInfo;
struct BroadcastBattleHeroInfo_HeroInfoDefaultTypeInternal;
extern BroadcastBattleHeroInfo_HeroInfoDefaultTypeInternal _BroadcastBattleHeroInfo_HeroInfo_default_instance_;
class BroadcastBuildingDestory;
struct BroadcastBuildingDestoryDefaultTypeInternal;
extern BroadcastBuildingDestoryDefaultTypeInternal _BroadcastBuildingDestory_default_instance_;
class BuffEffect;
struct BuffEffectDefaultTypeInternal;
extern BuffEffectDefaultTypeInternal _BuffEffect_default_instance_;
class CanInviteFriends;
struct CanInviteFriendsDefaultTypeInternal;
extern CanInviteFriendsDefaultTypeInternal _CanInviteFriends_default_instance_;
class CanInviteFriends_Friends;
struct CanInviteFriends_FriendsDefaultTypeInternal;
extern CanInviteFriends_FriendsDefaultTypeInternal _CanInviteFriends_Friends_default_instance_;
class CancelAbsorb;
struct CancelAbsorbDefaultTypeInternal;
extern CancelAbsorbDefaultTypeInternal _CancelAbsorb_default_instance_;
class ChatInRoom;
struct ChatInRoomDefaultTypeInternal;
extern ChatInRoomDefaultTypeInternal _ChatInRoom_default_instance_;
class CurAtkSpeed;
struct CurAtkSpeedDefaultTypeInternal;
extern CurAtkSpeedDefaultTypeInternal _CurAtkSpeed_default_instance_;
class CurAtkSpeed_SpeedInfo;
struct CurAtkSpeed_SpeedInfoDefaultTypeInternal;
extern CurAtkSpeed_SpeedInfoDefaultTypeInternal _CurAtkSpeed_SpeedInfo_default_instance_;
class CurBattleChange;
struct CurBattleChangeDefaultTypeInternal;
extern CurBattleChangeDefaultTypeInternal _CurBattleChange_default_instance_;
class CurCP;
struct CurCPDefaultTypeInternal;
extern CurCPDefaultTypeInternal _CurCP_default_instance_;
class CurDeadTimes;
struct CurDeadTimesDefaultTypeInternal;
extern CurDeadTimesDefaultTypeInternal _CurDeadTimes_default_instance_;
class DeadState;
struct DeadStateDefaultTypeInternal;
extern DeadStateDefaultTypeInternal _DeadState_default_instance_;
class DelAndSortMail;
struct DelAndSortMailDefaultTypeInternal;
extern DelAndSortMailDefaultTypeInternal _DelAndSortMail_default_instance_;
class DestroyEmitEffect;
struct DestroyEmitEffectDefaultTypeInternal;
extern DestroyEmitEffectDefaultTypeInternal _DestroyEmitEffect_default_instance_;
class Dir;
struct DirDefaultTypeInternal;
extern DirDefaultTypeInternal _Dir_default_instance_;
class DisappearInfo;
struct DisappearInfoDefaultTypeInternal;
extern DisappearInfoDefaultTypeInternal _DisappearInfo_default_instance_;
class EmitSkill;
struct EmitSkillDefaultTypeInternal;
extern EmitSkillDefaultTypeInternal _EmitSkill_default_instance_;
class Exp;
struct ExpDefaultTypeInternal;
extern ExpDefaultTypeInternal _Exp_default_instance_;
class FPInfo;
struct FPInfoDefaultTypeInternal;
extern FPInfoDefaultTypeInternal _FPInfo_default_instance_;
class FreeState;
struct FreeStateDefaultTypeInternal;
extern FreeStateDefaultTypeInternal _FreeState_default_instance_;
class FuryState;
struct FuryStateDefaultTypeInternal;
extern FuryStateDefaultTypeInternal _FuryState_default_instance_;
class FuryVal;
struct FuryValDefaultTypeInternal;
extern FuryValDefaultTypeInternal _FuryVal_default_instance_;
class GOAppear;
struct GOAppearDefaultTypeInternal;
extern GOAppearDefaultTypeInternal _GOAppear_default_instance_;
class GOAppear_AppearInfo;
struct GOAppear_AppearInfoDefaultTypeInternal;
extern GOAppear_AppearInfoDefaultTypeInternal _GOAppear_AppearInfo_default_instance_;
class GOReleaseSkill;
struct GOReleaseSkillDefaultTypeInternal;
extern GOReleaseSkillDefaultTypeInternal _GOReleaseSkill_default_instance_;
class GOSkillCD;
struct GOSkillCDDefaultTypeInternal;
extern GOSkillCDDefaultTypeInternal _GOSkillCD_default_instance_;
class GameNotice;
struct GameNoticeDefaultTypeInternal;
extern GameNoticeDefaultTypeInternal _GameNotice_default_instance_;
class GameNotice_Notice;
struct GameNotice_NoticeDefaultTypeInternal;
extern GameNotice_NoticeDefaultTypeInternal _GameNotice_Notice_default_instance_;
class GameTips;
struct GameTipsDefaultTypeInternal;
extern GameTipsDefaultTypeInternal _GameTips_default_instance_;
class GetloginRewardSuccess;
struct GetloginRewardSuccessDefaultTypeInternal;
extern GetloginRewardSuccessDefaultTypeInternal _GetloginRewardSuccess_default_instance_;
class GetloginReward_Hero;
struct GetloginReward_HeroDefaultTypeInternal;
extern GetloginReward_HeroDefaultTypeInternal _GetloginReward_Hero_default_instance_;
class GetloginReward_Rune;
struct GetloginReward_RuneDefaultTypeInternal;
extern GetloginReward_RuneDefaultTypeInternal _GetloginReward_Rune_default_instance_;
class GetloginReward_Skin;
struct GetloginReward_SkinDefaultTypeInternal;
extern GetloginReward_SkinDefaultTypeInternal _GetloginReward_Skin_default_instance_;
class GoodsBuyCfgInfo;
struct GoodsBuyCfgInfoDefaultTypeInternal;
extern GoodsBuyCfgInfoDefaultTypeInternal _GoodsBuyCfgInfo_default_instance_;
class GoodsCfgInfo;
struct GoodsCfgInfoDefaultTypeInternal;
extern GoodsCfgInfoDefaultTypeInternal _GoodsCfgInfo_default_instance_;
class GoodsCfgInfo_Consume;
struct GoodsCfgInfo_ConsumeDefaultTypeInternal;
extern GoodsCfgInfo_ConsumeDefaultTypeInternal _GoodsCfgInfo_Consume_default_instance_;
class GuideAward;
struct GuideAwardDefaultTypeInternal;
extern GuideAwardDefaultTypeInternal _GuideAward_default_instance_;
class GuideAward_awardtype;
struct GuideAward_awardtypeDefaultTypeInternal;
extern GuideAward_awardtypeDefaultTypeInternal _GuideAward_awardtype_default_instance_;
class GuideCSStepInfo;
struct GuideCSStepInfoDefaultTypeInternal;
extern GuideCSStepInfoDefaultTypeInternal _GuideCSStepInfo_default_instance_;
class GuideKillsInfo;
struct GuideKillsInfoDefaultTypeInternal;
extern GuideKillsInfoDefaultTypeInternal _GuideKillsInfo_default_instance_;
class GuideLastStep;
struct GuideLastStepDefaultTypeInternal;
extern GuideLastStepDefaultTypeInternal _GuideLastStep_default_instance_;
class GuideSteps;
struct GuideStepsDefaultTypeInternal;
extern GuideStepsDefaultTypeInternal _GuideSteps_default_instance_;
class HPChange;
struct HPChangeDefaultTypeInternal;
extern HPChangeDefaultTypeInternal _HPChange_default_instance_;
class HeroAssist;
struct HeroAssistDefaultTypeInternal;
extern HeroAssistDefaultTypeInternal _HeroAssist_default_instance_;
class HeroAttributes;
struct HeroAttributesDefaultTypeInternal;
extern HeroAttributesDefaultTypeInternal _HeroAttributes_default_instance_;
class HeroInfo;
struct HeroInfoDefaultTypeInternal;
extern HeroInfoDefaultTypeInternal _HeroInfo_default_instance_;
class HeroKills;
struct HeroKillsDefaultTypeInternal;
extern HeroKillsDefaultTypeInternal _HeroKills_default_instance_;
class HeroList;
struct HeroListDefaultTypeInternal;
extern HeroListDefaultTypeInternal _HeroList_default_instance_;
class HeroMoveInfo;
struct HeroMoveInfoDefaultTypeInternal;
extern HeroMoveInfoDefaultTypeInternal _HeroMoveInfo_default_instance_;
class HeroPosInfo;
struct HeroPosInfoDefaultTypeInternal;
extern HeroPosInfoDefaultTypeInternal _HeroPosInfo_default_instance_;
class HitTar;
struct HitTarDefaultTypeInternal;
extern HitTarDefaultTypeInternal _HitTar_default_instance_;
class LastHitNum;
struct LastHitNumDefaultTypeInternal;
extern LastHitNumDefaultTypeInternal _LastHitNum_default_instance_;
class LastingSkillState;
struct LastingSkillStateDefaultTypeInternal;
extern LastingSkillStateDefaultTypeInternal _LastingSkillState_default_instance_;
class LeaveBattleSuccess;
struct LeaveBattleSuccessDefaultTypeInternal;
extern LeaveBattleSuccessDefaultTypeInternal _LeaveBattleSuccess_default_instance_;
class LevelInfo;
struct LevelInfoDefaultTypeInternal;
extern LevelInfoDefaultTypeInternal _LevelInfo_default_instance_;
class MailInfo;
struct MailInfoDefaultTypeInternal;
extern MailInfoDefaultTypeInternal _MailInfo_default_instance_;
class MpChange;
struct MpChangeDefaultTypeInternal;
extern MpChangeDefaultTypeInternal _MpChange_default_instance_;
class NetClash;
struct NetClashDefaultTypeInternal;
extern NetClashDefaultTypeInternal _NetClash_default_instance_;
class NotifyAFPData;
struct NotifyAFPDataDefaultTypeInternal;
extern NotifyAFPDataDefaultTypeInternal _NotifyAFPData_default_instance_;
class NotifyAFPData_FPInfo;
struct NotifyAFPData_FPInfoDefaultTypeInternal;
extern NotifyAFPData_FPInfoDefaultTypeInternal _NotifyAFPData_FPInfo_default_instance_;
class NotifyAddOneTask;
struct NotifyAddOneTaskDefaultTypeInternal;
extern NotifyAddOneTaskDefaultTypeInternal _NotifyAddOneTask_default_instance_;
class NotifyAltarBSIco;
struct NotifyAltarBSIcoDefaultTypeInternal;
extern NotifyAltarBSIcoDefaultTypeInternal _NotifyAltarBSIco_default_instance_;
class NotifyBattleManagerChange;
struct NotifyBattleManagerChangeDefaultTypeInternal;
extern NotifyBattleManagerChangeDefaultTypeInternal _NotifyBattleManagerChange_default_instance_;
class NotifyBeAddFriendMs;
struct NotifyBeAddFriendMsDefaultTypeInternal;
extern NotifyBeAddFriendMsDefaultTypeInternal _NotifyBeAddFriendMs_default_instance_;
class NotifyBlastHurt;
struct NotifyBlastHurtDefaultTypeInternal;
extern NotifyBlastHurtDefaultTypeInternal _NotifyBlastHurt_default_instance_;
class NotifyBornObj;
struct NotifyBornObjDefaultTypeInternal;
extern NotifyBornObjDefaultTypeInternal _NotifyBornObj_default_instance_;
class NotifyCSHeroList;
struct NotifyCSHeroListDefaultTypeInternal;
extern NotifyCSHeroListDefaultTypeInternal _NotifyCSHeroList_default_instance_;
class NotifyCSHeroList_HeroListCfg;
struct NotifyCSHeroList_HeroListCfgDefaultTypeInternal;
extern NotifyCSHeroList_HeroListCfgDefaultTypeInternal _NotifyCSHeroList_HeroListCfg_default_instance_;
class NotifyChooseHeroTimeEnd;
struct NotifyChooseHeroTimeEndDefaultTypeInternal;
extern NotifyChooseHeroTimeEndDefaultTypeInternal _NotifyChooseHeroTimeEnd_default_instance_;
class NotifyCurDiamond;
struct NotifyCurDiamondDefaultTypeInternal;
extern NotifyCurDiamondDefaultTypeInternal _NotifyCurDiamond_default_instance_;
class NotifyCurGold;
struct NotifyCurGoldDefaultTypeInternal;
extern NotifyCurGoldDefaultTypeInternal _NotifyCurGold_default_instance_;
class NotifyDelOneTask;
struct NotifyDelOneTaskDefaultTypeInternal;
extern NotifyDelOneTaskDefaultTypeInternal _NotifyDelOneTask_default_instance_;
class NotifyGameObjectReliveState;
struct NotifyGameObjectReliveStateDefaultTypeInternal;
extern NotifyGameObjectReliveStateDefaultTypeInternal _NotifyGameObjectReliveState_default_instance_;
class NotifyGetNewCommodity;
struct NotifyGetNewCommodityDefaultTypeInternal;
extern NotifyGetNewCommodityDefaultTypeInternal _NotifyGetNewCommodity_default_instance_;
class NotifyGoodsExpired;
struct NotifyGoodsExpiredDefaultTypeInternal;
extern NotifyGoodsExpiredDefaultTypeInternal _NotifyGoodsExpired_default_instance_;
class NotifyGoodsInfo;
struct NotifyGoodsInfoDefaultTypeInternal;
extern NotifyGoodsInfoDefaultTypeInternal _NotifyGoodsInfo_default_instance_;
class NotifyGoodsInfo_GoodsInfo;
struct NotifyGoodsInfo_GoodsInfoDefaultTypeInternal;
extern NotifyGoodsInfo_GoodsInfoDefaultTypeInternal _NotifyGoodsInfo_GoodsInfo_default_instance_;
class NotifyHPInfo;
struct NotifyHPInfoDefaultTypeInternal;
extern NotifyHPInfoDefaultTypeInternal _NotifyHPInfo_default_instance_;
class NotifyHPInfo_HPInfo;
struct NotifyHPInfo_HPInfoDefaultTypeInternal;
extern NotifyHPInfo_HPInfoDefaultTypeInternal _NotifyHPInfo_HPInfo_default_instance_;
class NotifyHeroInfo;
struct NotifyHeroInfoDefaultTypeInternal;
extern NotifyHeroInfoDefaultTypeInternal _NotifyHeroInfo_default_instance_;
class NotifyHeroReborn;
struct NotifyHeroRebornDefaultTypeInternal;
extern NotifyHeroRebornDefaultTypeInternal _NotifyHeroReborn_default_instance_;
class NotifyHerosInfo;
struct NotifyHerosInfoDefaultTypeInternal;
extern NotifyHerosInfoDefaultTypeInternal _NotifyHerosInfo_default_instance_;
class NotifyHerosInfo_heropanelinfo;
struct NotifyHerosInfo_heropanelinfoDefaultTypeInternal;
extern NotifyHerosInfo_heropanelinfoDefaultTypeInternal _NotifyHerosInfo_heropanelinfo_default_instance_;
class NotifyHerosInfo_heropanelinfo_goodsmsg;
struct NotifyHerosInfo_heropanelinfo_goodsmsgDefaultTypeInternal;
extern NotifyHerosInfo_heropanelinfo_goodsmsgDefaultTypeInternal _NotifyHerosInfo_heropanelinfo_goodsmsg_default_instance_;
class NotifyIsOnSS;
struct NotifyIsOnSSDefaultTypeInternal;
extern NotifyIsOnSSDefaultTypeInternal _NotifyIsOnSS_default_instance_;
class NotifyKillNPC;
struct NotifyKillNPCDefaultTypeInternal;
extern NotifyKillNPCDefaultTypeInternal _NotifyKillNPC_default_instance_;
class NotifyMPInfo;
struct NotifyMPInfoDefaultTypeInternal;
extern NotifyMPInfoDefaultTypeInternal _NotifyMPInfo_default_instance_;
class NotifyMPInfo_MPInfo;
struct NotifyMPInfo_MPInfoDefaultTypeInternal;
extern NotifyMPInfo_MPInfoDefaultTypeInternal _NotifyMPInfo_MPInfo_default_instance_;
class NotifyMailList;
struct NotifyMailListDefaultTypeInternal;
extern NotifyMailListDefaultTypeInternal _NotifyMailList_default_instance_;
class NotifyMailRet;
struct NotifyMailRetDefaultTypeInternal;
extern NotifyMailRetDefaultTypeInternal _NotifyMailRet_default_instance_;
class NotifyMatchInviteJoin;
struct NotifyMatchInviteJoinDefaultTypeInternal;
extern NotifyMatchInviteJoinDefaultTypeInternal _NotifyMatchInviteJoin_default_instance_;
class NotifyMatchTeamBaseInfo;
struct NotifyMatchTeamBaseInfoDefaultTypeInternal;
extern NotifyMatchTeamBaseInfoDefaultTypeInternal _NotifyMatchTeamBaseInfo_default_instance_;
class NotifyMatchTeamPlayerInfo;
struct NotifyMatchTeamPlayerInfoDefaultTypeInternal;
extern NotifyMatchTeamPlayerInfoDefaultTypeInternal _NotifyMatchTeamPlayerInfo_default_instance_;
class NotifyMatchTeamSwitch;
struct NotifyMatchTeamSwitchDefaultTypeInternal;
extern NotifyMatchTeamSwitchDefaultTypeInternal _NotifyMatchTeamSwitch_default_instance_;
class NotifyMsgFromUser;
struct NotifyMsgFromUserDefaultTypeInternal;
extern NotifyMsgFromUserDefaultTypeInternal _NotifyMsgFromUser_default_instance_;
class NotifyNewHeaderid;
struct NotifyNewHeaderidDefaultTypeInternal;
extern NotifyNewHeaderidDefaultTypeInternal _NotifyNewHeaderid_default_instance_;
class NotifyNewNickname;
struct NotifyNewNicknameDefaultTypeInternal;
extern NotifyNewNicknameDefaultTypeInternal _NotifyNewNickname_default_instance_;
class NotifyOBAppear;
struct NotifyOBAppearDefaultTypeInternal;
extern NotifyOBAppearDefaultTypeInternal _NotifyOBAppear_default_instance_;
class NotifyOBReturnBattleRoom;
struct NotifyOBReturnBattleRoomDefaultTypeInternal;
extern NotifyOBReturnBattleRoomDefaultTypeInternal _NotifyOBReturnBattleRoom_default_instance_;
class NotifyOneMatchNeedOne;
struct NotifyOneMatchNeedOneDefaultTypeInternal;
extern NotifyOneMatchNeedOneDefaultTypeInternal _NotifyOneMatchNeedOne_default_instance_;
class NotifyOtherItemInfo;
struct NotifyOtherItemInfoDefaultTypeInternal;
extern NotifyOtherItemInfoDefaultTypeInternal _NotifyOtherItemInfo_default_instance_;
class NotifyOtherItemInfo_OtherItem;
struct NotifyOtherItemInfo_OtherItemDefaultTypeInternal;
extern NotifyOtherItemInfo_OtherItemDefaultTypeInternal _NotifyOtherItemInfo_OtherItem_default_instance_;
class NotifyPassitiveSkillLoad;
struct NotifyPassitiveSkillLoadDefaultTypeInternal;
extern NotifyPassitiveSkillLoadDefaultTypeInternal _NotifyPassitiveSkillLoad_default_instance_;
class NotifyPassitiveSkillRelease;
struct NotifyPassitiveSkillReleaseDefaultTypeInternal;
extern NotifyPassitiveSkillReleaseDefaultTypeInternal _NotifyPassitiveSkillRelease_default_instance_;
class NotifyPassitiveSkillUnLoad;
struct NotifyPassitiveSkillUnLoadDefaultTypeInternal;
extern NotifyPassitiveSkillUnLoadDefaultTypeInternal _NotifyPassitiveSkillUnLoad_default_instance_;
class NotifyQueryNickNameRet;
struct NotifyQueryNickNameRetDefaultTypeInternal;
extern NotifyQueryNickNameRetDefaultTypeInternal _NotifyQueryNickNameRet_default_instance_;
class NotifyQueryNickNameRet_QueryInfo;
struct NotifyQueryNickNameRet_QueryInfoDefaultTypeInternal;
extern NotifyQueryNickNameRet_QueryInfoDefaultTypeInternal _NotifyQueryNickNameRet_QueryInfo_default_instance_;
class NotifyReconnectInfo;
struct NotifyReconnectInfoDefaultTypeInternal;
extern NotifyReconnectInfoDefaultTypeInternal _NotifyReconnectInfo_default_instance_;
class NotifyReconnectInfo_ReconnectInfo;
struct NotifyReconnectInfo_ReconnectInfoDefaultTypeInternal;
extern NotifyReconnectInfo_ReconnectInfoDefaultTypeInternal _NotifyReconnectInfo_ReconnectInfo_default_instance_;
class NotifyRemoveCommodity;
struct NotifyRemoveCommodityDefaultTypeInternal;
extern NotifyRemoveCommodityDefaultTypeInternal _NotifyRemoveCommodity_default_instance_;
class NotifyRewardsOneTask;
struct NotifyRewardsOneTaskDefaultTypeInternal;
extern NotifyRewardsOneTaskDefaultTypeInternal _NotifyRewardsOneTask_default_instance_;
class NotifyRunesList;
struct NotifyRunesListDefaultTypeInternal;
extern NotifyRunesListDefaultTypeInternal _NotifyRunesList_default_instance_;
class NotifySkillInfo;
struct NotifySkillInfoDefaultTypeInternal;
extern NotifySkillInfoDefaultTypeInternal _NotifySkillInfo_default_instance_;
class NotifySkillModelEmitTurn;
struct NotifySkillModelEmitTurnDefaultTypeInternal;
extern NotifySkillModelEmitTurnDefaultTypeInternal _NotifySkillModelEmitTurn_default_instance_;
class NotifySkillModelLeading;
struct NotifySkillModelLeadingDefaultTypeInternal;
extern NotifySkillModelLeadingDefaultTypeInternal _NotifySkillModelLeading_default_instance_;
class NotifySkillModelPurification;
struct NotifySkillModelPurificationDefaultTypeInternal;
extern NotifySkillModelPurificationDefaultTypeInternal _NotifySkillModelPurification_default_instance_;
class NotifySkillModelStartForceMove;
struct NotifySkillModelStartForceMoveDefaultTypeInternal;
extern NotifySkillModelStartForceMoveDefaultTypeInternal _NotifySkillModelStartForceMove_default_instance_;
class NotifySkillModelStartForceMoveStop;
struct NotifySkillModelStartForceMoveStopDefaultTypeInternal;
extern NotifySkillModelStartForceMoveStopDefaultTypeInternal _NotifySkillModelStartForceMoveStop_default_instance_;
class NotifySkillModelStartForceMoveTeleport;
struct NotifySkillModelStartForceMoveTeleportDefaultTypeInternal;
extern NotifySkillModelStartForceMoveTeleportDefaultTypeInternal _NotifySkillModelStartForceMoveTeleport_default_instance_;
class NotifySkillModelStartLink;
struct NotifySkillModelStartLinkDefaultTypeInternal;
extern NotifySkillModelStartLinkDefaultTypeInternal _NotifySkillModelStartLink_default_instance_;
class NotifySkillModelStopLink;
struct NotifySkillModelStopLinkDefaultTypeInternal;
extern NotifySkillModelStopLinkDefaultTypeInternal _NotifySkillModelStopLink_default_instance_;
class NotifySkillUpLv;
struct NotifySkillUpLvDefaultTypeInternal;
extern NotifySkillUpLvDefaultTypeInternal _NotifySkillUpLv_default_instance_;
class NotifySummonLifeTime;
struct NotifySummonLifeTimeDefaultTypeInternal;
extern NotifySummonLifeTimeDefaultTypeInternal _NotifySummonLifeTime_default_instance_;
class NotifySystemAnnounce;
struct NotifySystemAnnounceDefaultTypeInternal;
extern NotifySystemAnnounceDefaultTypeInternal _NotifySystemAnnounce_default_instance_;
class NotifyUpdateAllDailyTask;
struct NotifyUpdateAllDailyTaskDefaultTypeInternal;
extern NotifyUpdateAllDailyTaskDefaultTypeInternal _NotifyUpdateAllDailyTask_default_instance_;
class NotifyUpdateAllTask;
struct NotifyUpdateAllTaskDefaultTypeInternal;
extern NotifyUpdateAllTaskDefaultTypeInternal _NotifyUpdateAllTask_default_instance_;
class NotifyUpdateOneTask;
struct NotifyUpdateOneTaskDefaultTypeInternal;
extern NotifyUpdateOneTaskDefaultTypeInternal _NotifyUpdateOneTask_default_instance_;
class NotifyUserCLDays;
struct NotifyUserCLDaysDefaultTypeInternal;
extern NotifyUserCLDaysDefaultTypeInternal _NotifyUserCLDays_default_instance_;
class NotifyUserLvInfo;
struct NotifyUserLvInfoDefaultTypeInternal;
extern NotifyUserLvInfoDefaultTypeInternal _NotifyUserLvInfo_default_instance_;
class NotifyUserReturnBattleRoom;
struct NotifyUserReturnBattleRoomDefaultTypeInternal;
extern NotifyUserReturnBattleRoomDefaultTypeInternal _NotifyUserReturnBattleRoom_default_instance_;
class NotifyUserSNSList;
struct NotifyUserSNSListDefaultTypeInternal;
extern NotifyUserSNSListDefaultTypeInternal _NotifyUserSNSList_default_instance_;
class NotifyUserSNSListChange;
struct NotifyUserSNSListChangeDefaultTypeInternal;
extern NotifyUserSNSListChangeDefaultTypeInternal _NotifyUserSNSListChange_default_instance_;
class PersonCPChange;
struct PersonCPChangeDefaultTypeInternal;
extern PersonCPChangeDefaultTypeInternal _PersonCPChange_default_instance_;
class PingRet;
struct PingRetDefaultTypeInternal;
extern PingRetDefaultTypeInternal _PingRet_default_instance_;
class PlayFinishVedio;
struct PlayFinishVedioDefaultTypeInternal;
extern PlayFinishVedioDefaultTypeInternal _PlayFinishVedio_default_instance_;
class Pos;
struct PosDefaultTypeInternal;
extern PosDefaultTypeInternal _Pos_default_instance_;
class PrepareSkillState;
struct PrepareSkillStateDefaultTypeInternal;
extern PrepareSkillStateDefaultTypeInternal _PrepareSkillState_default_instance_;
class RangeEffect;
struct RangeEffectDefaultTypeInternal;
extern RangeEffectDefaultTypeInternal _RangeEffect_default_instance_;
class RangeEffectEnd;
struct RangeEffectEndDefaultTypeInternal;
extern RangeEffectEndDefaultTypeInternal _RangeEffectEnd_default_instance_;
class RebornSuccess;
struct RebornSuccessDefaultTypeInternal;
extern RebornSuccessDefaultTypeInternal _RebornSuccess_default_instance_;
class RebornTimes;
struct RebornTimesDefaultTypeInternal;
extern RebornTimesDefaultTypeInternal _RebornTimes_default_instance_;
class RecoinRuneRet;
struct RecoinRuneRetDefaultTypeInternal;
extern RecoinRuneRetDefaultTypeInternal _RecoinRuneRet_default_instance_;
class ReleasingSkillState;
struct ReleasingSkillStateDefaultTypeInternal;
extern ReleasingSkillStateDefaultTypeInternal _ReleasingSkillState_default_instance_;
class RoomBaseInfo;
struct RoomBaseInfoDefaultTypeInternal;
extern RoomBaseInfoDefaultTypeInternal _RoomBaseInfo_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class RunesBagInfo;
struct RunesBagInfoDefaultTypeInternal;
extern RunesBagInfoDefaultTypeInternal _RunesBagInfo_default_instance_;
class RunesSlot;
struct RunesSlotDefaultTypeInternal;
extern RunesSlotDefaultTypeInternal _RunesSlot_default_instance_;
class RunningState;
struct RunningStateDefaultTypeInternal;
extern RunningStateDefaultTypeInternal _RunningState_default_instance_;
class SNSInfo;
struct SNSInfoDefaultTypeInternal;
extern SNSInfoDefaultTypeInternal _SNSInfo_default_instance_;
class SecondGuideTask;
struct SecondGuideTaskDefaultTypeInternal;
extern SecondGuideTaskDefaultTypeInternal _SecondGuideTask_default_instance_;
class SecondGuideTask_task_info;
struct SecondGuideTask_task_infoDefaultTypeInternal;
extern SecondGuideTask_task_infoDefaultTypeInternal _SecondGuideTask_task_info_default_instance_;
class ShortMail;
struct ShortMailDefaultTypeInternal;
extern ShortMailDefaultTypeInternal _ShortMail_default_instance_;
class SkillEnd;
struct SkillEndDefaultTypeInternal;
extern SkillEndDefaultTypeInternal _SkillEnd_default_instance_;
class SkillEntityInfo;
struct SkillEntityInfoDefaultTypeInternal;
extern SkillEntityInfoDefaultTypeInternal _SkillEntityInfo_default_instance_;
class SkillHitTar;
struct SkillHitTarDefaultTypeInternal;
extern SkillHitTarDefaultTypeInternal _SkillHitTar_default_instance_;
class SummonEffect;
struct SummonEffectDefaultTypeInternal;
extern SummonEffectDefaultTypeInternal _SummonEffect_default_instance_;
class TaskData;
struct TaskDataDefaultTypeInternal;
extern TaskDataDefaultTypeInternal _TaskData_default_instance_;
class TryToChooseHero;
struct TryToChooseHeroDefaultTypeInternal;
extern TryToChooseHeroDefaultTypeInternal _TryToChooseHero_default_instance_;
class UnloadRune;
struct UnloadRuneDefaultTypeInternal;
extern UnloadRuneDefaultTypeInternal _UnloadRune_default_instance_;
class UserBaseInfo;
struct UserBaseInfoDefaultTypeInternal;
extern UserBaseInfoDefaultTypeInternal _UserBaseInfo_default_instance_;
class UserBaseUpLv;
struct UserBaseUpLvDefaultTypeInternal;
extern UserBaseUpLvDefaultTypeInternal _UserBaseUpLv_default_instance_;
class UserBeInvitedToBattle;
struct UserBeInvitedToBattleDefaultTypeInternal;
extern UserBeInvitedToBattleDefaultTypeInternal _UserBeInvitedToBattle_default_instance_;
class UserGameInfo;
struct UserGameInfoDefaultTypeInternal;
extern UserGameInfoDefaultTypeInternal _UserGameInfo_default_instance_;
class UsingSkillState;
struct UsingSkillStateDefaultTypeInternal;
extern UsingSkillStateDefaultTypeInternal _UsingSkillState_default_instance_;
class WarningToSelectHero;
struct WarningToSelectHeroDefaultTypeInternal;
extern WarningToSelectHeroDefaultTypeInternal _WarningToSelectHero_default_instance_;
}  // namespace GSToGC
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace GSToGC {
enum GuideAward_dtype : int {
  GuideAward_dtype_type_gold = 1,
  GuideAward_dtype_type_diamond = 2,
  GuideAward_dtype_type_goodsid = 3,
};

bool GuideAward_dtype_IsValid(int value);
extern const uint32_t GuideAward_dtype_internal_data_[];
constexpr GuideAward_dtype GuideAward_dtype_dtype_MIN = static_cast<GuideAward_dtype>(1);
constexpr GuideAward_dtype GuideAward_dtype_dtype_MAX = static_cast<GuideAward_dtype>(3);
constexpr int GuideAward_dtype_dtype_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
GuideAward_dtype_descriptor();
template <typename T>
const std::string& GuideAward_dtype_Name(T value) {
  static_assert(std::is_same<T, GuideAward_dtype>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to dtype_Name().");
  return GuideAward_dtype_Name(static_cast<GuideAward_dtype>(value));
}
template <>
inline const std::string& GuideAward_dtype_Name(GuideAward_dtype value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GuideAward_dtype_descriptor,
                                                 1, 3>(
      static_cast<int>(value));
}
inline bool GuideAward_dtype_Parse(absl::string_view name, GuideAward_dtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuideAward_dtype>(
      GuideAward_dtype_descriptor(), name, value);
}
enum GoodsCfgInfo_CfgType : int {
  GoodsCfgInfo_CfgType_CfgType_Common = 0,
  GoodsCfgInfo_CfgType_CfgType_Discount = 1,
  GoodsCfgInfo_CfgType_CfgType_hot = 2,
  GoodsCfgInfo_CfgType_CfgType_New = 3,
};

bool GoodsCfgInfo_CfgType_IsValid(int value);
extern const uint32_t GoodsCfgInfo_CfgType_internal_data_[];
constexpr GoodsCfgInfo_CfgType GoodsCfgInfo_CfgType_CfgType_MIN = static_cast<GoodsCfgInfo_CfgType>(0);
constexpr GoodsCfgInfo_CfgType GoodsCfgInfo_CfgType_CfgType_MAX = static_cast<GoodsCfgInfo_CfgType>(3);
constexpr int GoodsCfgInfo_CfgType_CfgType_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
GoodsCfgInfo_CfgType_descriptor();
template <typename T>
const std::string& GoodsCfgInfo_CfgType_Name(T value) {
  static_assert(std::is_same<T, GoodsCfgInfo_CfgType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CfgType_Name().");
  return GoodsCfgInfo_CfgType_Name(static_cast<GoodsCfgInfo_CfgType>(value));
}
template <>
inline const std::string& GoodsCfgInfo_CfgType_Name(GoodsCfgInfo_CfgType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<GoodsCfgInfo_CfgType_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool GoodsCfgInfo_CfgType_Parse(absl::string_view name, GoodsCfgInfo_CfgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GoodsCfgInfo_CfgType>(
      GoodsCfgInfo_CfgType_descriptor(), name, value);
}
enum NotifyAFPData_EnumFpType : int {
  NotifyAFPData_EnumFpType_PhyHurt = 1,
  NotifyAFPData_EnumFpType_MagicHurt = 2,
  NotifyAFPData_EnumFpType_CurHP = 3,
  NotifyAFPData_EnumFpType_CurMP = 4,
  NotifyAFPData_EnumFpType_PhyAttack = 5,
  NotifyAFPData_EnumFpType_MagicAttack = 6,
  NotifyAFPData_EnumFpType_PhyDefense = 7,
  NotifyAFPData_EnumFpType_MagicDefense = 8,
  NotifyAFPData_EnumFpType_MoveSpeed = 9,
  NotifyAFPData_EnumFpType_AttackSpeed = 10,
  NotifyAFPData_EnumFpType_MaxHP = 11,
  NotifyAFPData_EnumFpType_MaxMP = 12,
  NotifyAFPData_EnumFpType_HPRecoverRate = 13,
  NotifyAFPData_EnumFpType_MPRecoverRate = 14,
  NotifyAFPData_EnumFpType_ReliveTime = 15,
  NotifyAFPData_EnumFpType_Dizziness = 16,
  NotifyAFPData_EnumFpType_Silence = 17,
  NotifyAFPData_EnumFpType_PosMove = 18,
  NotifyAFPData_EnumFpType_Rebound = 19,
  NotifyAFPData_EnumFpType_PhySuckBlood = 20,
  NotifyAFPData_EnumFpType_Disarm = 21,
  NotifyAFPData_EnumFpType_Restrain = 22,
  NotifyAFPData_EnumFpType_CriPersent = 23,
  NotifyAFPData_EnumFpType_CriHarm = 24,
  NotifyAFPData_EnumFpType_CPRecover = 25,
  NotifyAFPData_EnumFpType_PassitiveSkill = 26,
  NotifyAFPData_EnumFpType_Invisible = 27,
  NotifyAFPData_EnumFpType_AttackDist = 28,
  NotifyAFPData_EnumFpType_TrueHurt = 29,
  NotifyAFPData_EnumFpType_PhyPassNum = 30,
  NotifyAFPData_EnumFpType_PhyPassPercent = 31,
  NotifyAFPData_EnumFpType_MagicPassNum = 32,
  NotifyAFPData_EnumFpType_MagicPassPercent = 33,
  NotifyAFPData_EnumFpType_CooldownReduce = 34,
  NotifyAFPData_EnumFpType_PhyDmgReduce = 35,
  NotifyAFPData_EnumFpType_MagicDmgReduce = 36,
  NotifyAFPData_EnumFpType_TrueDmgReduce = 37,
  NotifyAFPData_EnumFpType_PhyDmgReduceNum = 38,
  NotifyAFPData_EnumFpType_MagicDmgReduceNum = 39,
  NotifyAFPData_EnumFpType_TrueDmgReduceNum = 40,
  NotifyAFPData_EnumFpType_MagicSuckBlood = 41,
};

bool NotifyAFPData_EnumFpType_IsValid(int value);
extern const uint32_t NotifyAFPData_EnumFpType_internal_data_[];
constexpr NotifyAFPData_EnumFpType NotifyAFPData_EnumFpType_EnumFpType_MIN = static_cast<NotifyAFPData_EnumFpType>(1);
constexpr NotifyAFPData_EnumFpType NotifyAFPData_EnumFpType_EnumFpType_MAX = static_cast<NotifyAFPData_EnumFpType>(41);
constexpr int NotifyAFPData_EnumFpType_EnumFpType_ARRAYSIZE = 41 + 1;
const ::google::protobuf::EnumDescriptor*
NotifyAFPData_EnumFpType_descriptor();
template <typename T>
const std::string& NotifyAFPData_EnumFpType_Name(T value) {
  static_assert(std::is_same<T, NotifyAFPData_EnumFpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EnumFpType_Name().");
  return NotifyAFPData_EnumFpType_Name(static_cast<NotifyAFPData_EnumFpType>(value));
}
template <>
inline const std::string& NotifyAFPData_EnumFpType_Name(NotifyAFPData_EnumFpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NotifyAFPData_EnumFpType_descriptor,
                                                 1, 41>(
      static_cast<int>(value));
}
inline bool NotifyAFPData_EnumFpType_Parse(absl::string_view name, NotifyAFPData_EnumFpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NotifyAFPData_EnumFpType>(
      NotifyAFPData_EnumFpType_descriptor(), name, value);
}
enum MsgID : int {
  eMsgToGCFromGS_Begin = 0,
  eMsgToGCFromGS_GCAskPingRet = 1,
  eMsgToGCFromGS_NotifyUserBaseInfo = 2,
  eMsgToGCFromGS_NotifySystemAnnounce = 3,
  eMsgToGCFromGS_NotifyNetClash = 4,
  eMsgToGCFromGS_GCAskRet = 5,
  eMsgToGCFromGS_NotifyHeroList = 7,
  eMsgToGCFromGS_NotifyBattleBaseInfo = 8,
  eMsgToGCFromGS_NotifyBattleSeatPosInfo = 9,
  eMsgToGCFromGS_NotifyBattleStateChange = 10,
  eMsgToGCFromGS_NotifyCurBattleChange = 11,
  eMsgToGCFromGS_NotifyGameObjectAppear = 12,
  eMsgToGCFromGS_NotifyGameObjectDisappear = 13,
  eMsgToGCFromGS_NotifyGameObjectFreeState = 14,
  eMsgToGCFromGS_NotifyGameObjectRunState = 15,
  eMsgToGCFromGS_NotifyGameObjectPrepareSkillState = 16,
  eMsgToGCFromGS_NotifyGameObjectReleaseSkillState = 17,
  eMsgToGCFromGS_NotifyGameObjectDeadState = 18,
  eMsgToGCFromGS_NotifyGoodsInf = 19,
  eMsgToGCFromGS_NotifyBattleLoadingState = 20,
  eMsgToGCFromGS_NotifyBattleHeroInfo = 21,
  eMsgToGCFromGS_BagRunesInfoChange = 22,
  eMsgToGCFromGS_ExchangeGold = 23,
  eMsgToGCFromGS_ChatInRoom = 24,
  eMsgToGCFromGS_NotifySkillHitTarget = 25,
  eMsgToGCFromGS_NotifyHPChange = 26,
  eMsgToGCFromGS_NotifyMPChange = 27,
  eMsgToGCFromGS_NotifyTryToChooseHero = 28,
  eMsgToGCFromGS_NotifyChooseHeroTimeEnd = 29,
  eMsgToGCFromGS_NotifySkillEntityInfo = 30,
  eMsgToGCFromGS_NotifyFightPropertyInfo = 31,
  eMsgToGCFromGS_NotifyHPInfo = 34,
  eMsgToGCFromGS_NotifyMPInfo = 35,
  eMsgToGCFromGS_NotifyHeroInfo = 36,
  eMsgToGCFromGS_NotifyBuffInfo = 37,
  eMsgToGCFromGS_NotifyBuffRemove = 38,
  eMsgToGCFromGS_NotifySkillInfo = 39,
  eMsgToGCFromGS_NotifyBattleFinish = 40,
  eMsgToGCFromGS_NotifyExpInfo = 41,
  eMsgToGCFromGS_NotifyHeroLevelInfo = 42,
  eMsgToGCFromGS_NotifyAbsorbBegin = 43,
  eMsgToGCFromGS_NotifyAbsorbMonsterResult = 44,
  eMsgToGCFromGS_NotifyCancelAbsorbSkill = 45,
  eMsgToGCFromGS_NotifyUserGameInfo = 46,
  eMsgToGCFromGS_NotifyHeroKills = 47,
  eMsgToGCFromGS_NotifyCurDeadTimes = 48,
  eMsgToGCFromGS_NotifyCurCP = 49,
  eMsgToGCFromGS_NotifyCurAtkSpeed = 50,
  eMsgToGCFromGS_NotifyFuryValue = 51,
  eMsgToGCFromGS_NotifyFuryState = 52,
  eMsgToGCFromGS_NotifyHeroRebornTimes = 53,
  eMsgToGCFromGS_NotifyBuyRebornSuccess = 54,
  eMsgToGCFromGS_BroadcastBattleHeroInfo = 55,
  eMsgToGCFromGS_NotifyPersonalCPChange = 56,
  eMsgToGCFromGS_BroadCurBattleResult = 57,
  eMsgToGCFromGS_BroadBuildingDestroyByWho = 58,
  eMsgToGCFromGS_NotifyVoipRoomId = 59,
  eMsgToGCFromGS_NotifyHeroDisplacementInfo = 60,
  eMsgToGCFromGS_BroadcastPlayFinishVedio = 61,
  eMsgToGCFromGS_NotifyLeaveBattleSuccess = 62,
  eMsgToGCFromGS_NotifyBornSolder = 63,
  eMsgToGCFromGS_NotifySkillEnd = 64,
  eMsgToGCFromGS_NotifyAltarBSIco = 65,
  eMsgToGCFromGS_WarningToSelectHero = 66,
  eMsgToGCFromGS_NotifyGameObjectReleaseSkill = 67,
  eMsgToGCFromGS_NotifyGameObjectSkillCD = 68,
  eMsgToGCFromGS_NotifySkillModelEmit = 69,
  eMsgToGCFromGS_NotifySkillModelEmitDestroy = 70,
  eMsgToGCFromGS_NotifySkillModelHitTarget = 71,
  eMsgToGCFromGS_NotifySkillModelRange = 72,
  eMsgToGCFromGS_NotifySkillModelRangeEnd = 73,
  eMsgToGCFromGS_NotifySkillModelLeading = 74,
  eMsgToGCFromGS_NotifySkillModelSummonEffect = 75,
  eMsgToGCFromGS_NotifySkillModelBufEffect = 76,
  eMsgToGCFromGS_NotifySummonLifeTime = 77,
  eMsgToGCFromGS_NotifySkillModelStartForceMove = 78,
  eMsgToGCFromGS_NotifySkillModelStartForceMoveStop = 79,
  eMsgToGCFromGS_NotifySkillModelStartForceMoveTeleport = 80,
  eMsgToGCFromGS_NotifyPassitiveSkillRelease = 81,
  eMsgToGCFromGS_NotifyPassitiveSkillLoad = 82,
  eMsgToGCFromGS_NotifyPassitiveSkillUnload = 83,
  eMsgToGCFromGS_NotifySkillModelEmitTurn = 84,
  eMsgToGCFromGS_NotifyAFPData = 85,
  eMsgToGCFromGS_NotifyBattleManagerChange = 86,
  eMsgToGCFromGS_NotifyBornObj = 87,
  eMsgToGCFromGS_NotifyReconnectInfo = 88,
  eMsgToGCFromGS_NotifyHeroGoodsInfo = 89,
  eMsgToGCFromGS_NotifyOBReturnBattleRoom = 90,
  eMsgToGCFromGS_NotifyUserReturnBattleRoom = 91,
  eMsgToGCFromGS_NotifyBattleAllUserInfo = 92,
  eMsgToGCFromGS_NotifyUserBeAddedFirendInfo = 93,
  eMsgToGCFromCS_NotifyDefaultHeros = 94,
  eMsgToGCFromGS_NotifyOBAppear = 95,
  eMsgToGCFromGS_NotifyKillNPC = 96,
  eMsgToGCFromGS_NotifyAltarBSOk = 97,
  eMsgToGCFromGS_NotifySkillUpLv = 98,
  eMsgToGCFromGS_NotifyUserSNSList = 99,
  eMsgToGCFromGS_NotifyUserSNSListChange = 100,
  eMsgToGCFromGS_UserBeInvitedToBattle = 101,
  eMsgToGCFromGS_NotifyMsgFromUser = 102,
  eMsgToGCFromGS_NotifyBeAddFriendMsg = 103,
  eMsgToGCFromGS_NotifyQueryNickNameRet = 104,
  eMsgToGCFromCS_NotifyGuideLastComStep = 106,
  eMsgToGCFromGS_NotifyBlastHurt = 107,
  eMsgToGCFromGS_NotifyHeroReborn = 110,
  eMsgToGCFromGS_NotifyGameObjectReliveState = 111,
  eMsgToGCFromGS_NotifyUserGuideSetups = 112,
  eMsgToGCFromBS_AskGateAddressRet = 113,
  eMsgToGCFromGS_NotifyUserName = 114,
  eMsgToGCFromCS_NotifyReconnectInfo = 115,
  eMsgToSSFromCS_NotifyBornObj = 116,
  eMsgToGCFromGS_NotifyNotice = 117,
  eMsgToGCFromGS_NotifyGuideTips = 118,
  eMsgToGCFromGS_NotifyUserCLDays = 119,
  eMsgToGCFromGs_NotifySecondaryGuideTask = 121,
  eMsgToGCFromGs_NotifyCurGold = 122,
  eMsgToGCFromGs_NotifyCurDiamond = 123,
  eMsgToGCFromGS_NotifyGetloginRewardSuccess = 124,
  eMsgToGCFromGS_NotifyGetloginReward_Skin = 125,
  eMsgToGCFromGS_NotifyGetloginReward_Rune = 126,
  eMsgToGCFromGS_NotifyGetloginReward_Hero = 127,
  eMsgToGCFromGS_NotifyUserBaseUpLv = 128,
  eMsgToGCFromGS_NotifyBattleSpanTime = 129,
  eMsgToGCFromGS_NotifyBattleMatherCount = 130,
  eMsgToGCFromGS_NotifyHeroAssist = 131,
  eMsgToGCFromGS_NotifyHeroAttributes = 132,
  eMsgToGCFromGS_NotifyGoodsCfgInfo = 133,
  eMsgToGCFromGS_NotifyUserMail = 134,
  eMsgToGCFromGS_NotifyMailInfo = 135,
  eMsgToGCFromGS_NotifyIfMailDelAndSort = 136,
  eMsgToGCFromGS_NotifyRoomBaseInfo = 140,
  eMsgToGCFromBS_NotifyCanInviteFriends = 141,
  eMsgToGCFromBS_NotifyCurLastHitNum = 142,
  eMsgToGCFromGS_AskRoomListRet = 143,
  eMsgToGCFromBS_NotifyHerosInfo = 144,
  eMsgToGCFromBS_NotifyGoodsExpired = 145,
  eMsgToGCFromGS_NotifySkillModelPurification = 220,
  eMsgToGCFromGS_NotifyCSHeroList = 221,
  eMsgToGCFromGS_NotifyMatchTeamBaseInfo = 222,
  eMsgToGCFromGS_NotifyMatchTeamPlayerInfo = 223,
  eMsgToGCFromGS_NotifyMatchTeamSwitch = 224,
  eMsgToGCFromGS_NotifyMatchInviteJoin = 225,
  eMsgToGCFromGS_NotifyGetNewCommodity = 226,
  eMsgToGCFromGS_NotifyRemoveCommodity = 227,
  eMsgToGCFromGS_NotifyRunesList = 228,
  eMsgToGCFromGS_NotifyNewNickname = 229,
  eMsgToGCFromGS_NotifyOneMatchNeedOne = 230,
  eMsgToGCFromGS_NotifyNewHeaderid = 231,
  eMsgToGCFromGS_NotifyUserLvInfo = 232,
  eMsgToGCFromGS_BroadBattlePersonalResult = 233,
  eMsgToGCFromGS_UnloadRune = 234,
  eMsgToGCFromGS_NotifyBattleDelayTime = 235,
  eMsgToGCFromGS_RecoinRuneRet = 236,
  eMsgToGCFromGS_NotifyOtherItemInfo = 237,
  eMsgToGCFromCS_NotifyIsOnSS = 238,
  eMsgToGCFromGS_NotifyGameObjectUsingSkillState = 240,
  eMsgToGCFromGS_NotifyGameObjectLastingSkillState = 241,
  eMsgToGCFromGS_GuideResp = 300,
  eMsgToGCFromCS_GuideKillsInfo = 301,
  eMsgToGCFromGS_GuideAward = 302,
  eMsgToGCFromGS_UpdateAllTask = 400,
  eMsgToGCFromGS_UpdateAllDailyTask = 401,
  eMsgToGCFromGS_AddOneTask = 402,
  eMsgToGCFromGS_UpdateOneTask = 403,
  eMsgToGCFromGS_DelOneTask = 404,
  eMsgToGCFromGS_RewardsOneTask = 405,
  eMsgToGCFromGS_NotifySkillModelStartLink = 550,
  eMsgToGCFromGS_NotifySkillModelStopLink = 551,
  eMsgToGCFromGS_NotifyMailRet = 601,
  eMsgToGCFromGS_End = 1000,
};

bool MsgID_IsValid(int value);
extern const uint32_t MsgID_internal_data_[];
constexpr MsgID MsgID_MIN = static_cast<MsgID>(0);
constexpr MsgID MsgID_MAX = static_cast<MsgID>(1000);
constexpr int MsgID_ARRAYSIZE = 1000 + 1;
const ::google::protobuf::EnumDescriptor*
MsgID_descriptor();
template <typename T>
const std::string& MsgID_Name(T value) {
  static_assert(std::is_same<T, MsgID>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgID_Name().");
  return ::google::protobuf::internal::NameOfEnum(MsgID_descriptor(), value);
}
inline bool MsgID_Parse(absl::string_view name, MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgID>(
      MsgID_descriptor(), name, value);
}
enum MailType : int {
  mailType_None = 0,
  mailType_1 = 1,
  mailType_2 = 2,
  mailType_3 = 3,
  mailType_4 = 4,
};

bool MailType_IsValid(int value);
extern const uint32_t MailType_internal_data_[];
constexpr MailType MailType_MIN = static_cast<MailType>(0);
constexpr MailType MailType_MAX = static_cast<MailType>(4);
constexpr int MailType_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
MailType_descriptor();
template <typename T>
const std::string& MailType_Name(T value) {
  static_assert(std::is_same<T, MailType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MailType_Name().");
  return MailType_Name(static_cast<MailType>(value));
}
template <>
inline const std::string& MailType_Name(MailType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MailType_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool MailType_Parse(absl::string_view name, MailType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MailType>(
      MailType_descriptor(), name, value);
}
enum EMailCurtState : int {
  eMailState_None = 0,
  eMailState_New = 1,
  eMailState_LookedButNotGotGift = 2,
  eMailState_Look = 3,
  eMailState_Del = 4,
};

bool EMailCurtState_IsValid(int value);
extern const uint32_t EMailCurtState_internal_data_[];
constexpr EMailCurtState EMailCurtState_MIN = static_cast<EMailCurtState>(0);
constexpr EMailCurtState EMailCurtState_MAX = static_cast<EMailCurtState>(4);
constexpr int EMailCurtState_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
EMailCurtState_descriptor();
template <typename T>
const std::string& EMailCurtState_Name(T value) {
  static_assert(std::is_same<T, EMailCurtState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to EMailCurtState_Name().");
  return EMailCurtState_Name(static_cast<EMailCurtState>(value));
}
template <>
inline const std::string& EMailCurtState_Name(EMailCurtState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<EMailCurtState_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool EMailCurtState_Parse(absl::string_view name, EMailCurtState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EMailCurtState>(
      EMailCurtState_descriptor(), name, value);
}
enum BattleState : int {
  free = 0,
  waiting = 1,
  selecthero = 2,
  loading = 3,
  playing = 4,
  finish = 5,
};

bool BattleState_IsValid(int value);
extern const uint32_t BattleState_internal_data_[];
constexpr BattleState BattleState_MIN = static_cast<BattleState>(0);
constexpr BattleState BattleState_MAX = static_cast<BattleState>(5);
constexpr int BattleState_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
BattleState_descriptor();
template <typename T>
const std::string& BattleState_Name(T value) {
  static_assert(std::is_same<T, BattleState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BattleState_Name().");
  return BattleState_Name(static_cast<BattleState>(value));
}
template <>
inline const std::string& BattleState_Name(BattleState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BattleState_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool BattleState_Parse(absl::string_view name, BattleState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BattleState>(
      BattleState_descriptor(), name, value);
}
enum ObjType : int {
  ObjType_Hero = 1,
  ObjType_NPC = 2,
};

bool ObjType_IsValid(int value);
extern const uint32_t ObjType_internal_data_[];
constexpr ObjType ObjType_MIN = static_cast<ObjType>(1);
constexpr ObjType ObjType_MAX = static_cast<ObjType>(2);
constexpr int ObjType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ObjType_descriptor();
template <typename T>
const std::string& ObjType_Name(T value) {
  static_assert(std::is_same<T, ObjType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ObjType_Name().");
  return ObjType_Name(static_cast<ObjType>(value));
}
template <>
inline const std::string& ObjType_Name(ObjType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObjType_descriptor,
                                                 1, 2>(
      static_cast<int>(value));
}
inline bool ObjType_Parse(absl::string_view name, ObjType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjType>(
      ObjType_descriptor(), name, value);
}
enum HPMPChangeReason : int {
  NormalHurt = 0,
  BloastHurt = 1,
  SkillHurt = 2,
  RecoverHurt = 3,
  SkillConsume = 4,
  BuffEffectReason = 5,
};

bool HPMPChangeReason_IsValid(int value);
extern const uint32_t HPMPChangeReason_internal_data_[];
constexpr HPMPChangeReason HPMPChangeReason_MIN = static_cast<HPMPChangeReason>(0);
constexpr HPMPChangeReason HPMPChangeReason_MAX = static_cast<HPMPChangeReason>(5);
constexpr int HPMPChangeReason_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
HPMPChangeReason_descriptor();
template <typename T>
const std::string& HPMPChangeReason_Name(T value) {
  static_assert(std::is_same<T, HPMPChangeReason>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to HPMPChangeReason_Name().");
  return HPMPChangeReason_Name(static_cast<HPMPChangeReason>(value));
}
template <>
inline const std::string& HPMPChangeReason_Name(HPMPChangeReason value) {
  return ::google::protobuf::internal::NameOfDenseEnum<HPMPChangeReason_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool HPMPChangeReason_Parse(absl::string_view name, HPMPChangeReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HPMPChangeReason>(
      HPMPChangeReason_descriptor(), name, value);
}
enum SkillState : int {
  sing = 0,
  prepare = 1,
  release = 2,
  end = 3,
};

bool SkillState_IsValid(int value);
extern const uint32_t SkillState_internal_data_[];
constexpr SkillState SkillState_MIN = static_cast<SkillState>(0);
constexpr SkillState SkillState_MAX = static_cast<SkillState>(3);
constexpr int SkillState_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SkillState_descriptor();
template <typename T>
const std::string& SkillState_Name(T value) {
  static_assert(std::is_same<T, SkillState>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SkillState_Name().");
  return SkillState_Name(static_cast<SkillState>(value));
}
template <>
inline const std::string& SkillState_Name(SkillState value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SkillState_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SkillState_Parse(absl::string_view name, SkillState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SkillState>(
      SkillState_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class WarningToSelectHero final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.WarningToSelectHero) */ {
 public:
  inline WarningToSelectHero() : WarningToSelectHero(nullptr) {}
  ~WarningToSelectHero() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WarningToSelectHero(
      ::google::protobuf::internal::ConstantInitialized);

  inline WarningToSelectHero(const WarningToSelectHero& from) : WarningToSelectHero(nullptr, from) {}
  inline WarningToSelectHero(WarningToSelectHero&& from) noexcept
      : WarningToSelectHero(nullptr, std::move(from)) {}
  inline WarningToSelectHero& operator=(const WarningToSelectHero& from) {
    CopyFrom(from);
    return *this;
  }
  inline WarningToSelectHero& operator=(WarningToSelectHero&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WarningToSelectHero& default_instance() {
    return *internal_default_instance();
  }
  static inline const WarningToSelectHero* internal_default_instance() {
    return reinterpret_cast<const WarningToSelectHero*>(
        &_WarningToSelectHero_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 74;
  friend void swap(WarningToSelectHero& a, WarningToSelectHero& b) { a.Swap(&b); }
  inline void Swap(WarningToSelectHero* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WarningToSelectHero* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WarningToSelectHero* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<WarningToSelectHero>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WarningToSelectHero& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WarningToSelectHero& from) { WarningToSelectHero::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WarningToSelectHero* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.WarningToSelectHero"; }

 protected:
  explicit WarningToSelectHero(::google::protobuf::Arena* arena);
  WarningToSelectHero(::google::protobuf::Arena* arena, const WarningToSelectHero& from);
  WarningToSelectHero(::google::protobuf::Arena* arena, WarningToSelectHero&& from) noexcept
      : WarningToSelectHero(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_WarningToSelectHero];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.WarningToSelectHero)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class UserGameInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.UserGameInfo) */ {
 public:
  inline UserGameInfo() : UserGameInfo(nullptr) {}
  ~UserGameInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserGameInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserGameInfo(const UserGameInfo& from) : UserGameInfo(nullptr, from) {}
  inline UserGameInfo(UserGameInfo&& from) noexcept
      : UserGameInfo(nullptr, std::move(from)) {}
  inline UserGameInfo& operator=(const UserGameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserGameInfo& operator=(UserGameInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserGameInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserGameInfo* internal_default_instance() {
    return reinterpret_cast<const UserGameInfo*>(
        &_UserGameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 123;
  friend void swap(UserGameInfo& a, UserGameInfo& b) { a.Swap(&b); }
  inline void Swap(UserGameInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserGameInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserGameInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserGameInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserGameInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserGameInfo& from) { UserGameInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserGameInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.UserGameInfo"; }

 protected:
  explicit UserGameInfo(::google::protobuf::Arena* arena);
  UserGameInfo(::google::protobuf::Arena* arena, const UserGameInfo& from);
  UserGameInfo(::google::protobuf::Arena* arena, UserGameInfo&& from) noexcept
      : UserGameInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 3,
    kGuildnameFieldNumber = 17,
    kHeadidFieldNumber = 2,
    kLevelFieldNumber = 4,
    kUpgradeexpFieldNumber = 5,
    kCurexpFieldNumber = 6,
    kTotalgameinnsFieldNumber = 7,
    kTotalwintimesFieldNumber = 8,
    kHerokillsFieldNumber = 9,
    kDestorybuildingsFieldNumber = 10,
    kDeadtimesFieldNumber = 11,
    kTotalAchnumFieldNumber = 12,
    kAchnumFieldNumber = 13,
    kVipscoreFieldNumber = 14,
    kAssistnumFieldNumber = 15,
    kLadderscoreFieldNumber = 16,
    kExpAdtimeFieldNumber = 18,
    kGoldAddtimeFieldNumber = 19,
    kMsgidFieldNumber = 1,
  };
  // optional string nickname = 3;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional string guildname = 17;
  bool has_guildname() const;
  void clear_guildname() ;
  const std::string& guildname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_guildname(Arg_&& arg, Args_... args);
  std::string* mutable_guildname();
  PROTOBUF_NODISCARD std::string* release_guildname();
  void set_allocated_guildname(std::string* value);

  private:
  const std::string& _internal_guildname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guildname(
      const std::string& value);
  std::string* _internal_mutable_guildname();

  public:
  // optional int32 headid = 2;
  bool has_headid() const;
  void clear_headid() ;
  ::int32_t headid() const;
  void set_headid(::int32_t value);

  private:
  ::int32_t _internal_headid() const;
  void _internal_set_headid(::int32_t value);

  public:
  // optional int32 level = 4;
  bool has_level() const;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // optional int32 upgradeexp = 5;
  bool has_upgradeexp() const;
  void clear_upgradeexp() ;
  ::int32_t upgradeexp() const;
  void set_upgradeexp(::int32_t value);

  private:
  ::int32_t _internal_upgradeexp() const;
  void _internal_set_upgradeexp(::int32_t value);

  public:
  // optional int32 curexp = 6;
  bool has_curexp() const;
  void clear_curexp() ;
  ::int32_t curexp() const;
  void set_curexp(::int32_t value);

  private:
  ::int32_t _internal_curexp() const;
  void _internal_set_curexp(::int32_t value);

  public:
  // optional int32 totalgameinns = 7;
  bool has_totalgameinns() const;
  void clear_totalgameinns() ;
  ::int32_t totalgameinns() const;
  void set_totalgameinns(::int32_t value);

  private:
  ::int32_t _internal_totalgameinns() const;
  void _internal_set_totalgameinns(::int32_t value);

  public:
  // optional int32 totalwintimes = 8;
  bool has_totalwintimes() const;
  void clear_totalwintimes() ;
  ::int32_t totalwintimes() const;
  void set_totalwintimes(::int32_t value);

  private:
  ::int32_t _internal_totalwintimes() const;
  void _internal_set_totalwintimes(::int32_t value);

  public:
  // optional int32 herokills = 9;
  bool has_herokills() const;
  void clear_herokills() ;
  ::int32_t herokills() const;
  void set_herokills(::int32_t value);

  private:
  ::int32_t _internal_herokills() const;
  void _internal_set_herokills(::int32_t value);

  public:
  // optional int32 destorybuildings = 10;
  bool has_destorybuildings() const;
  void clear_destorybuildings() ;
  ::int32_t destorybuildings() const;
  void set_destorybuildings(::int32_t value);

  private:
  ::int32_t _internal_destorybuildings() const;
  void _internal_set_destorybuildings(::int32_t value);

  public:
  // optional int32 deadtimes = 11;
  bool has_deadtimes() const;
  void clear_deadtimes() ;
  ::int32_t deadtimes() const;
  void set_deadtimes(::int32_t value);

  private:
  ::int32_t _internal_deadtimes() const;
  void _internal_set_deadtimes(::int32_t value);

  public:
  // optional int32 total_achnum = 12;
  bool has_total_achnum() const;
  void clear_total_achnum() ;
  ::int32_t total_achnum() const;
  void set_total_achnum(::int32_t value);

  private:
  ::int32_t _internal_total_achnum() const;
  void _internal_set_total_achnum(::int32_t value);

  public:
  // optional int32 achnum = 13;
  bool has_achnum() const;
  void clear_achnum() ;
  ::int32_t achnum() const;
  void set_achnum(::int32_t value);

  private:
  ::int32_t _internal_achnum() const;
  void _internal_set_achnum(::int32_t value);

  public:
  // optional int32 vipscore = 14;
  bool has_vipscore() const;
  void clear_vipscore() ;
  ::int32_t vipscore() const;
  void set_vipscore(::int32_t value);

  private:
  ::int32_t _internal_vipscore() const;
  void _internal_set_vipscore(::int32_t value);

  public:
  // optional int32 assistnum = 15;
  bool has_assistnum() const;
  void clear_assistnum() ;
  ::int32_t assistnum() const;
  void set_assistnum(::int32_t value);

  private:
  ::int32_t _internal_assistnum() const;
  void _internal_set_assistnum(::int32_t value);

  public:
  // optional int32 ladderscore = 16;
  bool has_ladderscore() const;
  void clear_ladderscore() ;
  ::int32_t ladderscore() const;
  void set_ladderscore(::int32_t value);

  private:
  ::int32_t _internal_ladderscore() const;
  void _internal_set_ladderscore(::int32_t value);

  public:
  // optional int64 exp_adtime = 18;
  bool has_exp_adtime() const;
  void clear_exp_adtime() ;
  ::int64_t exp_adtime() const;
  void set_exp_adtime(::int64_t value);

  private:
  ::int64_t _internal_exp_adtime() const;
  void _internal_set_exp_adtime(::int64_t value);

  public:
  // optional int64 gold_addtime = 19;
  bool has_gold_addtime() const;
  void clear_gold_addtime() ;
  ::int64_t gold_addtime() const;
  void set_gold_addtime(::int64_t value);

  private:
  ::int64_t _internal_gold_addtime() const;
  void _internal_set_gold_addtime(::int64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserGameInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.UserGameInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 19, 1,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr guildname_;
    ::int32_t headid_;
    ::int32_t level_;
    ::int32_t upgradeexp_;
    ::int32_t curexp_;
    ::int32_t totalgameinns_;
    ::int32_t totalwintimes_;
    ::int32_t herokills_;
    ::int32_t destorybuildings_;
    ::int32_t deadtimes_;
    ::int32_t total_achnum_;
    ::int32_t achnum_;
    ::int32_t vipscore_;
    ::int32_t assistnum_;
    ::int32_t ladderscore_;
    ::int64_t exp_adtime_;
    ::int64_t gold_addtime_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class UserBeInvitedToBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.UserBeInvitedToBattle) */ {
 public:
  inline UserBeInvitedToBattle() : UserBeInvitedToBattle(nullptr) {}
  ~UserBeInvitedToBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserBeInvitedToBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserBeInvitedToBattle(const UserBeInvitedToBattle& from) : UserBeInvitedToBattle(nullptr, from) {}
  inline UserBeInvitedToBattle(UserBeInvitedToBattle&& from) noexcept
      : UserBeInvitedToBattle(nullptr, std::move(from)) {}
  inline UserBeInvitedToBattle& operator=(const UserBeInvitedToBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserBeInvitedToBattle& operator=(UserBeInvitedToBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserBeInvitedToBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserBeInvitedToBattle* internal_default_instance() {
    return reinterpret_cast<const UserBeInvitedToBattle*>(
        &_UserBeInvitedToBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 68;
  friend void swap(UserBeInvitedToBattle& a, UserBeInvitedToBattle& b) { a.Swap(&b); }
  inline void Swap(UserBeInvitedToBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserBeInvitedToBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserBeInvitedToBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserBeInvitedToBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserBeInvitedToBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserBeInvitedToBattle& from) { UserBeInvitedToBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserBeInvitedToBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.UserBeInvitedToBattle"; }

 protected:
  explicit UserBeInvitedToBattle(::google::protobuf::Arena* arena);
  UserBeInvitedToBattle(::google::protobuf::Arena* arena, const UserBeInvitedToBattle& from);
  UserBeInvitedToBattle(::google::protobuf::Arena* arena, UserBeInvitedToBattle&& from) noexcept
      : UserBeInvitedToBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPwdFieldNumber = 3,
    kInvitorFieldNumber = 4,
    kBattleidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // optional string pwd = 3;
  bool has_pwd() const;
  void clear_pwd() ;
  const std::string& pwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pwd(Arg_&& arg, Args_... args);
  std::string* mutable_pwd();
  PROTOBUF_NODISCARD std::string* release_pwd();
  void set_allocated_pwd(std::string* value);

  private:
  const std::string& _internal_pwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pwd(
      const std::string& value);
  std::string* _internal_mutable_pwd();

  public:
  // optional string Invitor = 4;
  bool has_invitor() const;
  void clear_invitor() ;
  const std::string& invitor() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_invitor(Arg_&& arg, Args_... args);
  std::string* mutable_invitor();
  PROTOBUF_NODISCARD std::string* release_invitor();
  void set_allocated_invitor(std::string* value);

  private:
  const std::string& _internal_invitor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invitor(
      const std::string& value);
  std::string* _internal_mutable_invitor();

  public:
  // optional int32 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::int32_t battleid() const;
  void set_battleid(::int32_t value);

  private:
  ::int32_t _internal_battleid() const;
  void _internal_set_battleid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_UserBeInvitedToBattle];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GSToGC::MsgID msgnum() const;
  void set_msgnum(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgnum() const;
  void _internal_set_msgnum(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.UserBeInvitedToBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      47, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr pwd_;
    ::google::protobuf::internal::ArenaStringPtr invitor_;
    ::int32_t battleid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class UserBaseUpLv final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.UserBaseUpLv) */ {
 public:
  inline UserBaseUpLv() : UserBaseUpLv(nullptr) {}
  ~UserBaseUpLv() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserBaseUpLv(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserBaseUpLv(const UserBaseUpLv& from) : UserBaseUpLv(nullptr, from) {}
  inline UserBaseUpLv(UserBaseUpLv&& from) noexcept
      : UserBaseUpLv(nullptr, std::move(from)) {}
  inline UserBaseUpLv& operator=(const UserBaseUpLv& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserBaseUpLv& operator=(UserBaseUpLv&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserBaseUpLv& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserBaseUpLv* internal_default_instance() {
    return reinterpret_cast<const UserBaseUpLv*>(
        &_UserBaseUpLv_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 46;
  friend void swap(UserBaseUpLv& a, UserBaseUpLv& b) { a.Swap(&b); }
  inline void Swap(UserBaseUpLv* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserBaseUpLv* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserBaseUpLv* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserBaseUpLv>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserBaseUpLv& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserBaseUpLv& from) { UserBaseUpLv::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserBaseUpLv* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.UserBaseUpLv"; }

 protected:
  explicit UserBaseUpLv(::google::protobuf::Arena* arena);
  UserBaseUpLv(::google::protobuf::Arena* arena, const UserBaseUpLv& from);
  UserBaseUpLv(::google::protobuf::Arena* arena, UserBaseUpLv&& from) noexcept
      : UserBaseUpLv(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLvFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int32 lv = 2;
  bool has_lv() const;
  void clear_lv() ;
  ::int32_t lv() const;
  void set_lv(::int32_t value);

  private:
  ::int32_t _internal_lv() const;
  void _internal_set_lv(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserBaseUpLv];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.UserBaseUpLv)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t lv_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class UserBaseInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.UserBaseInfo) */ {
 public:
  inline UserBaseInfo() : UserBaseInfo(nullptr) {}
  ~UserBaseInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserBaseInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserBaseInfo(const UserBaseInfo& from) : UserBaseInfo(nullptr, from) {}
  inline UserBaseInfo(UserBaseInfo&& from) noexcept
      : UserBaseInfo(nullptr, std::move(from)) {}
  inline UserBaseInfo& operator=(const UserBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserBaseInfo& operator=(UserBaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserBaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserBaseInfo* internal_default_instance() {
    return reinterpret_cast<const UserBaseInfo*>(
        &_UserBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 71;
  friend void swap(UserBaseInfo& a, UserBaseInfo& b) { a.Swap(&b); }
  inline void Swap(UserBaseInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserBaseInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserBaseInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserBaseInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserBaseInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserBaseInfo& from) { UserBaseInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserBaseInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.UserBaseInfo"; }

 protected:
  explicit UserBaseInfo(::google::protobuf::Arena* arena);
  UserBaseInfo(::google::protobuf::Arena* arena, const UserBaseInfo& from);
  UserBaseInfo(::google::protobuf::Arena* arena, UserBaseInfo&& from) noexcept
      : UserBaseInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 3,
    kNicknameFieldNumber = 4,
    kGuidFieldNumber = 2,
    kHeadidFieldNumber = 5,
    kSexFieldNumber = 6,
    kCurscoreFieldNumber = 7,
    kCurdiamoandFieldNumber = 8,
    kCurgoldFieldNumber = 9,
    kMapidFieldNumber = 11,
    kIfreconnectFieldNumber = 12,
    kBattleidFieldNumber = 13,
    kLevelFieldNumber = 14,
    kVipLevelFieldNumber = 15,
    kVipScoreFieldNumber = 16,
    kCurExpFieldNumber = 17,
    kMsgidFieldNumber = 1,
  };
  // optional string name = 3;
  bool has_name() const;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // optional string nickname = 4;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 headid = 5;
  bool has_headid() const;
  void clear_headid() ;
  ::int32_t headid() const;
  void set_headid(::int32_t value);

  private:
  ::int32_t _internal_headid() const;
  void _internal_set_headid(::int32_t value);

  public:
  // optional int32 sex = 6;
  bool has_sex() const;
  void clear_sex() ;
  ::int32_t sex() const;
  void set_sex(::int32_t value);

  private:
  ::int32_t _internal_sex() const;
  void _internal_set_sex(::int32_t value);

  public:
  // optional int64 curscore = 7;
  bool has_curscore() const;
  void clear_curscore() ;
  ::int64_t curscore() const;
  void set_curscore(::int64_t value);

  private:
  ::int64_t _internal_curscore() const;
  void _internal_set_curscore(::int64_t value);

  public:
  // optional int64 curdiamoand = 8;
  bool has_curdiamoand() const;
  void clear_curdiamoand() ;
  ::int64_t curdiamoand() const;
  void set_curdiamoand(::int64_t value);

  private:
  ::int64_t _internal_curdiamoand() const;
  void _internal_set_curdiamoand(::int64_t value);

  public:
  // optional int64 curgold = 9;
  bool has_curgold() const;
  void clear_curgold() ;
  ::int64_t curgold() const;
  void set_curgold(::int64_t value);

  private:
  ::int64_t _internal_curgold() const;
  void _internal_set_curgold(::int64_t value);

  public:
  // optional int32 mapid = 11;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional bool ifreconnect = 12;
  bool has_ifreconnect() const;
  void clear_ifreconnect() ;
  bool ifreconnect() const;
  void set_ifreconnect(bool value);

  private:
  bool _internal_ifreconnect() const;
  void _internal_set_ifreconnect(bool value);

  public:
  // optional uint64 battleid = 13;
  bool has_battleid() const;
  void clear_battleid() ;
  ::uint64_t battleid() const;
  void set_battleid(::uint64_t value);

  private:
  ::uint64_t _internal_battleid() const;
  void _internal_set_battleid(::uint64_t value);

  public:
  // optional int32 level = 14;
  bool has_level() const;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // optional int32 vip_level = 15;
  bool has_vip_level() const;
  void clear_vip_level() ;
  ::int32_t vip_level() const;
  void set_vip_level(::int32_t value);

  private:
  ::int32_t _internal_vip_level() const;
  void _internal_set_vip_level(::int32_t value);

  public:
  // optional int32 vip_score = 16;
  bool has_vip_score() const;
  void clear_vip_score() ;
  ::int32_t vip_score() const;
  void set_vip_score(::int32_t value);

  private:
  ::int32_t _internal_vip_score() const;
  void _internal_set_vip_score(::int32_t value);

  public:
  // optional int32 cur_exp = 17;
  bool has_cur_exp() const;
  void clear_cur_exp() ;
  ::int32_t cur_exp() const;
  void set_cur_exp(::int32_t value);

  private:
  ::int32_t _internal_cur_exp() const;
  void _internal_set_cur_exp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserBaseInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.UserBaseInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      5, 16, 1,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint64_t guid_;
    ::int32_t headid_;
    ::int32_t sex_;
    ::int64_t curscore_;
    ::int64_t curdiamoand_;
    ::int64_t curgold_;
    ::int32_t mapid_;
    bool ifreconnect_;
    ::uint64_t battleid_;
    ::int32_t level_;
    ::int32_t vip_level_;
    ::int32_t vip_score_;
    ::int32_t cur_exp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class UnloadRune final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.UnloadRune) */ {
 public:
  inline UnloadRune() : UnloadRune(nullptr) {}
  ~UnloadRune() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnloadRune(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnloadRune(const UnloadRune& from) : UnloadRune(nullptr, from) {}
  inline UnloadRune(UnloadRune&& from) noexcept
      : UnloadRune(nullptr, std::move(from)) {}
  inline UnloadRune& operator=(const UnloadRune& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnloadRune& operator=(UnloadRune&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnloadRune& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnloadRune* internal_default_instance() {
    return reinterpret_cast<const UnloadRune*>(
        &_UnloadRune_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(UnloadRune& a, UnloadRune& b) { a.Swap(&b); }
  inline void Swap(UnloadRune* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnloadRune* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnloadRune* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UnloadRune>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnloadRune& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnloadRune& from) { UnloadRune::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnloadRune* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.UnloadRune"; }

 protected:
  explicit UnloadRune(::google::protobuf::Arena* arena);
  UnloadRune(::google::protobuf::Arena* arena, const UnloadRune& from);
  UnloadRune(::google::protobuf::Arena* arena, UnloadRune&& from) noexcept
      : UnloadRune(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageFieldNumber = 2,
    kPosFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int32 page = 2;
  bool has_page() const;
  void clear_page() ;
  ::int32_t page() const;
  void set_page(::int32_t value);

  private:
  ::int32_t _internal_page() const;
  void _internal_set_page(::int32_t value);

  public:
  // optional int32 pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UnloadRune];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.UnloadRune)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t page_;
    ::int32_t pos_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class TryToChooseHero final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.TryToChooseHero) */ {
 public:
  inline TryToChooseHero() : TryToChooseHero(nullptr) {}
  ~TryToChooseHero() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TryToChooseHero(
      ::google::protobuf::internal::ConstantInitialized);

  inline TryToChooseHero(const TryToChooseHero& from) : TryToChooseHero(nullptr, from) {}
  inline TryToChooseHero(TryToChooseHero&& from) noexcept
      : TryToChooseHero(nullptr, std::move(from)) {}
  inline TryToChooseHero& operator=(const TryToChooseHero& from) {
    CopyFrom(from);
    return *this;
  }
  inline TryToChooseHero& operator=(TryToChooseHero&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TryToChooseHero& default_instance() {
    return *internal_default_instance();
  }
  static inline const TryToChooseHero* internal_default_instance() {
    return reinterpret_cast<const TryToChooseHero*>(
        &_TryToChooseHero_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 107;
  friend void swap(TryToChooseHero& a, TryToChooseHero& b) { a.Swap(&b); }
  inline void Swap(TryToChooseHero* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TryToChooseHero* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TryToChooseHero* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TryToChooseHero>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TryToChooseHero& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TryToChooseHero& from) { TryToChooseHero::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TryToChooseHero* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.TryToChooseHero"; }

 protected:
  explicit TryToChooseHero(::google::protobuf::Arena* arena);
  TryToChooseHero(::google::protobuf::Arena* arena, const TryToChooseHero& from);
  TryToChooseHero(::google::protobuf::Arena* arena, TryToChooseHero&& from) noexcept
      : TryToChooseHero(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 2,
    kHeroidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int32 pos = 2;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional int32 heroid = 3;
  bool has_heroid() const;
  void clear_heroid() ;
  ::int32_t heroid() const;
  void set_heroid(::int32_t value);

  private:
  ::int32_t _internal_heroid() const;
  void _internal_set_heroid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyTryToChooseHero];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.TryToChooseHero)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t pos_;
    ::int32_t heroid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class TaskData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.TaskData) */ {
 public:
  inline TaskData() : TaskData(nullptr) {}
  ~TaskData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaskData(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaskData(const TaskData& from) : TaskData(nullptr, from) {}
  inline TaskData(TaskData&& from) noexcept
      : TaskData(nullptr, std::move(from)) {}
  inline TaskData& operator=(const TaskData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaskData& operator=(TaskData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaskData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaskData* internal_default_instance() {
    return reinterpret_cast<const TaskData*>(
        &_TaskData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(TaskData& a, TaskData& b) { a.Swap(&b); }
  inline void Swap(TaskData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaskData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaskData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<TaskData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaskData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaskData& from) { TaskData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaskData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.TaskData"; }

 protected:
  explicit TaskData(::google::protobuf::Arena* arena);
  TaskData(::google::protobuf::Arena* arena, const TaskData& from);
  TaskData(::google::protobuf::Arena* arena, TaskData&& from) noexcept
      : TaskData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskIdFieldNumber = 1,
    kTaskGuidFieldNumber = 2,
    kTaskCurCountFieldNumber = 3,
  };
  // optional uint32 task_id = 1;
  bool has_task_id() const;
  void clear_task_id() ;
  ::uint32_t task_id() const;
  void set_task_id(::uint32_t value);

  private:
  ::uint32_t _internal_task_id() const;
  void _internal_set_task_id(::uint32_t value);

  public:
  // optional uint32 task_guid = 2;
  bool has_task_guid() const;
  void clear_task_guid() ;
  ::uint32_t task_guid() const;
  void set_task_guid(::uint32_t value);

  private:
  ::uint32_t _internal_task_guid() const;
  void _internal_set_task_guid(::uint32_t value);

  public:
  // optional uint32 task_curCount = 3;
  bool has_task_curcount() const;
  void clear_task_curcount() ;
  ::uint32_t task_curcount() const;
  void set_task_curcount(::uint32_t value);

  private:
  ::uint32_t _internal_task_curcount() const;
  void _internal_set_task_curcount(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.TaskData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t task_id_;
    ::uint32_t task_guid_;
    ::uint32_t task_curcount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class SummonEffect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.SummonEffect) */ {
 public:
  inline SummonEffect() : SummonEffect(nullptr) {}
  ~SummonEffect() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SummonEffect(
      ::google::protobuf::internal::ConstantInitialized);

  inline SummonEffect(const SummonEffect& from) : SummonEffect(nullptr, from) {}
  inline SummonEffect(SummonEffect&& from) noexcept
      : SummonEffect(nullptr, std::move(from)) {}
  inline SummonEffect& operator=(const SummonEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline SummonEffect& operator=(SummonEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SummonEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const SummonEffect* internal_default_instance() {
    return reinterpret_cast<const SummonEffect*>(
        &_SummonEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 152;
  friend void swap(SummonEffect& a, SummonEffect& b) { a.Swap(&b); }
  inline void Swap(SummonEffect* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SummonEffect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SummonEffect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SummonEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SummonEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SummonEffect& from) { SummonEffect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SummonEffect* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.SummonEffect"; }

 protected:
  explicit SummonEffect(::google::protobuf::Arena* arena);
  SummonEffect(::google::protobuf::Arena* arena, const SummonEffect& from);
  SummonEffect(::google::protobuf::Arena* arena, SummonEffect&& from) noexcept
      : SummonEffect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kNpcguidFieldNumber = 4,
    kEffectidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint64 npcguid = 4;
  bool has_npcguid() const;
  void clear_npcguid() ;
  ::uint64_t npcguid() const;
  void set_npcguid(::uint64_t value);

  private:
  ::uint64_t _internal_npcguid() const;
  void _internal_set_npcguid(::uint64_t value);

  public:
  // optional uint32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::uint32_t effectid() const;
  void set_effectid(::uint32_t value);

  private:
  ::uint32_t _internal_effectid() const;
  void _internal_set_effectid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelSummonEffect];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.SummonEffect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint64_t npcguid_;
    ::uint32_t effectid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class SkillHitTar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.SkillHitTar) */ {
 public:
  inline SkillHitTar() : SkillHitTar(nullptr) {}
  ~SkillHitTar() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillHitTar(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillHitTar(const SkillHitTar& from) : SkillHitTar(nullptr, from) {}
  inline SkillHitTar(SkillHitTar&& from) noexcept
      : SkillHitTar(nullptr, std::move(from)) {}
  inline SkillHitTar& operator=(const SkillHitTar& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillHitTar& operator=(SkillHitTar&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillHitTar& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillHitTar* internal_default_instance() {
    return reinterpret_cast<const SkillHitTar*>(
        &_SkillHitTar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 104;
  friend void swap(SkillHitTar& a, SkillHitTar& b) { a.Swap(&b); }
  inline void Swap(SkillHitTar* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillHitTar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillHitTar* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SkillHitTar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillHitTar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillHitTar& from) { SkillHitTar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillHitTar* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.SkillHitTar"; }

 protected:
  explicit SkillHitTar(::google::protobuf::Arena* arena);
  SkillHitTar(::google::protobuf::Arena* arena, const SkillHitTar& from);
  SkillHitTar(::google::protobuf::Arena* arena, SkillHitTar&& from) noexcept
      : SkillHitTar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kTarguidFieldNumber = 4,
    kSkillidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional int64 targuid = 4;
  bool has_targuid() const;
  void clear_targuid() ;
  ::int64_t targuid() const;
  void set_targuid(::int64_t value);

  private:
  ::int64_t _internal_targuid() const;
  void _internal_set_targuid(::int64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillHitTarget];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.SkillHitTar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t guid_;
    ::int64_t targuid_;
    ::int32_t skillid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class SkillEnd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.SkillEnd) */ {
 public:
  inline SkillEnd() : SkillEnd(nullptr) {}
  ~SkillEnd() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillEnd(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillEnd(const SkillEnd& from) : SkillEnd(nullptr, from) {}
  inline SkillEnd(SkillEnd&& from) noexcept
      : SkillEnd(nullptr, std::move(from)) {}
  inline SkillEnd& operator=(const SkillEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillEnd& operator=(SkillEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillEnd* internal_default_instance() {
    return reinterpret_cast<const SkillEnd*>(
        &_SkillEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 143;
  friend void swap(SkillEnd& a, SkillEnd& b) { a.Swap(&b); }
  inline void Swap(SkillEnd* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillEnd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SkillEnd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillEnd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillEnd& from) { SkillEnd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillEnd* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.SkillEnd"; }

 protected:
  explicit SkillEnd(::google::protobuf::Arena* arena);
  SkillEnd(::google::protobuf::Arena* arena, const SkillEnd& from);
  SkillEnd(::google::protobuf::Arena* arena, SkillEnd&& from) noexcept
      : SkillEnd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kTarguidFieldNumber = 4,
    kSkillidFieldNumber = 3,
    kUniqueidFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional int64 targuid = 4;
  bool has_targuid() const;
  void clear_targuid() ;
  ::int64_t targuid() const;
  void set_targuid(::int64_t value);

  private:
  ::int64_t _internal_targuid() const;
  void _internal_set_targuid(::int64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional int32 uniqueid = 5;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::int32_t uniqueid() const;
  void set_uniqueid(::int32_t value);

  private:
  ::int32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillEnd];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.SkillEnd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t guid_;
    ::int64_t targuid_;
    ::int32_t skillid_;
    ::int32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class ShortMail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.ShortMail) */ {
 public:
  inline ShortMail() : ShortMail(nullptr) {}
  ~ShortMail() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ShortMail(
      ::google::protobuf::internal::ConstantInitialized);

  inline ShortMail(const ShortMail& from) : ShortMail(nullptr, from) {}
  inline ShortMail(ShortMail&& from) noexcept
      : ShortMail(nullptr, std::move(from)) {}
  inline ShortMail& operator=(const ShortMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShortMail& operator=(ShortMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShortMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShortMail* internal_default_instance() {
    return reinterpret_cast<const ShortMail*>(
        &_ShortMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(ShortMail& a, ShortMail& b) { a.Swap(&b); }
  inline void Swap(ShortMail* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShortMail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShortMail* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ShortMail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShortMail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ShortMail& from) { ShortMail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShortMail* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.ShortMail"; }

 protected:
  explicit ShortMail(::google::protobuf::Arena* arena);
  ShortMail(::google::protobuf::Arena* arena, const ShortMail& from);
  ShortMail(::google::protobuf::Arena* arena, ShortMail&& from) noexcept
      : ShortMail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailTitleFieldNumber = 3,
    kMailidFieldNumber = 1,
    kMailTypeFieldNumber = 2,
    kMailStateFieldNumber = 4,
  };
  // optional string mailTitle = 3;
  bool has_mailtitle() const;
  void clear_mailtitle() ;
  const std::string& mailtitle() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mailtitle(Arg_&& arg, Args_... args);
  std::string* mutable_mailtitle();
  PROTOBUF_NODISCARD std::string* release_mailtitle();
  void set_allocated_mailtitle(std::string* value);

  private:
  const std::string& _internal_mailtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mailtitle(
      const std::string& value);
  std::string* _internal_mutable_mailtitle();

  public:
  // optional int32 mailid = 1;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional .GSToGC.MailType mailType = 2;
  bool has_mailtype() const;
  void clear_mailtype() ;
  ::GSToGC::MailType mailtype() const;
  void set_mailtype(::GSToGC::MailType value);

  private:
  ::GSToGC::MailType _internal_mailtype() const;
  void _internal_set_mailtype(::GSToGC::MailType value);

  public:
  // optional .GSToGC.EMailCurtState mailState = 4;
  bool has_mailstate() const;
  void clear_mailstate() ;
  ::GSToGC::EMailCurtState mailstate() const;
  void set_mailstate(::GSToGC::EMailCurtState value);

  private:
  ::GSToGC::EMailCurtState _internal_mailstate() const;
  void _internal_set_mailstate(::GSToGC::EMailCurtState value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.ShortMail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr mailtitle_;
    ::int32_t mailid_;
    int mailtype_;
    int mailstate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class SecondGuideTask_task_info final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.SecondGuideTask.task_info) */ {
 public:
  inline SecondGuideTask_task_info() : SecondGuideTask_task_info(nullptr) {}
  ~SecondGuideTask_task_info() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SecondGuideTask_task_info(
      ::google::protobuf::internal::ConstantInitialized);

  inline SecondGuideTask_task_info(const SecondGuideTask_task_info& from) : SecondGuideTask_task_info(nullptr, from) {}
  inline SecondGuideTask_task_info(SecondGuideTask_task_info&& from) noexcept
      : SecondGuideTask_task_info(nullptr, std::move(from)) {}
  inline SecondGuideTask_task_info& operator=(const SecondGuideTask_task_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecondGuideTask_task_info& operator=(SecondGuideTask_task_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecondGuideTask_task_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecondGuideTask_task_info* internal_default_instance() {
    return reinterpret_cast<const SecondGuideTask_task_info*>(
        &_SecondGuideTask_task_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 47;
  friend void swap(SecondGuideTask_task_info& a, SecondGuideTask_task_info& b) { a.Swap(&b); }
  inline void Swap(SecondGuideTask_task_info* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecondGuideTask_task_info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecondGuideTask_task_info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SecondGuideTask_task_info>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SecondGuideTask_task_info& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SecondGuideTask_task_info& from) { SecondGuideTask_task_info::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SecondGuideTask_task_info* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.SecondGuideTask.task_info"; }

 protected:
  explicit SecondGuideTask_task_info(::google::protobuf::Arena* arena);
  SecondGuideTask_task_info(::google::protobuf::Arena* arena, const SecondGuideTask_task_info& from);
  SecondGuideTask_task_info(::google::protobuf::Arena* arena, SecondGuideTask_task_info&& from) noexcept
      : SecondGuideTask_task_info(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskidFieldNumber = 1,
    kNumFieldNumber = 2,
  };
  // optional int32 taskid = 1;
  bool has_taskid() const;
  void clear_taskid() ;
  ::int32_t taskid() const;
  void set_taskid(::int32_t value);

  private:
  ::int32_t _internal_taskid() const;
  void _internal_set_taskid(::int32_t value);

  public:
  // optional int32 num = 2;
  bool has_num() const;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.SecondGuideTask.task_info)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t taskid_;
    ::int32_t num_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class SNSInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.SNSInfo) */ {
 public:
  inline SNSInfo() : SNSInfo(nullptr) {}
  ~SNSInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SNSInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SNSInfo(const SNSInfo& from) : SNSInfo(nullptr, from) {}
  inline SNSInfo(SNSInfo&& from) noexcept
      : SNSInfo(nullptr, std::move(from)) {}
  inline SNSInfo& operator=(const SNSInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SNSInfo& operator=(SNSInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SNSInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SNSInfo* internal_default_instance() {
    return reinterpret_cast<const SNSInfo*>(
        &_SNSInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 62;
  friend void swap(SNSInfo& a, SNSInfo& b) { a.Swap(&b); }
  inline void Swap(SNSInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SNSInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SNSInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SNSInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SNSInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SNSInfo& from) { SNSInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SNSInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.SNSInfo"; }

 protected:
  explicit SNSInfo(::google::protobuf::Arena* arena);
  SNSInfo(::google::protobuf::Arena* arena, const SNSInfo& from);
  SNSInfo(::google::protobuf::Arena* arena, SNSInfo&& from) noexcept
      : SNSInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kTypeFieldNumber = 1,
    kHeadidFieldNumber = 3,
    kGuididxFieldNumber = 5,
    kStatusFieldNumber = 4,
    kViplvFieldNumber = 6,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional int32 type = 1;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional uint32 headid = 3;
  bool has_headid() const;
  void clear_headid() ;
  ::uint32_t headid() const;
  void set_headid(::uint32_t value);

  private:
  ::uint32_t _internal_headid() const;
  void _internal_set_headid(::uint32_t value);

  public:
  // optional uint64 guididx = 5;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional int32 status = 4;
  bool has_status() const;
  void clear_status() ;
  ::int32_t status() const;
  void set_status(::int32_t value);

  private:
  ::int32_t _internal_status() const;
  void _internal_set_status(::int32_t value);

  public:
  // optional uint32 viplv = 6;
  bool has_viplv() const;
  void clear_viplv() ;
  ::uint32_t viplv() const;
  void set_viplv(::uint32_t value);

  private:
  ::uint32_t _internal_viplv() const;
  void _internal_set_viplv(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.SNSInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::int32_t type_;
    ::uint32_t headid_;
    ::uint64_t guididx_;
    ::int32_t status_;
    ::uint32_t viplv_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RunesSlot final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RunesSlot) */ {
 public:
  inline RunesSlot() : RunesSlot(nullptr) {}
  ~RunesSlot() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunesSlot(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunesSlot(const RunesSlot& from) : RunesSlot(nullptr, from) {}
  inline RunesSlot(RunesSlot&& from) noexcept
      : RunesSlot(nullptr, std::move(from)) {}
  inline RunesSlot& operator=(const RunesSlot& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunesSlot& operator=(RunesSlot&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunesSlot& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunesSlot* internal_default_instance() {
    return reinterpret_cast<const RunesSlot*>(
        &_RunesSlot_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(RunesSlot& a, RunesSlot& b) { a.Swap(&b); }
  inline void Swap(RunesSlot* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunesSlot* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunesSlot* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RunesSlot>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunesSlot& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunesSlot& from) { RunesSlot::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunesSlot* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RunesSlot"; }

 protected:
  explicit RunesSlot(::google::protobuf::Arena* arena);
  RunesSlot(::google::protobuf::Arena* arena, const RunesSlot& from);
  RunesSlot(::google::protobuf::Arena* arena, RunesSlot&& from) noexcept
      : RunesSlot(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSlotposFieldNumber = 1,
    kRuneidFieldNumber = 2,
    kPageFieldNumber = 3,
  };
  // optional int32 slotpos = 1;
  bool has_slotpos() const;
  void clear_slotpos() ;
  ::int32_t slotpos() const;
  void set_slotpos(::int32_t value);

  private:
  ::int32_t _internal_slotpos() const;
  void _internal_set_slotpos(::int32_t value);

  public:
  // optional uint32 runeid = 2;
  bool has_runeid() const;
  void clear_runeid() ;
  ::uint32_t runeid() const;
  void set_runeid(::uint32_t value);

  private:
  ::uint32_t _internal_runeid() const;
  void _internal_set_runeid(::uint32_t value);

  public:
  // optional int32 page = 3;
  bool has_page() const;
  void clear_page() ;
  ::int32_t page() const;
  void set_page(::int32_t value);

  private:
  ::int32_t _internal_page() const;
  void _internal_set_page(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RunesSlot)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t slotpos_;
    ::uint32_t runeid_;
    ::int32_t page_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RunesBagInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RunesBagInfo) */ {
 public:
  inline RunesBagInfo() : RunesBagInfo(nullptr) {}
  ~RunesBagInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunesBagInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunesBagInfo(const RunesBagInfo& from) : RunesBagInfo(nullptr, from) {}
  inline RunesBagInfo(RunesBagInfo&& from) noexcept
      : RunesBagInfo(nullptr, std::move(from)) {}
  inline RunesBagInfo& operator=(const RunesBagInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunesBagInfo& operator=(RunesBagInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunesBagInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunesBagInfo* internal_default_instance() {
    return reinterpret_cast<const RunesBagInfo*>(
        &_RunesBagInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(RunesBagInfo& a, RunesBagInfo& b) { a.Swap(&b); }
  inline void Swap(RunesBagInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunesBagInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunesBagInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RunesBagInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunesBagInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunesBagInfo& from) { RunesBagInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunesBagInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RunesBagInfo"; }

 protected:
  explicit RunesBagInfo(::google::protobuf::Arena* arena);
  RunesBagInfo(::google::protobuf::Arena* arena, const RunesBagInfo& from);
  RunesBagInfo(::google::protobuf::Arena* arena, RunesBagInfo&& from) noexcept
      : RunesBagInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRuneidFieldNumber = 1,
    kNumFieldNumber = 2,
    kGottimeFieldNumber = 3,
  };
  // optional uint32 runeid = 1;
  bool has_runeid() const;
  void clear_runeid() ;
  ::uint32_t runeid() const;
  void set_runeid(::uint32_t value);

  private:
  ::uint32_t _internal_runeid() const;
  void _internal_set_runeid(::uint32_t value);

  public:
  // optional int32 num = 2;
  bool has_num() const;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // optional int64 gottime = 3;
  bool has_gottime() const;
  void clear_gottime() ;
  ::int64_t gottime() const;
  void set_gottime(::int64_t value);

  private:
  ::int64_t _internal_gottime() const;
  void _internal_set_gottime(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RunesBagInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t runeid_;
    ::int32_t num_;
    ::int64_t gottime_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoomInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoomInfo(const RoomInfo& from) : RoomInfo(nullptr, from) {}
  inline RoomInfo(RoomInfo&& from) noexcept
      : RoomInfo(nullptr, std::move(from)) {}
  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
        &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 184;
  friend void swap(RoomInfo& a, RoomInfo& b) { a.Swap(&b); }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoomInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoomInfo& from) { RoomInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoomInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RoomInfo"; }

 protected:
  explicit RoomInfo(::google::protobuf::Arena* arena);
  RoomInfo(::google::protobuf::Arena* arena, const RoomInfo& from);
  RoomInfo(::google::protobuf::Arena* arena, RoomInfo&& from) noexcept
      : RoomInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMasterFieldNumber = 4,
    kRoomIdFieldNumber = 1,
    kIfPwdFieldNumber = 2,
    kMapIdFieldNumber = 3,
    kCurUserCountFieldNumber = 5,
    kMaxUserCountFieldNumber = 6,
  };
  // optional string master = 4;
  bool has_master() const;
  void clear_master() ;
  const std::string& master() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_master(Arg_&& arg, Args_... args);
  std::string* mutable_master();
  PROTOBUF_NODISCARD std::string* release_master();
  void set_allocated_master(std::string* value);

  private:
  const std::string& _internal_master() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master(
      const std::string& value);
  std::string* _internal_mutable_master();

  public:
  // optional int32 roomId = 1;
  bool has_roomid() const;
  void clear_roomid() ;
  ::int32_t roomid() const;
  void set_roomid(::int32_t value);

  private:
  ::int32_t _internal_roomid() const;
  void _internal_set_roomid(::int32_t value);

  public:
  // optional int32 ifPwd = 2;
  bool has_ifpwd() const;
  void clear_ifpwd() ;
  ::int32_t ifpwd() const;
  void set_ifpwd(::int32_t value);

  private:
  ::int32_t _internal_ifpwd() const;
  void _internal_set_ifpwd(::int32_t value);

  public:
  // optional int32 mapId = 3;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional int32 curUserCount = 5;
  bool has_curusercount() const;
  void clear_curusercount() ;
  ::int32_t curusercount() const;
  void set_curusercount(::int32_t value);

  private:
  ::int32_t _internal_curusercount() const;
  void _internal_set_curusercount(::int32_t value);

  public:
  // optional int32 maxUserCount = 6;
  bool has_maxusercount() const;
  void clear_maxusercount() ;
  ::int32_t maxusercount() const;
  void set_maxusercount(::int32_t value);

  private:
  ::int32_t _internal_maxusercount() const;
  void _internal_set_maxusercount(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RoomInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr master_;
    ::int32_t roomid_;
    ::int32_t ifpwd_;
    ::int32_t mapid_;
    ::int32_t curusercount_;
    ::int32_t maxusercount_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RoomBaseInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RoomBaseInfo) */ {
 public:
  inline RoomBaseInfo() : RoomBaseInfo(nullptr) {}
  ~RoomBaseInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RoomBaseInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RoomBaseInfo(const RoomBaseInfo& from) : RoomBaseInfo(nullptr, from) {}
  inline RoomBaseInfo(RoomBaseInfo&& from) noexcept
      : RoomBaseInfo(nullptr, std::move(from)) {}
  inline RoomBaseInfo& operator=(const RoomBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomBaseInfo& operator=(RoomBaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomBaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomBaseInfo* internal_default_instance() {
    return reinterpret_cast<const RoomBaseInfo*>(
        &_RoomBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 81;
  friend void swap(RoomBaseInfo& a, RoomBaseInfo& b) { a.Swap(&b); }
  inline void Swap(RoomBaseInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomBaseInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomBaseInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RoomBaseInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RoomBaseInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RoomBaseInfo& from) { RoomBaseInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RoomBaseInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RoomBaseInfo"; }

 protected:
  explicit RoomBaseInfo(::google::protobuf::Arena* arena);
  RoomBaseInfo(::google::protobuf::Arena* arena, const RoomBaseInfo& from);
  RoomBaseInfo(::google::protobuf::Arena* arena, RoomBaseInfo&& from) noexcept
      : RoomBaseInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomidFieldNumber = 2,
    kMapidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 roomid = 2;
  bool has_roomid() const;
  void clear_roomid() ;
  ::uint64_t roomid() const;
  void set_roomid(::uint64_t value);

  private:
  ::uint64_t _internal_roomid() const;
  void _internal_set_roomid(::uint64_t value);

  public:
  // optional uint32 mapid = 3;
  bool has_mapid() const;
  void clear_mapid() ;
  ::uint32_t mapid() const;
  void set_mapid(::uint32_t value);

  private:
  ::uint32_t _internal_mapid() const;
  void _internal_set_mapid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyRoomBaseInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RoomBaseInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t roomid_;
    ::uint32_t mapid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RecoinRuneRet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RecoinRuneRet) */ {
 public:
  inline RecoinRuneRet() : RecoinRuneRet(nullptr) {}
  ~RecoinRuneRet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RecoinRuneRet(
      ::google::protobuf::internal::ConstantInitialized);

  inline RecoinRuneRet(const RecoinRuneRet& from) : RecoinRuneRet(nullptr, from) {}
  inline RecoinRuneRet(RecoinRuneRet&& from) noexcept
      : RecoinRuneRet(nullptr, std::move(from)) {}
  inline RecoinRuneRet& operator=(const RecoinRuneRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoinRuneRet& operator=(RecoinRuneRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoinRuneRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoinRuneRet* internal_default_instance() {
    return reinterpret_cast<const RecoinRuneRet*>(
        &_RecoinRuneRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RecoinRuneRet& a, RecoinRuneRet& b) { a.Swap(&b); }
  inline void Swap(RecoinRuneRet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoinRuneRet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoinRuneRet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RecoinRuneRet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RecoinRuneRet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RecoinRuneRet& from) { RecoinRuneRet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RecoinRuneRet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RecoinRuneRet"; }

 protected:
  explicit RecoinRuneRet(::google::protobuf::Arena* arena);
  RecoinRuneRet(::google::protobuf::Arena* arena, const RecoinRuneRet& from);
  RecoinRuneRet(::google::protobuf::Arena* arena, RecoinRuneRet&& from) noexcept
      : RecoinRuneRet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRuneIdFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 rune_id = 2;
  bool has_rune_id() const;
  void clear_rune_id() ;
  ::uint32_t rune_id() const;
  void set_rune_id(::uint32_t value);

  private:
  ::uint32_t _internal_rune_id() const;
  void _internal_set_rune_id(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_RecoinRuneRet];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RecoinRuneRet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t rune_id_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RebornTimes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RebornTimes) */ {
 public:
  inline RebornTimes() : RebornTimes(nullptr) {}
  ~RebornTimes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RebornTimes(
      ::google::protobuf::internal::ConstantInitialized);

  inline RebornTimes(const RebornTimes& from) : RebornTimes(nullptr, from) {}
  inline RebornTimes(RebornTimes&& from) noexcept
      : RebornTimes(nullptr, std::move(from)) {}
  inline RebornTimes& operator=(const RebornTimes& from) {
    CopyFrom(from);
    return *this;
  }
  inline RebornTimes& operator=(RebornTimes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RebornTimes& default_instance() {
    return *internal_default_instance();
  }
  static inline const RebornTimes* internal_default_instance() {
    return reinterpret_cast<const RebornTimes*>(
        &_RebornTimes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 132;
  friend void swap(RebornTimes& a, RebornTimes& b) { a.Swap(&b); }
  inline void Swap(RebornTimes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RebornTimes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RebornTimes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RebornTimes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RebornTimes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RebornTimes& from) { RebornTimes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RebornTimes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RebornTimes"; }

 protected:
  explicit RebornTimes(::google::protobuf::Arena* arena);
  RebornTimes(::google::protobuf::Arena* arena, const RebornTimes& from);
  RebornTimes(::google::protobuf::Arena* arena, RebornTimes&& from) noexcept
      : RebornTimes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMasterguidFieldNumber = 2,
    kSendtimesFieldNumber = 3,
    kGoldFieldNumber = 4,
    kRemainTimesFieldNumber = 5,
    kRebornTimeFieldNumber = 6,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 masterguid = 2;
  bool has_masterguid() const;
  void clear_masterguid() ;
  ::uint64_t masterguid() const;
  void set_masterguid(::uint64_t value);

  private:
  ::uint64_t _internal_masterguid() const;
  void _internal_set_masterguid(::uint64_t value);

  public:
  // optional int64 sendtimes = 3;
  bool has_sendtimes() const;
  void clear_sendtimes() ;
  ::int64_t sendtimes() const;
  void set_sendtimes(::int64_t value);

  private:
  ::int64_t _internal_sendtimes() const;
  void _internal_set_sendtimes(::int64_t value);

  public:
  // optional int64 gold = 4;
  bool has_gold() const;
  void clear_gold() ;
  ::int64_t gold() const;
  void set_gold(::int64_t value);

  private:
  ::int64_t _internal_gold() const;
  void _internal_set_gold(::int64_t value);

  public:
  // optional int32 remain_times = 5;
  bool has_remain_times() const;
  void clear_remain_times() ;
  ::int32_t remain_times() const;
  void set_remain_times(::int32_t value);

  private:
  ::int32_t _internal_remain_times() const;
  void _internal_set_remain_times(::int32_t value);

  public:
  // optional int32 reborn_time = 6;
  bool has_reborn_time() const;
  void clear_reborn_time() ;
  ::int32_t reborn_time() const;
  void set_reborn_time(::int32_t value);

  private:
  ::int32_t _internal_reborn_time() const;
  void _internal_set_reborn_time(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroRebornTimes];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RebornTimes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t masterguid_;
    ::int64_t sendtimes_;
    ::int64_t gold_;
    ::int32_t remain_times_;
    ::int32_t reborn_time_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RebornSuccess final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RebornSuccess) */ {
 public:
  inline RebornSuccess() : RebornSuccess(nullptr) {}
  ~RebornSuccess() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RebornSuccess(
      ::google::protobuf::internal::ConstantInitialized);

  inline RebornSuccess(const RebornSuccess& from) : RebornSuccess(nullptr, from) {}
  inline RebornSuccess(RebornSuccess&& from) noexcept
      : RebornSuccess(nullptr, std::move(from)) {}
  inline RebornSuccess& operator=(const RebornSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline RebornSuccess& operator=(RebornSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RebornSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const RebornSuccess* internal_default_instance() {
    return reinterpret_cast<const RebornSuccess*>(
        &_RebornSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 133;
  friend void swap(RebornSuccess& a, RebornSuccess& b) { a.Swap(&b); }
  inline void Swap(RebornSuccess* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RebornSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RebornSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RebornSuccess>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RebornSuccess& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RebornSuccess& from) { RebornSuccess::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RebornSuccess* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RebornSuccess"; }

 protected:
  explicit RebornSuccess(::google::protobuf::Arena* arena);
  RebornSuccess(::google::protobuf::Arena* arena, const RebornSuccess& from);
  RebornSuccess(::google::protobuf::Arena* arena, RebornSuccess&& from) noexcept
      : RebornSuccess(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBuyRebornSuccess];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RebornSuccess)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RangeEffectEnd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RangeEffectEnd) */ {
 public:
  inline RangeEffectEnd() : RangeEffectEnd(nullptr) {}
  ~RangeEffectEnd() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RangeEffectEnd(
      ::google::protobuf::internal::ConstantInitialized);

  inline RangeEffectEnd(const RangeEffectEnd& from) : RangeEffectEnd(nullptr, from) {}
  inline RangeEffectEnd(RangeEffectEnd&& from) noexcept
      : RangeEffectEnd(nullptr, std::move(from)) {}
  inline RangeEffectEnd& operator=(const RangeEffectEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeEffectEnd& operator=(RangeEffectEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeEffectEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeEffectEnd* internal_default_instance() {
    return reinterpret_cast<const RangeEffectEnd*>(
        &_RangeEffectEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 151;
  friend void swap(RangeEffectEnd& a, RangeEffectEnd& b) { a.Swap(&b); }
  inline void Swap(RangeEffectEnd* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeEffectEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeEffectEnd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RangeEffectEnd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RangeEffectEnd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RangeEffectEnd& from) { RangeEffectEnd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RangeEffectEnd* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RangeEffectEnd"; }

 protected:
  explicit RangeEffectEnd(::google::protobuf::Arena* arena);
  RangeEffectEnd(::google::protobuf::Arena* arena, const RangeEffectEnd& from);
  RangeEffectEnd(::google::protobuf::Arena* arena, RangeEffectEnd&& from) noexcept
      : RangeEffectEnd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kUniqueidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 uniqueid = 3;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::uint32_t uniqueid() const;
  void set_uniqueid(::uint32_t value);

  private:
  ::uint32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelRangeEnd];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RangeEffectEnd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class Pos final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.Pos) */ {
 public:
  inline Pos() : Pos(nullptr) {}
  ~Pos() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pos(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pos(const Pos& from) : Pos(nullptr, from) {}
  inline Pos(Pos&& from) noexcept
      : Pos(nullptr, std::move(from)) {}
  inline Pos& operator=(const Pos& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pos& operator=(Pos&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pos& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pos* internal_default_instance() {
    return reinterpret_cast<const Pos*>(
        &_Pos_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 86;
  friend void swap(Pos& a, Pos& b) { a.Swap(&b); }
  inline void Swap(Pos* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pos* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pos* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Pos>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pos& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pos& from) { Pos::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pos* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.Pos"; }

 protected:
  explicit Pos(::google::protobuf::Arena* arena);
  Pos(::google::protobuf::Arena* arena, const Pos& from);
  Pos(::google::protobuf::Arena* arena, Pos&& from) noexcept
      : Pos(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXFieldNumber = 1,
    kZFieldNumber = 3,
  };
  // optional int32 x = 1;
  bool has_x() const;
  void clear_x() ;
  ::int32_t x() const;
  void set_x(::int32_t value);

  private:
  ::int32_t _internal_x() const;
  void _internal_set_x(::int32_t value);

  public:
  // optional int32 z = 3;
  bool has_z() const;
  void clear_z() ;
  ::int32_t z() const;
  void set_z(::int32_t value);

  private:
  ::int32_t _internal_z() const;
  void _internal_set_z(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.Pos)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t x_;
    ::int32_t z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class PlayFinishVedio final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.PlayFinishVedio) */ {
 public:
  inline PlayFinishVedio() : PlayFinishVedio(nullptr) {}
  ~PlayFinishVedio() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PlayFinishVedio(
      ::google::protobuf::internal::ConstantInitialized);

  inline PlayFinishVedio(const PlayFinishVedio& from) : PlayFinishVedio(nullptr, from) {}
  inline PlayFinishVedio(PlayFinishVedio&& from) noexcept
      : PlayFinishVedio(nullptr, std::move(from)) {}
  inline PlayFinishVedio& operator=(const PlayFinishVedio& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayFinishVedio& operator=(PlayFinishVedio&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayFinishVedio& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayFinishVedio* internal_default_instance() {
    return reinterpret_cast<const PlayFinishVedio*>(
        &_PlayFinishVedio_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 140;
  friend void swap(PlayFinishVedio& a, PlayFinishVedio& b) { a.Swap(&b); }
  inline void Swap(PlayFinishVedio* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayFinishVedio* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayFinishVedio* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PlayFinishVedio>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayFinishVedio& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PlayFinishVedio& from) { PlayFinishVedio::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayFinishVedio* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.PlayFinishVedio"; }

 protected:
  explicit PlayFinishVedio(::google::protobuf::Arena* arena);
  PlayFinishVedio(::google::protobuf::Arena* arena, const PlayFinishVedio& from);
  PlayFinishVedio(::google::protobuf::Arena* arena, PlayFinishVedio&& from) noexcept
      : PlayFinishVedio(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWincampFieldNumber = 2,
    kLosercampFieldNumber = 3,
    kGuidFieldNumber = 5,
    kMapidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional int32 wincamp = 2;
  bool has_wincamp() const;
  void clear_wincamp() ;
  ::int32_t wincamp() const;
  void set_wincamp(::int32_t value);

  private:
  ::int32_t _internal_wincamp() const;
  void _internal_set_wincamp(::int32_t value);

  public:
  // optional int32 losercamp = 3;
  bool has_losercamp() const;
  void clear_losercamp() ;
  ::int32_t losercamp() const;
  void set_losercamp(::int32_t value);

  private:
  ::int32_t _internal_losercamp() const;
  void _internal_set_losercamp(::int32_t value);

  public:
  // optional uint64 guid = 5;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 mapid = 4;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadcastPlayFinishVedio];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.PlayFinishVedio)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t wincamp_;
    ::int32_t losercamp_;
    ::uint64_t guid_;
    ::int32_t mapid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class PingRet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.PingRet) */ {
 public:
  inline PingRet() : PingRet(nullptr) {}
  ~PingRet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PingRet(
      ::google::protobuf::internal::ConstantInitialized);

  inline PingRet(const PingRet& from) : PingRet(nullptr, from) {}
  inline PingRet(PingRet&& from) noexcept
      : PingRet(nullptr, std::move(from)) {}
  inline PingRet& operator=(const PingRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRet& operator=(PingRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRet* internal_default_instance() {
    return reinterpret_cast<const PingRet*>(
        &_PingRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 59;
  friend void swap(PingRet& a, PingRet& b) { a.Swap(&b); }
  inline void Swap(PingRet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PingRet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PingRet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PingRet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PingRet& from) { PingRet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PingRet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.PingRet"; }

 protected:
  explicit PingRet(::google::protobuf::Arena* arena);
  PingRet(::google::protobuf::Arena* arena, const PingRet& from);
  PingRet(::google::protobuf::Arena* arena, PingRet&& from) noexcept
      : PingRet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 2,
    kFlagFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int64 time = 2;
  bool has_time() const;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // optional int32 flag = 3;
  bool has_flag() const;
  void clear_flag() ;
  ::int32_t flag() const;
  void set_flag(::int32_t value);

  private:
  ::int32_t _internal_flag() const;
  void _internal_set_flag(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GCAskPingRet];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.PingRet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t time_;
    ::int32_t flag_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class PersonCPChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.PersonCPChange) */ {
 public:
  inline PersonCPChange() : PersonCPChange(nullptr) {}
  ~PersonCPChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PersonCPChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline PersonCPChange(const PersonCPChange& from) : PersonCPChange(nullptr, from) {}
  inline PersonCPChange(PersonCPChange&& from) noexcept
      : PersonCPChange(nullptr, std::move(from)) {}
  inline PersonCPChange& operator=(const PersonCPChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline PersonCPChange& operator=(PersonCPChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PersonCPChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const PersonCPChange* internal_default_instance() {
    return reinterpret_cast<const PersonCPChange*>(
        &_PersonCPChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 134;
  friend void swap(PersonCPChange& a, PersonCPChange& b) { a.Swap(&b); }
  inline void Swap(PersonCPChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PersonCPChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PersonCPChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PersonCPChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PersonCPChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PersonCPChange& from) { PersonCPChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PersonCPChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.PersonCPChange"; }

 protected:
  explicit PersonCPChange(::google::protobuf::Arena* arena);
  PersonCPChange(::google::protobuf::Arena* arena, const PersonCPChange& from);
  PersonCPChange(::google::protobuf::Arena* arena, PersonCPChange&& from) noexcept
      : PersonCPChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kCpFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 cp = 3;
  bool has_cp() const;
  void clear_cp() ;
  ::int32_t cp() const;
  void set_cp(::int32_t value);

  private:
  ::int32_t _internal_cp() const;
  void _internal_set_cp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPersonalCPChange];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.PersonCPChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t cp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUserSNSListChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUserSNSListChange) */ {
 public:
  inline NotifyUserSNSListChange() : NotifyUserSNSListChange(nullptr) {}
  ~NotifyUserSNSListChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUserSNSListChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUserSNSListChange(const NotifyUserSNSListChange& from) : NotifyUserSNSListChange(nullptr, from) {}
  inline NotifyUserSNSListChange(NotifyUserSNSListChange&& from) noexcept
      : NotifyUserSNSListChange(nullptr, std::move(from)) {}
  inline NotifyUserSNSListChange& operator=(const NotifyUserSNSListChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUserSNSListChange& operator=(NotifyUserSNSListChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUserSNSListChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUserSNSListChange* internal_default_instance() {
    return reinterpret_cast<const NotifyUserSNSListChange*>(
        &_NotifyUserSNSListChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 67;
  friend void swap(NotifyUserSNSListChange& a, NotifyUserSNSListChange& b) { a.Swap(&b); }
  inline void Swap(NotifyUserSNSListChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUserSNSListChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUserSNSListChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUserSNSListChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUserSNSListChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUserSNSListChange& from) { NotifyUserSNSListChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUserSNSListChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUserSNSListChange"; }

 protected:
  explicit NotifyUserSNSListChange(::google::protobuf::Arena* arena);
  NotifyUserSNSListChange(::google::protobuf::Arena* arena, const NotifyUserSNSListChange& from);
  NotifyUserSNSListChange(::google::protobuf::Arena* arena, NotifyUserSNSListChange&& from) noexcept
      : NotifyUserSNSListChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuididxFieldNumber = 2,
    kTypeFieldNumber = 3,
    kMsgnumFieldNumber = 1,
  };
  // optional uint64 guididx = 2;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional uint32 type = 3;
  bool has_type() const;
  void clear_type() ;
  ::uint32_t type() const;
  void set_type(::uint32_t value);

  private:
  ::uint32_t _internal_type() const;
  void _internal_set_type(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyUserSNSListChange];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GSToGC::MsgID msgnum() const;
  void set_msgnum(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgnum() const;
  void _internal_set_msgnum(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUserSNSListChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guididx_;
    ::uint32_t type_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUserReturnBattleRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUserReturnBattleRoom) */ {
 public:
  inline NotifyUserReturnBattleRoom() : NotifyUserReturnBattleRoom(nullptr) {}
  ~NotifyUserReturnBattleRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUserReturnBattleRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUserReturnBattleRoom(const NotifyUserReturnBattleRoom& from) : NotifyUserReturnBattleRoom(nullptr, from) {}
  inline NotifyUserReturnBattleRoom(NotifyUserReturnBattleRoom&& from) noexcept
      : NotifyUserReturnBattleRoom(nullptr, std::move(from)) {}
  inline NotifyUserReturnBattleRoom& operator=(const NotifyUserReturnBattleRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUserReturnBattleRoom& operator=(NotifyUserReturnBattleRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUserReturnBattleRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUserReturnBattleRoom* internal_default_instance() {
    return reinterpret_cast<const NotifyUserReturnBattleRoom*>(
        &_NotifyUserReturnBattleRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 50;
  friend void swap(NotifyUserReturnBattleRoom& a, NotifyUserReturnBattleRoom& b) { a.Swap(&b); }
  inline void Swap(NotifyUserReturnBattleRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUserReturnBattleRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUserReturnBattleRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUserReturnBattleRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUserReturnBattleRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUserReturnBattleRoom& from) { NotifyUserReturnBattleRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUserReturnBattleRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUserReturnBattleRoom"; }

 protected:
  explicit NotifyUserReturnBattleRoom(::google::protobuf::Arena* arena);
  NotifyUserReturnBattleRoom(::google::protobuf::Arena* arena, const NotifyUserReturnBattleRoom& from);
  NotifyUserReturnBattleRoom(::google::protobuf::Arena* arena, NotifyUserReturnBattleRoom&& from) noexcept
      : NotifyUserReturnBattleRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserReturnBattleRoom];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUserReturnBattleRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUserLvInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUserLvInfo) */ {
 public:
  inline NotifyUserLvInfo() : NotifyUserLvInfo(nullptr) {}
  ~NotifyUserLvInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUserLvInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUserLvInfo(const NotifyUserLvInfo& from) : NotifyUserLvInfo(nullptr, from) {}
  inline NotifyUserLvInfo(NotifyUserLvInfo&& from) noexcept
      : NotifyUserLvInfo(nullptr, std::move(from)) {}
  inline NotifyUserLvInfo& operator=(const NotifyUserLvInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUserLvInfo& operator=(NotifyUserLvInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUserLvInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUserLvInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyUserLvInfo*>(
        &_NotifyUserLvInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(NotifyUserLvInfo& a, NotifyUserLvInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyUserLvInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUserLvInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUserLvInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUserLvInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUserLvInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUserLvInfo& from) { NotifyUserLvInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUserLvInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUserLvInfo"; }

 protected:
  explicit NotifyUserLvInfo(::google::protobuf::Arena* arena);
  NotifyUserLvInfo(::google::protobuf::Arena* arena, const NotifyUserLvInfo& from);
  NotifyUserLvInfo(::google::protobuf::Arena* arena, NotifyUserLvInfo&& from) noexcept
      : NotifyUserLvInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCurlvFieldNumber = 2,
    kCurexpFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 curlv = 2;
  bool has_curlv() const;
  void clear_curlv() ;
  ::uint32_t curlv() const;
  void set_curlv(::uint32_t value);

  private:
  ::uint32_t _internal_curlv() const;
  void _internal_set_curlv(::uint32_t value);

  public:
  // optional uint32 curexp = 3;
  bool has_curexp() const;
  void clear_curexp() ;
  ::uint32_t curexp() const;
  void set_curexp(::uint32_t value);

  private:
  ::uint32_t _internal_curexp() const;
  void _internal_set_curexp(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserLvInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUserLvInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t curlv_;
    ::uint32_t curexp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUserCLDays final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUserCLDays) */ {
 public:
  inline NotifyUserCLDays() : NotifyUserCLDays(nullptr) {}
  ~NotifyUserCLDays() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUserCLDays(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUserCLDays(const NotifyUserCLDays& from) : NotifyUserCLDays(nullptr, from) {}
  inline NotifyUserCLDays(NotifyUserCLDays&& from) noexcept
      : NotifyUserCLDays(nullptr, std::move(from)) {}
  inline NotifyUserCLDays& operator=(const NotifyUserCLDays& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUserCLDays& operator=(NotifyUserCLDays&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUserCLDays& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUserCLDays* internal_default_instance() {
    return reinterpret_cast<const NotifyUserCLDays*>(
        &_NotifyUserCLDays_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 55;
  friend void swap(NotifyUserCLDays& a, NotifyUserCLDays& b) { a.Swap(&b); }
  inline void Swap(NotifyUserCLDays* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUserCLDays* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUserCLDays* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUserCLDays>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUserCLDays& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUserCLDays& from) { NotifyUserCLDays::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUserCLDays* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUserCLDays"; }

 protected:
  explicit NotifyUserCLDays(::google::protobuf::Arena* arena);
  NotifyUserCLDays(::google::protobuf::Arena* arena, const NotifyUserCLDays& from);
  NotifyUserCLDays(::google::protobuf::Arena* arena, NotifyUserCLDays&& from) noexcept
      : NotifyUserCLDays(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonthFieldNumber = 2,
    kTodayFieldNumber = 3,
    kTotalCldaysFieldNumber = 4,
    kCldaysFieldNumber = 5,
    kIsTodayCanFieldNumber = 6,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 month = 2;
  bool has_month() const;
  void clear_month() ;
  ::uint32_t month() const;
  void set_month(::uint32_t value);

  private:
  ::uint32_t _internal_month() const;
  void _internal_set_month(::uint32_t value);

  public:
  // optional uint32 today = 3;
  bool has_today() const;
  void clear_today() ;
  ::uint32_t today() const;
  void set_today(::uint32_t value);

  private:
  ::uint32_t _internal_today() const;
  void _internal_set_today(::uint32_t value);

  public:
  // optional uint32 totalCldays = 4;
  bool has_totalcldays() const;
  void clear_totalcldays() ;
  ::uint32_t totalcldays() const;
  void set_totalcldays(::uint32_t value);

  private:
  ::uint32_t _internal_totalcldays() const;
  void _internal_set_totalcldays(::uint32_t value);

  public:
  // optional uint32 cldays = 5;
  bool has_cldays() const;
  void clear_cldays() ;
  ::uint32_t cldays() const;
  void set_cldays(::uint32_t value);

  private:
  ::uint32_t _internal_cldays() const;
  void _internal_set_cldays(::uint32_t value);

  public:
  // optional bool isTodayCan = 6;
  bool has_istodaycan() const;
  void clear_istodaycan() ;
  bool istodaycan() const;
  void set_istodaycan(bool value);

  private:
  bool _internal_istodaycan() const;
  void _internal_set_istodaycan(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserCLDays];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUserCLDays)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t month_;
    ::uint32_t today_;
    ::uint32_t totalcldays_;
    ::uint32_t cldays_;
    bool istodaycan_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySystemAnnounce final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySystemAnnounce) */ {
 public:
  inline NotifySystemAnnounce() : NotifySystemAnnounce(nullptr) {}
  ~NotifySystemAnnounce() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySystemAnnounce(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySystemAnnounce(const NotifySystemAnnounce& from) : NotifySystemAnnounce(nullptr, from) {}
  inline NotifySystemAnnounce(NotifySystemAnnounce&& from) noexcept
      : NotifySystemAnnounce(nullptr, std::move(from)) {}
  inline NotifySystemAnnounce& operator=(const NotifySystemAnnounce& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySystemAnnounce& operator=(NotifySystemAnnounce&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySystemAnnounce& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySystemAnnounce* internal_default_instance() {
    return reinterpret_cast<const NotifySystemAnnounce*>(
        &_NotifySystemAnnounce_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 72;
  friend void swap(NotifySystemAnnounce& a, NotifySystemAnnounce& b) { a.Swap(&b); }
  inline void Swap(NotifySystemAnnounce* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySystemAnnounce* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySystemAnnounce* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySystemAnnounce>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySystemAnnounce& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySystemAnnounce& from) { NotifySystemAnnounce::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySystemAnnounce* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySystemAnnounce"; }

 protected:
  explicit NotifySystemAnnounce(::google::protobuf::Arena* arena);
  NotifySystemAnnounce(::google::protobuf::Arena* arena, const NotifySystemAnnounce& from);
  NotifySystemAnnounce(::google::protobuf::Arena* arena, NotifySystemAnnounce&& from) noexcept
      : NotifySystemAnnounce(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAnnounceFieldNumber = 3,
    kTypeFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string announce = 3;
  bool has_announce() const;
  void clear_announce() ;
  const std::string& announce() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_announce(Arg_&& arg, Args_... args);
  std::string* mutable_announce();
  PROTOBUF_NODISCARD std::string* release_announce();
  void set_allocated_announce(std::string* value);

  private:
  const std::string& _internal_announce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_announce(
      const std::string& value);
  std::string* _internal_mutable_announce();

  public:
  // optional int32 type = 2;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySystemAnnounce];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySystemAnnounce)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr announce_;
    ::int32_t type_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillUpLv final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillUpLv) */ {
 public:
  inline NotifySkillUpLv() : NotifySkillUpLv(nullptr) {}
  ~NotifySkillUpLv() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillUpLv(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillUpLv(const NotifySkillUpLv& from) : NotifySkillUpLv(nullptr, from) {}
  inline NotifySkillUpLv(NotifySkillUpLv&& from) noexcept
      : NotifySkillUpLv(nullptr, std::move(from)) {}
  inline NotifySkillUpLv& operator=(const NotifySkillUpLv& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillUpLv& operator=(NotifySkillUpLv&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillUpLv& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillUpLv* internal_default_instance() {
    return reinterpret_cast<const NotifySkillUpLv*>(
        &_NotifySkillUpLv_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 172;
  friend void swap(NotifySkillUpLv& a, NotifySkillUpLv& b) { a.Swap(&b); }
  inline void Swap(NotifySkillUpLv* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillUpLv* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillUpLv* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillUpLv>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillUpLv& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillUpLv& from) { NotifySkillUpLv::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillUpLv* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillUpLv"; }

 protected:
  explicit NotifySkillUpLv(::google::protobuf::Arena* arena);
  NotifySkillUpLv(::google::protobuf::Arena* arena, const NotifySkillUpLv& from);
  NotifySkillUpLv(::google::protobuf::Arena* arena, NotifySkillUpLv&& from) noexcept
      : NotifySkillUpLv(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kSkillposFieldNumber = 3,
    kSkillidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 skillpos = 3;
  bool has_skillpos() const;
  void clear_skillpos() ;
  ::uint32_t skillpos() const;
  void set_skillpos(::uint32_t value);

  private:
  ::uint32_t _internal_skillpos() const;
  void _internal_set_skillpos(::uint32_t value);

  public:
  // optional uint32 skillid = 4;
  bool has_skillid() const;
  void clear_skillid() ;
  ::uint32_t skillid() const;
  void set_skillid(::uint32_t value);

  private:
  ::uint32_t _internal_skillid() const;
  void _internal_set_skillid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillUpLv];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillUpLv)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint32_t skillpos_;
    ::uint32_t skillid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelStopLink final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelStopLink) */ {
 public:
  inline NotifySkillModelStopLink() : NotifySkillModelStopLink(nullptr) {}
  ~NotifySkillModelStopLink() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelStopLink(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelStopLink(const NotifySkillModelStopLink& from) : NotifySkillModelStopLink(nullptr, from) {}
  inline NotifySkillModelStopLink(NotifySkillModelStopLink&& from) noexcept
      : NotifySkillModelStopLink(nullptr, std::move(from)) {}
  inline NotifySkillModelStopLink& operator=(const NotifySkillModelStopLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelStopLink& operator=(NotifySkillModelStopLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelStopLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelStopLink* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelStopLink*>(
        &_NotifySkillModelStopLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 160;
  friend void swap(NotifySkillModelStopLink& a, NotifySkillModelStopLink& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelStopLink* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelStopLink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelStopLink* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelStopLink>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelStopLink& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelStopLink& from) { NotifySkillModelStopLink::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelStopLink* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelStopLink"; }

 protected:
  explicit NotifySkillModelStopLink(::google::protobuf::Arena* arena);
  NotifySkillModelStopLink(::google::protobuf::Arena* arena, const NotifySkillModelStopLink& from);
  NotifySkillModelStopLink(::google::protobuf::Arena* arena, NotifySkillModelStopLink&& from) noexcept
      : NotifySkillModelStopLink(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUniqueidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 uniqueid = 2;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::uint32_t uniqueid() const;
  void set_uniqueid(::uint32_t value);

  private:
  ::uint32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStopLink];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelStopLink)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelPurification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelPurification) */ {
 public:
  inline NotifySkillModelPurification() : NotifySkillModelPurification(nullptr) {}
  ~NotifySkillModelPurification() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelPurification(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelPurification(const NotifySkillModelPurification& from) : NotifySkillModelPurification(nullptr, from) {}
  inline NotifySkillModelPurification(NotifySkillModelPurification&& from) noexcept
      : NotifySkillModelPurification(nullptr, std::move(from)) {}
  inline NotifySkillModelPurification& operator=(const NotifySkillModelPurification& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelPurification& operator=(NotifySkillModelPurification&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelPurification& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelPurification* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelPurification*>(
        &_NotifySkillModelPurification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 158;
  friend void swap(NotifySkillModelPurification& a, NotifySkillModelPurification& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelPurification* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelPurification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelPurification* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelPurification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelPurification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelPurification& from) { NotifySkillModelPurification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelPurification* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelPurification"; }

 protected:
  explicit NotifySkillModelPurification(::google::protobuf::Arena* arena);
  NotifySkillModelPurification(::google::protobuf::Arena* arena, const NotifySkillModelPurification& from);
  NotifySkillModelPurification(::google::protobuf::Arena* arena, NotifySkillModelPurification&& from) noexcept
      : NotifySkillModelPurification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kTargetguidFieldNumber = 3,
    kEffectidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint64 targetguid = 3;
  bool has_targetguid() const;
  void clear_targetguid() ;
  ::uint64_t targetguid() const;
  void set_targetguid(::uint64_t value);

  private:
  ::uint64_t _internal_targetguid() const;
  void _internal_set_targetguid(::uint64_t value);

  public:
  // optional int32 effectid = 4;
  bool has_effectid() const;
  void clear_effectid() ;
  ::int32_t effectid() const;
  void set_effectid(::int32_t value);

  private:
  ::int32_t _internal_effectid() const;
  void _internal_set_effectid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelPurification];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelPurification)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint64_t targetguid_;
    ::int32_t effectid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelLeading final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelLeading) */ {
 public:
  inline NotifySkillModelLeading() : NotifySkillModelLeading(nullptr) {}
  ~NotifySkillModelLeading() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelLeading(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelLeading(const NotifySkillModelLeading& from) : NotifySkillModelLeading(nullptr, from) {}
  inline NotifySkillModelLeading(NotifySkillModelLeading&& from) noexcept
      : NotifySkillModelLeading(nullptr, std::move(from)) {}
  inline NotifySkillModelLeading& operator=(const NotifySkillModelLeading& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelLeading& operator=(NotifySkillModelLeading&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelLeading& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelLeading* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelLeading*>(
        &_NotifySkillModelLeading_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 75;
  friend void swap(NotifySkillModelLeading& a, NotifySkillModelLeading& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelLeading* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelLeading* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelLeading* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelLeading>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelLeading& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelLeading& from) { NotifySkillModelLeading::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelLeading* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelLeading"; }

 protected:
  explicit NotifySkillModelLeading(::google::protobuf::Arena* arena);
  NotifySkillModelLeading(::google::protobuf::Arena* arena, const NotifySkillModelLeading& from);
  NotifySkillModelLeading(::google::protobuf::Arena* arena, NotifySkillModelLeading&& from) noexcept
      : NotifySkillModelLeading(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kUniqueidFieldNumber = 4,
    kTarguidFieldNumber = 5,
    kStateFieldNumber = 6,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::uint32_t effectid() const;
  void set_effectid(::uint32_t value);

  private:
  ::uint32_t _internal_effectid() const;
  void _internal_set_effectid(::uint32_t value);

  public:
  // optional int32 uniqueid = 4;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::int32_t uniqueid() const;
  void set_uniqueid(::int32_t value);

  private:
  ::int32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::int32_t value);

  public:
  // optional uint64 targuid = 5;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional int32 state = 6;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelLeading];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelLeading)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint32_t effectid_;
    ::int32_t uniqueid_;
    ::uint64_t targuid_;
    ::int32_t state_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillInfo) */ {
 public:
  inline NotifySkillInfo() : NotifySkillInfo(nullptr) {}
  ~NotifySkillInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillInfo(const NotifySkillInfo& from) : NotifySkillInfo(nullptr, from) {}
  inline NotifySkillInfo(NotifySkillInfo&& from) noexcept
      : NotifySkillInfo(nullptr, std::move(from)) {}
  inline NotifySkillInfo& operator=(const NotifySkillInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillInfo& operator=(NotifySkillInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillInfo* internal_default_instance() {
    return reinterpret_cast<const NotifySkillInfo*>(
        &_NotifySkillInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 116;
  friend void swap(NotifySkillInfo& a, NotifySkillInfo& b) { a.Swap(&b); }
  inline void Swap(NotifySkillInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillInfo& from) { NotifySkillInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillInfo"; }

 protected:
  explicit NotifySkillInfo(::google::protobuf::Arena* arena);
  NotifySkillInfo(::google::protobuf::Arena* arena, const NotifySkillInfo& from);
  NotifySkillInfo(::google::protobuf::Arena* arena, NotifySkillInfo&& from) noexcept
      : NotifySkillInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kSkillslotFieldNumber = 3,
    kSkillidFieldNumber = 4,
    kTimeFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 skillslot = 3;
  bool has_skillslot() const;
  void clear_skillslot() ;
  ::int32_t skillslot() const;
  void set_skillslot(::int32_t value);

  private:
  ::int32_t _internal_skillslot() const;
  void _internal_set_skillslot(::int32_t value);

  public:
  // optional int32 skillid = 4;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional int32 time = 5;
  bool has_time() const;
  void clear_time() ;
  ::int32_t time() const;
  void set_time(::int32_t value);

  private:
  ::int32_t _internal_time() const;
  void _internal_set_time(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t skillslot_;
    ::int32_t skillid_;
    ::int32_t time_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyRewardsOneTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyRewardsOneTask) */ {
 public:
  inline NotifyRewardsOneTask() : NotifyRewardsOneTask(nullptr) {}
  ~NotifyRewardsOneTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyRewardsOneTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyRewardsOneTask(const NotifyRewardsOneTask& from) : NotifyRewardsOneTask(nullptr, from) {}
  inline NotifyRewardsOneTask(NotifyRewardsOneTask&& from) noexcept
      : NotifyRewardsOneTask(nullptr, std::move(from)) {}
  inline NotifyRewardsOneTask& operator=(const NotifyRewardsOneTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRewardsOneTask& operator=(NotifyRewardsOneTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRewardsOneTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRewardsOneTask* internal_default_instance() {
    return reinterpret_cast<const NotifyRewardsOneTask*>(
        &_NotifyRewardsOneTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(NotifyRewardsOneTask& a, NotifyRewardsOneTask& b) { a.Swap(&b); }
  inline void Swap(NotifyRewardsOneTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRewardsOneTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRewardsOneTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyRewardsOneTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyRewardsOneTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyRewardsOneTask& from) { NotifyRewardsOneTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyRewardsOneTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyRewardsOneTask"; }

 protected:
  explicit NotifyRewardsOneTask(::google::protobuf::Arena* arena);
  NotifyRewardsOneTask(::google::protobuf::Arena* arena, const NotifyRewardsOneTask& from);
  NotifyRewardsOneTask(::google::protobuf::Arena* arena, NotifyRewardsOneTask&& from) noexcept
      : NotifyRewardsOneTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 task_guid = 2;
  bool has_task_guid() const;
  void clear_task_guid() ;
  ::uint32_t task_guid() const;
  void set_task_guid(::uint32_t value);

  private:
  ::uint32_t _internal_task_guid() const;
  void _internal_set_task_guid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_RewardsOneTask];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyRewardsOneTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t task_guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyRemoveCommodity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyRemoveCommodity) */ {
 public:
  inline NotifyRemoveCommodity() : NotifyRemoveCommodity(nullptr) {}
  ~NotifyRemoveCommodity() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyRemoveCommodity(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyRemoveCommodity(const NotifyRemoveCommodity& from) : NotifyRemoveCommodity(nullptr, from) {}
  inline NotifyRemoveCommodity(NotifyRemoveCommodity&& from) noexcept
      : NotifyRemoveCommodity(nullptr, std::move(from)) {}
  inline NotifyRemoveCommodity& operator=(const NotifyRemoveCommodity& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRemoveCommodity& operator=(NotifyRemoveCommodity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRemoveCommodity& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRemoveCommodity* internal_default_instance() {
    return reinterpret_cast<const NotifyRemoveCommodity*>(
        &_NotifyRemoveCommodity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(NotifyRemoveCommodity& a, NotifyRemoveCommodity& b) { a.Swap(&b); }
  inline void Swap(NotifyRemoveCommodity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRemoveCommodity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRemoveCommodity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyRemoveCommodity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyRemoveCommodity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyRemoveCommodity& from) { NotifyRemoveCommodity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyRemoveCommodity* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyRemoveCommodity"; }

 protected:
  explicit NotifyRemoveCommodity(::google::protobuf::Arena* arena);
  NotifyRemoveCommodity(::google::protobuf::Arena* arena, const NotifyRemoveCommodity& from);
  NotifyRemoveCommodity(::google::protobuf::Arena* arena, NotifyRemoveCommodity&& from) noexcept
      : NotifyRemoveCommodity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommodityidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated uint32 Commodityid = 2;
  int commodityid_size() const;
  private:
  int _internal_commodityid_size() const;

  public:
  void clear_commodityid() ;
  ::uint32_t commodityid(int index) const;
  void set_commodityid(int index, ::uint32_t value);
  void add_commodityid(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& commodityid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_commodityid();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_commodityid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_commodityid();

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyRemoveCommodity];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyRemoveCommodity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> commodityid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyReconnectInfo_ReconnectInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyReconnectInfo.ReconnectInfo) */ {
 public:
  inline NotifyReconnectInfo_ReconnectInfo() : NotifyReconnectInfo_ReconnectInfo(nullptr) {}
  ~NotifyReconnectInfo_ReconnectInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyReconnectInfo_ReconnectInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyReconnectInfo_ReconnectInfo(const NotifyReconnectInfo_ReconnectInfo& from) : NotifyReconnectInfo_ReconnectInfo(nullptr, from) {}
  inline NotifyReconnectInfo_ReconnectInfo(NotifyReconnectInfo_ReconnectInfo&& from) noexcept
      : NotifyReconnectInfo_ReconnectInfo(nullptr, std::move(from)) {}
  inline NotifyReconnectInfo_ReconnectInfo& operator=(const NotifyReconnectInfo_ReconnectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyReconnectInfo_ReconnectInfo& operator=(NotifyReconnectInfo_ReconnectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyReconnectInfo_ReconnectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyReconnectInfo_ReconnectInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyReconnectInfo_ReconnectInfo*>(
        &_NotifyReconnectInfo_ReconnectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 166;
  friend void swap(NotifyReconnectInfo_ReconnectInfo& a, NotifyReconnectInfo_ReconnectInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyReconnectInfo_ReconnectInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyReconnectInfo_ReconnectInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyReconnectInfo_ReconnectInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyReconnectInfo_ReconnectInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyReconnectInfo_ReconnectInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyReconnectInfo_ReconnectInfo& from) { NotifyReconnectInfo_ReconnectInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyReconnectInfo_ReconnectInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyReconnectInfo.ReconnectInfo"; }

 protected:
  explicit NotifyReconnectInfo_ReconnectInfo(::google::protobuf::Arena* arena);
  NotifyReconnectInfo_ReconnectInfo(::google::protobuf::Arena* arena, const NotifyReconnectInfo_ReconnectInfo& from);
  NotifyReconnectInfo_ReconnectInfo(::google::protobuf::Arena* arena, NotifyReconnectInfo_ReconnectInfo&& from) noexcept
      : NotifyReconnectInfo_ReconnectInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 3,
    kGuidFieldNumber = 2,
    kPosFieldNumber = 1,
    kHeroidFieldNumber = 4,
    kIfselectedFieldNumber = 5,
  };
  // optional string nickname = 3;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 pos = 1;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional uint32 heroid = 4;
  bool has_heroid() const;
  void clear_heroid() ;
  ::uint32_t heroid() const;
  void set_heroid(::uint32_t value);

  private:
  ::uint32_t _internal_heroid() const;
  void _internal_set_heroid(::uint32_t value);

  public:
  // optional bool ifselected = 5;
  bool has_ifselected() const;
  void clear_ifselected() ;
  bool ifselected() const;
  void set_ifselected(bool value);

  private:
  bool _internal_ifselected() const;
  void _internal_set_ifselected(bool value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyReconnectInfo.ReconnectInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      57, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint64_t guid_;
    ::int32_t pos_;
    ::uint32_t heroid_;
    bool ifselected_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyQueryNickNameRet_QueryInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyQueryNickNameRet.QueryInfo) */ {
 public:
  inline NotifyQueryNickNameRet_QueryInfo() : NotifyQueryNickNameRet_QueryInfo(nullptr) {}
  ~NotifyQueryNickNameRet_QueryInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyQueryNickNameRet_QueryInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyQueryNickNameRet_QueryInfo(const NotifyQueryNickNameRet_QueryInfo& from) : NotifyQueryNickNameRet_QueryInfo(nullptr, from) {}
  inline NotifyQueryNickNameRet_QueryInfo(NotifyQueryNickNameRet_QueryInfo&& from) noexcept
      : NotifyQueryNickNameRet_QueryInfo(nullptr, std::move(from)) {}
  inline NotifyQueryNickNameRet_QueryInfo& operator=(const NotifyQueryNickNameRet_QueryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyQueryNickNameRet_QueryInfo& operator=(NotifyQueryNickNameRet_QueryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyQueryNickNameRet_QueryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyQueryNickNameRet_QueryInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyQueryNickNameRet_QueryInfo*>(
        &_NotifyQueryNickNameRet_QueryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 60;
  friend void swap(NotifyQueryNickNameRet_QueryInfo& a, NotifyQueryNickNameRet_QueryInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyQueryNickNameRet_QueryInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyQueryNickNameRet_QueryInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyQueryNickNameRet_QueryInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyQueryNickNameRet_QueryInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyQueryNickNameRet_QueryInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyQueryNickNameRet_QueryInfo& from) { NotifyQueryNickNameRet_QueryInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyQueryNickNameRet_QueryInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyQueryNickNameRet.QueryInfo"; }

 protected:
  explicit NotifyQueryNickNameRet_QueryInfo(::google::protobuf::Arena* arena);
  NotifyQueryNickNameRet_QueryInfo(::google::protobuf::Arena* arena, const NotifyQueryNickNameRet_QueryInfo& from);
  NotifyQueryNickNameRet_QueryInfo(::google::protobuf::Arena* arena, NotifyQueryNickNameRet_QueryInfo&& from) noexcept
      : NotifyQueryNickNameRet_QueryInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 1,
    kHeadidFieldNumber = 2,
  };
  // optional string nickname = 1;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional int32 headid = 2;
  bool has_headid() const;
  void clear_headid() ;
  ::int32_t headid() const;
  void set_headid(::int32_t value);

  private:
  ::int32_t _internal_headid() const;
  void _internal_set_headid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyQueryNickNameRet.QueryInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::int32_t headid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyPassitiveSkillUnLoad final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyPassitiveSkillUnLoad) */ {
 public:
  inline NotifyPassitiveSkillUnLoad() : NotifyPassitiveSkillUnLoad(nullptr) {}
  ~NotifyPassitiveSkillUnLoad() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyPassitiveSkillUnLoad(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyPassitiveSkillUnLoad(const NotifyPassitiveSkillUnLoad& from) : NotifyPassitiveSkillUnLoad(nullptr, from) {}
  inline NotifyPassitiveSkillUnLoad(NotifyPassitiveSkillUnLoad&& from) noexcept
      : NotifyPassitiveSkillUnLoad(nullptr, std::move(from)) {}
  inline NotifyPassitiveSkillUnLoad& operator=(const NotifyPassitiveSkillUnLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyPassitiveSkillUnLoad& operator=(NotifyPassitiveSkillUnLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyPassitiveSkillUnLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyPassitiveSkillUnLoad* internal_default_instance() {
    return reinterpret_cast<const NotifyPassitiveSkillUnLoad*>(
        &_NotifyPassitiveSkillUnLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 163;
  friend void swap(NotifyPassitiveSkillUnLoad& a, NotifyPassitiveSkillUnLoad& b) { a.Swap(&b); }
  inline void Swap(NotifyPassitiveSkillUnLoad* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyPassitiveSkillUnLoad* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyPassitiveSkillUnLoad* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyPassitiveSkillUnLoad>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyPassitiveSkillUnLoad& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyPassitiveSkillUnLoad& from) { NotifyPassitiveSkillUnLoad::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyPassitiveSkillUnLoad* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyPassitiveSkillUnLoad"; }

 protected:
  explicit NotifyPassitiveSkillUnLoad(::google::protobuf::Arena* arena);
  NotifyPassitiveSkillUnLoad(::google::protobuf::Arena* arena, const NotifyPassitiveSkillUnLoad& from);
  NotifyPassitiveSkillUnLoad(::google::protobuf::Arena* arena, NotifyPassitiveSkillUnLoad&& from) noexcept
      : NotifyPassitiveSkillUnLoad(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kSkillidFieldNumber = 3,
    kUniqueidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional int32 uniqueid = 4;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::int32_t uniqueid() const;
  void set_uniqueid(::int32_t value);

  private:
  ::int32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPassitiveSkillUnload];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyPassitiveSkillUnLoad)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t skillid_;
    ::int32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyPassitiveSkillRelease final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyPassitiveSkillRelease) */ {
 public:
  inline NotifyPassitiveSkillRelease() : NotifyPassitiveSkillRelease(nullptr) {}
  ~NotifyPassitiveSkillRelease() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyPassitiveSkillRelease(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyPassitiveSkillRelease(const NotifyPassitiveSkillRelease& from) : NotifyPassitiveSkillRelease(nullptr, from) {}
  inline NotifyPassitiveSkillRelease(NotifyPassitiveSkillRelease&& from) noexcept
      : NotifyPassitiveSkillRelease(nullptr, std::move(from)) {}
  inline NotifyPassitiveSkillRelease& operator=(const NotifyPassitiveSkillRelease& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyPassitiveSkillRelease& operator=(NotifyPassitiveSkillRelease&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyPassitiveSkillRelease& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyPassitiveSkillRelease* internal_default_instance() {
    return reinterpret_cast<const NotifyPassitiveSkillRelease*>(
        &_NotifyPassitiveSkillRelease_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 161;
  friend void swap(NotifyPassitiveSkillRelease& a, NotifyPassitiveSkillRelease& b) { a.Swap(&b); }
  inline void Swap(NotifyPassitiveSkillRelease* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyPassitiveSkillRelease* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyPassitiveSkillRelease* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyPassitiveSkillRelease>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyPassitiveSkillRelease& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyPassitiveSkillRelease& from) { NotifyPassitiveSkillRelease::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyPassitiveSkillRelease* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyPassitiveSkillRelease"; }

 protected:
  explicit NotifyPassitiveSkillRelease(::google::protobuf::Arena* arena);
  NotifyPassitiveSkillRelease(::google::protobuf::Arena* arena, const NotifyPassitiveSkillRelease& from);
  NotifyPassitiveSkillRelease(::google::protobuf::Arena* arena, NotifyPassitiveSkillRelease&& from) noexcept
      : NotifyPassitiveSkillRelease(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kSkillidFieldNumber = 3,
    kTimeLeftFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional int32 timeLeft = 4;
  bool has_timeleft() const;
  void clear_timeleft() ;
  ::int32_t timeleft() const;
  void set_timeleft(::int32_t value);

  private:
  ::int32_t _internal_timeleft() const;
  void _internal_set_timeleft(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPassitiveSkillRelease];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyPassitiveSkillRelease)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t skillid_;
    ::int32_t timeleft_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyPassitiveSkillLoad final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyPassitiveSkillLoad) */ {
 public:
  inline NotifyPassitiveSkillLoad() : NotifyPassitiveSkillLoad(nullptr) {}
  ~NotifyPassitiveSkillLoad() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyPassitiveSkillLoad(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyPassitiveSkillLoad(const NotifyPassitiveSkillLoad& from) : NotifyPassitiveSkillLoad(nullptr, from) {}
  inline NotifyPassitiveSkillLoad(NotifyPassitiveSkillLoad&& from) noexcept
      : NotifyPassitiveSkillLoad(nullptr, std::move(from)) {}
  inline NotifyPassitiveSkillLoad& operator=(const NotifyPassitiveSkillLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyPassitiveSkillLoad& operator=(NotifyPassitiveSkillLoad&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyPassitiveSkillLoad& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyPassitiveSkillLoad* internal_default_instance() {
    return reinterpret_cast<const NotifyPassitiveSkillLoad*>(
        &_NotifyPassitiveSkillLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 162;
  friend void swap(NotifyPassitiveSkillLoad& a, NotifyPassitiveSkillLoad& b) { a.Swap(&b); }
  inline void Swap(NotifyPassitiveSkillLoad* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyPassitiveSkillLoad* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyPassitiveSkillLoad* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyPassitiveSkillLoad>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyPassitiveSkillLoad& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyPassitiveSkillLoad& from) { NotifyPassitiveSkillLoad::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyPassitiveSkillLoad* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyPassitiveSkillLoad"; }

 protected:
  explicit NotifyPassitiveSkillLoad(::google::protobuf::Arena* arena);
  NotifyPassitiveSkillLoad(::google::protobuf::Arena* arena, const NotifyPassitiveSkillLoad& from);
  NotifyPassitiveSkillLoad(::google::protobuf::Arena* arena, NotifyPassitiveSkillLoad&& from) noexcept
      : NotifyPassitiveSkillLoad(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kSkillidFieldNumber = 3,
    kUniqueidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional int32 uniqueid = 4;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::int32_t uniqueid() const;
  void set_uniqueid(::int32_t value);

  private:
  ::int32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPassitiveSkillLoad];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyPassitiveSkillLoad)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t skillid_;
    ::int32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyOtherItemInfo_OtherItem final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyOtherItemInfo.OtherItem) */ {
 public:
  inline NotifyOtherItemInfo_OtherItem() : NotifyOtherItemInfo_OtherItem(nullptr) {}
  ~NotifyOtherItemInfo_OtherItem() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyOtherItemInfo_OtherItem(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyOtherItemInfo_OtherItem(const NotifyOtherItemInfo_OtherItem& from) : NotifyOtherItemInfo_OtherItem(nullptr, from) {}
  inline NotifyOtherItemInfo_OtherItem(NotifyOtherItemInfo_OtherItem&& from) noexcept
      : NotifyOtherItemInfo_OtherItem(nullptr, std::move(from)) {}
  inline NotifyOtherItemInfo_OtherItem& operator=(const NotifyOtherItemInfo_OtherItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyOtherItemInfo_OtherItem& operator=(NotifyOtherItemInfo_OtherItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyOtherItemInfo_OtherItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyOtherItemInfo_OtherItem* internal_default_instance() {
    return reinterpret_cast<const NotifyOtherItemInfo_OtherItem*>(
        &_NotifyOtherItemInfo_OtherItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(NotifyOtherItemInfo_OtherItem& a, NotifyOtherItemInfo_OtherItem& b) { a.Swap(&b); }
  inline void Swap(NotifyOtherItemInfo_OtherItem* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyOtherItemInfo_OtherItem* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyOtherItemInfo_OtherItem* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyOtherItemInfo_OtherItem>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyOtherItemInfo_OtherItem& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyOtherItemInfo_OtherItem& from) { NotifyOtherItemInfo_OtherItem::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyOtherItemInfo_OtherItem* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyOtherItemInfo.OtherItem"; }

 protected:
  explicit NotifyOtherItemInfo_OtherItem(::google::protobuf::Arena* arena);
  NotifyOtherItemInfo_OtherItem(::google::protobuf::Arena* arena, const NotifyOtherItemInfo_OtherItem& from);
  NotifyOtherItemInfo_OtherItem(::google::protobuf::Arena* arena, NotifyOtherItemInfo_OtherItem&& from) noexcept
      : NotifyOtherItemInfo_OtherItem(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kItemNumFieldNumber = 2,
    kExpiredTimeFieldNumber = 3,
  };
  // optional uint32 item_id = 1;
  bool has_item_id() const;
  void clear_item_id() ;
  ::uint32_t item_id() const;
  void set_item_id(::uint32_t value);

  private:
  ::uint32_t _internal_item_id() const;
  void _internal_set_item_id(::uint32_t value);

  public:
  // optional uint32 item_num = 2;
  bool has_item_num() const;
  void clear_item_num() ;
  ::uint32_t item_num() const;
  void set_item_num(::uint32_t value);

  private:
  ::uint32_t _internal_item_num() const;
  void _internal_set_item_num(::uint32_t value);

  public:
  // optional int64 expired_time = 3;
  bool has_expired_time() const;
  void clear_expired_time() ;
  ::int64_t expired_time() const;
  void set_expired_time(::int64_t value);

  private:
  ::int64_t _internal_expired_time() const;
  void _internal_set_expired_time(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyOtherItemInfo.OtherItem)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t item_id_;
    ::uint32_t item_num_;
    ::int64_t expired_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyOneMatchNeedOne final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyOneMatchNeedOne) */ {
 public:
  inline NotifyOneMatchNeedOne() : NotifyOneMatchNeedOne(nullptr) {}
  ~NotifyOneMatchNeedOne() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyOneMatchNeedOne(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyOneMatchNeedOne(const NotifyOneMatchNeedOne& from) : NotifyOneMatchNeedOne(nullptr, from) {}
  inline NotifyOneMatchNeedOne(NotifyOneMatchNeedOne&& from) noexcept
      : NotifyOneMatchNeedOne(nullptr, std::move(from)) {}
  inline NotifyOneMatchNeedOne& operator=(const NotifyOneMatchNeedOne& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyOneMatchNeedOne& operator=(NotifyOneMatchNeedOne&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyOneMatchNeedOne& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyOneMatchNeedOne* internal_default_instance() {
    return reinterpret_cast<const NotifyOneMatchNeedOne*>(
        &_NotifyOneMatchNeedOne_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(NotifyOneMatchNeedOne& a, NotifyOneMatchNeedOne& b) { a.Swap(&b); }
  inline void Swap(NotifyOneMatchNeedOne* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyOneMatchNeedOne* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyOneMatchNeedOne* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyOneMatchNeedOne>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyOneMatchNeedOne& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyOneMatchNeedOne& from) { NotifyOneMatchNeedOne::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyOneMatchNeedOne* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyOneMatchNeedOne"; }

 protected:
  explicit NotifyOneMatchNeedOne(::google::protobuf::Arena* arena);
  NotifyOneMatchNeedOne(::google::protobuf::Arena* arena, const NotifyOneMatchNeedOne& from);
  NotifyOneMatchNeedOne(::google::protobuf::Arena* arena, NotifyOneMatchNeedOne&& from) noexcept
      : NotifyOneMatchNeedOne(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapidFieldNumber = 2,
    kFightidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 mapid = 2;
  bool has_mapid() const;
  void clear_mapid() ;
  ::uint32_t mapid() const;
  void set_mapid(::uint32_t value);

  private:
  ::uint32_t _internal_mapid() const;
  void _internal_set_mapid(::uint32_t value);

  public:
  // optional uint32 fightid = 3;
  bool has_fightid() const;
  void clear_fightid() ;
  ::uint32_t fightid() const;
  void set_fightid(::uint32_t value);

  private:
  ::uint32_t _internal_fightid() const;
  void _internal_set_fightid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOneMatchNeedOne];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyOneMatchNeedOne)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t mapid_;
    ::uint32_t fightid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyOBReturnBattleRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyOBReturnBattleRoom) */ {
 public:
  inline NotifyOBReturnBattleRoom() : NotifyOBReturnBattleRoom(nullptr) {}
  ~NotifyOBReturnBattleRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyOBReturnBattleRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyOBReturnBattleRoom(const NotifyOBReturnBattleRoom& from) : NotifyOBReturnBattleRoom(nullptr, from) {}
  inline NotifyOBReturnBattleRoom(NotifyOBReturnBattleRoom&& from) noexcept
      : NotifyOBReturnBattleRoom(nullptr, std::move(from)) {}
  inline NotifyOBReturnBattleRoom& operator=(const NotifyOBReturnBattleRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyOBReturnBattleRoom& operator=(NotifyOBReturnBattleRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyOBReturnBattleRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyOBReturnBattleRoom* internal_default_instance() {
    return reinterpret_cast<const NotifyOBReturnBattleRoom*>(
        &_NotifyOBReturnBattleRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 168;
  friend void swap(NotifyOBReturnBattleRoom& a, NotifyOBReturnBattleRoom& b) { a.Swap(&b); }
  inline void Swap(NotifyOBReturnBattleRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyOBReturnBattleRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyOBReturnBattleRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyOBReturnBattleRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyOBReturnBattleRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyOBReturnBattleRoom& from) { NotifyOBReturnBattleRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyOBReturnBattleRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyOBReturnBattleRoom"; }

 protected:
  explicit NotifyOBReturnBattleRoom(::google::protobuf::Arena* arena);
  NotifyOBReturnBattleRoom(::google::protobuf::Arena* arena, const NotifyOBReturnBattleRoom& from);
  NotifyOBReturnBattleRoom(::google::protobuf::Arena* arena, NotifyOBReturnBattleRoom&& from) noexcept
      : NotifyOBReturnBattleRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOBReturnBattleRoom];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyOBReturnBattleRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyOBAppear final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyOBAppear) */ {
 public:
  inline NotifyOBAppear() : NotifyOBAppear(nullptr) {}
  ~NotifyOBAppear() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyOBAppear(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyOBAppear(const NotifyOBAppear& from) : NotifyOBAppear(nullptr, from) {}
  inline NotifyOBAppear(NotifyOBAppear&& from) noexcept
      : NotifyOBAppear(nullptr, std::move(from)) {}
  inline NotifyOBAppear& operator=(const NotifyOBAppear& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyOBAppear& operator=(NotifyOBAppear&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyOBAppear& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyOBAppear* internal_default_instance() {
    return reinterpret_cast<const NotifyOBAppear*>(
        &_NotifyOBAppear_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 169;
  friend void swap(NotifyOBAppear& a, NotifyOBAppear& b) { a.Swap(&b); }
  inline void Swap(NotifyOBAppear* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyOBAppear* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyOBAppear* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyOBAppear>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyOBAppear& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyOBAppear& from) { NotifyOBAppear::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyOBAppear* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyOBAppear"; }

 protected:
  explicit NotifyOBAppear(::google::protobuf::Arena* arena);
  NotifyOBAppear(::google::protobuf::Arena* arena, const NotifyOBAppear& from);
  NotifyOBAppear(::google::protobuf::Arena* arena, NotifyOBAppear&& from) noexcept
      : NotifyOBAppear(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObidFieldNumber = 2,
    kCampFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 obid = 2;
  bool has_obid() const;
  void clear_obid() ;
  ::uint64_t obid() const;
  void set_obid(::uint64_t value);

  private:
  ::uint64_t _internal_obid() const;
  void _internal_set_obid(::uint64_t value);

  public:
  // optional int32 camp = 3;
  bool has_camp() const;
  void clear_camp() ;
  ::int32_t camp() const;
  void set_camp(::int32_t value);

  private:
  ::int32_t _internal_camp() const;
  void _internal_set_camp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOBAppear];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyOBAppear)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t obid_;
    ::int32_t camp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyNewNickname final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyNewNickname) */ {
 public:
  inline NotifyNewNickname() : NotifyNewNickname(nullptr) {}
  ~NotifyNewNickname() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyNewNickname(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyNewNickname(const NotifyNewNickname& from) : NotifyNewNickname(nullptr, from) {}
  inline NotifyNewNickname(NotifyNewNickname&& from) noexcept
      : NotifyNewNickname(nullptr, std::move(from)) {}
  inline NotifyNewNickname& operator=(const NotifyNewNickname& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyNewNickname& operator=(NotifyNewNickname&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyNewNickname& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyNewNickname* internal_default_instance() {
    return reinterpret_cast<const NotifyNewNickname*>(
        &_NotifyNewNickname_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(NotifyNewNickname& a, NotifyNewNickname& b) { a.Swap(&b); }
  inline void Swap(NotifyNewNickname* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyNewNickname* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyNewNickname* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyNewNickname>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyNewNickname& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyNewNickname& from) { NotifyNewNickname::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyNewNickname* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyNewNickname"; }

 protected:
  explicit NotifyNewNickname(::google::protobuf::Arena* arena);
  NotifyNewNickname(::google::protobuf::Arena* arena, const NotifyNewNickname& from);
  NotifyNewNickname(::google::protobuf::Arena* arena, NotifyNewNickname&& from) noexcept
      : NotifyNewNickname(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewnicknameFieldNumber = 3,
    kGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string newnickname = 3;
  bool has_newnickname() const;
  void clear_newnickname() ;
  const std::string& newnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_newnickname(Arg_&& arg, Args_... args);
  std::string* mutable_newnickname();
  PROTOBUF_NODISCARD std::string* release_newnickname();
  void set_allocated_newnickname(std::string* value);

  private:
  const std::string& _internal_newnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newnickname(
      const std::string& value);
  std::string* _internal_mutable_newnickname();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNewNickname];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyNewNickname)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr newnickname_;
    ::uint64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyNewHeaderid final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyNewHeaderid) */ {
 public:
  inline NotifyNewHeaderid() : NotifyNewHeaderid(nullptr) {}
  ~NotifyNewHeaderid() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyNewHeaderid(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyNewHeaderid(const NotifyNewHeaderid& from) : NotifyNewHeaderid(nullptr, from) {}
  inline NotifyNewHeaderid(NotifyNewHeaderid&& from) noexcept
      : NotifyNewHeaderid(nullptr, std::move(from)) {}
  inline NotifyNewHeaderid& operator=(const NotifyNewHeaderid& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyNewHeaderid& operator=(NotifyNewHeaderid&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyNewHeaderid& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyNewHeaderid* internal_default_instance() {
    return reinterpret_cast<const NotifyNewHeaderid*>(
        &_NotifyNewHeaderid_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(NotifyNewHeaderid& a, NotifyNewHeaderid& b) { a.Swap(&b); }
  inline void Swap(NotifyNewHeaderid* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyNewHeaderid* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyNewHeaderid* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyNewHeaderid>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyNewHeaderid& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyNewHeaderid& from) { NotifyNewHeaderid::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyNewHeaderid* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyNewHeaderid"; }

 protected:
  explicit NotifyNewHeaderid(::google::protobuf::Arena* arena);
  NotifyNewHeaderid(::google::protobuf::Arena* arena, const NotifyNewHeaderid& from);
  NotifyNewHeaderid(::google::protobuf::Arena* arena, NotifyNewHeaderid&& from) noexcept
      : NotifyNewHeaderid(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kNewheaderidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 newheaderid = 3;
  bool has_newheaderid() const;
  void clear_newheaderid() ;
  ::uint32_t newheaderid() const;
  void set_newheaderid(::uint32_t value);

  private:
  ::uint32_t _internal_newheaderid() const;
  void _internal_set_newheaderid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNewHeaderid];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyNewHeaderid)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint32_t newheaderid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMsgFromUser final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMsgFromUser) */ {
 public:
  inline NotifyMsgFromUser() : NotifyMsgFromUser(nullptr) {}
  ~NotifyMsgFromUser() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMsgFromUser(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMsgFromUser(const NotifyMsgFromUser& from) : NotifyMsgFromUser(nullptr, from) {}
  inline NotifyMsgFromUser(NotifyMsgFromUser&& from) noexcept
      : NotifyMsgFromUser(nullptr, std::move(from)) {}
  inline NotifyMsgFromUser& operator=(const NotifyMsgFromUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMsgFromUser& operator=(NotifyMsgFromUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMsgFromUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMsgFromUser* internal_default_instance() {
    return reinterpret_cast<const NotifyMsgFromUser*>(
        &_NotifyMsgFromUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 66;
  friend void swap(NotifyMsgFromUser& a, NotifyMsgFromUser& b) { a.Swap(&b); }
  inline void Swap(NotifyMsgFromUser* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMsgFromUser* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMsgFromUser* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMsgFromUser>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMsgFromUser& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMsgFromUser& from) { NotifyMsgFromUser::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMsgFromUser* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMsgFromUser"; }

 protected:
  explicit NotifyMsgFromUser(::google::protobuf::Arena* arena);
  NotifyMsgFromUser(::google::protobuf::Arena* arena, const NotifyMsgFromUser& from);
  NotifyMsgFromUser(::google::protobuf::Arena* arena, NotifyMsgFromUser&& from) noexcept
      : NotifyMsgFromUser(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 3,
    kChatstrFieldNumber = 5,
    kGuididxFieldNumber = 2,
    kHeadidFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional string nickname = 3;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional string chatstr = 5;
  bool has_chatstr() const;
  void clear_chatstr() ;
  const std::string& chatstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chatstr(Arg_&& arg, Args_... args);
  std::string* mutable_chatstr();
  PROTOBUF_NODISCARD std::string* release_chatstr();
  void set_allocated_chatstr(std::string* value);

  private:
  const std::string& _internal_chatstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chatstr(
      const std::string& value);
  std::string* _internal_mutable_chatstr();

  public:
  // optional uint64 guididx = 2;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional int32 headid = 4;
  bool has_headid() const;
  void clear_headid() ;
  ::int32_t headid() const;
  void set_headid(::int32_t value);

  private:
  ::int32_t _internal_headid() const;
  void _internal_set_headid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyMsgFromUser];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GSToGC::MsgID msgnum() const;
  void set_msgnum(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgnum() const;
  void _internal_set_msgnum(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMsgFromUser)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr chatstr_;
    ::uint64_t guididx_;
    ::int32_t headid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMatchTeamSwitch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMatchTeamSwitch) */ {
 public:
  inline NotifyMatchTeamSwitch() : NotifyMatchTeamSwitch(nullptr) {}
  ~NotifyMatchTeamSwitch() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMatchTeamSwitch(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMatchTeamSwitch(const NotifyMatchTeamSwitch& from) : NotifyMatchTeamSwitch(nullptr, from) {}
  inline NotifyMatchTeamSwitch(NotifyMatchTeamSwitch&& from) noexcept
      : NotifyMatchTeamSwitch(nullptr, std::move(from)) {}
  inline NotifyMatchTeamSwitch& operator=(const NotifyMatchTeamSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMatchTeamSwitch& operator=(NotifyMatchTeamSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMatchTeamSwitch& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMatchTeamSwitch* internal_default_instance() {
    return reinterpret_cast<const NotifyMatchTeamSwitch*>(
        &_NotifyMatchTeamSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(NotifyMatchTeamSwitch& a, NotifyMatchTeamSwitch& b) { a.Swap(&b); }
  inline void Swap(NotifyMatchTeamSwitch* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMatchTeamSwitch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMatchTeamSwitch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMatchTeamSwitch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMatchTeamSwitch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMatchTeamSwitch& from) { NotifyMatchTeamSwitch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMatchTeamSwitch* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMatchTeamSwitch"; }

 protected:
  explicit NotifyMatchTeamSwitch(::google::protobuf::Arena* arena);
  NotifyMatchTeamSwitch(::google::protobuf::Arena* arena, const NotifyMatchTeamSwitch& from);
  NotifyMatchTeamSwitch(::google::protobuf::Arena* arena, NotifyMatchTeamSwitch&& from) noexcept
      : NotifyMatchTeamSwitch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStartflagFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional bool startflag = 2;
  bool has_startflag() const;
  void clear_startflag() ;
  bool startflag() const;
  void set_startflag(bool value);

  private:
  bool _internal_startflag() const;
  void _internal_set_startflag(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchTeamSwitch];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMatchTeamSwitch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool startflag_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMatchTeamPlayerInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMatchTeamPlayerInfo) */ {
 public:
  inline NotifyMatchTeamPlayerInfo() : NotifyMatchTeamPlayerInfo(nullptr) {}
  ~NotifyMatchTeamPlayerInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMatchTeamPlayerInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMatchTeamPlayerInfo(const NotifyMatchTeamPlayerInfo& from) : NotifyMatchTeamPlayerInfo(nullptr, from) {}
  inline NotifyMatchTeamPlayerInfo(NotifyMatchTeamPlayerInfo&& from) noexcept
      : NotifyMatchTeamPlayerInfo(nullptr, std::move(from)) {}
  inline NotifyMatchTeamPlayerInfo& operator=(const NotifyMatchTeamPlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMatchTeamPlayerInfo& operator=(NotifyMatchTeamPlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMatchTeamPlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMatchTeamPlayerInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyMatchTeamPlayerInfo*>(
        &_NotifyMatchTeamPlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(NotifyMatchTeamPlayerInfo& a, NotifyMatchTeamPlayerInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyMatchTeamPlayerInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMatchTeamPlayerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMatchTeamPlayerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMatchTeamPlayerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMatchTeamPlayerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMatchTeamPlayerInfo& from) { NotifyMatchTeamPlayerInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMatchTeamPlayerInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMatchTeamPlayerInfo"; }

 protected:
  explicit NotifyMatchTeamPlayerInfo(::google::protobuf::Arena* arena);
  NotifyMatchTeamPlayerInfo(::google::protobuf::Arena* arena, const NotifyMatchTeamPlayerInfo& from);
  NotifyMatchTeamPlayerInfo(::google::protobuf::Arena* arena, NotifyMatchTeamPlayerInfo&& from) noexcept
      : NotifyMatchTeamPlayerInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 4,
    kPostionFieldNumber = 2,
    kIsInsertFieldNumber = 3,
    kHeadidFieldNumber = 5,
    kUserlevelFieldNumber = 6,
    kMsgidFieldNumber = 1,
  };
  // optional string nickname = 4;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional uint32 postion = 2;
  bool has_postion() const;
  void clear_postion() ;
  ::uint32_t postion() const;
  void set_postion(::uint32_t value);

  private:
  ::uint32_t _internal_postion() const;
  void _internal_set_postion(::uint32_t value);

  public:
  // optional bool isInsert = 3;
  bool has_isinsert() const;
  void clear_isinsert() ;
  bool isinsert() const;
  void set_isinsert(bool value);

  private:
  bool _internal_isinsert() const;
  void _internal_set_isinsert(bool value);

  public:
  // optional uint32 headid = 5;
  bool has_headid() const;
  void clear_headid() ;
  ::uint32_t headid() const;
  void set_headid(::uint32_t value);

  private:
  ::uint32_t _internal_headid() const;
  void _internal_set_headid(::uint32_t value);

  public:
  // optional uint32 userlevel = 6;
  bool has_userlevel() const;
  void clear_userlevel() ;
  ::uint32_t userlevel() const;
  void set_userlevel(::uint32_t value);

  private:
  ::uint32_t _internal_userlevel() const;
  void _internal_set_userlevel(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchTeamPlayerInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMatchTeamPlayerInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint32_t postion_;
    bool isinsert_;
    ::uint32_t headid_;
    ::uint32_t userlevel_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMatchTeamBaseInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMatchTeamBaseInfo) */ {
 public:
  inline NotifyMatchTeamBaseInfo() : NotifyMatchTeamBaseInfo(nullptr) {}
  ~NotifyMatchTeamBaseInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMatchTeamBaseInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMatchTeamBaseInfo(const NotifyMatchTeamBaseInfo& from) : NotifyMatchTeamBaseInfo(nullptr, from) {}
  inline NotifyMatchTeamBaseInfo(NotifyMatchTeamBaseInfo&& from) noexcept
      : NotifyMatchTeamBaseInfo(nullptr, std::move(from)) {}
  inline NotifyMatchTeamBaseInfo& operator=(const NotifyMatchTeamBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMatchTeamBaseInfo& operator=(NotifyMatchTeamBaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMatchTeamBaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMatchTeamBaseInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyMatchTeamBaseInfo*>(
        &_NotifyMatchTeamBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(NotifyMatchTeamBaseInfo& a, NotifyMatchTeamBaseInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyMatchTeamBaseInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMatchTeamBaseInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMatchTeamBaseInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMatchTeamBaseInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMatchTeamBaseInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMatchTeamBaseInfo& from) { NotifyMatchTeamBaseInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMatchTeamBaseInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMatchTeamBaseInfo"; }

 protected:
  explicit NotifyMatchTeamBaseInfo(::google::protobuf::Arena* arena);
  NotifyMatchTeamBaseInfo(::google::protobuf::Arena* arena, const NotifyMatchTeamBaseInfo& from);
  NotifyMatchTeamBaseInfo(::google::protobuf::Arena* arena, NotifyMatchTeamBaseInfo&& from) noexcept
      : NotifyMatchTeamBaseInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTeamidFieldNumber = 2,
    kMatchtypeFieldNumber = 3,
    kMapidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 teamid = 2;
  bool has_teamid() const;
  void clear_teamid() ;
  ::uint32_t teamid() const;
  void set_teamid(::uint32_t value);

  private:
  ::uint32_t _internal_teamid() const;
  void _internal_set_teamid(::uint32_t value);

  public:
  // optional uint32 matchtype = 3;
  bool has_matchtype() const;
  void clear_matchtype() ;
  ::uint32_t matchtype() const;
  void set_matchtype(::uint32_t value);

  private:
  ::uint32_t _internal_matchtype() const;
  void _internal_set_matchtype(::uint32_t value);

  public:
  // optional uint32 mapid = 4;
  bool has_mapid() const;
  void clear_mapid() ;
  ::uint32_t mapid() const;
  void set_mapid(::uint32_t value);

  private:
  ::uint32_t _internal_mapid() const;
  void _internal_set_mapid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchTeamBaseInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMatchTeamBaseInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t teamid_;
    ::uint32_t matchtype_;
    ::uint32_t mapid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMatchInviteJoin final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMatchInviteJoin) */ {
 public:
  inline NotifyMatchInviteJoin() : NotifyMatchInviteJoin(nullptr) {}
  ~NotifyMatchInviteJoin() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMatchInviteJoin(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMatchInviteJoin(const NotifyMatchInviteJoin& from) : NotifyMatchInviteJoin(nullptr, from) {}
  inline NotifyMatchInviteJoin(NotifyMatchInviteJoin&& from) noexcept
      : NotifyMatchInviteJoin(nullptr, std::move(from)) {}
  inline NotifyMatchInviteJoin& operator=(const NotifyMatchInviteJoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMatchInviteJoin& operator=(NotifyMatchInviteJoin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMatchInviteJoin& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMatchInviteJoin* internal_default_instance() {
    return reinterpret_cast<const NotifyMatchInviteJoin*>(
        &_NotifyMatchInviteJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(NotifyMatchInviteJoin& a, NotifyMatchInviteJoin& b) { a.Swap(&b); }
  inline void Swap(NotifyMatchInviteJoin* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMatchInviteJoin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMatchInviteJoin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMatchInviteJoin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMatchInviteJoin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMatchInviteJoin& from) { NotifyMatchInviteJoin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMatchInviteJoin* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMatchInviteJoin"; }

 protected:
  explicit NotifyMatchInviteJoin(::google::protobuf::Arena* arena);
  NotifyMatchInviteJoin(::google::protobuf::Arena* arena, const NotifyMatchInviteJoin& from);
  NotifyMatchInviteJoin(::google::protobuf::Arena* arena, NotifyMatchInviteJoin&& from) noexcept
      : NotifyMatchInviteJoin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchInviteJoin];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMatchInviteJoin)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMailRet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMailRet) */ {
 public:
  inline NotifyMailRet() : NotifyMailRet(nullptr) {}
  ~NotifyMailRet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMailRet(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMailRet(const NotifyMailRet& from) : NotifyMailRet(nullptr, from) {}
  inline NotifyMailRet(NotifyMailRet&& from) noexcept
      : NotifyMailRet(nullptr, std::move(from)) {}
  inline NotifyMailRet& operator=(const NotifyMailRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMailRet& operator=(NotifyMailRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMailRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMailRet* internal_default_instance() {
    return reinterpret_cast<const NotifyMailRet*>(
        &_NotifyMailRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(NotifyMailRet& a, NotifyMailRet& b) { a.Swap(&b); }
  inline void Swap(NotifyMailRet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMailRet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMailRet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMailRet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMailRet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMailRet& from) { NotifyMailRet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMailRet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMailRet"; }

 protected:
  explicit NotifyMailRet(::google::protobuf::Arena* arena);
  NotifyMailRet(::google::protobuf::Arena* arena, const NotifyMailRet& from);
  NotifyMailRet(::google::protobuf::Arena* arena, NotifyMailRet&& from) noexcept
      : NotifyMailRet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailidFieldNumber = 2,
    kErrcodeFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int32 mailid = 2;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional int32 errcode = 3;
  bool has_errcode() const;
  void clear_errcode() ;
  ::int32_t errcode() const;
  void set_errcode(::int32_t value);

  private:
  ::int32_t _internal_errcode() const;
  void _internal_set_errcode(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMailRet];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMailRet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mailid_;
    ::int32_t errcode_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMPInfo_MPInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMPInfo.MPInfo) */ {
 public:
  inline NotifyMPInfo_MPInfo() : NotifyMPInfo_MPInfo(nullptr) {}
  ~NotifyMPInfo_MPInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMPInfo_MPInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMPInfo_MPInfo(const NotifyMPInfo_MPInfo& from) : NotifyMPInfo_MPInfo(nullptr, from) {}
  inline NotifyMPInfo_MPInfo(NotifyMPInfo_MPInfo&& from) noexcept
      : NotifyMPInfo_MPInfo(nullptr, std::move(from)) {}
  inline NotifyMPInfo_MPInfo& operator=(const NotifyMPInfo_MPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMPInfo_MPInfo& operator=(NotifyMPInfo_MPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMPInfo_MPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMPInfo_MPInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyMPInfo_MPInfo*>(
        &_NotifyMPInfo_MPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 113;
  friend void swap(NotifyMPInfo_MPInfo& a, NotifyMPInfo_MPInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyMPInfo_MPInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMPInfo_MPInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMPInfo_MPInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMPInfo_MPInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMPInfo_MPInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMPInfo_MPInfo& from) { NotifyMPInfo_MPInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMPInfo_MPInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMPInfo.MPInfo"; }

 protected:
  explicit NotifyMPInfo_MPInfo(::google::protobuf::Arena* arena);
  NotifyMPInfo_MPInfo(::google::protobuf::Arena* arena, const NotifyMPInfo_MPInfo& from);
  NotifyMPInfo_MPInfo(::google::protobuf::Arena* arena, NotifyMPInfo_MPInfo&& from) noexcept
      : NotifyMPInfo_MPInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 1,
    kCurmpFieldNumber = 2,
    kMaxmpFieldNumber = 3,
  };
  // optional uint64 guid = 1;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 curmp = 2;
  bool has_curmp() const;
  void clear_curmp() ;
  ::int32_t curmp() const;
  void set_curmp(::int32_t value);

  private:
  ::int32_t _internal_curmp() const;
  void _internal_set_curmp(::int32_t value);

  public:
  // optional int32 maxmp = 3;
  bool has_maxmp() const;
  void clear_maxmp() ;
  ::int32_t maxmp() const;
  void set_maxmp(::int32_t value);

  private:
  ::int32_t _internal_maxmp() const;
  void _internal_set_maxmp(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMPInfo.MPInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t curmp_;
    ::int32_t maxmp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyKillNPC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyKillNPC) */ {
 public:
  inline NotifyKillNPC() : NotifyKillNPC(nullptr) {}
  ~NotifyKillNPC() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyKillNPC(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyKillNPC(const NotifyKillNPC& from) : NotifyKillNPC(nullptr, from) {}
  inline NotifyKillNPC(NotifyKillNPC&& from) noexcept
      : NotifyKillNPC(nullptr, std::move(from)) {}
  inline NotifyKillNPC& operator=(const NotifyKillNPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyKillNPC& operator=(NotifyKillNPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyKillNPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyKillNPC* internal_default_instance() {
    return reinterpret_cast<const NotifyKillNPC*>(
        &_NotifyKillNPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 170;
  friend void swap(NotifyKillNPC& a, NotifyKillNPC& b) { a.Swap(&b); }
  inline void Swap(NotifyKillNPC* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyKillNPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyKillNPC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyKillNPC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyKillNPC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyKillNPC& from) { NotifyKillNPC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyKillNPC* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyKillNPC"; }

 protected:
  explicit NotifyKillNPC(::google::protobuf::Arena* arena);
  NotifyKillNPC(::google::protobuf::Arena* arena, const NotifyKillNPC& from);
  NotifyKillNPC(::google::protobuf::Arena* arena, NotifyKillNPC&& from) noexcept
      : NotifyKillNPC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kKillnumFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 killnum = 3;
  bool has_killnum() const;
  void clear_killnum() ;
  ::uint32_t killnum() const;
  void set_killnum(::uint32_t value);

  private:
  ::uint32_t _internal_killnum() const;
  void _internal_set_killnum(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyKillNPC];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyKillNPC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint32_t killnum_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyIsOnSS final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyIsOnSS) */ {
 public:
  inline NotifyIsOnSS() : NotifyIsOnSS(nullptr) {}
  ~NotifyIsOnSS() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyIsOnSS(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyIsOnSS(const NotifyIsOnSS& from) : NotifyIsOnSS(nullptr, from) {}
  inline NotifyIsOnSS(NotifyIsOnSS&& from) noexcept
      : NotifyIsOnSS(nullptr, std::move(from)) {}
  inline NotifyIsOnSS& operator=(const NotifyIsOnSS& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyIsOnSS& operator=(NotifyIsOnSS&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyIsOnSS& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyIsOnSS* internal_default_instance() {
    return reinterpret_cast<const NotifyIsOnSS*>(
        &_NotifyIsOnSS_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(NotifyIsOnSS& a, NotifyIsOnSS& b) { a.Swap(&b); }
  inline void Swap(NotifyIsOnSS* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyIsOnSS* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyIsOnSS* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyIsOnSS>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyIsOnSS& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyIsOnSS& from) { NotifyIsOnSS::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyIsOnSS* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyIsOnSS"; }

 protected:
  explicit NotifyIsOnSS(::google::protobuf::Arena* arena);
  NotifyIsOnSS(::google::protobuf::Arena* arena, const NotifyIsOnSS& from);
  NotifyIsOnSS(::google::protobuf::Arena* arena, NotifyIsOnSS&& from) noexcept
      : NotifyIsOnSS(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSsidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 ssid = 2;
  bool has_ssid() const;
  void clear_ssid() ;
  ::uint32_t ssid() const;
  void set_ssid(::uint32_t value);

  private:
  ::uint32_t _internal_ssid() const;
  void _internal_set_ssid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_NotifyIsOnSS];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyIsOnSS)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t ssid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyHerosInfo_heropanelinfo_goodsmsg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg) */ {
 public:
  inline NotifyHerosInfo_heropanelinfo_goodsmsg() : NotifyHerosInfo_heropanelinfo_goodsmsg(nullptr) {}
  ~NotifyHerosInfo_heropanelinfo_goodsmsg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyHerosInfo_heropanelinfo_goodsmsg(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyHerosInfo_heropanelinfo_goodsmsg(const NotifyHerosInfo_heropanelinfo_goodsmsg& from) : NotifyHerosInfo_heropanelinfo_goodsmsg(nullptr, from) {}
  inline NotifyHerosInfo_heropanelinfo_goodsmsg(NotifyHerosInfo_heropanelinfo_goodsmsg&& from) noexcept
      : NotifyHerosInfo_heropanelinfo_goodsmsg(nullptr, std::move(from)) {}
  inline NotifyHerosInfo_heropanelinfo_goodsmsg& operator=(const NotifyHerosInfo_heropanelinfo_goodsmsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyHerosInfo_heropanelinfo_goodsmsg& operator=(NotifyHerosInfo_heropanelinfo_goodsmsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyHerosInfo_heropanelinfo_goodsmsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyHerosInfo_heropanelinfo_goodsmsg* internal_default_instance() {
    return reinterpret_cast<const NotifyHerosInfo_heropanelinfo_goodsmsg*>(
        &_NotifyHerosInfo_heropanelinfo_goodsmsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(NotifyHerosInfo_heropanelinfo_goodsmsg& a, NotifyHerosInfo_heropanelinfo_goodsmsg& b) { a.Swap(&b); }
  inline void Swap(NotifyHerosInfo_heropanelinfo_goodsmsg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyHerosInfo_heropanelinfo_goodsmsg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyHerosInfo_heropanelinfo_goodsmsg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyHerosInfo_heropanelinfo_goodsmsg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyHerosInfo_heropanelinfo_goodsmsg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyHerosInfo_heropanelinfo_goodsmsg& from) { NotifyHerosInfo_heropanelinfo_goodsmsg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyHerosInfo_heropanelinfo_goodsmsg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg"; }

 protected:
  explicit NotifyHerosInfo_heropanelinfo_goodsmsg(::google::protobuf::Arena* arena);
  NotifyHerosInfo_heropanelinfo_goodsmsg(::google::protobuf::Arena* arena, const NotifyHerosInfo_heropanelinfo_goodsmsg& from);
  NotifyHerosInfo_heropanelinfo_goodsmsg(::google::protobuf::Arena* arena, NotifyHerosInfo_heropanelinfo_goodsmsg&& from) noexcept
      : NotifyHerosInfo_heropanelinfo_goodsmsg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGridFieldNumber = 1,
    kGoodidFieldNumber = 2,
  };
  // optional int32 grid = 1;
  bool has_grid() const;
  void clear_grid() ;
  ::int32_t grid() const;
  void set_grid(::int32_t value);

  private:
  ::int32_t _internal_grid() const;
  void _internal_set_grid(::int32_t value);

  public:
  // optional int32 goodid = 2;
  bool has_goodid() const;
  void clear_goodid() ;
  ::int32_t goodid() const;
  void set_goodid(::int32_t value);

  private:
  ::int32_t _internal_goodid() const;
  void _internal_set_goodid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t grid_;
    ::int32_t goodid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyHeroReborn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyHeroReborn) */ {
 public:
  inline NotifyHeroReborn() : NotifyHeroReborn(nullptr) {}
  ~NotifyHeroReborn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyHeroReborn(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyHeroReborn(const NotifyHeroReborn& from) : NotifyHeroReborn(nullptr, from) {}
  inline NotifyHeroReborn(NotifyHeroReborn&& from) noexcept
      : NotifyHeroReborn(nullptr, std::move(from)) {}
  inline NotifyHeroReborn& operator=(const NotifyHeroReborn& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyHeroReborn& operator=(NotifyHeroReborn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyHeroReborn& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyHeroReborn* internal_default_instance() {
    return reinterpret_cast<const NotifyHeroReborn*>(
        &_NotifyHeroReborn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 131;
  friend void swap(NotifyHeroReborn& a, NotifyHeroReborn& b) { a.Swap(&b); }
  inline void Swap(NotifyHeroReborn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyHeroReborn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyHeroReborn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyHeroReborn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyHeroReborn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyHeroReborn& from) { NotifyHeroReborn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyHeroReborn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyHeroReborn"; }

 protected:
  explicit NotifyHeroReborn(::google::protobuf::Arena* arena);
  NotifyHeroReborn(::google::protobuf::Arena* arena, const NotifyHeroReborn& from);
  NotifyHeroReborn(::google::protobuf::Arena* arena, NotifyHeroReborn&& from) noexcept
      : NotifyHeroReborn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroReborn];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyHeroReborn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyHeroInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyHeroInfo) */ {
 public:
  inline NotifyHeroInfo() : NotifyHeroInfo(nullptr) {}
  ~NotifyHeroInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyHeroInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyHeroInfo(const NotifyHeroInfo& from) : NotifyHeroInfo(nullptr, from) {}
  inline NotifyHeroInfo(NotifyHeroInfo&& from) noexcept
      : NotifyHeroInfo(nullptr, std::move(from)) {}
  inline NotifyHeroInfo& operator=(const NotifyHeroInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyHeroInfo& operator=(NotifyHeroInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyHeroInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyHeroInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyHeroInfo*>(
        &_NotifyHeroInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 115;
  friend void swap(NotifyHeroInfo& a, NotifyHeroInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyHeroInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyHeroInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyHeroInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyHeroInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyHeroInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyHeroInfo& from) { NotifyHeroInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyHeroInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyHeroInfo"; }

 protected:
  explicit NotifyHeroInfo(::google::protobuf::Arena* arena);
  NotifyHeroInfo(::google::protobuf::Arena* arena, const NotifyHeroInfo& from);
  NotifyHeroInfo(::google::protobuf::Arena* arena, NotifyHeroInfo&& from) noexcept
      : NotifyHeroInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kLevelFieldNumber = 3,
    kExpFieldNumber = 4,
    kFuryFieldNumber = 5,
    kAbsorb1FieldNumber = 6,
    kAbsorb2FieldNumber = 7,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 level = 3;
  bool has_level() const;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // optional int32 exp = 4;
  bool has_exp() const;
  void clear_exp() ;
  ::int32_t exp() const;
  void set_exp(::int32_t value);

  private:
  ::int32_t _internal_exp() const;
  void _internal_set_exp(::int32_t value);

  public:
  // optional int32 fury = 5;
  bool has_fury() const;
  void clear_fury() ;
  ::int32_t fury() const;
  void set_fury(::int32_t value);

  private:
  ::int32_t _internal_fury() const;
  void _internal_set_fury(::int32_t value);

  public:
  // optional int32 absorb1 = 6;
  bool has_absorb1() const;
  void clear_absorb1() ;
  ::int32_t absorb1() const;
  void set_absorb1(::int32_t value);

  private:
  ::int32_t _internal_absorb1() const;
  void _internal_set_absorb1(::int32_t value);

  public:
  // optional int32 absorb2 = 7;
  bool has_absorb2() const;
  void clear_absorb2() ;
  ::int32_t absorb2() const;
  void set_absorb2(::int32_t value);

  private:
  ::int32_t _internal_absorb2() const;
  void _internal_set_absorb2(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyHeroInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t level_;
    ::int32_t exp_;
    ::int32_t fury_;
    ::int32_t absorb1_;
    ::int32_t absorb2_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyHPInfo_HPInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyHPInfo.HPInfo) */ {
 public:
  inline NotifyHPInfo_HPInfo() : NotifyHPInfo_HPInfo(nullptr) {}
  ~NotifyHPInfo_HPInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyHPInfo_HPInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyHPInfo_HPInfo(const NotifyHPInfo_HPInfo& from) : NotifyHPInfo_HPInfo(nullptr, from) {}
  inline NotifyHPInfo_HPInfo(NotifyHPInfo_HPInfo&& from) noexcept
      : NotifyHPInfo_HPInfo(nullptr, std::move(from)) {}
  inline NotifyHPInfo_HPInfo& operator=(const NotifyHPInfo_HPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyHPInfo_HPInfo& operator=(NotifyHPInfo_HPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyHPInfo_HPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyHPInfo_HPInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyHPInfo_HPInfo*>(
        &_NotifyHPInfo_HPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 111;
  friend void swap(NotifyHPInfo_HPInfo& a, NotifyHPInfo_HPInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyHPInfo_HPInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyHPInfo_HPInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyHPInfo_HPInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyHPInfo_HPInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyHPInfo_HPInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyHPInfo_HPInfo& from) { NotifyHPInfo_HPInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyHPInfo_HPInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyHPInfo.HPInfo"; }

 protected:
  explicit NotifyHPInfo_HPInfo(::google::protobuf::Arena* arena);
  NotifyHPInfo_HPInfo(::google::protobuf::Arena* arena, const NotifyHPInfo_HPInfo& from);
  NotifyHPInfo_HPInfo(::google::protobuf::Arena* arena, NotifyHPInfo_HPInfo&& from) noexcept
      : NotifyHPInfo_HPInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 1,
    kCurhpFieldNumber = 2,
    kMaxhpFieldNumber = 3,
  };
  // optional uint64 guid = 1;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 curhp = 2;
  bool has_curhp() const;
  void clear_curhp() ;
  ::int32_t curhp() const;
  void set_curhp(::int32_t value);

  private:
  ::int32_t _internal_curhp() const;
  void _internal_set_curhp(::int32_t value);

  public:
  // optional int32 maxhp = 3;
  bool has_maxhp() const;
  void clear_maxhp() ;
  ::int32_t maxhp() const;
  void set_maxhp(::int32_t value);

  private:
  ::int32_t _internal_maxhp() const;
  void _internal_set_maxhp(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyHPInfo.HPInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t curhp_;
    ::int32_t maxhp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyGoodsInfo_GoodsInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyGoodsInfo.GoodsInfo) */ {
 public:
  inline NotifyGoodsInfo_GoodsInfo() : NotifyGoodsInfo_GoodsInfo(nullptr) {}
  ~NotifyGoodsInfo_GoodsInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyGoodsInfo_GoodsInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyGoodsInfo_GoodsInfo(const NotifyGoodsInfo_GoodsInfo& from) : NotifyGoodsInfo_GoodsInfo(nullptr, from) {}
  inline NotifyGoodsInfo_GoodsInfo(NotifyGoodsInfo_GoodsInfo&& from) noexcept
      : NotifyGoodsInfo_GoodsInfo(nullptr, std::move(from)) {}
  inline NotifyGoodsInfo_GoodsInfo& operator=(const NotifyGoodsInfo_GoodsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyGoodsInfo_GoodsInfo& operator=(NotifyGoodsInfo_GoodsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyGoodsInfo_GoodsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyGoodsInfo_GoodsInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyGoodsInfo_GoodsInfo*>(
        &_NotifyGoodsInfo_GoodsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 98;
  friend void swap(NotifyGoodsInfo_GoodsInfo& a, NotifyGoodsInfo_GoodsInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyGoodsInfo_GoodsInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyGoodsInfo_GoodsInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyGoodsInfo_GoodsInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyGoodsInfo_GoodsInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyGoodsInfo_GoodsInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyGoodsInfo_GoodsInfo& from) { NotifyGoodsInfo_GoodsInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyGoodsInfo_GoodsInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyGoodsInfo.GoodsInfo"; }

 protected:
  explicit NotifyGoodsInfo_GoodsInfo(::google::protobuf::Arena* arena);
  NotifyGoodsInfo_GoodsInfo(::google::protobuf::Arena* arena, const NotifyGoodsInfo_GoodsInfo& from);
  NotifyGoodsInfo_GoodsInfo(::google::protobuf::Arena* arena, NotifyGoodsInfo_GoodsInfo&& from) noexcept
      : NotifyGoodsInfo_GoodsInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNumFieldNumber = 1,
    kPosFieldNumber = 2,
    kIfComposedFieldNumber = 3,
    kTyepidFieldNumber = 4,
    kStateFieldNumber = 5,
    kStatetimeFieldNumber = 6,
  };
  // optional int32 num = 1;
  bool has_num() const;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // optional int32 pos = 2;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional bool ifComposed = 3;
  bool has_ifcomposed() const;
  void clear_ifcomposed() ;
  bool ifcomposed() const;
  void set_ifcomposed(bool value);

  private:
  bool _internal_ifcomposed() const;
  void _internal_set_ifcomposed(bool value);

  public:
  // optional int32 tyepid = 4;
  bool has_tyepid() const;
  void clear_tyepid() ;
  ::int32_t tyepid() const;
  void set_tyepid(::int32_t value);

  private:
  ::int32_t _internal_tyepid() const;
  void _internal_set_tyepid(::int32_t value);

  public:
  // optional int32 state = 5;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional int32 statetime = 6;
  bool has_statetime() const;
  void clear_statetime() ;
  ::int32_t statetime() const;
  void set_statetime(::int32_t value);

  private:
  ::int32_t _internal_statetime() const;
  void _internal_set_statetime(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyGoodsInfo.GoodsInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t num_;
    ::int32_t pos_;
    bool ifcomposed_;
    ::int32_t tyepid_;
    ::int32_t state_;
    ::int32_t statetime_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyGoodsExpired final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyGoodsExpired) */ {
 public:
  inline NotifyGoodsExpired() : NotifyGoodsExpired(nullptr) {}
  ~NotifyGoodsExpired() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyGoodsExpired(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyGoodsExpired(const NotifyGoodsExpired& from) : NotifyGoodsExpired(nullptr, from) {}
  inline NotifyGoodsExpired(NotifyGoodsExpired&& from) noexcept
      : NotifyGoodsExpired(nullptr, std::move(from)) {}
  inline NotifyGoodsExpired& operator=(const NotifyGoodsExpired& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyGoodsExpired& operator=(NotifyGoodsExpired&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyGoodsExpired& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyGoodsExpired* internal_default_instance() {
    return reinterpret_cast<const NotifyGoodsExpired*>(
        &_NotifyGoodsExpired_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(NotifyGoodsExpired& a, NotifyGoodsExpired& b) { a.Swap(&b); }
  inline void Swap(NotifyGoodsExpired* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyGoodsExpired* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyGoodsExpired* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyGoodsExpired>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyGoodsExpired& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyGoodsExpired& from) { NotifyGoodsExpired::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyGoodsExpired* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyGoodsExpired"; }

 protected:
  explicit NotifyGoodsExpired(::google::protobuf::Arena* arena);
  NotifyGoodsExpired(::google::protobuf::Arena* arena, const NotifyGoodsExpired& from);
  NotifyGoodsExpired(::google::protobuf::Arena* arena, NotifyGoodsExpired&& from) noexcept
      : NotifyGoodsExpired(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommondityidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated int32 commondityid = 2;
  int commondityid_size() const;
  private:
  int _internal_commondityid_size() const;

  public:
  void clear_commondityid() ;
  ::int32_t commondityid(int index) const;
  void set_commondityid(int index, ::int32_t value);
  void add_commondityid(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& commondityid() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_commondityid();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_commondityid() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_commondityid();

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyGoodsExpired];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyGoodsExpired)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> commondityid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyGetNewCommodity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyGetNewCommodity) */ {
 public:
  inline NotifyGetNewCommodity() : NotifyGetNewCommodity(nullptr) {}
  ~NotifyGetNewCommodity() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyGetNewCommodity(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyGetNewCommodity(const NotifyGetNewCommodity& from) : NotifyGetNewCommodity(nullptr, from) {}
  inline NotifyGetNewCommodity(NotifyGetNewCommodity&& from) noexcept
      : NotifyGetNewCommodity(nullptr, std::move(from)) {}
  inline NotifyGetNewCommodity& operator=(const NotifyGetNewCommodity& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyGetNewCommodity& operator=(NotifyGetNewCommodity&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyGetNewCommodity& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyGetNewCommodity* internal_default_instance() {
    return reinterpret_cast<const NotifyGetNewCommodity*>(
        &_NotifyGetNewCommodity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(NotifyGetNewCommodity& a, NotifyGetNewCommodity& b) { a.Swap(&b); }
  inline void Swap(NotifyGetNewCommodity* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyGetNewCommodity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyGetNewCommodity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyGetNewCommodity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyGetNewCommodity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyGetNewCommodity& from) { NotifyGetNewCommodity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyGetNewCommodity* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyGetNewCommodity"; }

 protected:
  explicit NotifyGetNewCommodity(::google::protobuf::Arena* arena);
  NotifyGetNewCommodity(::google::protobuf::Arena* arena, const NotifyGetNewCommodity& from);
  NotifyGetNewCommodity(::google::protobuf::Arena* arena, NotifyGetNewCommodity&& from) noexcept
      : NotifyGetNewCommodity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCommodityidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 Commodityid = 2;
  bool has_commodityid() const;
  void clear_commodityid() ;
  ::uint32_t commodityid() const;
  void set_commodityid(::uint32_t value);

  private:
  ::uint32_t _internal_commodityid() const;
  void _internal_set_commodityid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetNewCommodity];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyGetNewCommodity)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t commodityid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyDelOneTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyDelOneTask) */ {
 public:
  inline NotifyDelOneTask() : NotifyDelOneTask(nullptr) {}
  ~NotifyDelOneTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyDelOneTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyDelOneTask(const NotifyDelOneTask& from) : NotifyDelOneTask(nullptr, from) {}
  inline NotifyDelOneTask(NotifyDelOneTask&& from) noexcept
      : NotifyDelOneTask(nullptr, std::move(from)) {}
  inline NotifyDelOneTask& operator=(const NotifyDelOneTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyDelOneTask& operator=(NotifyDelOneTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyDelOneTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyDelOneTask* internal_default_instance() {
    return reinterpret_cast<const NotifyDelOneTask*>(
        &_NotifyDelOneTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(NotifyDelOneTask& a, NotifyDelOneTask& b) { a.Swap(&b); }
  inline void Swap(NotifyDelOneTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyDelOneTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyDelOneTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyDelOneTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyDelOneTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyDelOneTask& from) { NotifyDelOneTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyDelOneTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyDelOneTask"; }

 protected:
  explicit NotifyDelOneTask(::google::protobuf::Arena* arena);
  NotifyDelOneTask(::google::protobuf::Arena* arena, const NotifyDelOneTask& from);
  NotifyDelOneTask(::google::protobuf::Arena* arena, NotifyDelOneTask&& from) noexcept
      : NotifyDelOneTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 task_guid = 2;
  bool has_task_guid() const;
  void clear_task_guid() ;
  ::uint32_t task_guid() const;
  void set_task_guid(::uint32_t value);

  private:
  ::uint32_t _internal_task_guid() const;
  void _internal_set_task_guid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_DelOneTask];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyDelOneTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t task_guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyCurGold final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyCurGold) */ {
 public:
  inline NotifyCurGold() : NotifyCurGold(nullptr) {}
  ~NotifyCurGold() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyCurGold(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyCurGold(const NotifyCurGold& from) : NotifyCurGold(nullptr, from) {}
  inline NotifyCurGold(NotifyCurGold&& from) noexcept
      : NotifyCurGold(nullptr, std::move(from)) {}
  inline NotifyCurGold& operator=(const NotifyCurGold& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCurGold& operator=(NotifyCurGold&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCurGold& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCurGold* internal_default_instance() {
    return reinterpret_cast<const NotifyCurGold*>(
        &_NotifyCurGold_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 175;
  friend void swap(NotifyCurGold& a, NotifyCurGold& b) { a.Swap(&b); }
  inline void Swap(NotifyCurGold* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCurGold* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCurGold* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyCurGold>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyCurGold& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyCurGold& from) { NotifyCurGold::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyCurGold* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyCurGold"; }

 protected:
  explicit NotifyCurGold(::google::protobuf::Arena* arena);
  NotifyCurGold(::google::protobuf::Arena* arena, const NotifyCurGold& from);
  NotifyCurGold(::google::protobuf::Arena* arena, NotifyCurGold&& from) noexcept
      : NotifyCurGold(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGoldFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 gold = 2;
  bool has_gold() const;
  void clear_gold() ;
  ::uint64_t gold() const;
  void set_gold(::uint64_t value);

  private:
  ::uint64_t _internal_gold() const;
  void _internal_set_gold(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGs_NotifyCurGold];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyCurGold)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t gold_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyCurDiamond final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyCurDiamond) */ {
 public:
  inline NotifyCurDiamond() : NotifyCurDiamond(nullptr) {}
  ~NotifyCurDiamond() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyCurDiamond(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyCurDiamond(const NotifyCurDiamond& from) : NotifyCurDiamond(nullptr, from) {}
  inline NotifyCurDiamond(NotifyCurDiamond&& from) noexcept
      : NotifyCurDiamond(nullptr, std::move(from)) {}
  inline NotifyCurDiamond& operator=(const NotifyCurDiamond& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCurDiamond& operator=(NotifyCurDiamond&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCurDiamond& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCurDiamond* internal_default_instance() {
    return reinterpret_cast<const NotifyCurDiamond*>(
        &_NotifyCurDiamond_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 176;
  friend void swap(NotifyCurDiamond& a, NotifyCurDiamond& b) { a.Swap(&b); }
  inline void Swap(NotifyCurDiamond* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCurDiamond* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCurDiamond* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyCurDiamond>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyCurDiamond& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyCurDiamond& from) { NotifyCurDiamond::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyCurDiamond* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyCurDiamond"; }

 protected:
  explicit NotifyCurDiamond(::google::protobuf::Arena* arena);
  NotifyCurDiamond(::google::protobuf::Arena* arena, const NotifyCurDiamond& from);
  NotifyCurDiamond(::google::protobuf::Arena* arena, NotifyCurDiamond&& from) noexcept
      : NotifyCurDiamond(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDiamondFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 Diamond = 2;
  bool has_diamond() const;
  void clear_diamond() ;
  ::uint64_t diamond() const;
  void set_diamond(::uint64_t value);

  private:
  ::uint64_t _internal_diamond() const;
  void _internal_set_diamond(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGs_NotifyCurDiamond];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyCurDiamond)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t diamond_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyCSHeroList_HeroListCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyCSHeroList.HeroListCfg) */ {
 public:
  inline NotifyCSHeroList_HeroListCfg() : NotifyCSHeroList_HeroListCfg(nullptr) {}
  ~NotifyCSHeroList_HeroListCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyCSHeroList_HeroListCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyCSHeroList_HeroListCfg(const NotifyCSHeroList_HeroListCfg& from) : NotifyCSHeroList_HeroListCfg(nullptr, from) {}
  inline NotifyCSHeroList_HeroListCfg(NotifyCSHeroList_HeroListCfg&& from) noexcept
      : NotifyCSHeroList_HeroListCfg(nullptr, std::move(from)) {}
  inline NotifyCSHeroList_HeroListCfg& operator=(const NotifyCSHeroList_HeroListCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCSHeroList_HeroListCfg& operator=(NotifyCSHeroList_HeroListCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCSHeroList_HeroListCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCSHeroList_HeroListCfg* internal_default_instance() {
    return reinterpret_cast<const NotifyCSHeroList_HeroListCfg*>(
        &_NotifyCSHeroList_HeroListCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 77;
  friend void swap(NotifyCSHeroList_HeroListCfg& a, NotifyCSHeroList_HeroListCfg& b) { a.Swap(&b); }
  inline void Swap(NotifyCSHeroList_HeroListCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCSHeroList_HeroListCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCSHeroList_HeroListCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyCSHeroList_HeroListCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyCSHeroList_HeroListCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyCSHeroList_HeroListCfg& from) { NotifyCSHeroList_HeroListCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyCSHeroList_HeroListCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyCSHeroList.HeroListCfg"; }

 protected:
  explicit NotifyCSHeroList_HeroListCfg(::google::protobuf::Arena* arena);
  NotifyCSHeroList_HeroListCfg(::google::protobuf::Arena* arena, const NotifyCSHeroList_HeroListCfg& from);
  NotifyCSHeroList_HeroListCfg(::google::protobuf::Arena* arena, NotifyCSHeroList_HeroListCfg&& from) noexcept
      : NotifyCSHeroList_HeroListCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpiredTimeFieldNumber = 2,
    kHeroidFieldNumber = 1,
    kIfFreeFieldNumber = 3,
  };
  // optional int64 expired_time = 2;
  bool has_expired_time() const;
  void clear_expired_time() ;
  ::int64_t expired_time() const;
  void set_expired_time(::int64_t value);

  private:
  ::int64_t _internal_expired_time() const;
  void _internal_set_expired_time(::int64_t value);

  public:
  // optional uint32 heroid = 1;
  bool has_heroid() const;
  void clear_heroid() ;
  ::uint32_t heroid() const;
  void set_heroid(::uint32_t value);

  private:
  ::uint32_t _internal_heroid() const;
  void _internal_set_heroid(::uint32_t value);

  public:
  // optional bool if_free = 3;
  bool has_if_free() const;
  void clear_if_free() ;
  bool if_free() const;
  void set_if_free(bool value);

  private:
  bool _internal_if_free() const;
  void _internal_set_if_free(bool value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyCSHeroList.HeroListCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t expired_time_;
    ::uint32_t heroid_;
    bool if_free_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyBornObj final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyBornObj) */ {
 public:
  inline NotifyBornObj() : NotifyBornObj(nullptr) {}
  ~NotifyBornObj() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyBornObj(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyBornObj(const NotifyBornObj& from) : NotifyBornObj(nullptr, from) {}
  inline NotifyBornObj(NotifyBornObj&& from) noexcept
      : NotifyBornObj(nullptr, std::move(from)) {}
  inline NotifyBornObj& operator=(const NotifyBornObj& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyBornObj& operator=(NotifyBornObj&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyBornObj& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyBornObj* internal_default_instance() {
    return reinterpret_cast<const NotifyBornObj*>(
        &_NotifyBornObj_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 165;
  friend void swap(NotifyBornObj& a, NotifyBornObj& b) { a.Swap(&b); }
  inline void Swap(NotifyBornObj* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyBornObj* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyBornObj* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyBornObj>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyBornObj& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyBornObj& from) { NotifyBornObj::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyBornObj* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyBornObj"; }

 protected:
  explicit NotifyBornObj(::google::protobuf::Arena* arena);
  NotifyBornObj(::google::protobuf::Arena* arena, const NotifyBornObj& from);
  NotifyBornObj(::google::protobuf::Arena* arena, NotifyBornObj&& from) noexcept
      : NotifyBornObj(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int32 type = 2;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToSSFromCS_NotifyBornObj];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyBornObj)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t type_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyBlastHurt final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyBlastHurt) */ {
 public:
  inline NotifyBlastHurt() : NotifyBlastHurt(nullptr) {}
  ~NotifyBlastHurt() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyBlastHurt(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyBlastHurt(const NotifyBlastHurt& from) : NotifyBlastHurt(nullptr, from) {}
  inline NotifyBlastHurt(NotifyBlastHurt&& from) noexcept
      : NotifyBlastHurt(nullptr, std::move(from)) {}
  inline NotifyBlastHurt& operator=(const NotifyBlastHurt& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyBlastHurt& operator=(NotifyBlastHurt&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyBlastHurt& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyBlastHurt* internal_default_instance() {
    return reinterpret_cast<const NotifyBlastHurt*>(
        &_NotifyBlastHurt_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 173;
  friend void swap(NotifyBlastHurt& a, NotifyBlastHurt& b) { a.Swap(&b); }
  inline void Swap(NotifyBlastHurt* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyBlastHurt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyBlastHurt* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyBlastHurt>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyBlastHurt& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyBlastHurt& from) { NotifyBlastHurt::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyBlastHurt* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyBlastHurt"; }

 protected:
  explicit NotifyBlastHurt(::google::protobuf::Arena* arena);
  NotifyBlastHurt(::google::protobuf::Arena* arena, const NotifyBlastHurt& from);
  NotifyBlastHurt(::google::protobuf::Arena* arena, NotifyBlastHurt&& from) noexcept
      : NotifyBlastHurt(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kBlasthpFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 blasthp = 3;
  bool has_blasthp() const;
  void clear_blasthp() ;
  ::int32_t blasthp() const;
  void set_blasthp(::int32_t value);

  private:
  ::int32_t _internal_blasthp() const;
  void _internal_set_blasthp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBlastHurt];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyBlastHurt)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t blasthp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyBeAddFriendMs final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyBeAddFriendMs) */ {
 public:
  inline NotifyBeAddFriendMs() : NotifyBeAddFriendMs(nullptr) {}
  ~NotifyBeAddFriendMs() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyBeAddFriendMs(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyBeAddFriendMs(const NotifyBeAddFriendMs& from) : NotifyBeAddFriendMs(nullptr, from) {}
  inline NotifyBeAddFriendMs(NotifyBeAddFriendMs&& from) noexcept
      : NotifyBeAddFriendMs(nullptr, std::move(from)) {}
  inline NotifyBeAddFriendMs& operator=(const NotifyBeAddFriendMs& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyBeAddFriendMs& operator=(NotifyBeAddFriendMs&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyBeAddFriendMs& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyBeAddFriendMs* internal_default_instance() {
    return reinterpret_cast<const NotifyBeAddFriendMs*>(
        &_NotifyBeAddFriendMs_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 65;
  friend void swap(NotifyBeAddFriendMs& a, NotifyBeAddFriendMs& b) { a.Swap(&b); }
  inline void Swap(NotifyBeAddFriendMs* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyBeAddFriendMs* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyBeAddFriendMs* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyBeAddFriendMs>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyBeAddFriendMs& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyBeAddFriendMs& from) { NotifyBeAddFriendMs::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyBeAddFriendMs* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyBeAddFriendMs"; }

 protected:
  explicit NotifyBeAddFriendMs(::google::protobuf::Arena* arena);
  NotifyBeAddFriendMs(::google::protobuf::Arena* arena, const NotifyBeAddFriendMs& from);
  NotifyBeAddFriendMs(::google::protobuf::Arena* arena, NotifyBeAddFriendMs&& from) noexcept
      : NotifyBeAddFriendMs(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSendnicknameFieldNumber = 2,
    kRecnicknameFieldNumber = 3,
    kSdnderGuididxFieldNumber = 4,
    kMsgnumFieldNumber = 1,
  };
  // optional string sendnickname = 2;
  bool has_sendnickname() const;
  void clear_sendnickname() ;
  const std::string& sendnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sendnickname(Arg_&& arg, Args_... args);
  std::string* mutable_sendnickname();
  PROTOBUF_NODISCARD std::string* release_sendnickname();
  void set_allocated_sendnickname(std::string* value);

  private:
  const std::string& _internal_sendnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendnickname(
      const std::string& value);
  std::string* _internal_mutable_sendnickname();

  public:
  // optional string recnickname = 3;
  bool has_recnickname() const;
  void clear_recnickname() ;
  const std::string& recnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_recnickname(Arg_&& arg, Args_... args);
  std::string* mutable_recnickname();
  PROTOBUF_NODISCARD std::string* release_recnickname();
  void set_allocated_recnickname(std::string* value);

  private:
  const std::string& _internal_recnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_recnickname(
      const std::string& value);
  std::string* _internal_mutable_recnickname();

  public:
  // optional uint64 sdnder_guididx = 4;
  bool has_sdnder_guididx() const;
  void clear_sdnder_guididx() ;
  ::uint64_t sdnder_guididx() const;
  void set_sdnder_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_sdnder_guididx() const;
  void _internal_set_sdnder_guididx(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyBeAddFriendMsg];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GSToGC::MsgID msgnum() const;
  void set_msgnum(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgnum() const;
  void _internal_set_msgnum(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyBeAddFriendMs)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      58, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr sendnickname_;
    ::google::protobuf::internal::ArenaStringPtr recnickname_;
    ::uint64_t sdnder_guididx_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyBattleManagerChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyBattleManagerChange) */ {
 public:
  inline NotifyBattleManagerChange() : NotifyBattleManagerChange(nullptr) {}
  ~NotifyBattleManagerChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyBattleManagerChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyBattleManagerChange(const NotifyBattleManagerChange& from) : NotifyBattleManagerChange(nullptr, from) {}
  inline NotifyBattleManagerChange(NotifyBattleManagerChange&& from) noexcept
      : NotifyBattleManagerChange(nullptr, std::move(from)) {}
  inline NotifyBattleManagerChange& operator=(const NotifyBattleManagerChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyBattleManagerChange& operator=(NotifyBattleManagerChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyBattleManagerChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyBattleManagerChange* internal_default_instance() {
    return reinterpret_cast<const NotifyBattleManagerChange*>(
        &_NotifyBattleManagerChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 64;
  friend void swap(NotifyBattleManagerChange& a, NotifyBattleManagerChange& b) { a.Swap(&b); }
  inline void Swap(NotifyBattleManagerChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyBattleManagerChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyBattleManagerChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyBattleManagerChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyBattleManagerChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyBattleManagerChange& from) { NotifyBattleManagerChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyBattleManagerChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyBattleManagerChange"; }

 protected:
  explicit NotifyBattleManagerChange(::google::protobuf::Arena* arena);
  NotifyBattleManagerChange(::google::protobuf::Arena* arena, const NotifyBattleManagerChange& from);
  NotifyBattleManagerChange(::google::protobuf::Arena* arena, NotifyBattleManagerChange&& from) noexcept
      : NotifyBattleManagerChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleManagerChange];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyBattleManagerChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyAltarBSIco final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyAltarBSIco) */ {
 public:
  inline NotifyAltarBSIco() : NotifyAltarBSIco(nullptr) {}
  ~NotifyAltarBSIco() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyAltarBSIco(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyAltarBSIco(const NotifyAltarBSIco& from) : NotifyAltarBSIco(nullptr, from) {}
  inline NotifyAltarBSIco(NotifyAltarBSIco&& from) noexcept
      : NotifyAltarBSIco(nullptr, std::move(from)) {}
  inline NotifyAltarBSIco& operator=(const NotifyAltarBSIco& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyAltarBSIco& operator=(NotifyAltarBSIco&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyAltarBSIco& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyAltarBSIco* internal_default_instance() {
    return reinterpret_cast<const NotifyAltarBSIco*>(
        &_NotifyAltarBSIco_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 171;
  friend void swap(NotifyAltarBSIco& a, NotifyAltarBSIco& b) { a.Swap(&b); }
  inline void Swap(NotifyAltarBSIco* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyAltarBSIco* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyAltarBSIco* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyAltarBSIco>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyAltarBSIco& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyAltarBSIco& from) { NotifyAltarBSIco::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyAltarBSIco* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyAltarBSIco"; }

 protected:
  explicit NotifyAltarBSIco(::google::protobuf::Arena* arena);
  NotifyAltarBSIco(::google::protobuf::Arena* arena, const NotifyAltarBSIco& from);
  NotifyAltarBSIco(::google::protobuf::Arena* arena, NotifyAltarBSIco&& from) noexcept
      : NotifyAltarBSIco(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAltaridFieldNumber = 2,
    kObjtypeFieldNumber = 3,
    kOptypeFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint32 altarid = 2;
  bool has_altarid() const;
  void clear_altarid() ;
  ::uint32_t altarid() const;
  void set_altarid(::uint32_t value);

  private:
  ::uint32_t _internal_altarid() const;
  void _internal_set_altarid(::uint32_t value);

  public:
  // optional uint32 objtype = 3;
  bool has_objtype() const;
  void clear_objtype() ;
  ::uint32_t objtype() const;
  void set_objtype(::uint32_t value);

  private:
  ::uint32_t _internal_objtype() const;
  void _internal_set_objtype(::uint32_t value);

  public:
  // optional uint32 optype = 4;
  bool has_optype() const;
  void clear_optype() ;
  ::uint32_t optype() const;
  void set_optype(::uint32_t value);

  private:
  ::uint32_t _internal_optype() const;
  void _internal_set_optype(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAltarBSOk];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyAltarBSIco)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t altarid_;
    ::uint32_t objtype_;
    ::uint32_t optype_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyAFPData_FPInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyAFPData.FPInfo) */ {
 public:
  inline NotifyAFPData_FPInfo() : NotifyAFPData_FPInfo(nullptr) {}
  ~NotifyAFPData_FPInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyAFPData_FPInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyAFPData_FPInfo(const NotifyAFPData_FPInfo& from) : NotifyAFPData_FPInfo(nullptr, from) {}
  inline NotifyAFPData_FPInfo(NotifyAFPData_FPInfo&& from) noexcept
      : NotifyAFPData_FPInfo(nullptr, std::move(from)) {}
  inline NotifyAFPData_FPInfo& operator=(const NotifyAFPData_FPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyAFPData_FPInfo& operator=(NotifyAFPData_FPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyAFPData_FPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyAFPData_FPInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyAFPData_FPInfo*>(
        &_NotifyAFPData_FPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 69;
  friend void swap(NotifyAFPData_FPInfo& a, NotifyAFPData_FPInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyAFPData_FPInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyAFPData_FPInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyAFPData_FPInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyAFPData_FPInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyAFPData_FPInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyAFPData_FPInfo& from) { NotifyAFPData_FPInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyAFPData_FPInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyAFPData.FPInfo"; }

 protected:
  explicit NotifyAFPData_FPInfo(::google::protobuf::Arena* arena);
  NotifyAFPData_FPInfo(::google::protobuf::Arena* arena, const NotifyAFPData_FPInfo& from);
  NotifyAFPData_FPInfo(::google::protobuf::Arena* arena, NotifyAFPData_FPInfo&& from) noexcept
      : NotifyAFPData_FPInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional int32 type = 1;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional int32 value = 2;
  bool has_value() const;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyAFPData.FPInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t type_;
    ::int32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NetClash final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NetClash) */ {
 public:
  inline NetClash() : NetClash(nullptr) {}
  ~NetClash() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NetClash(
      ::google::protobuf::internal::ConstantInitialized);

  inline NetClash(const NetClash& from) : NetClash(nullptr, from) {}
  inline NetClash(NetClash&& from) noexcept
      : NetClash(nullptr, std::move(from)) {}
  inline NetClash& operator=(const NetClash& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetClash& operator=(NetClash&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NetClash& default_instance() {
    return *internal_default_instance();
  }
  static inline const NetClash* internal_default_instance() {
    return reinterpret_cast<const NetClash*>(
        &_NetClash_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 73;
  friend void swap(NetClash& a, NetClash& b) { a.Swap(&b); }
  inline void Swap(NetClash* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NetClash* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NetClash* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NetClash>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NetClash& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NetClash& from) { NetClash::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NetClash* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NetClash"; }

 protected:
  explicit NetClash(::google::protobuf::Arena* arena);
  NetClash(::google::protobuf::Arena* arena, const NetClash& from);
  NetClash(::google::protobuf::Arena* arena, NetClash&& from) noexcept
      : NetClash(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNetClash];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NetClash)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class MpChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.MpChange) */ {
 public:
  inline MpChange() : MpChange(nullptr) {}
  ~MpChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MpChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline MpChange(const MpChange& from) : MpChange(nullptr, from) {}
  inline MpChange(MpChange&& from) noexcept
      : MpChange(nullptr, std::move(from)) {}
  inline MpChange& operator=(const MpChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline MpChange& operator=(MpChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MpChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const MpChange* internal_default_instance() {
    return reinterpret_cast<const MpChange*>(
        &_MpChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 106;
  friend void swap(MpChange& a, MpChange& b) { a.Swap(&b); }
  inline void Swap(MpChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MpChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MpChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MpChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MpChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MpChange& from) { MpChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MpChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.MpChange"; }

 protected:
  explicit MpChange(::google::protobuf::Arena* arena);
  MpChange(::google::protobuf::Arena* arena, const MpChange& from);
  MpChange(::google::protobuf::Arena* arena, MpChange&& from) noexcept
      : MpChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kMpFieldNumber = 3,
    kReasonFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 mp = 3;
  bool has_mp() const;
  void clear_mp() ;
  ::int32_t mp() const;
  void set_mp(::int32_t value);

  private:
  ::int32_t _internal_mp() const;
  void _internal_set_mp(::int32_t value);

  public:
  // optional .GSToGC.HPMPChangeReason reason = 4;
  bool has_reason() const;
  void clear_reason() ;
  ::GSToGC::HPMPChangeReason reason() const;
  void set_reason(::GSToGC::HPMPChangeReason value);

  private:
  ::GSToGC::HPMPChangeReason _internal_reason() const;
  void _internal_set_reason(::GSToGC::HPMPChangeReason value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMPChange];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.MpChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t mp_;
    int reason_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class MailInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.MailInfo) */ {
 public:
  inline MailInfo() : MailInfo(nullptr) {}
  ~MailInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MailInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline MailInfo(const MailInfo& from) : MailInfo(nullptr, from) {}
  inline MailInfo(MailInfo&& from) noexcept
      : MailInfo(nullptr, std::move(from)) {}
  inline MailInfo& operator=(const MailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailInfo& operator=(MailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailInfo* internal_default_instance() {
    return reinterpret_cast<const MailInfo*>(
        &_MailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(MailInfo& a, MailInfo& b) { a.Swap(&b); }
  inline void Swap(MailInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MailInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MailInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MailInfo& from) { MailInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MailInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.MailInfo"; }

 protected:
  explicit MailInfo(::google::protobuf::Arena* arena);
  MailInfo(::google::protobuf::Arena* arena, const MailInfo& from);
  MailInfo(::google::protobuf::Arena* arena, MailInfo&& from) noexcept
      : MailInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailcontentFieldNumber = 3,
    kSenderFieldNumber = 4,
    kCreateTimeFieldNumber = 5,
    kMailgiftFieldNumber = 6,
    kMailidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string mailcontent = 3;
  bool has_mailcontent() const;
  void clear_mailcontent() ;
  const std::string& mailcontent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mailcontent(Arg_&& arg, Args_... args);
  std::string* mutable_mailcontent();
  PROTOBUF_NODISCARD std::string* release_mailcontent();
  void set_allocated_mailcontent(std::string* value);

  private:
  const std::string& _internal_mailcontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mailcontent(
      const std::string& value);
  std::string* _internal_mutable_mailcontent();

  public:
  // optional string sender = 4;
  bool has_sender() const;
  void clear_sender() ;
  const std::string& sender() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* value);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // optional string createTime = 5;
  bool has_createtime() const;
  void clear_createtime() ;
  const std::string& createtime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_createtime(Arg_&& arg, Args_... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* value);

  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(
      const std::string& value);
  std::string* _internal_mutable_createtime();

  public:
  // optional string mailgift = 6;
  bool has_mailgift() const;
  void clear_mailgift() ;
  const std::string& mailgift() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_mailgift(Arg_&& arg, Args_... args);
  std::string* mutable_mailgift();
  PROTOBUF_NODISCARD std::string* release_mailgift();
  void set_allocated_mailgift(std::string* value);

  private:
  const std::string& _internal_mailgift() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mailgift(
      const std::string& value);
  std::string* _internal_mutable_mailgift();

  public:
  // optional int32 mailid = 2;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMailInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.MailInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr mailcontent_;
    ::google::protobuf::internal::ArenaStringPtr sender_;
    ::google::protobuf::internal::ArenaStringPtr createtime_;
    ::google::protobuf::internal::ArenaStringPtr mailgift_;
    ::int32_t mailid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class LevelInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.LevelInfo) */ {
 public:
  inline LevelInfo() : LevelInfo(nullptr) {}
  ~LevelInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LevelInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline LevelInfo(const LevelInfo& from) : LevelInfo(nullptr, from) {}
  inline LevelInfo(LevelInfo&& from) noexcept
      : LevelInfo(nullptr, std::move(from)) {}
  inline LevelInfo& operator=(const LevelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LevelInfo& operator=(LevelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LevelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LevelInfo* internal_default_instance() {
    return reinterpret_cast<const LevelInfo*>(
        &_LevelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 119;
  friend void swap(LevelInfo& a, LevelInfo& b) { a.Swap(&b); }
  inline void Swap(LevelInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LevelInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LevelInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LevelInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LevelInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LevelInfo& from) { LevelInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LevelInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.LevelInfo"; }

 protected:
  explicit LevelInfo(::google::protobuf::Arena* arena);
  LevelInfo(::google::protobuf::Arena* arena, const LevelInfo& from);
  LevelInfo(::google::protobuf::Arena* arena, LevelInfo&& from) noexcept
      : LevelInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kLevelFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 level = 3;
  bool has_level() const;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroLevelInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.LevelInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t level_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class LeaveBattleSuccess final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.LeaveBattleSuccess) */ {
 public:
  inline LeaveBattleSuccess() : LeaveBattleSuccess(nullptr) {}
  ~LeaveBattleSuccess() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LeaveBattleSuccess(
      ::google::protobuf::internal::ConstantInitialized);

  inline LeaveBattleSuccess(const LeaveBattleSuccess& from) : LeaveBattleSuccess(nullptr, from) {}
  inline LeaveBattleSuccess(LeaveBattleSuccess&& from) noexcept
      : LeaveBattleSuccess(nullptr, std::move(from)) {}
  inline LeaveBattleSuccess& operator=(const LeaveBattleSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeaveBattleSuccess& operator=(LeaveBattleSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeaveBattleSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeaveBattleSuccess* internal_default_instance() {
    return reinterpret_cast<const LeaveBattleSuccess*>(
        &_LeaveBattleSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 141;
  friend void swap(LeaveBattleSuccess& a, LeaveBattleSuccess& b) { a.Swap(&b); }
  inline void Swap(LeaveBattleSuccess* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeaveBattleSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeaveBattleSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LeaveBattleSuccess>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeaveBattleSuccess& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LeaveBattleSuccess& from) { LeaveBattleSuccess::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LeaveBattleSuccess* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.LeaveBattleSuccess"; }

 protected:
  explicit LeaveBattleSuccess(::google::protobuf::Arena* arena);
  LeaveBattleSuccess(::google::protobuf::Arena* arena, const LeaveBattleSuccess& from);
  LeaveBattleSuccess(::google::protobuf::Arena* arena, LeaveBattleSuccess&& from) noexcept
      : LeaveBattleSuccess(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyLeaveBattleSuccess];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.LeaveBattleSuccess)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class LastHitNum final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.LastHitNum) */ {
 public:
  inline LastHitNum() : LastHitNum(nullptr) {}
  ~LastHitNum() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LastHitNum(
      ::google::protobuf::internal::ConstantInitialized);

  inline LastHitNum(const LastHitNum& from) : LastHitNum(nullptr, from) {}
  inline LastHitNum(LastHitNum&& from) noexcept
      : LastHitNum(nullptr, std::move(from)) {}
  inline LastHitNum& operator=(const LastHitNum& from) {
    CopyFrom(from);
    return *this;
  }
  inline LastHitNum& operator=(LastHitNum&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LastHitNum& default_instance() {
    return *internal_default_instance();
  }
  static inline const LastHitNum* internal_default_instance() {
    return reinterpret_cast<const LastHitNum*>(
        &_LastHitNum_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 183;
  friend void swap(LastHitNum& a, LastHitNum& b) { a.Swap(&b); }
  inline void Swap(LastHitNum* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LastHitNum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LastHitNum* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LastHitNum>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LastHitNum& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LastHitNum& from) { LastHitNum::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LastHitNum* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.LastHitNum"; }

 protected:
  explicit LastHitNum(::google::protobuf::Arena* arena);
  LastHitNum(::google::protobuf::Arena* arena, const LastHitNum& from);
  LastHitNum(::google::protobuf::Arena* arena, LastHitNum&& from) noexcept
      : LastHitNum(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kLhnumFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 lhnum = 3;
  bool has_lhnum() const;
  void clear_lhnum() ;
  ::int32_t lhnum() const;
  void set_lhnum(::int32_t value);

  private:
  ::int32_t _internal_lhnum() const;
  void _internal_set_lhnum(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyCurLastHitNum];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.LastHitNum)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t lhnum_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HitTar final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HitTar) */ {
 public:
  inline HitTar() : HitTar(nullptr) {}
  ~HitTar() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HitTar(
      ::google::protobuf::internal::ConstantInitialized);

  inline HitTar(const HitTar& from) : HitTar(nullptr, from) {}
  inline HitTar(HitTar&& from) noexcept
      : HitTar(nullptr, std::move(from)) {}
  inline HitTar& operator=(const HitTar& from) {
    CopyFrom(from);
    return *this;
  }
  inline HitTar& operator=(HitTar&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HitTar& default_instance() {
    return *internal_default_instance();
  }
  static inline const HitTar* internal_default_instance() {
    return reinterpret_cast<const HitTar*>(
        &_HitTar_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 149;
  friend void swap(HitTar& a, HitTar& b) { a.Swap(&b); }
  inline void Swap(HitTar* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HitTar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HitTar* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HitTar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HitTar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HitTar& from) { HitTar::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HitTar* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HitTar"; }

 protected:
  explicit HitTar(::google::protobuf::Arena* arena);
  HitTar(::google::protobuf::Arena* arena, const HitTar& from);
  HitTar(::google::protobuf::Arena* arena, HitTar&& from) noexcept
      : HitTar(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kTarguidFieldNumber = 4,
    kEffectidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint64 targuid = 4;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional uint32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::uint32_t effectid() const;
  void set_effectid(::uint32_t value);

  private:
  ::uint32_t _internal_effectid() const;
  void _internal_set_effectid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelHitTarget];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HitTar)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint64_t targuid_;
    ::uint32_t effectid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HeroPosInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HeroPosInfo) */ {
 public:
  inline HeroPosInfo() : HeroPosInfo(nullptr) {}
  ~HeroPosInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroPosInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroPosInfo(const HeroPosInfo& from) : HeroPosInfo(nullptr, from) {}
  inline HeroPosInfo(HeroPosInfo&& from) noexcept
      : HeroPosInfo(nullptr, std::move(from)) {}
  inline HeroPosInfo& operator=(const HeroPosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroPosInfo& operator=(HeroPosInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroPosInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroPosInfo* internal_default_instance() {
    return reinterpret_cast<const HeroPosInfo*>(
        &_HeroPosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 101;
  friend void swap(HeroPosInfo& a, HeroPosInfo& b) { a.Swap(&b); }
  inline void Swap(HeroPosInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroPosInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroPosInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroPosInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroPosInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroPosInfo& from) { HeroPosInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroPosInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HeroPosInfo"; }

 protected:
  explicit HeroPosInfo(::google::protobuf::Arena* arena);
  HeroPosInfo(::google::protobuf::Arena* arena, const HeroPosInfo& from);
  HeroPosInfo(::google::protobuf::Arena* arena, HeroPosInfo&& from) noexcept
      : HeroPosInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 2,
    kHeroidFieldNumber = 3,
  };
  // optional int32 pos = 2;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional int32 heroid = 3;
  bool has_heroid() const;
  void clear_heroid() ;
  ::int32_t heroid() const;
  void set_heroid(::int32_t value);

  private:
  ::int32_t _internal_heroid() const;
  void _internal_set_heroid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HeroPosInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t pos_;
    ::int32_t heroid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HeroList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HeroList) */ {
 public:
  inline HeroList() : HeroList(nullptr) {}
  ~HeroList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroList(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroList(const HeroList& from) : HeroList(nullptr, from) {}
  inline HeroList(HeroList&& from) noexcept
      : HeroList(nullptr, std::move(from)) {}
  inline HeroList& operator=(const HeroList& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroList& operator=(HeroList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroList& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroList* internal_default_instance() {
    return reinterpret_cast<const HeroList*>(
        &_HeroList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 79;
  friend void swap(HeroList& a, HeroList& b) { a.Swap(&b); }
  inline void Swap(HeroList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroList& from) { HeroList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HeroList"; }

 protected:
  explicit HeroList(::google::protobuf::Arena* arena);
  HeroList(::google::protobuf::Arena* arena, const HeroList& from);
  HeroList(::google::protobuf::Arena* arena, HeroList&& from) noexcept
      : HeroList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeroidFieldNumber = 2,
    kTimeDiffFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // repeated uint32 heroid = 2;
  int heroid_size() const;
  private:
  int _internal_heroid_size() const;

  public:
  void clear_heroid() ;
  ::uint32_t heroid(int index) const;
  void set_heroid(int index, ::uint32_t value);
  void add_heroid(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& heroid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_heroid();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_heroid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_heroid();

  public:
  // optional int64 timeDiff = 3;
  bool has_timediff() const;
  void clear_timediff() ;
  ::int64_t timediff() const;
  void set_timediff(::int64_t value);

  private:
  ::int64_t _internal_timediff() const;
  void _internal_set_timediff(::int64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroList];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HeroList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> heroid_;
    ::int64_t timediff_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HeroKills final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HeroKills) */ {
 public:
  inline HeroKills() : HeroKills(nullptr) {}
  ~HeroKills() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroKills(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroKills(const HeroKills& from) : HeroKills(nullptr, from) {}
  inline HeroKills(HeroKills&& from) noexcept
      : HeroKills(nullptr, std::move(from)) {}
  inline HeroKills& operator=(const HeroKills& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroKills& operator=(HeroKills&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroKills& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroKills* internal_default_instance() {
    return reinterpret_cast<const HeroKills*>(
        &_HeroKills_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 124;
  friend void swap(HeroKills& a, HeroKills& b) { a.Swap(&b); }
  inline void Swap(HeroKills* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroKills* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroKills* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroKills>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroKills& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroKills& from) { HeroKills::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroKills* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HeroKills"; }

 protected:
  explicit HeroKills(::google::protobuf::Arena* arena);
  HeroKills(::google::protobuf::Arena* arena, const HeroKills& from);
  HeroKills(::google::protobuf::Arena* arena, HeroKills&& from) noexcept
      : HeroKills(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kKillsFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 kills = 3;
  bool has_kills() const;
  void clear_kills() ;
  ::int32_t kills() const;
  void set_kills(::int32_t value);

  private:
  ::int32_t _internal_kills() const;
  void _internal_set_kills(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroKills];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HeroKills)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t kills_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HeroAttributes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HeroAttributes) */ {
 public:
  inline HeroAttributes() : HeroAttributes(nullptr) {}
  ~HeroAttributes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroAttributes(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroAttributes(const HeroAttributes& from) : HeroAttributes(nullptr, from) {}
  inline HeroAttributes(HeroAttributes&& from) noexcept
      : HeroAttributes(nullptr, std::move(from)) {}
  inline HeroAttributes& operator=(const HeroAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroAttributes& operator=(HeroAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroAttributes* internal_default_instance() {
    return reinterpret_cast<const HeroAttributes*>(
        &_HeroAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 41;
  friend void swap(HeroAttributes& a, HeroAttributes& b) { a.Swap(&b); }
  inline void Swap(HeroAttributes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroAttributes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroAttributes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroAttributes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroAttributes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroAttributes& from) { HeroAttributes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroAttributes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HeroAttributes"; }

 protected:
  explicit HeroAttributes(::google::protobuf::Arena* arena);
  HeroAttributes(::google::protobuf::Arena* arena, const HeroAttributes& from);
  HeroAttributes(::google::protobuf::Arena* arena, HeroAttributes&& from) noexcept
      : HeroAttributes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kPlayerSpeedFieldNumber = 3,
    kAttackIntervalFieldNumber = 4,
    kAttackRangeFieldNumber = 5,
    kResurgenceTimeFieldNumber = 6,
    kPhysicAttackFieldNumber = 7,
    kSpellsAttackFieldNumber = 8,
    kPhysicDefFieldNumber = 9,
    kSpellsDefFieldNumber = 10,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 PlayerSpeed = 3;
  bool has_playerspeed() const;
  void clear_playerspeed() ;
  ::int32_t playerspeed() const;
  void set_playerspeed(::int32_t value);

  private:
  ::int32_t _internal_playerspeed() const;
  void _internal_set_playerspeed(::int32_t value);

  public:
  // optional int32 AttackInterval = 4;
  bool has_attackinterval() const;
  void clear_attackinterval() ;
  ::int32_t attackinterval() const;
  void set_attackinterval(::int32_t value);

  private:
  ::int32_t _internal_attackinterval() const;
  void _internal_set_attackinterval(::int32_t value);

  public:
  // optional int32 AttackRange = 5;
  bool has_attackrange() const;
  void clear_attackrange() ;
  ::int32_t attackrange() const;
  void set_attackrange(::int32_t value);

  private:
  ::int32_t _internal_attackrange() const;
  void _internal_set_attackrange(::int32_t value);

  public:
  // optional int32 ResurgenceTime = 6;
  bool has_resurgencetime() const;
  void clear_resurgencetime() ;
  ::int32_t resurgencetime() const;
  void set_resurgencetime(::int32_t value);

  private:
  ::int32_t _internal_resurgencetime() const;
  void _internal_set_resurgencetime(::int32_t value);

  public:
  // optional int32 PhysicAttack = 7;
  bool has_physicattack() const;
  void clear_physicattack() ;
  ::int32_t physicattack() const;
  void set_physicattack(::int32_t value);

  private:
  ::int32_t _internal_physicattack() const;
  void _internal_set_physicattack(::int32_t value);

  public:
  // optional int32 SpellsAttack = 8;
  bool has_spellsattack() const;
  void clear_spellsattack() ;
  ::int32_t spellsattack() const;
  void set_spellsattack(::int32_t value);

  private:
  ::int32_t _internal_spellsattack() const;
  void _internal_set_spellsattack(::int32_t value);

  public:
  // optional int32 PhysicDef = 9;
  bool has_physicdef() const;
  void clear_physicdef() ;
  ::int32_t physicdef() const;
  void set_physicdef(::int32_t value);

  private:
  ::int32_t _internal_physicdef() const;
  void _internal_set_physicdef(::int32_t value);

  public:
  // optional int32 SpellsDef = 10;
  bool has_spellsdef() const;
  void clear_spellsdef() ;
  ::int32_t spellsdef() const;
  void set_spellsdef(::int32_t value);

  private:
  ::int32_t _internal_spellsdef() const;
  void _internal_set_spellsdef(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroAttributes];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HeroAttributes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t playerspeed_;
    ::int32_t attackinterval_;
    ::int32_t attackrange_;
    ::int32_t resurgencetime_;
    ::int32_t physicattack_;
    ::int32_t spellsattack_;
    ::int32_t physicdef_;
    ::int32_t spellsdef_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HeroAssist final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HeroAssist) */ {
 public:
  inline HeroAssist() : HeroAssist(nullptr) {}
  ~HeroAssist() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroAssist(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroAssist(const HeroAssist& from) : HeroAssist(nullptr, from) {}
  inline HeroAssist(HeroAssist&& from) noexcept
      : HeroAssist(nullptr, std::move(from)) {}
  inline HeroAssist& operator=(const HeroAssist& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroAssist& operator=(HeroAssist&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroAssist& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroAssist* internal_default_instance() {
    return reinterpret_cast<const HeroAssist*>(
        &_HeroAssist_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 42;
  friend void swap(HeroAssist& a, HeroAssist& b) { a.Swap(&b); }
  inline void Swap(HeroAssist* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroAssist* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroAssist* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroAssist>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroAssist& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroAssist& from) { HeroAssist::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroAssist* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HeroAssist"; }

 protected:
  explicit HeroAssist(::google::protobuf::Arena* arena);
  HeroAssist(::google::protobuf::Arena* arena, const HeroAssist& from);
  HeroAssist(::google::protobuf::Arena* arena, HeroAssist&& from) noexcept
      : HeroAssist(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kAssistFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 assist = 3;
  bool has_assist() const;
  void clear_assist() ;
  ::int32_t assist() const;
  void set_assist(::int32_t value);

  private:
  ::int32_t _internal_assist() const;
  void _internal_set_assist(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroAssist];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HeroAssist)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t assist_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HPChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HPChange) */ {
 public:
  inline HPChange() : HPChange(nullptr) {}
  ~HPChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HPChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline HPChange(const HPChange& from) : HPChange(nullptr, from) {}
  inline HPChange(HPChange&& from) noexcept
      : HPChange(nullptr, std::move(from)) {}
  inline HPChange& operator=(const HPChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline HPChange& operator=(HPChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HPChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const HPChange* internal_default_instance() {
    return reinterpret_cast<const HPChange*>(
        &_HPChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 105;
  friend void swap(HPChange& a, HPChange& b) { a.Swap(&b); }
  inline void Swap(HPChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HPChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HPChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HPChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HPChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HPChange& from) { HPChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HPChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HPChange"; }

 protected:
  explicit HPChange(::google::protobuf::Arena* arena);
  HPChange(::google::protobuf::Arena* arena, const HPChange& from);
  HPChange(::google::protobuf::Arena* arena, HPChange&& from) noexcept
      : HPChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kHpFieldNumber = 3,
    kReasonFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 hp = 3;
  bool has_hp() const;
  void clear_hp() ;
  ::int32_t hp() const;
  void set_hp(::int32_t value);

  private:
  ::int32_t _internal_hp() const;
  void _internal_set_hp(::int32_t value);

  public:
  // optional .GSToGC.HPMPChangeReason reason = 4;
  bool has_reason() const;
  void clear_reason() ;
  ::GSToGC::HPMPChangeReason reason() const;
  void set_reason(::GSToGC::HPMPChangeReason value);

  private:
  ::GSToGC::HPMPChangeReason _internal_reason() const;
  void _internal_set_reason(::GSToGC::HPMPChangeReason value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHPChange];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HPChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t hp_;
    int reason_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GuideSteps final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GuideSteps) */ {
 public:
  inline GuideSteps() : GuideSteps(nullptr) {}
  ~GuideSteps() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideSteps(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideSteps(const GuideSteps& from) : GuideSteps(nullptr, from) {}
  inline GuideSteps(GuideSteps&& from) noexcept
      : GuideSteps(nullptr, std::move(from)) {}
  inline GuideSteps& operator=(const GuideSteps& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideSteps& operator=(GuideSteps&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideSteps& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideSteps* internal_default_instance() {
    return reinterpret_cast<const GuideSteps*>(
        &_GuideSteps_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 58;
  friend void swap(GuideSteps& a, GuideSteps& b) { a.Swap(&b); }
  inline void Swap(GuideSteps* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideSteps* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideSteps* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideSteps>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideSteps& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideSteps& from) { GuideSteps::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideSteps* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GuideSteps"; }

 protected:
  explicit GuideSteps(::google::protobuf::Arena* arena);
  GuideSteps(::google::protobuf::Arena* arena, const GuideSteps& from);
  GuideSteps(::google::protobuf::Arena* arena, GuideSteps&& from) noexcept
      : GuideSteps(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStepsFieldNumber = 5,
    kGuidFieldNumber = 2,
    kTypeFieldNumber = 3,
    kIfCompFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional string steps = 5;
  bool has_steps() const;
  void clear_steps() ;
  const std::string& steps() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_steps(Arg_&& arg, Args_... args);
  std::string* mutable_steps();
  PROTOBUF_NODISCARD std::string* release_steps();
  void set_allocated_steps(std::string* value);

  private:
  const std::string& _internal_steps() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_steps(
      const std::string& value);
  std::string* _internal_mutable_steps();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 type = 3;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional bool ifComp = 4;
  bool has_ifcomp() const;
  void clear_ifcomp() ;
  bool ifcomp() const;
  void set_ifcomp(bool value);

  private:
  bool _internal_ifcomp() const;
  void _internal_set_ifcomp(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserGuideSetups];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GuideSteps)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      31, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr steps_;
    ::uint64_t guid_;
    ::int32_t type_;
    bool ifcomp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GuideLastStep final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GuideLastStep) */ {
 public:
  inline GuideLastStep() : GuideLastStep(nullptr) {}
  ~GuideLastStep() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideLastStep(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideLastStep(const GuideLastStep& from) : GuideLastStep(nullptr, from) {}
  inline GuideLastStep(GuideLastStep&& from) noexcept
      : GuideLastStep(nullptr, std::move(from)) {}
  inline GuideLastStep& operator=(const GuideLastStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideLastStep& operator=(GuideLastStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideLastStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideLastStep* internal_default_instance() {
    return reinterpret_cast<const GuideLastStep*>(
        &_GuideLastStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 54;
  friend void swap(GuideLastStep& a, GuideLastStep& b) { a.Swap(&b); }
  inline void Swap(GuideLastStep* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideLastStep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideLastStep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideLastStep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideLastStep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideLastStep& from) { GuideLastStep::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideLastStep* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GuideLastStep"; }

 protected:
  explicit GuideLastStep(::google::protobuf::Arena* arena);
  GuideLastStep(::google::protobuf::Arena* arena, const GuideLastStep& from);
  GuideLastStep(::google::protobuf::Arena* arena, GuideLastStep&& from) noexcept
      : GuideLastStep(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIfCompFieldNumber = 2,
    kStepidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional bool ifComp = 2;
  bool has_ifcomp() const;
  void clear_ifcomp() ;
  bool ifcomp() const;
  void set_ifcomp(bool value);

  private:
  bool _internal_ifcomp() const;
  void _internal_set_ifcomp(bool value);

  public:
  // optional int32 stepid = 3;
  bool has_stepid() const;
  void clear_stepid() ;
  ::int32_t stepid() const;
  void set_stepid(::int32_t value);

  private:
  ::int32_t _internal_stepid() const;
  void _internal_set_stepid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_NotifyGuideLastComStep];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GuideLastStep)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    bool ifcomp_;
    ::int32_t stepid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GuideKillsInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GuideKillsInfo) */ {
 public:
  inline GuideKillsInfo() : GuideKillsInfo(nullptr) {}
  ~GuideKillsInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideKillsInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideKillsInfo(const GuideKillsInfo& from) : GuideKillsInfo(nullptr, from) {}
  inline GuideKillsInfo(GuideKillsInfo&& from) noexcept
      : GuideKillsInfo(nullptr, std::move(from)) {}
  inline GuideKillsInfo& operator=(const GuideKillsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideKillsInfo& operator=(GuideKillsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideKillsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideKillsInfo* internal_default_instance() {
    return reinterpret_cast<const GuideKillsInfo*>(
        &_GuideKillsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(GuideKillsInfo& a, GuideKillsInfo& b) { a.Swap(&b); }
  inline void Swap(GuideKillsInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideKillsInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideKillsInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideKillsInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideKillsInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideKillsInfo& from) { GuideKillsInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideKillsInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GuideKillsInfo"; }

 protected:
  explicit GuideKillsInfo(::google::protobuf::Arena* arena);
  GuideKillsInfo(::google::protobuf::Arena* arena, const GuideKillsInfo& from);
  GuideKillsInfo(::google::protobuf::Arena* arena, GuideKillsInfo&& from) noexcept
      : GuideKillsInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kNpctypeFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 npctype = 3;
  bool has_npctype() const;
  void clear_npctype() ;
  ::int32_t npctype() const;
  void set_npctype(::int32_t value);

  private:
  ::int32_t _internal_npctype() const;
  void _internal_set_npctype(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_GuideKillsInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GuideKillsInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t npctype_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GuideCSStepInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GuideCSStepInfo) */ {
 public:
  inline GuideCSStepInfo() : GuideCSStepInfo(nullptr) {}
  ~GuideCSStepInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideCSStepInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideCSStepInfo(const GuideCSStepInfo& from) : GuideCSStepInfo(nullptr, from) {}
  inline GuideCSStepInfo(GuideCSStepInfo&& from) noexcept
      : GuideCSStepInfo(nullptr, std::move(from)) {}
  inline GuideCSStepInfo& operator=(const GuideCSStepInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideCSStepInfo& operator=(GuideCSStepInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideCSStepInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideCSStepInfo* internal_default_instance() {
    return reinterpret_cast<const GuideCSStepInfo*>(
        &_GuideCSStepInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(GuideCSStepInfo& a, GuideCSStepInfo& b) { a.Swap(&b); }
  inline void Swap(GuideCSStepInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideCSStepInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideCSStepInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideCSStepInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideCSStepInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideCSStepInfo& from) { GuideCSStepInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideCSStepInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GuideCSStepInfo"; }

 protected:
  explicit GuideCSStepInfo(::google::protobuf::Arena* arena);
  GuideCSStepInfo(::google::protobuf::Arena* arena, const GuideCSStepInfo& from);
  GuideCSStepInfo(::google::protobuf::Arena* arena, GuideCSStepInfo&& from) noexcept
      : GuideCSStepInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskidFieldNumber = 3,
    kAllcompFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated uint32 taskid = 3;
  int taskid_size() const;
  private:
  int _internal_taskid_size() const;

  public:
  void clear_taskid() ;
  ::uint32_t taskid(int index) const;
  void set_taskid(int index, ::uint32_t value);
  void add_taskid(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& taskid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_taskid();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_taskid() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_taskid();

  public:
  // optional bool allcomp = 2;
  bool has_allcomp() const;
  void clear_allcomp() ;
  bool allcomp() const;
  void set_allcomp(bool value);

  private:
  bool _internal_allcomp() const;
  void _internal_set_allcomp(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GuideResp];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GuideCSStepInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint32_t> taskid_;
    bool allcomp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GuideAward_awardtype final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GuideAward.awardtype) */ {
 public:
  inline GuideAward_awardtype() : GuideAward_awardtype(nullptr) {}
  ~GuideAward_awardtype() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideAward_awardtype(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideAward_awardtype(const GuideAward_awardtype& from) : GuideAward_awardtype(nullptr, from) {}
  inline GuideAward_awardtype(GuideAward_awardtype&& from) noexcept
      : GuideAward_awardtype(nullptr, std::move(from)) {}
  inline GuideAward_awardtype& operator=(const GuideAward_awardtype& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideAward_awardtype& operator=(GuideAward_awardtype&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideAward_awardtype& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideAward_awardtype* internal_default_instance() {
    return reinterpret_cast<const GuideAward_awardtype*>(
        &_GuideAward_awardtype_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(GuideAward_awardtype& a, GuideAward_awardtype& b) { a.Swap(&b); }
  inline void Swap(GuideAward_awardtype* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideAward_awardtype* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideAward_awardtype* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideAward_awardtype>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideAward_awardtype& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideAward_awardtype& from) { GuideAward_awardtype::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideAward_awardtype* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GuideAward.awardtype"; }

 protected:
  explicit GuideAward_awardtype(::google::protobuf::Arena* arena);
  GuideAward_awardtype(::google::protobuf::Arena* arena, const GuideAward_awardtype& from);
  GuideAward_awardtype(::google::protobuf::Arena* arena, GuideAward_awardtype&& from) noexcept
      : GuideAward_awardtype(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdxnFieldNumber = 2,
    kDtFieldNumber = 1,
  };
  // optional uint32 idxn = 2;
  bool has_idxn() const;
  void clear_idxn() ;
  ::uint32_t idxn() const;
  void set_idxn(::uint32_t value);

  private:
  ::uint32_t _internal_idxn() const;
  void _internal_set_idxn(::uint32_t value);

  public:
  // optional .GSToGC.GuideAward.dtype dt = 1;
  bool has_dt() const;
  void clear_dt() ;
  ::GSToGC::GuideAward_dtype dt() const;
  void set_dt(::GSToGC::GuideAward_dtype value);

  private:
  ::GSToGC::GuideAward_dtype _internal_dt() const;
  void _internal_set_dt(::GSToGC::GuideAward_dtype value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GuideAward.awardtype)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t idxn_;
    int dt_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GoodsCfgInfo_Consume final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GoodsCfgInfo.Consume) */ {
 public:
  inline GoodsCfgInfo_Consume() : GoodsCfgInfo_Consume(nullptr) {}
  ~GoodsCfgInfo_Consume() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoodsCfgInfo_Consume(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoodsCfgInfo_Consume(const GoodsCfgInfo_Consume& from) : GoodsCfgInfo_Consume(nullptr, from) {}
  inline GoodsCfgInfo_Consume(GoodsCfgInfo_Consume&& from) noexcept
      : GoodsCfgInfo_Consume(nullptr, std::move(from)) {}
  inline GoodsCfgInfo_Consume& operator=(const GoodsCfgInfo_Consume& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoodsCfgInfo_Consume& operator=(GoodsCfgInfo_Consume&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoodsCfgInfo_Consume& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoodsCfgInfo_Consume* internal_default_instance() {
    return reinterpret_cast<const GoodsCfgInfo_Consume*>(
        &_GoodsCfgInfo_Consume_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 38;
  friend void swap(GoodsCfgInfo_Consume& a, GoodsCfgInfo_Consume& b) { a.Swap(&b); }
  inline void Swap(GoodsCfgInfo_Consume* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoodsCfgInfo_Consume* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoodsCfgInfo_Consume* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GoodsCfgInfo_Consume>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoodsCfgInfo_Consume& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoodsCfgInfo_Consume& from) { GoodsCfgInfo_Consume::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GoodsCfgInfo_Consume* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GoodsCfgInfo.Consume"; }

 protected:
  explicit GoodsCfgInfo_Consume(::google::protobuf::Arena* arena);
  GoodsCfgInfo_Consume(::google::protobuf::Arena* arena, const GoodsCfgInfo_Consume& from);
  GoodsCfgInfo_Consume(::google::protobuf::Arena* arena, GoodsCfgInfo_Consume&& from) noexcept
      : GoodsCfgInfo_Consume(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kConsumetypeFieldNumber = 1,
    kPriceFieldNumber = 2,
  };
  // optional int32 consumetype = 1;
  bool has_consumetype() const;
  void clear_consumetype() ;
  ::int32_t consumetype() const;
  void set_consumetype(::int32_t value);

  private:
  ::int32_t _internal_consumetype() const;
  void _internal_set_consumetype(::int32_t value);

  public:
  // optional int32 price = 2;
  bool has_price() const;
  void clear_price() ;
  ::int32_t price() const;
  void set_price(::int32_t value);

  private:
  ::int32_t _internal_price() const;
  void _internal_set_price(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GoodsCfgInfo.Consume)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t consumetype_;
    ::int32_t price_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GetloginReward_Skin final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GetloginReward_Skin) */ {
 public:
  inline GetloginReward_Skin() : GetloginReward_Skin(nullptr) {}
  ~GetloginReward_Skin() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetloginReward_Skin(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetloginReward_Skin(const GetloginReward_Skin& from) : GetloginReward_Skin(nullptr, from) {}
  inline GetloginReward_Skin(GetloginReward_Skin&& from) noexcept
      : GetloginReward_Skin(nullptr, std::move(from)) {}
  inline GetloginReward_Skin& operator=(const GetloginReward_Skin& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetloginReward_Skin& operator=(GetloginReward_Skin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetloginReward_Skin& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetloginReward_Skin* internal_default_instance() {
    return reinterpret_cast<const GetloginReward_Skin*>(
        &_GetloginReward_Skin_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 178;
  friend void swap(GetloginReward_Skin& a, GetloginReward_Skin& b) { a.Swap(&b); }
  inline void Swap(GetloginReward_Skin* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetloginReward_Skin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetloginReward_Skin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetloginReward_Skin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetloginReward_Skin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetloginReward_Skin& from) { GetloginReward_Skin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetloginReward_Skin* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GetloginReward_Skin"; }

 protected:
  explicit GetloginReward_Skin(::google::protobuf::Arena* arena);
  GetloginReward_Skin(::google::protobuf::Arena* arena, const GetloginReward_Skin& from);
  GetloginReward_Skin(::google::protobuf::Arena* arena, GetloginReward_Skin&& from) noexcept
      : GetloginReward_Skin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSkinidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int64 skinid = 2;
  bool has_skinid() const;
  void clear_skinid() ;
  ::int64_t skinid() const;
  void set_skinid(::int64_t value);

  private:
  ::int64_t _internal_skinid() const;
  void _internal_set_skinid(::int64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginReward_Skin];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GetloginReward_Skin)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t skinid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GetloginReward_Rune final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GetloginReward_Rune) */ {
 public:
  inline GetloginReward_Rune() : GetloginReward_Rune(nullptr) {}
  ~GetloginReward_Rune() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetloginReward_Rune(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetloginReward_Rune(const GetloginReward_Rune& from) : GetloginReward_Rune(nullptr, from) {}
  inline GetloginReward_Rune(GetloginReward_Rune&& from) noexcept
      : GetloginReward_Rune(nullptr, std::move(from)) {}
  inline GetloginReward_Rune& operator=(const GetloginReward_Rune& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetloginReward_Rune& operator=(GetloginReward_Rune&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetloginReward_Rune& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetloginReward_Rune* internal_default_instance() {
    return reinterpret_cast<const GetloginReward_Rune*>(
        &_GetloginReward_Rune_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 179;
  friend void swap(GetloginReward_Rune& a, GetloginReward_Rune& b) { a.Swap(&b); }
  inline void Swap(GetloginReward_Rune* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetloginReward_Rune* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetloginReward_Rune* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetloginReward_Rune>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetloginReward_Rune& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetloginReward_Rune& from) { GetloginReward_Rune::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetloginReward_Rune* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GetloginReward_Rune"; }

 protected:
  explicit GetloginReward_Rune(::google::protobuf::Arena* arena);
  GetloginReward_Rune(::google::protobuf::Arena* arena, const GetloginReward_Rune& from);
  GetloginReward_Rune(::google::protobuf::Arena* arena, GetloginReward_Rune&& from) noexcept
      : GetloginReward_Rune(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRuneidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int64 runeid = 2;
  bool has_runeid() const;
  void clear_runeid() ;
  ::int64_t runeid() const;
  void set_runeid(::int64_t value);

  private:
  ::int64_t _internal_runeid() const;
  void _internal_set_runeid(::int64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginReward_Rune];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GetloginReward_Rune)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t runeid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GetloginReward_Hero final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GetloginReward_Hero) */ {
 public:
  inline GetloginReward_Hero() : GetloginReward_Hero(nullptr) {}
  ~GetloginReward_Hero() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetloginReward_Hero(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetloginReward_Hero(const GetloginReward_Hero& from) : GetloginReward_Hero(nullptr, from) {}
  inline GetloginReward_Hero(GetloginReward_Hero&& from) noexcept
      : GetloginReward_Hero(nullptr, std::move(from)) {}
  inline GetloginReward_Hero& operator=(const GetloginReward_Hero& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetloginReward_Hero& operator=(GetloginReward_Hero&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetloginReward_Hero& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetloginReward_Hero* internal_default_instance() {
    return reinterpret_cast<const GetloginReward_Hero*>(
        &_GetloginReward_Hero_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 180;
  friend void swap(GetloginReward_Hero& a, GetloginReward_Hero& b) { a.Swap(&b); }
  inline void Swap(GetloginReward_Hero* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetloginReward_Hero* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetloginReward_Hero* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetloginReward_Hero>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetloginReward_Hero& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetloginReward_Hero& from) { GetloginReward_Hero::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetloginReward_Hero* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GetloginReward_Hero"; }

 protected:
  explicit GetloginReward_Hero(::google::protobuf::Arena* arena);
  GetloginReward_Hero(::google::protobuf::Arena* arena, const GetloginReward_Hero& from);
  GetloginReward_Hero(::google::protobuf::Arena* arena, GetloginReward_Hero&& from) noexcept
      : GetloginReward_Hero(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kExpiredTimeFieldNumber = 3,
    kHeroidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int64 expired_time = 3;
  bool has_expired_time() const;
  void clear_expired_time() ;
  ::int64_t expired_time() const;
  void set_expired_time(::int64_t value);

  private:
  ::int64_t _internal_expired_time() const;
  void _internal_set_expired_time(::int64_t value);

  public:
  // optional uint32 heroid = 2;
  bool has_heroid() const;
  void clear_heroid() ;
  ::uint32_t heroid() const;
  void set_heroid(::uint32_t value);

  private:
  ::uint32_t _internal_heroid() const;
  void _internal_set_heroid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginReward_Hero];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GetloginReward_Hero)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t expired_time_;
    ::uint32_t heroid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GetloginRewardSuccess final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GetloginRewardSuccess) */ {
 public:
  inline GetloginRewardSuccess() : GetloginRewardSuccess(nullptr) {}
  ~GetloginRewardSuccess() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetloginRewardSuccess(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetloginRewardSuccess(const GetloginRewardSuccess& from) : GetloginRewardSuccess(nullptr, from) {}
  inline GetloginRewardSuccess(GetloginRewardSuccess&& from) noexcept
      : GetloginRewardSuccess(nullptr, std::move(from)) {}
  inline GetloginRewardSuccess& operator=(const GetloginRewardSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetloginRewardSuccess& operator=(GetloginRewardSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetloginRewardSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetloginRewardSuccess* internal_default_instance() {
    return reinterpret_cast<const GetloginRewardSuccess*>(
        &_GetloginRewardSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 177;
  friend void swap(GetloginRewardSuccess& a, GetloginRewardSuccess& b) { a.Swap(&b); }
  inline void Swap(GetloginRewardSuccess* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetloginRewardSuccess* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetloginRewardSuccess* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GetloginRewardSuccess>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetloginRewardSuccess& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetloginRewardSuccess& from) { GetloginRewardSuccess::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GetloginRewardSuccess* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GetloginRewardSuccess"; }

 protected:
  explicit GetloginRewardSuccess(::google::protobuf::Arena* arena);
  GetloginRewardSuccess(::google::protobuf::Arena* arena, const GetloginRewardSuccess& from);
  GetloginRewardSuccess(::google::protobuf::Arena* arena, GetloginRewardSuccess&& from) noexcept
      : GetloginRewardSuccess(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginRewardSuccess];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GetloginRewardSuccess)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GameTips final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GameTips) */ {
 public:
  inline GameTips() : GameTips(nullptr) {}
  ~GameTips() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameTips(
      ::google::protobuf::internal::ConstantInitialized);

  inline GameTips(const GameTips& from) : GameTips(nullptr, from) {}
  inline GameTips(GameTips&& from) noexcept
      : GameTips(nullptr, std::move(from)) {}
  inline GameTips& operator=(const GameTips& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameTips& operator=(GameTips&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameTips& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameTips* internal_default_instance() {
    return reinterpret_cast<const GameTips*>(
        &_GameTips_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 49;
  friend void swap(GameTips& a, GameTips& b) { a.Swap(&b); }
  inline void Swap(GameTips* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameTips* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameTips* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GameTips>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameTips& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GameTips& from) { GameTips::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameTips* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GameTips"; }

 protected:
  explicit GameTips(::google::protobuf::Arena* arena);
  GameTips(::google::protobuf::Arena* arena, const GameTips& from);
  GameTips(::google::protobuf::Arena* arena, GameTips&& from) noexcept
      : GameTips(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kErrocodeFieldNumber = 2,
    kCampidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int32 errocode = 2;
  bool has_errocode() const;
  void clear_errocode() ;
  ::int32_t errocode() const;
  void set_errocode(::int32_t value);

  private:
  ::int32_t _internal_errocode() const;
  void _internal_set_errocode(::int32_t value);

  public:
  // optional int32 campid = 3;
  bool has_campid() const;
  void clear_campid() ;
  ::int32_t campid() const;
  void set_campid(::int32_t value);

  private:
  ::int32_t _internal_campid() const;
  void _internal_set_campid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGuideTips];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GameTips)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t errocode_;
    ::int32_t campid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GameNotice_Notice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GameNotice.Notice) */ {
 public:
  inline GameNotice_Notice() : GameNotice_Notice(nullptr) {}
  ~GameNotice_Notice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameNotice_Notice(
      ::google::protobuf::internal::ConstantInitialized);

  inline GameNotice_Notice(const GameNotice_Notice& from) : GameNotice_Notice(nullptr, from) {}
  inline GameNotice_Notice(GameNotice_Notice&& from) noexcept
      : GameNotice_Notice(nullptr, std::move(from)) {}
  inline GameNotice_Notice& operator=(const GameNotice_Notice& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameNotice_Notice& operator=(GameNotice_Notice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameNotice_Notice& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameNotice_Notice* internal_default_instance() {
    return reinterpret_cast<const GameNotice_Notice*>(
        &_GameNotice_Notice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 56;
  friend void swap(GameNotice_Notice& a, GameNotice_Notice& b) { a.Swap(&b); }
  inline void Swap(GameNotice_Notice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameNotice_Notice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameNotice_Notice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GameNotice_Notice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameNotice_Notice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GameNotice_Notice& from) { GameNotice_Notice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameNotice_Notice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GameNotice.Notice"; }

 protected:
  explicit GameNotice_Notice(::google::protobuf::Arena* arena);
  GameNotice_Notice(::google::protobuf::Arena* arena, const GameNotice_Notice& from);
  GameNotice_Notice(::google::protobuf::Arena* arena, GameNotice_Notice&& from) noexcept
      : GameNotice_Notice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTitleFieldNumber = 1,
    kNoticeFieldNumber = 5,
    kFlagFieldNumber = 2,
    kStatusFieldNumber = 3,
    kPriorityFieldNumber = 4,
  };
  // optional string title = 1;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string notice = 5;
  bool has_notice() const;
  void clear_notice() ;
  const std::string& notice() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_notice(Arg_&& arg, Args_... args);
  std::string* mutable_notice();
  PROTOBUF_NODISCARD std::string* release_notice();
  void set_allocated_notice(std::string* value);

  private:
  const std::string& _internal_notice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notice(
      const std::string& value);
  std::string* _internal_mutable_notice();

  public:
  // optional uint32 flag = 2;
  bool has_flag() const;
  void clear_flag() ;
  ::uint32_t flag() const;
  void set_flag(::uint32_t value);

  private:
  ::uint32_t _internal_flag() const;
  void _internal_set_flag(::uint32_t value);

  public:
  // optional uint32 status = 3;
  bool has_status() const;
  void clear_status() ;
  ::uint32_t status() const;
  void set_status(::uint32_t value);

  private:
  ::uint32_t _internal_status() const;
  void _internal_set_status(::uint32_t value);

  public:
  // optional uint32 priority = 4;
  bool has_priority() const;
  void clear_priority() ;
  ::uint32_t priority() const;
  void set_priority(::uint32_t value);

  private:
  ::uint32_t _internal_priority() const;
  void _internal_set_priority(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GameNotice.Notice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      44, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr notice_;
    ::uint32_t flag_;
    ::uint32_t status_;
    ::uint32_t priority_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GOSkillCD final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GOSkillCD) */ {
 public:
  inline GOSkillCD() : GOSkillCD(nullptr) {}
  ~GOSkillCD() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GOSkillCD(
      ::google::protobuf::internal::ConstantInitialized);

  inline GOSkillCD(const GOSkillCD& from) : GOSkillCD(nullptr, from) {}
  inline GOSkillCD(GOSkillCD&& from) noexcept
      : GOSkillCD(nullptr, std::move(from)) {}
  inline GOSkillCD& operator=(const GOSkillCD& from) {
    CopyFrom(from);
    return *this;
  }
  inline GOSkillCD& operator=(GOSkillCD&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GOSkillCD& default_instance() {
    return *internal_default_instance();
  }
  static inline const GOSkillCD* internal_default_instance() {
    return reinterpret_cast<const GOSkillCD*>(
        &_GOSkillCD_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 146;
  friend void swap(GOSkillCD& a, GOSkillCD& b) { a.Swap(&b); }
  inline void Swap(GOSkillCD* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GOSkillCD* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GOSkillCD* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GOSkillCD>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GOSkillCD& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GOSkillCD& from) { GOSkillCD::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GOSkillCD* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GOSkillCD"; }

 protected:
  explicit GOSkillCD(::google::protobuf::Arena* arena);
  GOSkillCD(::google::protobuf::Arena* arena, const GOSkillCD& from);
  GOSkillCD(::google::protobuf::Arena* arena, GOSkillCD&& from) noexcept
      : GOSkillCD(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kSkillidFieldNumber = 3,
    kTimeFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional int32 time = 4;
  bool has_time() const;
  void clear_time() ;
  ::int32_t time() const;
  void set_time(::int32_t value);

  private:
  ::int32_t _internal_time() const;
  void _internal_set_time(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectSkillCD];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GOSkillCD)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t skillid_;
    ::int32_t time_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class FuryVal final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.FuryVal) */ {
 public:
  inline FuryVal() : FuryVal(nullptr) {}
  ~FuryVal() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FuryVal(
      ::google::protobuf::internal::ConstantInitialized);

  inline FuryVal(const FuryVal& from) : FuryVal(nullptr, from) {}
  inline FuryVal(FuryVal&& from) noexcept
      : FuryVal(nullptr, std::move(from)) {}
  inline FuryVal& operator=(const FuryVal& from) {
    CopyFrom(from);
    return *this;
  }
  inline FuryVal& operator=(FuryVal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FuryVal& default_instance() {
    return *internal_default_instance();
  }
  static inline const FuryVal* internal_default_instance() {
    return reinterpret_cast<const FuryVal*>(
        &_FuryVal_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 129;
  friend void swap(FuryVal& a, FuryVal& b) { a.Swap(&b); }
  inline void Swap(FuryVal* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FuryVal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FuryVal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FuryVal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FuryVal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FuryVal& from) { FuryVal::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FuryVal* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.FuryVal"; }

 protected:
  explicit FuryVal(::google::protobuf::Arena* arena);
  FuryVal(::google::protobuf::Arena* arena, const FuryVal& from);
  FuryVal(::google::protobuf::Arena* arena, FuryVal&& from) noexcept
      : FuryVal(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kFuryFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 fury = 3;
  bool has_fury() const;
  void clear_fury() ;
  ::int32_t fury() const;
  void set_fury(::int32_t value);

  private:
  ::int32_t _internal_fury() const;
  void _internal_set_fury(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyFuryValue];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.FuryVal)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t fury_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class FuryState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.FuryState) */ {
 public:
  inline FuryState() : FuryState(nullptr) {}
  ~FuryState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FuryState(
      ::google::protobuf::internal::ConstantInitialized);

  inline FuryState(const FuryState& from) : FuryState(nullptr, from) {}
  inline FuryState(FuryState&& from) noexcept
      : FuryState(nullptr, std::move(from)) {}
  inline FuryState& operator=(const FuryState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FuryState& operator=(FuryState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FuryState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FuryState* internal_default_instance() {
    return reinterpret_cast<const FuryState*>(
        &_FuryState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 130;
  friend void swap(FuryState& a, FuryState& b) { a.Swap(&b); }
  inline void Swap(FuryState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FuryState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FuryState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FuryState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FuryState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FuryState& from) { FuryState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FuryState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.FuryState"; }

 protected:
  explicit FuryState(::google::protobuf::Arena* arena);
  FuryState(::google::protobuf::Arena* arena, const FuryState& from);
  FuryState(::google::protobuf::Arena* arena, FuryState&& from) noexcept
      : FuryState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kStateFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 state = 3;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyFuryState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.FuryState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t state_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class FPInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.FPInfo) */ {
 public:
  inline FPInfo() : FPInfo(nullptr) {}
  ~FPInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FPInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline FPInfo(const FPInfo& from) : FPInfo(nullptr, from) {}
  inline FPInfo(FPInfo&& from) noexcept
      : FPInfo(nullptr, std::move(from)) {}
  inline FPInfo& operator=(const FPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FPInfo& operator=(FPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FPInfo* internal_default_instance() {
    return reinterpret_cast<const FPInfo*>(
        &_FPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 110;
  friend void swap(FPInfo& a, FPInfo& b) { a.Swap(&b); }
  inline void Swap(FPInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FPInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FPInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FPInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FPInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FPInfo& from) { FPInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FPInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.FPInfo"; }

 protected:
  explicit FPInfo(::google::protobuf::Arena* arena);
  FPInfo(::google::protobuf::Arena* arena, const FPInfo& from);
  FPInfo(::google::protobuf::Arena* arena, FPInfo&& from) noexcept
      : FPInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 3,
    kGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated int32 info = 3;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::int32_t info(int index) const;
  void set_info(int index, ::int32_t value);
  void add_info(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& info() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_info();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_info() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_info();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyFightPropertyInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.FPInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> info_;
    ::uint64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class Exp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.Exp) */ {
 public:
  inline Exp() : Exp(nullptr) {}
  ~Exp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Exp(
      ::google::protobuf::internal::ConstantInitialized);

  inline Exp(const Exp& from) : Exp(nullptr, from) {}
  inline Exp(Exp&& from) noexcept
      : Exp(nullptr, std::move(from)) {}
  inline Exp& operator=(const Exp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Exp& operator=(Exp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Exp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Exp* internal_default_instance() {
    return reinterpret_cast<const Exp*>(
        &_Exp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 118;
  friend void swap(Exp& a, Exp& b) { a.Swap(&b); }
  inline void Swap(Exp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Exp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Exp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Exp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Exp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Exp& from) { Exp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Exp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.Exp"; }

 protected:
  explicit Exp(::google::protobuf::Arena* arena);
  Exp(::google::protobuf::Arena* arena, const Exp& from);
  Exp(::google::protobuf::Arena* arena, Exp&& from) noexcept
      : Exp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kExpFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 exp = 3;
  bool has_exp() const;
  void clear_exp() ;
  ::int32_t exp() const;
  void set_exp(::int32_t value);

  private:
  ::int32_t _internal_exp() const;
  void _internal_set_exp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyExpInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.Exp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t exp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class DisappearInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.DisappearInfo) */ {
 public:
  inline DisappearInfo() : DisappearInfo(nullptr) {}
  ~DisappearInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DisappearInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline DisappearInfo(const DisappearInfo& from) : DisappearInfo(nullptr, from) {}
  inline DisappearInfo(DisappearInfo&& from) noexcept
      : DisappearInfo(nullptr, std::move(from)) {}
  inline DisappearInfo& operator=(const DisappearInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisappearInfo& operator=(DisappearInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisappearInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisappearInfo* internal_default_instance() {
    return reinterpret_cast<const DisappearInfo*>(
        &_DisappearInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 90;
  friend void swap(DisappearInfo& a, DisappearInfo& b) { a.Swap(&b); }
  inline void Swap(DisappearInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisappearInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisappearInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DisappearInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DisappearInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DisappearInfo& from) { DisappearInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DisappearInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.DisappearInfo"; }

 protected:
  explicit DisappearInfo(::google::protobuf::Arena* arena);
  DisappearInfo(::google::protobuf::Arena* arena, const DisappearInfo& from);
  DisappearInfo(::google::protobuf::Arena* arena, DisappearInfo&& from) noexcept
      : DisappearInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated uint64 guid = 2;
  int guid_size() const;
  private:
  int _internal_guid_size() const;

  public:
  void clear_guid() ;
  ::uint64_t guid(int index) const;
  void set_guid(int index, ::uint64_t value);
  void add_guid(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& guid() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_guid();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_guid() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_guid();

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectDisappear];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.DisappearInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class Dir final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.Dir) */ {
 public:
  inline Dir() : Dir(nullptr) {}
  ~Dir() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Dir(
      ::google::protobuf::internal::ConstantInitialized);

  inline Dir(const Dir& from) : Dir(nullptr, from) {}
  inline Dir(Dir&& from) noexcept
      : Dir(nullptr, std::move(from)) {}
  inline Dir& operator=(const Dir& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dir& operator=(Dir&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dir& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dir* internal_default_instance() {
    return reinterpret_cast<const Dir*>(
        &_Dir_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 87;
  friend void swap(Dir& a, Dir& b) { a.Swap(&b); }
  inline void Swap(Dir* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dir* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dir* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Dir>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Dir& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Dir& from) { Dir::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Dir* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.Dir"; }

 protected:
  explicit Dir(::google::protobuf::Arena* arena);
  Dir(::google::protobuf::Arena* arena, const Dir& from);
  Dir(::google::protobuf::Arena* arena, Dir&& from) noexcept
      : Dir(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAngleFieldNumber = 4,
  };
  // optional int32 angle = 4;
  bool has_angle() const;
  void clear_angle() ;
  ::int32_t angle() const;
  void set_angle(::int32_t value);

  private:
  ::int32_t _internal_angle() const;
  void _internal_set_angle(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.Dir)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t angle_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class DestroyEmitEffect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.DestroyEmitEffect) */ {
 public:
  inline DestroyEmitEffect() : DestroyEmitEffect(nullptr) {}
  ~DestroyEmitEffect() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DestroyEmitEffect(
      ::google::protobuf::internal::ConstantInitialized);

  inline DestroyEmitEffect(const DestroyEmitEffect& from) : DestroyEmitEffect(nullptr, from) {}
  inline DestroyEmitEffect(DestroyEmitEffect&& from) noexcept
      : DestroyEmitEffect(nullptr, std::move(from)) {}
  inline DestroyEmitEffect& operator=(const DestroyEmitEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyEmitEffect& operator=(DestroyEmitEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyEmitEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyEmitEffect* internal_default_instance() {
    return reinterpret_cast<const DestroyEmitEffect*>(
        &_DestroyEmitEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 148;
  friend void swap(DestroyEmitEffect& a, DestroyEmitEffect& b) { a.Swap(&b); }
  inline void Swap(DestroyEmitEffect* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyEmitEffect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyEmitEffect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DestroyEmitEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DestroyEmitEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DestroyEmitEffect& from) { DestroyEmitEffect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DestroyEmitEffect* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.DestroyEmitEffect"; }

 protected:
  explicit DestroyEmitEffect(::google::protobuf::Arena* arena);
  DestroyEmitEffect(::google::protobuf::Arena* arena, const DestroyEmitEffect& from);
  DestroyEmitEffect(::google::protobuf::Arena* arena, DestroyEmitEffect&& from) noexcept
      : DestroyEmitEffect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUniqueidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int32 uniqueid = 2;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::int32_t uniqueid() const;
  void set_uniqueid(::int32_t value);

  private:
  ::int32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelEmitDestroy];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.DestroyEmitEffect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class DelAndSortMail final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.DelAndSortMail) */ {
 public:
  inline DelAndSortMail() : DelAndSortMail(nullptr) {}
  ~DelAndSortMail() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DelAndSortMail(
      ::google::protobuf::internal::ConstantInitialized);

  inline DelAndSortMail(const DelAndSortMail& from) : DelAndSortMail(nullptr, from) {}
  inline DelAndSortMail(DelAndSortMail&& from) noexcept
      : DelAndSortMail(nullptr, std::move(from)) {}
  inline DelAndSortMail& operator=(const DelAndSortMail& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelAndSortMail& operator=(DelAndSortMail&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DelAndSortMail& default_instance() {
    return *internal_default_instance();
  }
  static inline const DelAndSortMail* internal_default_instance() {
    return reinterpret_cast<const DelAndSortMail*>(
        &_DelAndSortMail_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(DelAndSortMail& a, DelAndSortMail& b) { a.Swap(&b); }
  inline void Swap(DelAndSortMail* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DelAndSortMail* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DelAndSortMail* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DelAndSortMail>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DelAndSortMail& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DelAndSortMail& from) { DelAndSortMail::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DelAndSortMail* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.DelAndSortMail"; }

 protected:
  explicit DelAndSortMail(::google::protobuf::Arena* arena);
  DelAndSortMail(::google::protobuf::Arena* arena, const DelAndSortMail& from);
  DelAndSortMail(::google::protobuf::Arena* arena, DelAndSortMail&& from) noexcept
      : DelAndSortMail(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailidFieldNumber = 2,
    kMailidDelFieldNumber = 3,
    kSortFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional int32 mailid = 2;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional bool mailidDel = 3;
  bool has_mailiddel() const;
  void clear_mailiddel() ;
  bool mailiddel() const;
  void set_mailiddel(bool value);

  private:
  bool _internal_mailiddel() const;
  void _internal_set_mailiddel(bool value);

  public:
  // optional bool sort = 4;
  bool has_sort() const;
  void clear_sort() ;
  bool sort() const;
  void set_sort(bool value);

  private:
  bool _internal_sort() const;
  void _internal_set_sort(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyIfMailDelAndSort];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.DelAndSortMail)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mailid_;
    bool mailiddel_;
    bool sort_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CurDeadTimes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CurDeadTimes) */ {
 public:
  inline CurDeadTimes() : CurDeadTimes(nullptr) {}
  ~CurDeadTimes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurDeadTimes(
      ::google::protobuf::internal::ConstantInitialized);

  inline CurDeadTimes(const CurDeadTimes& from) : CurDeadTimes(nullptr, from) {}
  inline CurDeadTimes(CurDeadTimes&& from) noexcept
      : CurDeadTimes(nullptr, std::move(from)) {}
  inline CurDeadTimes& operator=(const CurDeadTimes& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurDeadTimes& operator=(CurDeadTimes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurDeadTimes& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurDeadTimes* internal_default_instance() {
    return reinterpret_cast<const CurDeadTimes*>(
        &_CurDeadTimes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 125;
  friend void swap(CurDeadTimes& a, CurDeadTimes& b) { a.Swap(&b); }
  inline void Swap(CurDeadTimes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurDeadTimes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurDeadTimes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CurDeadTimes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurDeadTimes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CurDeadTimes& from) { CurDeadTimes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurDeadTimes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CurDeadTimes"; }

 protected:
  explicit CurDeadTimes(::google::protobuf::Arena* arena);
  CurDeadTimes(::google::protobuf::Arena* arena, const CurDeadTimes& from);
  CurDeadTimes(::google::protobuf::Arena* arena, CurDeadTimes&& from) noexcept
      : CurDeadTimes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kObjguidFieldNumber = 2,
    kDeadtimesFieldNumber = 3,
    kKillerCampFieldNumber = 4,
    kReasonheroguidFieldNumber = 5,
    kIfAcedFieldNumber = 6,
    kCampFieldNumber = 7,
    kHerostateFieldNumber = 8,
    kHerotitleFieldNumber = 9,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional int32 deadtimes = 3;
  bool has_deadtimes() const;
  void clear_deadtimes() ;
  ::int32_t deadtimes() const;
  void set_deadtimes(::int32_t value);

  private:
  ::int32_t _internal_deadtimes() const;
  void _internal_set_deadtimes(::int32_t value);

  public:
  // optional int32 killer_camp = 4;
  bool has_killer_camp() const;
  void clear_killer_camp() ;
  ::int32_t killer_camp() const;
  void set_killer_camp(::int32_t value);

  private:
  ::int32_t _internal_killer_camp() const;
  void _internal_set_killer_camp(::int32_t value);

  public:
  // optional uint64 reasonheroguid = 5;
  bool has_reasonheroguid() const;
  void clear_reasonheroguid() ;
  ::uint64_t reasonheroguid() const;
  void set_reasonheroguid(::uint64_t value);

  private:
  ::uint64_t _internal_reasonheroguid() const;
  void _internal_set_reasonheroguid(::uint64_t value);

  public:
  // optional bool ifAced = 6;
  bool has_ifaced() const;
  void clear_ifaced() ;
  bool ifaced() const;
  void set_ifaced(bool value);

  private:
  bool _internal_ifaced() const;
  void _internal_set_ifaced(bool value);

  public:
  // optional int32 camp = 7;
  bool has_camp() const;
  void clear_camp() ;
  ::int32_t camp() const;
  void set_camp(::int32_t value);

  private:
  ::int32_t _internal_camp() const;
  void _internal_set_camp(::int32_t value);

  public:
  // optional int32 herostate = 8;
  bool has_herostate() const;
  void clear_herostate() ;
  ::int32_t herostate() const;
  void set_herostate(::int32_t value);

  private:
  ::int32_t _internal_herostate() const;
  void _internal_set_herostate(::int32_t value);

  public:
  // optional int32 herotitle = 9;
  bool has_herotitle() const;
  void clear_herotitle() ;
  ::int32_t herotitle() const;
  void set_herotitle(::int32_t value);

  private:
  ::int32_t _internal_herotitle() const;
  void _internal_set_herotitle(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurDeadTimes];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CurDeadTimes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t objguid_;
    ::int32_t deadtimes_;
    ::int32_t killer_camp_;
    ::uint64_t reasonheroguid_;
    bool ifaced_;
    ::int32_t camp_;
    ::int32_t herostate_;
    ::int32_t herotitle_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CurCP final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CurCP) */ {
 public:
  inline CurCP() : CurCP(nullptr) {}
  ~CurCP() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurCP(
      ::google::protobuf::internal::ConstantInitialized);

  inline CurCP(const CurCP& from) : CurCP(nullptr, from) {}
  inline CurCP(CurCP&& from) noexcept
      : CurCP(nullptr, std::move(from)) {}
  inline CurCP& operator=(const CurCP& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurCP& operator=(CurCP&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurCP& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurCP* internal_default_instance() {
    return reinterpret_cast<const CurCP*>(
        &_CurCP_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 126;
  friend void swap(CurCP& a, CurCP& b) { a.Swap(&b); }
  inline void Swap(CurCP* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurCP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurCP* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CurCP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurCP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CurCP& from) { CurCP::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurCP* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CurCP"; }

 protected:
  explicit CurCP(::google::protobuf::Arena* arena);
  CurCP(::google::protobuf::Arena* arena, const CurCP& from);
  CurCP(::google::protobuf::Arena* arena, CurCP&& from) noexcept
      : CurCP(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTargetguidFieldNumber = 2,
    kPersonCpFieldNumber = 3,
    kTeamCpFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 targetguid = 2;
  bool has_targetguid() const;
  void clear_targetguid() ;
  ::uint64_t targetguid() const;
  void set_targetguid(::uint64_t value);

  private:
  ::uint64_t _internal_targetguid() const;
  void _internal_set_targetguid(::uint64_t value);

  public:
  // optional int32 person_cp = 3;
  bool has_person_cp() const;
  void clear_person_cp() ;
  ::int32_t person_cp() const;
  void set_person_cp(::int32_t value);

  private:
  ::int32_t _internal_person_cp() const;
  void _internal_set_person_cp(::int32_t value);

  public:
  // optional int32 team_cp = 4;
  bool has_team_cp() const;
  void clear_team_cp() ;
  ::int32_t team_cp() const;
  void set_team_cp(::int32_t value);

  private:
  ::int32_t _internal_team_cp() const;
  void _internal_set_team_cp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurCP];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CurCP)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t targetguid_;
    ::int32_t person_cp_;
    ::int32_t team_cp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CurBattleChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CurBattleChange) */ {
 public:
  inline CurBattleChange() : CurBattleChange(nullptr) {}
  ~CurBattleChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurBattleChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline CurBattleChange(const CurBattleChange& from) : CurBattleChange(nullptr, from) {}
  inline CurBattleChange(CurBattleChange&& from) noexcept
      : CurBattleChange(nullptr, std::move(from)) {}
  inline CurBattleChange& operator=(const CurBattleChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurBattleChange& operator=(CurBattleChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurBattleChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurBattleChange* internal_default_instance() {
    return reinterpret_cast<const CurBattleChange*>(
        &_CurBattleChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 85;
  friend void swap(CurBattleChange& a, CurBattleChange& b) { a.Swap(&b); }
  inline void Swap(CurBattleChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurBattleChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurBattleChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CurBattleChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurBattleChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CurBattleChange& from) { CurBattleChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurBattleChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CurBattleChange"; }

 protected:
  explicit CurBattleChange(::google::protobuf::Arena* arena);
  CurBattleChange(::google::protobuf::Arena* arena, const CurBattleChange& from);
  CurBattleChange(::google::protobuf::Arena* arena, CurBattleChange&& from) noexcept
      : CurBattleChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBattleidFieldNumber = 3,
    kSsidFieldNumber = 2,
    kMapidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 battleid = 3;
  bool has_battleid() const;
  void clear_battleid() ;
  ::uint64_t battleid() const;
  void set_battleid(::uint64_t value);

  private:
  ::uint64_t _internal_battleid() const;
  void _internal_set_battleid(::uint64_t value);

  public:
  // optional int32 ssid = 2;
  bool has_ssid() const;
  void clear_ssid() ;
  ::int32_t ssid() const;
  void set_ssid(::int32_t value);

  private:
  ::int32_t _internal_ssid() const;
  void _internal_set_ssid(::int32_t value);

  public:
  // optional int32 mapid = 4;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurBattleChange];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CurBattleChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t battleid_;
    ::int32_t ssid_;
    ::int32_t mapid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CurAtkSpeed_SpeedInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CurAtkSpeed.SpeedInfo) */ {
 public:
  inline CurAtkSpeed_SpeedInfo() : CurAtkSpeed_SpeedInfo(nullptr) {}
  ~CurAtkSpeed_SpeedInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurAtkSpeed_SpeedInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline CurAtkSpeed_SpeedInfo(const CurAtkSpeed_SpeedInfo& from) : CurAtkSpeed_SpeedInfo(nullptr, from) {}
  inline CurAtkSpeed_SpeedInfo(CurAtkSpeed_SpeedInfo&& from) noexcept
      : CurAtkSpeed_SpeedInfo(nullptr, std::move(from)) {}
  inline CurAtkSpeed_SpeedInfo& operator=(const CurAtkSpeed_SpeedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurAtkSpeed_SpeedInfo& operator=(CurAtkSpeed_SpeedInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurAtkSpeed_SpeedInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurAtkSpeed_SpeedInfo* internal_default_instance() {
    return reinterpret_cast<const CurAtkSpeed_SpeedInfo*>(
        &_CurAtkSpeed_SpeedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 127;
  friend void swap(CurAtkSpeed_SpeedInfo& a, CurAtkSpeed_SpeedInfo& b) { a.Swap(&b); }
  inline void Swap(CurAtkSpeed_SpeedInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurAtkSpeed_SpeedInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurAtkSpeed_SpeedInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CurAtkSpeed_SpeedInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurAtkSpeed_SpeedInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CurAtkSpeed_SpeedInfo& from) { CurAtkSpeed_SpeedInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurAtkSpeed_SpeedInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CurAtkSpeed.SpeedInfo"; }

 protected:
  explicit CurAtkSpeed_SpeedInfo(::google::protobuf::Arena* arena);
  CurAtkSpeed_SpeedInfo(::google::protobuf::Arena* arena, const CurAtkSpeed_SpeedInfo& from);
  CurAtkSpeed_SpeedInfo(::google::protobuf::Arena* arena, CurAtkSpeed_SpeedInfo&& from) noexcept
      : CurAtkSpeed_SpeedInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // optional uint64 guid = 1;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 speed = 2;
  bool has_speed() const;
  void clear_speed() ;
  ::int32_t speed() const;
  void set_speed(::int32_t value);

  private:
  ::int32_t _internal_speed() const;
  void _internal_set_speed(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CurAtkSpeed.SpeedInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t speed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class ChatInRoom final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.ChatInRoom) */ {
 public:
  inline ChatInRoom() : ChatInRoom(nullptr) {}
  ~ChatInRoom() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChatInRoom(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChatInRoom(const ChatInRoom& from) : ChatInRoom(nullptr, from) {}
  inline ChatInRoom(ChatInRoom&& from) noexcept
      : ChatInRoom(nullptr, std::move(from)) {}
  inline ChatInRoom& operator=(const ChatInRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatInRoom& operator=(ChatInRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatInRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatInRoom* internal_default_instance() {
    return reinterpret_cast<const ChatInRoom*>(
        &_ChatInRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 103;
  friend void swap(ChatInRoom& a, ChatInRoom& b) { a.Swap(&b); }
  inline void Swap(ChatInRoom* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatInRoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatInRoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChatInRoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatInRoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChatInRoom& from) { ChatInRoom::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatInRoom* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.ChatInRoom"; }

 protected:
  explicit ChatInRoom(::google::protobuf::Arena* arena);
  ChatInRoom(::google::protobuf::Arena* arena, const ChatInRoom& from);
  ChatInRoom(::google::protobuf::Arena* arena, ChatInRoom&& from) noexcept
      : ChatInRoom(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChatFieldNumber = 3,
    kPosFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional string chat = 3;
  bool has_chat() const;
  void clear_chat() ;
  const std::string& chat() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_chat(Arg_&& arg, Args_... args);
  std::string* mutable_chat();
  PROTOBUF_NODISCARD std::string* release_chat();
  void set_allocated_chat(std::string* value);

  private:
  const std::string& _internal_chat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat(
      const std::string& value);
  std::string* _internal_mutable_chat();

  public:
  // optional int32 pos = 2;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_ChatInRoom];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.ChatInRoom)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      30, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr chat_;
    ::int32_t pos_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CancelAbsorb final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CancelAbsorb) */ {
 public:
  inline CancelAbsorb() : CancelAbsorb(nullptr) {}
  ~CancelAbsorb() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CancelAbsorb(
      ::google::protobuf::internal::ConstantInitialized);

  inline CancelAbsorb(const CancelAbsorb& from) : CancelAbsorb(nullptr, from) {}
  inline CancelAbsorb(CancelAbsorb&& from) noexcept
      : CancelAbsorb(nullptr, std::move(from)) {}
  inline CancelAbsorb& operator=(const CancelAbsorb& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelAbsorb& operator=(CancelAbsorb&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelAbsorb& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelAbsorb* internal_default_instance() {
    return reinterpret_cast<const CancelAbsorb*>(
        &_CancelAbsorb_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 122;
  friend void swap(CancelAbsorb& a, CancelAbsorb& b) { a.Swap(&b); }
  inline void Swap(CancelAbsorb* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelAbsorb* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelAbsorb* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CancelAbsorb>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CancelAbsorb& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CancelAbsorb& from) { CancelAbsorb::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CancelAbsorb* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CancelAbsorb"; }

 protected:
  explicit CancelAbsorb(::google::protobuf::Arena* arena);
  CancelAbsorb(::google::protobuf::Arena* arena, const CancelAbsorb& from);
  CancelAbsorb(::google::protobuf::Arena* arena, CancelAbsorb&& from) noexcept
      : CancelAbsorb(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMonsteridFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int32 monsterid = 2;
  bool has_monsterid() const;
  void clear_monsterid() ;
  ::int32_t monsterid() const;
  void set_monsterid(::int32_t value);

  private:
  ::int32_t _internal_monsterid() const;
  void _internal_set_monsterid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCancelAbsorbSkill];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CancelAbsorb)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t monsterid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CanInviteFriends_Friends final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CanInviteFriends.Friends) */ {
 public:
  inline CanInviteFriends_Friends() : CanInviteFriends_Friends(nullptr) {}
  ~CanInviteFriends_Friends() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CanInviteFriends_Friends(
      ::google::protobuf::internal::ConstantInitialized);

  inline CanInviteFriends_Friends(const CanInviteFriends_Friends& from) : CanInviteFriends_Friends(nullptr, from) {}
  inline CanInviteFriends_Friends(CanInviteFriends_Friends&& from) noexcept
      : CanInviteFriends_Friends(nullptr, std::move(from)) {}
  inline CanInviteFriends_Friends& operator=(const CanInviteFriends_Friends& from) {
    CopyFrom(from);
    return *this;
  }
  inline CanInviteFriends_Friends& operator=(CanInviteFriends_Friends&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CanInviteFriends_Friends& default_instance() {
    return *internal_default_instance();
  }
  static inline const CanInviteFriends_Friends* internal_default_instance() {
    return reinterpret_cast<const CanInviteFriends_Friends*>(
        &_CanInviteFriends_Friends_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 181;
  friend void swap(CanInviteFriends_Friends& a, CanInviteFriends_Friends& b) { a.Swap(&b); }
  inline void Swap(CanInviteFriends_Friends* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CanInviteFriends_Friends* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CanInviteFriends_Friends* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CanInviteFriends_Friends>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CanInviteFriends_Friends& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CanInviteFriends_Friends& from) { CanInviteFriends_Friends::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CanInviteFriends_Friends* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CanInviteFriends.Friends"; }

 protected:
  explicit CanInviteFriends_Friends(::google::protobuf::Arena* arena);
  CanInviteFriends_Friends(::google::protobuf::Arena* arena, const CanInviteFriends_Friends& from);
  CanInviteFriends_Friends(::google::protobuf::Arena* arena, CanInviteFriends_Friends&& from) noexcept
      : CanInviteFriends_Friends(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kGuididxFieldNumber = 3,
    kHeaderIdFieldNumber = 1,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional uint64 guididx = 3;
  bool has_guididx() const;
  void clear_guididx() ;
  ::uint64_t guididx() const;
  void set_guididx(::uint64_t value);

  private:
  ::uint64_t _internal_guididx() const;
  void _internal_set_guididx(::uint64_t value);

  public:
  // optional int32 HeaderId = 1;
  bool has_headerid() const;
  void clear_headerid() ;
  ::int32_t headerid() const;
  void set_headerid(::int32_t value);

  private:
  ::int32_t _internal_headerid() const;
  void _internal_set_headerid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CanInviteFriends.Friends)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      48, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint64_t guididx_;
    ::int32_t headerid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BuffEffect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BuffEffect) */ {
 public:
  inline BuffEffect() : BuffEffect(nullptr) {}
  ~BuffEffect() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuffEffect(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuffEffect(const BuffEffect& from) : BuffEffect(nullptr, from) {}
  inline BuffEffect(BuffEffect&& from) noexcept
      : BuffEffect(nullptr, std::move(from)) {}
  inline BuffEffect& operator=(const BuffEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuffEffect& operator=(BuffEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuffEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuffEffect* internal_default_instance() {
    return reinterpret_cast<const BuffEffect*>(
        &_BuffEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 153;
  friend void swap(BuffEffect& a, BuffEffect& b) { a.Swap(&b); }
  inline void Swap(BuffEffect* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuffEffect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuffEffect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BuffEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuffEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuffEffect& from) { BuffEffect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuffEffect* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BuffEffect"; }

 protected:
  explicit BuffEffect(::google::protobuf::Arena* arena);
  BuffEffect(::google::protobuf::Arena* arena, const BuffEffect& from);
  BuffEffect(::google::protobuf::Arena* arena, BuffEffect&& from) noexcept
      : BuffEffect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kUniqueidFieldNumber = 4,
    kTarguidFieldNumber = 5,
    kTimeFieldNumber = 6,
    kStateFieldNumber = 7,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::uint32_t effectid() const;
  void set_effectid(::uint32_t value);

  private:
  ::uint32_t _internal_effectid() const;
  void _internal_set_effectid(::uint32_t value);

  public:
  // optional uint32 uniqueid = 4;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::uint32_t uniqueid() const;
  void set_uniqueid(::uint32_t value);

  private:
  ::uint32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::uint32_t value);

  public:
  // optional uint64 targuid = 5;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional int32 time = 6;
  bool has_time() const;
  void clear_time() ;
  ::int32_t time() const;
  void set_time(::int32_t value);

  private:
  ::int32_t _internal_time() const;
  void _internal_set_time(::int32_t value);

  public:
  // optional int32 state = 7;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelBufEffect];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BuffEffect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint32_t effectid_;
    ::uint32_t uniqueid_;
    ::uint64_t targuid_;
    ::int32_t time_;
    ::int32_t state_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BroadcastBuildingDestory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BroadcastBuildingDestory) */ {
 public:
  inline BroadcastBuildingDestory() : BroadcastBuildingDestory(nullptr) {}
  ~BroadcastBuildingDestory() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastBuildingDestory(
      ::google::protobuf::internal::ConstantInitialized);

  inline BroadcastBuildingDestory(const BroadcastBuildingDestory& from) : BroadcastBuildingDestory(nullptr, from) {}
  inline BroadcastBuildingDestory(BroadcastBuildingDestory&& from) noexcept
      : BroadcastBuildingDestory(nullptr, std::move(from)) {}
  inline BroadcastBuildingDestory& operator=(const BroadcastBuildingDestory& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastBuildingDestory& operator=(BroadcastBuildingDestory&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastBuildingDestory& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastBuildingDestory* internal_default_instance() {
    return reinterpret_cast<const BroadcastBuildingDestory*>(
        &_BroadcastBuildingDestory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 138;
  friend void swap(BroadcastBuildingDestory& a, BroadcastBuildingDestory& b) { a.Swap(&b); }
  inline void Swap(BroadcastBuildingDestory* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastBuildingDestory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastBuildingDestory* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BroadcastBuildingDestory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BroadcastBuildingDestory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BroadcastBuildingDestory& from) { BroadcastBuildingDestory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BroadcastBuildingDestory* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BroadcastBuildingDestory"; }

 protected:
  explicit BroadcastBuildingDestory(::google::protobuf::Arena* arena);
  BroadcastBuildingDestory(::google::protobuf::Arena* arena, const BroadcastBuildingDestory& from);
  BroadcastBuildingDestory(::google::protobuf::Arena* arena, BroadcastBuildingDestory&& from) noexcept
      : BroadcastBuildingDestory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBuildingguidFieldNumber = 2,
    kKillerGuidFieldNumber = 4,
    kBuildingCampFieldNumber = 3,
    kKillerCampFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 buildingguid = 2;
  bool has_buildingguid() const;
  void clear_buildingguid() ;
  ::uint64_t buildingguid() const;
  void set_buildingguid(::uint64_t value);

  private:
  ::uint64_t _internal_buildingguid() const;
  void _internal_set_buildingguid(::uint64_t value);

  public:
  // optional uint64 killer_guid = 4;
  bool has_killer_guid() const;
  void clear_killer_guid() ;
  ::uint64_t killer_guid() const;
  void set_killer_guid(::uint64_t value);

  private:
  ::uint64_t _internal_killer_guid() const;
  void _internal_set_killer_guid(::uint64_t value);

  public:
  // optional int32 building_camp = 3;
  bool has_building_camp() const;
  void clear_building_camp() ;
  ::int32_t building_camp() const;
  void set_building_camp(::int32_t value);

  private:
  ::int32_t _internal_building_camp() const;
  void _internal_set_building_camp(::int32_t value);

  public:
  // optional int32 killer_camp = 5;
  bool has_killer_camp() const;
  void clear_killer_camp() ;
  ::int32_t killer_camp() const;
  void set_killer_camp(::int32_t value);

  private:
  ::int32_t _internal_killer_camp() const;
  void _internal_set_killer_camp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadBuildingDestroyByWho];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BroadcastBuildingDestory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t buildingguid_;
    ::uint64_t killer_guid_;
    ::int32_t building_camp_;
    ::int32_t killer_camp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BroadcastBattleHeroInfo_HeroInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BroadcastBattleHeroInfo.HeroInfo) */ {
 public:
  inline BroadcastBattleHeroInfo_HeroInfo() : BroadcastBattleHeroInfo_HeroInfo(nullptr) {}
  ~BroadcastBattleHeroInfo_HeroInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastBattleHeroInfo_HeroInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BroadcastBattleHeroInfo_HeroInfo(const BroadcastBattleHeroInfo_HeroInfo& from) : BroadcastBattleHeroInfo_HeroInfo(nullptr, from) {}
  inline BroadcastBattleHeroInfo_HeroInfo(BroadcastBattleHeroInfo_HeroInfo&& from) noexcept
      : BroadcastBattleHeroInfo_HeroInfo(nullptr, std::move(from)) {}
  inline BroadcastBattleHeroInfo_HeroInfo& operator=(const BroadcastBattleHeroInfo_HeroInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastBattleHeroInfo_HeroInfo& operator=(BroadcastBattleHeroInfo_HeroInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastBattleHeroInfo_HeroInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastBattleHeroInfo_HeroInfo* internal_default_instance() {
    return reinterpret_cast<const BroadcastBattleHeroInfo_HeroInfo*>(
        &_BroadcastBattleHeroInfo_HeroInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 51;
  friend void swap(BroadcastBattleHeroInfo_HeroInfo& a, BroadcastBattleHeroInfo_HeroInfo& b) { a.Swap(&b); }
  inline void Swap(BroadcastBattleHeroInfo_HeroInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastBattleHeroInfo_HeroInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastBattleHeroInfo_HeroInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BroadcastBattleHeroInfo_HeroInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BroadcastBattleHeroInfo_HeroInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BroadcastBattleHeroInfo_HeroInfo& from) { BroadcastBattleHeroInfo_HeroInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BroadcastBattleHeroInfo_HeroInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BroadcastBattleHeroInfo.HeroInfo"; }

 protected:
  explicit BroadcastBattleHeroInfo_HeroInfo(::google::protobuf::Arena* arena);
  BroadcastBattleHeroInfo_HeroInfo(::google::protobuf::Arena* arena, const BroadcastBattleHeroInfo_HeroInfo& from);
  BroadcastBattleHeroInfo_HeroInfo(::google::protobuf::Arena* arena, BroadcastBattleHeroInfo_HeroInfo&& from) noexcept
      : BroadcastBattleHeroInfo_HeroInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 2,
    kGuidFieldNumber = 1,
    kLevelFieldNumber = 3,
    kDeadtimesFieldNumber = 4,
    kCampidFieldNumber = 5,
    kHeadidFieldNumber = 6,
    kHpFieldNumber = 7,
    kMpFieldNumber = 8,
    kMasterguidFieldNumber = 10,
    kPosFieldNumber = 9,
    kKillsFieldNumber = 11,
    kAssistFieldNumber = 12,
    kHeroidFieldNumber = 13,
  };
  // optional string nickname = 2;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional uint64 guid = 1;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 level = 3;
  bool has_level() const;
  void clear_level() ;
  ::int32_t level() const;
  void set_level(::int32_t value);

  private:
  ::int32_t _internal_level() const;
  void _internal_set_level(::int32_t value);

  public:
  // optional int32 deadtimes = 4;
  bool has_deadtimes() const;
  void clear_deadtimes() ;
  ::int32_t deadtimes() const;
  void set_deadtimes(::int32_t value);

  private:
  ::int32_t _internal_deadtimes() const;
  void _internal_set_deadtimes(::int32_t value);

  public:
  // optional int32 campid = 5;
  bool has_campid() const;
  void clear_campid() ;
  ::int32_t campid() const;
  void set_campid(::int32_t value);

  private:
  ::int32_t _internal_campid() const;
  void _internal_set_campid(::int32_t value);

  public:
  // optional int32 headid = 6;
  bool has_headid() const;
  void clear_headid() ;
  ::int32_t headid() const;
  void set_headid(::int32_t value);

  private:
  ::int32_t _internal_headid() const;
  void _internal_set_headid(::int32_t value);

  public:
  // optional int32 hp = 7;
  bool has_hp() const;
  void clear_hp() ;
  ::int32_t hp() const;
  void set_hp(::int32_t value);

  private:
  ::int32_t _internal_hp() const;
  void _internal_set_hp(::int32_t value);

  public:
  // optional int32 mp = 8;
  bool has_mp() const;
  void clear_mp() ;
  ::int32_t mp() const;
  void set_mp(::int32_t value);

  private:
  ::int32_t _internal_mp() const;
  void _internal_set_mp(::int32_t value);

  public:
  // optional uint64 masterguid = 10;
  bool has_masterguid() const;
  void clear_masterguid() ;
  ::uint64_t masterguid() const;
  void set_masterguid(::uint64_t value);

  private:
  ::uint64_t _internal_masterguid() const;
  void _internal_set_masterguid(::uint64_t value);

  public:
  // optional int32 pos = 9;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional int32 kills = 11;
  bool has_kills() const;
  void clear_kills() ;
  ::int32_t kills() const;
  void set_kills(::int32_t value);

  private:
  ::int32_t _internal_kills() const;
  void _internal_set_kills(::int32_t value);

  public:
  // optional int32 assist = 12;
  bool has_assist() const;
  void clear_assist() ;
  ::int32_t assist() const;
  void set_assist(::int32_t value);

  private:
  ::int32_t _internal_assist() const;
  void _internal_set_assist(::int32_t value);

  public:
  // optional int32 heroid = 13;
  bool has_heroid() const;
  void clear_heroid() ;
  ::int32_t heroid() const;
  void set_heroid(::int32_t value);

  private:
  ::int32_t _internal_heroid() const;
  void _internal_set_heroid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BroadcastBattleHeroInfo.HeroInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 0,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint64_t guid_;
    ::int32_t level_;
    ::int32_t deadtimes_;
    ::int32_t campid_;
    ::int32_t headid_;
    ::int32_t hp_;
    ::int32_t mp_;
    ::uint64_t masterguid_;
    ::int32_t pos_;
    ::int32_t kills_;
    ::int32_t assist_;
    ::int32_t heroid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BroadcastBattleHeroInfo_BaseGoodsInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo) */ {
 public:
  inline BroadcastBattleHeroInfo_BaseGoodsInfo() : BroadcastBattleHeroInfo_BaseGoodsInfo(nullptr) {}
  ~BroadcastBattleHeroInfo_BaseGoodsInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastBattleHeroInfo_BaseGoodsInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BroadcastBattleHeroInfo_BaseGoodsInfo(const BroadcastBattleHeroInfo_BaseGoodsInfo& from) : BroadcastBattleHeroInfo_BaseGoodsInfo(nullptr, from) {}
  inline BroadcastBattleHeroInfo_BaseGoodsInfo(BroadcastBattleHeroInfo_BaseGoodsInfo&& from) noexcept
      : BroadcastBattleHeroInfo_BaseGoodsInfo(nullptr, std::move(from)) {}
  inline BroadcastBattleHeroInfo_BaseGoodsInfo& operator=(const BroadcastBattleHeroInfo_BaseGoodsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastBattleHeroInfo_BaseGoodsInfo& operator=(BroadcastBattleHeroInfo_BaseGoodsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastBattleHeroInfo_BaseGoodsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastBattleHeroInfo_BaseGoodsInfo* internal_default_instance() {
    return reinterpret_cast<const BroadcastBattleHeroInfo_BaseGoodsInfo*>(
        &_BroadcastBattleHeroInfo_BaseGoodsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 52;
  friend void swap(BroadcastBattleHeroInfo_BaseGoodsInfo& a, BroadcastBattleHeroInfo_BaseGoodsInfo& b) { a.Swap(&b); }
  inline void Swap(BroadcastBattleHeroInfo_BaseGoodsInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastBattleHeroInfo_BaseGoodsInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastBattleHeroInfo_BaseGoodsInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BroadcastBattleHeroInfo_BaseGoodsInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BroadcastBattleHeroInfo_BaseGoodsInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BroadcastBattleHeroInfo_BaseGoodsInfo& from) { BroadcastBattleHeroInfo_BaseGoodsInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BroadcastBattleHeroInfo_BaseGoodsInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo"; }

 protected:
  explicit BroadcastBattleHeroInfo_BaseGoodsInfo(::google::protobuf::Arena* arena);
  BroadcastBattleHeroInfo_BaseGoodsInfo(::google::protobuf::Arena* arena, const BroadcastBattleHeroInfo_BaseGoodsInfo& from);
  BroadcastBattleHeroInfo_BaseGoodsInfo(::google::protobuf::Arena* arena, BroadcastBattleHeroInfo_BaseGoodsInfo&& from) noexcept
      : BroadcastBattleHeroInfo_BaseGoodsInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 13,
    kIdFieldNumber = 14,
  };
  // optional int32 index = 13;
  bool has_index() const;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // optional int32 id = 14;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t index_;
    ::int32_t id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BroadcastBatteleRes_ResInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BroadcastBatteleRes.ResInfo) */ {
 public:
  inline BroadcastBatteleRes_ResInfo() : BroadcastBatteleRes_ResInfo(nullptr) {}
  ~BroadcastBatteleRes_ResInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastBatteleRes_ResInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BroadcastBatteleRes_ResInfo(const BroadcastBatteleRes_ResInfo& from) : BroadcastBatteleRes_ResInfo(nullptr, from) {}
  inline BroadcastBatteleRes_ResInfo(BroadcastBatteleRes_ResInfo&& from) noexcept
      : BroadcastBatteleRes_ResInfo(nullptr, std::move(from)) {}
  inline BroadcastBatteleRes_ResInfo& operator=(const BroadcastBatteleRes_ResInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastBatteleRes_ResInfo& operator=(BroadcastBatteleRes_ResInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastBatteleRes_ResInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastBatteleRes_ResInfo* internal_default_instance() {
    return reinterpret_cast<const BroadcastBatteleRes_ResInfo*>(
        &_BroadcastBatteleRes_ResInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 135;
  friend void swap(BroadcastBatteleRes_ResInfo& a, BroadcastBatteleRes_ResInfo& b) { a.Swap(&b); }
  inline void Swap(BroadcastBatteleRes_ResInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastBatteleRes_ResInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastBatteleRes_ResInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BroadcastBatteleRes_ResInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BroadcastBatteleRes_ResInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BroadcastBatteleRes_ResInfo& from) { BroadcastBatteleRes_ResInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BroadcastBatteleRes_ResInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BroadcastBatteleRes.ResInfo"; }

 protected:
  explicit BroadcastBatteleRes_ResInfo(::google::protobuf::Arena* arena);
  BroadcastBatteleRes_ResInfo(::google::protobuf::Arena* arena, const BroadcastBatteleRes_ResInfo& from);
  BroadcastBatteleRes_ResInfo(::google::protobuf::Arena* arena, BroadcastBatteleRes_ResInfo&& from) noexcept
      : BroadcastBatteleRes_ResInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 3,
    kObjguidFieldNumber = 1,
    kHeroidFieldNumber = 2,
    kCurlevelFieldNumber = 4,
    kKilltimesFieldNumber = 5,
    kDeadtimesFieldNumber = 6,
    kAsstimesFieldNumber = 7,
    kTotalcpFieldNumber = 8,
    kLasthitFieldNumber = 9,
    kCamgpidFieldNumber = 10,
  };
  // optional string nickname = 3;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional uint64 objguid = 1;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional int32 heroid = 2;
  bool has_heroid() const;
  void clear_heroid() ;
  ::int32_t heroid() const;
  void set_heroid(::int32_t value);

  private:
  ::int32_t _internal_heroid() const;
  void _internal_set_heroid(::int32_t value);

  public:
  // optional int32 curlevel = 4;
  bool has_curlevel() const;
  void clear_curlevel() ;
  ::int32_t curlevel() const;
  void set_curlevel(::int32_t value);

  private:
  ::int32_t _internal_curlevel() const;
  void _internal_set_curlevel(::int32_t value);

  public:
  // optional int32 killtimes = 5;
  bool has_killtimes() const;
  void clear_killtimes() ;
  ::int32_t killtimes() const;
  void set_killtimes(::int32_t value);

  private:
  ::int32_t _internal_killtimes() const;
  void _internal_set_killtimes(::int32_t value);

  public:
  // optional int32 deadtimes = 6;
  bool has_deadtimes() const;
  void clear_deadtimes() ;
  ::int32_t deadtimes() const;
  void set_deadtimes(::int32_t value);

  private:
  ::int32_t _internal_deadtimes() const;
  void _internal_set_deadtimes(::int32_t value);

  public:
  // optional int32 asstimes = 7;
  bool has_asstimes() const;
  void clear_asstimes() ;
  ::int32_t asstimes() const;
  void set_asstimes(::int32_t value);

  private:
  ::int32_t _internal_asstimes() const;
  void _internal_set_asstimes(::int32_t value);

  public:
  // optional int32 totalcp = 8;
  bool has_totalcp() const;
  void clear_totalcp() ;
  ::int32_t totalcp() const;
  void set_totalcp(::int32_t value);

  private:
  ::int32_t _internal_totalcp() const;
  void _internal_set_totalcp(::int32_t value);

  public:
  // optional int32 lasthit = 9;
  bool has_lasthit() const;
  void clear_lasthit() ;
  ::int32_t lasthit() const;
  void set_lasthit(::int32_t value);

  private:
  ::int32_t _internal_lasthit() const;
  void _internal_set_lasthit(::int32_t value);

  public:
  // optional int32 camgpid = 10;
  bool has_camgpid() const;
  void clear_camgpid() ;
  ::int32_t camgpid() const;
  void set_camgpid(::int32_t value);

  private:
  ::int32_t _internal_camgpid() const;
  void _internal_set_camgpid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BroadcastBatteleRes.ResInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint64_t objguid_;
    ::int32_t heroid_;
    ::int32_t curlevel_;
    ::int32_t killtimes_;
    ::int32_t deadtimes_;
    ::int32_t asstimes_;
    ::int32_t totalcp_;
    ::int32_t lasthit_;
    ::int32_t camgpid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BroadcastBattelePersonalRes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BroadcastBattelePersonalRes) */ {
 public:
  inline BroadcastBattelePersonalRes() : BroadcastBattelePersonalRes(nullptr) {}
  ~BroadcastBattelePersonalRes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastBattelePersonalRes(
      ::google::protobuf::internal::ConstantInitialized);

  inline BroadcastBattelePersonalRes(const BroadcastBattelePersonalRes& from) : BroadcastBattelePersonalRes(nullptr, from) {}
  inline BroadcastBattelePersonalRes(BroadcastBattelePersonalRes&& from) noexcept
      : BroadcastBattelePersonalRes(nullptr, std::move(from)) {}
  inline BroadcastBattelePersonalRes& operator=(const BroadcastBattelePersonalRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastBattelePersonalRes& operator=(BroadcastBattelePersonalRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastBattelePersonalRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastBattelePersonalRes* internal_default_instance() {
    return reinterpret_cast<const BroadcastBattelePersonalRes*>(
        &_BroadcastBattelePersonalRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 137;
  friend void swap(BroadcastBattelePersonalRes& a, BroadcastBattelePersonalRes& b) { a.Swap(&b); }
  inline void Swap(BroadcastBattelePersonalRes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastBattelePersonalRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastBattelePersonalRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BroadcastBattelePersonalRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BroadcastBattelePersonalRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BroadcastBattelePersonalRes& from) { BroadcastBattelePersonalRes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BroadcastBattelePersonalRes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BroadcastBattelePersonalRes"; }

 protected:
  explicit BroadcastBattelePersonalRes(::google::protobuf::Arena* arena);
  BroadcastBattelePersonalRes(::google::protobuf::Arena* arena, const BroadcastBattelePersonalRes& from);
  BroadcastBattelePersonalRes(::google::protobuf::Arena* arena, BroadcastBattelePersonalRes&& from) noexcept
      : BroadcastBattelePersonalRes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGotGoldFieldNumber = 2,
    kOldLvFieldNumber = 3,
    kOldExpFieldNumber = 4,
    kCurLvFieldNumber = 5,
    kCurExpFieldNumber = 6,
    kGotExpFieldNumber = 7,
    kMsgidFieldNumber = 1,
  };
  // optional int64 got_gold = 2;
  bool has_got_gold() const;
  void clear_got_gold() ;
  ::int64_t got_gold() const;
  void set_got_gold(::int64_t value);

  private:
  ::int64_t _internal_got_gold() const;
  void _internal_set_got_gold(::int64_t value);

  public:
  // optional int32 old_lv = 3;
  bool has_old_lv() const;
  void clear_old_lv() ;
  ::int32_t old_lv() const;
  void set_old_lv(::int32_t value);

  private:
  ::int32_t _internal_old_lv() const;
  void _internal_set_old_lv(::int32_t value);

  public:
  // optional int32 old_exp = 4;
  bool has_old_exp() const;
  void clear_old_exp() ;
  ::int32_t old_exp() const;
  void set_old_exp(::int32_t value);

  private:
  ::int32_t _internal_old_exp() const;
  void _internal_set_old_exp(::int32_t value);

  public:
  // optional int32 cur_lv = 5;
  bool has_cur_lv() const;
  void clear_cur_lv() ;
  ::int32_t cur_lv() const;
  void set_cur_lv(::int32_t value);

  private:
  ::int32_t _internal_cur_lv() const;
  void _internal_set_cur_lv(::int32_t value);

  public:
  // optional int32 cur_exp = 6;
  bool has_cur_exp() const;
  void clear_cur_exp() ;
  ::int32_t cur_exp() const;
  void set_cur_exp(::int32_t value);

  private:
  ::int32_t _internal_cur_exp() const;
  void _internal_set_cur_exp(::int32_t value);

  public:
  // optional int32 got_exp = 7;
  bool has_got_exp() const;
  void clear_got_exp() ;
  ::int32_t got_exp() const;
  void set_got_exp(::int32_t value);

  private:
  ::int32_t _internal_got_exp() const;
  void _internal_set_got_exp(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadBattlePersonalResult];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BroadcastBattelePersonalRes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t got_gold_;
    ::int32_t old_lv_;
    ::int32_t old_exp_;
    ::int32_t cur_lv_;
    ::int32_t cur_exp_;
    ::int32_t got_exp_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleStateChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleStateChange) */ {
 public:
  inline BattleStateChange() : BattleStateChange(nullptr) {}
  ~BattleStateChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleStateChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleStateChange(const BattleStateChange& from) : BattleStateChange(nullptr, from) {}
  inline BattleStateChange(BattleStateChange&& from) noexcept
      : BattleStateChange(nullptr, std::move(from)) {}
  inline BattleStateChange& operator=(const BattleStateChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleStateChange& operator=(BattleStateChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleStateChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleStateChange* internal_default_instance() {
    return reinterpret_cast<const BattleStateChange*>(
        &_BattleStateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 84;
  friend void swap(BattleStateChange& a, BattleStateChange& b) { a.Swap(&b); }
  inline void Swap(BattleStateChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleStateChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleStateChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleStateChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleStateChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleStateChange& from) { BattleStateChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleStateChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleStateChange"; }

 protected:
  explicit BattleStateChange(::google::protobuf::Arena* arena);
  BattleStateChange(::google::protobuf::Arena* arena, const BattleStateChange& from);
  BattleStateChange(::google::protobuf::Arena* arena, BattleStateChange&& from) noexcept
      : BattleStateChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kStateFieldNumber = 2,
    kStatetimeleftFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int32 state = 2;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional int32 statetimeleft = 3;
  bool has_statetimeleft() const;
  void clear_statetimeleft() ;
  ::int32_t statetimeleft() const;
  void set_statetimeleft(::int32_t value);

  private:
  ::int32_t _internal_statetimeleft() const;
  void _internal_set_statetimeleft(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleStateChange];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleStateChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t state_;
    ::int32_t statetimeleft_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleSpanTime final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleSpanTime) */ {
 public:
  inline BattleSpanTime() : BattleSpanTime(nullptr) {}
  ~BattleSpanTime() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleSpanTime(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleSpanTime(const BattleSpanTime& from) : BattleSpanTime(nullptr, from) {}
  inline BattleSpanTime(BattleSpanTime&& from) noexcept
      : BattleSpanTime(nullptr, std::move(from)) {}
  inline BattleSpanTime& operator=(const BattleSpanTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleSpanTime& operator=(BattleSpanTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleSpanTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleSpanTime* internal_default_instance() {
    return reinterpret_cast<const BattleSpanTime*>(
        &_BattleSpanTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 44;
  friend void swap(BattleSpanTime& a, BattleSpanTime& b) { a.Swap(&b); }
  inline void Swap(BattleSpanTime* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleSpanTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleSpanTime* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleSpanTime>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleSpanTime& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleSpanTime& from) { BattleSpanTime::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleSpanTime* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleSpanTime"; }

 protected:
  explicit BattleSpanTime(::google::protobuf::Arena* arena);
  BattleSpanTime(::google::protobuf::Arena* arena, const BattleSpanTime& from);
  BattleSpanTime(::google::protobuf::Arena* arena, BattleSpanTime&& from) noexcept
      : BattleSpanTime(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpanTimeFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int64 spanTime = 2;
  bool has_spantime() const;
  void clear_spantime() ;
  ::int64_t spantime() const;
  void set_spantime(::int64_t value);

  private:
  ::int64_t _internal_spantime() const;
  void _internal_set_spantime(::int64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleSpanTime];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleSpanTime)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t spantime_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleSeatPosInfo_PosInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleSeatPosInfo.PosInfo) */ {
 public:
  inline BattleSeatPosInfo_PosInfo() : BattleSeatPosInfo_PosInfo(nullptr) {}
  ~BattleSeatPosInfo_PosInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleSeatPosInfo_PosInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleSeatPosInfo_PosInfo(const BattleSeatPosInfo_PosInfo& from) : BattleSeatPosInfo_PosInfo(nullptr, from) {}
  inline BattleSeatPosInfo_PosInfo(BattleSeatPosInfo_PosInfo&& from) noexcept
      : BattleSeatPosInfo_PosInfo(nullptr, std::move(from)) {}
  inline BattleSeatPosInfo_PosInfo& operator=(const BattleSeatPosInfo_PosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleSeatPosInfo_PosInfo& operator=(BattleSeatPosInfo_PosInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleSeatPosInfo_PosInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleSeatPosInfo_PosInfo* internal_default_instance() {
    return reinterpret_cast<const BattleSeatPosInfo_PosInfo*>(
        &_BattleSeatPosInfo_PosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 82;
  friend void swap(BattleSeatPosInfo_PosInfo& a, BattleSeatPosInfo_PosInfo& b) { a.Swap(&b); }
  inline void Swap(BattleSeatPosInfo_PosInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleSeatPosInfo_PosInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleSeatPosInfo_PosInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleSeatPosInfo_PosInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleSeatPosInfo_PosInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleSeatPosInfo_PosInfo& from) { BattleSeatPosInfo_PosInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleSeatPosInfo_PosInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleSeatPosInfo.PosInfo"; }

 protected:
  explicit BattleSeatPosInfo_PosInfo(::google::protobuf::Arena* arena);
  BattleSeatPosInfo_PosInfo(::google::protobuf::Arena* arena, const BattleSeatPosInfo_PosInfo& from);
  BattleSeatPosInfo_PosInfo(::google::protobuf::Arena* arena, BattleSeatPosInfo_PosInfo&& from) noexcept
      : BattleSeatPosInfo_PosInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNicknameFieldNumber = 3,
    kGuidFieldNumber = 2,
    kPosFieldNumber = 1,
    kIfmasterFieldNumber = 4,
    kIfreadyFieldNumber = 5,
    kGoldFieldNumber = 7,
    kHeadidFieldNumber = 6,
  };
  // optional string nickname = 3;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 pos = 1;
  bool has_pos() const;
  void clear_pos() ;
  ::int32_t pos() const;
  void set_pos(::int32_t value);

  private:
  ::int32_t _internal_pos() const;
  void _internal_set_pos(::int32_t value);

  public:
  // optional bool ifmaster = 4;
  bool has_ifmaster() const;
  void clear_ifmaster() ;
  bool ifmaster() const;
  void set_ifmaster(bool value);

  private:
  bool _internal_ifmaster() const;
  void _internal_set_ifmaster(bool value);

  public:
  // optional bool ifready = 5;
  bool has_ifready() const;
  void clear_ifready() ;
  bool ifready() const;
  void set_ifready(bool value);

  private:
  bool _internal_ifready() const;
  void _internal_set_ifready(bool value);

  public:
  // optional int64 gold = 7;
  bool has_gold() const;
  void clear_gold() ;
  ::int64_t gold() const;
  void set_gold(::int64_t value);

  private:
  ::int64_t _internal_gold() const;
  void _internal_set_gold(::int64_t value);

  public:
  // optional int32 headid = 6;
  bool has_headid() const;
  void clear_headid() ;
  ::int32_t headid() const;
  void set_headid(::int32_t value);

  private:
  ::int32_t _internal_headid() const;
  void _internal_set_headid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleSeatPosInfo.PosInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      49, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::uint64_t guid_;
    ::int32_t pos_;
    bool ifmaster_;
    bool ifready_;
    ::int64_t gold_;
    ::int32_t headid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleMatcherCount final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleMatcherCount) */ {
 public:
  inline BattleMatcherCount() : BattleMatcherCount(nullptr) {}
  ~BattleMatcherCount() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleMatcherCount(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleMatcherCount(const BattleMatcherCount& from) : BattleMatcherCount(nullptr, from) {}
  inline BattleMatcherCount(BattleMatcherCount&& from) noexcept
      : BattleMatcherCount(nullptr, std::move(from)) {}
  inline BattleMatcherCount& operator=(const BattleMatcherCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleMatcherCount& operator=(BattleMatcherCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleMatcherCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleMatcherCount* internal_default_instance() {
    return reinterpret_cast<const BattleMatcherCount*>(
        &_BattleMatcherCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 43;
  friend void swap(BattleMatcherCount& a, BattleMatcherCount& b) { a.Swap(&b); }
  inline void Swap(BattleMatcherCount* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleMatcherCount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleMatcherCount* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleMatcherCount>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleMatcherCount& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleMatcherCount& from) { BattleMatcherCount::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleMatcherCount* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleMatcherCount"; }

 protected:
  explicit BattleMatcherCount(::google::protobuf::Arena* arena);
  BattleMatcherCount(::google::protobuf::Arena* arena, const BattleMatcherCount& from);
  BattleMatcherCount(::google::protobuf::Arena* arena, BattleMatcherCount&& from) noexcept
      : BattleMatcherCount(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCountFieldNumber = 2,
    kMaxcountFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int32 count = 2;
  bool has_count() const;
  void clear_count() ;
  ::int32_t count() const;
  void set_count(::int32_t value);

  private:
  ::int32_t _internal_count() const;
  void _internal_set_count(::int32_t value);

  public:
  // optional int32 maxcount = 3;
  bool has_maxcount() const;
  void clear_maxcount() ;
  ::int32_t maxcount() const;
  void set_maxcount(::int32_t value);

  private:
  ::int32_t _internal_maxcount() const;
  void _internal_set_maxcount(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleMatherCount];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleMatcherCount)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t count_;
    ::int32_t maxcount_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleLoadingState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleLoadingState) */ {
 public:
  inline BattleLoadingState() : BattleLoadingState(nullptr) {}
  ~BattleLoadingState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleLoadingState(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleLoadingState(const BattleLoadingState& from) : BattleLoadingState(nullptr, from) {}
  inline BattleLoadingState(BattleLoadingState&& from) noexcept
      : BattleLoadingState(nullptr, std::move(from)) {}
  inline BattleLoadingState& operator=(const BattleLoadingState& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleLoadingState& operator=(BattleLoadingState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleLoadingState& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleLoadingState* internal_default_instance() {
    return reinterpret_cast<const BattleLoadingState*>(
        &_BattleLoadingState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 100;
  friend void swap(BattleLoadingState& a, BattleLoadingState& b) { a.Swap(&b); }
  inline void Swap(BattleLoadingState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleLoadingState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleLoadingState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleLoadingState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleLoadingState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleLoadingState& from) { BattleLoadingState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleLoadingState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleLoadingState"; }

 protected:
  explicit BattleLoadingState(::google::protobuf::Arena* arena);
  BattleLoadingState(::google::protobuf::Arena* arena, const BattleLoadingState& from);
  BattleLoadingState(::google::protobuf::Arena* arena, BattleLoadingState&& from) noexcept
      : BattleLoadingState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kLoadperFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional int32 loadper = 3;
  bool has_loadper() const;
  void clear_loadper() ;
  ::int32_t loadper() const;
  void set_loadper(::int32_t value);

  private:
  ::int32_t _internal_loadper() const;
  void _internal_set_loadper(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleLoadingState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleLoadingState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t guid_;
    ::int32_t loadper_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleFinish final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleFinish) */ {
 public:
  inline BattleFinish() : BattleFinish(nullptr) {}
  ~BattleFinish() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleFinish(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleFinish(const BattleFinish& from) : BattleFinish(nullptr, from) {}
  inline BattleFinish(BattleFinish&& from) noexcept
      : BattleFinish(nullptr, std::move(from)) {}
  inline BattleFinish& operator=(const BattleFinish& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleFinish& operator=(BattleFinish&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleFinish& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleFinish* internal_default_instance() {
    return reinterpret_cast<const BattleFinish*>(
        &_BattleFinish_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 117;
  friend void swap(BattleFinish& a, BattleFinish& b) { a.Swap(&b); }
  inline void Swap(BattleFinish* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleFinish* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleFinish* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleFinish>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleFinish& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleFinish& from) { BattleFinish::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleFinish* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleFinish"; }

 protected:
  explicit BattleFinish(::google::protobuf::Arena* arena);
  BattleFinish(::google::protobuf::Arena* arena, const BattleFinish& from);
  BattleFinish(::google::protobuf::Arena* arena, BattleFinish&& from) noexcept
      : BattleFinish(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBulidguidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 bulidguid = 2;
  bool has_bulidguid() const;
  void clear_bulidguid() ;
  ::uint64_t bulidguid() const;
  void set_bulidguid(::uint64_t value);

  private:
  ::uint64_t _internal_bulidguid() const;
  void _internal_set_bulidguid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleFinish];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleFinish)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t bulidguid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleDelayTime final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleDelayTime) */ {
 public:
  inline BattleDelayTime() : BattleDelayTime(nullptr) {}
  ~BattleDelayTime() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleDelayTime(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleDelayTime(const BattleDelayTime& from) : BattleDelayTime(nullptr, from) {}
  inline BattleDelayTime(BattleDelayTime&& from) noexcept
      : BattleDelayTime(nullptr, std::move(from)) {}
  inline BattleDelayTime& operator=(const BattleDelayTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleDelayTime& operator=(BattleDelayTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleDelayTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleDelayTime* internal_default_instance() {
    return reinterpret_cast<const BattleDelayTime*>(
        &_BattleDelayTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 45;
  friend void swap(BattleDelayTime& a, BattleDelayTime& b) { a.Swap(&b); }
  inline void Swap(BattleDelayTime* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleDelayTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleDelayTime* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleDelayTime>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleDelayTime& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleDelayTime& from) { BattleDelayTime::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleDelayTime* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleDelayTime"; }

 protected:
  explicit BattleDelayTime(::google::protobuf::Arena* arena);
  BattleDelayTime(::google::protobuf::Arena* arena, const BattleDelayTime& from);
  BattleDelayTime(::google::protobuf::Arena* arena, BattleDelayTime&& from) noexcept
      : BattleDelayTime(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDelayTimeFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional int64 delayTime = 2;
  bool has_delaytime() const;
  void clear_delaytime() ;
  ::int64_t delaytime() const;
  void set_delaytime(::int64_t value);

  private:
  ::int64_t _internal_delaytime() const;
  void _internal_set_delaytime(::int64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleDelayTime];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleDelayTime)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t delaytime_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleBaseInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleBaseInfo) */ {
 public:
  inline BattleBaseInfo() : BattleBaseInfo(nullptr) {}
  ~BattleBaseInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleBaseInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleBaseInfo(const BattleBaseInfo& from) : BattleBaseInfo(nullptr, from) {}
  inline BattleBaseInfo(BattleBaseInfo&& from) noexcept
      : BattleBaseInfo(nullptr, std::move(from)) {}
  inline BattleBaseInfo& operator=(const BattleBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleBaseInfo& operator=(BattleBaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleBaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleBaseInfo* internal_default_instance() {
    return reinterpret_cast<const BattleBaseInfo*>(
        &_BattleBaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 80;
  friend void swap(BattleBaseInfo& a, BattleBaseInfo& b) { a.Swap(&b); }
  inline void Swap(BattleBaseInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleBaseInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleBaseInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleBaseInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleBaseInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleBaseInfo& from) { BattleBaseInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleBaseInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleBaseInfo"; }

 protected:
  explicit BattleBaseInfo(::google::protobuf::Arena* arena);
  BattleBaseInfo(::google::protobuf::Arena* arena, const BattleBaseInfo& from);
  BattleBaseInfo(::google::protobuf::Arena* arena, BattleBaseInfo&& from) noexcept
      : BattleBaseInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBattleidFieldNumber = 2,
    kMapidFieldNumber = 3,
    kIfReconnectFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::uint64_t battleid() const;
  void set_battleid(::uint64_t value);

  private:
  ::uint64_t _internal_battleid() const;
  void _internal_set_battleid(::uint64_t value);

  public:
  // optional uint32 mapid = 3;
  bool has_mapid() const;
  void clear_mapid() ;
  ::uint32_t mapid() const;
  void set_mapid(::uint32_t value);

  private:
  ::uint32_t _internal_mapid() const;
  void _internal_set_mapid(::uint32_t value);

  public:
  // optional bool ifReconnect = 4;
  bool has_ifreconnect() const;
  void clear_ifreconnect() ;
  bool ifreconnect() const;
  void set_ifreconnect(bool value);

  private:
  bool _internal_ifreconnect() const;
  void _internal_set_ifreconnect(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleBaseInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleBaseInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t battleid_;
    ::uint32_t mapid_;
    bool ifreconnect_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class AskRet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.AskRet) */ {
 public:
  inline AskRet() : AskRet(nullptr) {}
  ~AskRet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRet(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRet(const AskRet& from) : AskRet(nullptr, from) {}
  inline AskRet(AskRet&& from) noexcept
      : AskRet(nullptr, std::move(from)) {}
  inline AskRet& operator=(const AskRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRet& operator=(AskRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRet* internal_default_instance() {
    return reinterpret_cast<const AskRet*>(
        &_AskRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 76;
  friend void swap(AskRet& a, AskRet& b) { a.Swap(&b); }
  inline void Swap(AskRet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRet& from) { AskRet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.AskRet"; }

 protected:
  explicit AskRet(::google::protobuf::Arena* arena);
  AskRet(::google::protobuf::Arena* arena, const AskRet& from);
  AskRet(::google::protobuf::Arena* arena, AskRet&& from) noexcept
      : AskRet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAskidFieldNumber = 2,
    kErrorcodeFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional int32 askid = 2;
  bool has_askid() const;
  void clear_askid() ;
  ::int32_t askid() const;
  void set_askid(::int32_t value);

  private:
  ::int32_t _internal_askid() const;
  void _internal_set_askid(::int32_t value);

  public:
  // optional int32 errorcode = 3;
  bool has_errorcode() const;
  void clear_errorcode() ;
  ::int32_t errorcode() const;
  void set_errorcode(::int32_t value);

  private:
  ::int32_t _internal_errorcode() const;
  void _internal_set_errorcode(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GCAskRet];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.AskRet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t askid_;
    ::int32_t errorcode_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class AltarBSIco final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.AltarBSIco) */ {
 public:
  inline AltarBSIco() : AltarBSIco(nullptr) {}
  ~AltarBSIco() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AltarBSIco(
      ::google::protobuf::internal::ConstantInitialized);

  inline AltarBSIco(const AltarBSIco& from) : AltarBSIco(nullptr, from) {}
  inline AltarBSIco(AltarBSIco&& from) noexcept
      : AltarBSIco(nullptr, std::move(from)) {}
  inline AltarBSIco& operator=(const AltarBSIco& from) {
    CopyFrom(from);
    return *this;
  }
  inline AltarBSIco& operator=(AltarBSIco&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AltarBSIco& default_instance() {
    return *internal_default_instance();
  }
  static inline const AltarBSIco* internal_default_instance() {
    return reinterpret_cast<const AltarBSIco*>(
        &_AltarBSIco_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 144;
  friend void swap(AltarBSIco& a, AltarBSIco& b) { a.Swap(&b); }
  inline void Swap(AltarBSIco* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AltarBSIco* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AltarBSIco* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AltarBSIco>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AltarBSIco& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AltarBSIco& from) { AltarBSIco::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AltarBSIco* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.AltarBSIco"; }

 protected:
  explicit AltarBSIco(::google::protobuf::Arena* arena);
  AltarBSIco(::google::protobuf::Arena* arena, const AltarBSIco& from);
  AltarBSIco(::google::protobuf::Arena* arena, AltarBSIco&& from) noexcept
      : AltarBSIco(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 2,
    kTypeFieldNumber = 3,
    kOptypeFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional int32 index = 2;
  bool has_index() const;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // optional int32 type = 3;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional int32 optype = 4;
  bool has_optype() const;
  void clear_optype() ;
  ::int32_t optype() const;
  void set_optype(::int32_t value);

  private:
  ::int32_t _internal_optype() const;
  void _internal_set_optype(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAltarBSIco];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.AltarBSIco)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t index_;
    ::int32_t type_;
    ::int32_t optype_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class AbsorbRes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.AbsorbRes) */ {
 public:
  inline AbsorbRes() : AbsorbRes(nullptr) {}
  ~AbsorbRes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AbsorbRes(
      ::google::protobuf::internal::ConstantInitialized);

  inline AbsorbRes(const AbsorbRes& from) : AbsorbRes(nullptr, from) {}
  inline AbsorbRes(AbsorbRes&& from) noexcept
      : AbsorbRes(nullptr, std::move(from)) {}
  inline AbsorbRes& operator=(const AbsorbRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsorbRes& operator=(AbsorbRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbsorbRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbsorbRes* internal_default_instance() {
    return reinterpret_cast<const AbsorbRes*>(
        &_AbsorbRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 121;
  friend void swap(AbsorbRes& a, AbsorbRes& b) { a.Swap(&b); }
  inline void Swap(AbsorbRes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsorbRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbsorbRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AbsorbRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbsorbRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AbsorbRes& from) { AbsorbRes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AbsorbRes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.AbsorbRes"; }

 protected:
  explicit AbsorbRes(::google::protobuf::Arena* arena);
  AbsorbRes(::google::protobuf::Arena* arena, const AbsorbRes& from);
  AbsorbRes(::google::protobuf::Arena* arena, AbsorbRes&& from) noexcept
      : AbsorbRes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kResFieldNumber = 3,
    kAbsorb1FieldNumber = 4,
    kAbsorb2FieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional bool res = 3;
  bool has_res() const;
  void clear_res() ;
  bool res() const;
  void set_res(bool value);

  private:
  bool _internal_res() const;
  void _internal_set_res(bool value);

  public:
  // optional int32 absorb1 = 4;
  bool has_absorb1() const;
  void clear_absorb1() ;
  ::int32_t absorb1() const;
  void set_absorb1(::int32_t value);

  private:
  ::int32_t _internal_absorb1() const;
  void _internal_set_absorb1(::int32_t value);

  public:
  // optional int32 absorb2 = 5;
  bool has_absorb2() const;
  void clear_absorb2() ;
  ::int32_t absorb2() const;
  void set_absorb2(::int32_t value);

  private:
  ::int32_t _internal_absorb2() const;
  void _internal_set_absorb2(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAbsorbMonsterResult];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.AbsorbRes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    bool res_;
    ::int32_t absorb1_;
    ::int32_t absorb2_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class AbsorbBegin final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.AbsorbBegin) */ {
 public:
  inline AbsorbBegin() : AbsorbBegin(nullptr) {}
  ~AbsorbBegin() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AbsorbBegin(
      ::google::protobuf::internal::ConstantInitialized);

  inline AbsorbBegin(const AbsorbBegin& from) : AbsorbBegin(nullptr, from) {}
  inline AbsorbBegin(AbsorbBegin&& from) noexcept
      : AbsorbBegin(nullptr, std::move(from)) {}
  inline AbsorbBegin& operator=(const AbsorbBegin& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsorbBegin& operator=(AbsorbBegin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AbsorbBegin& default_instance() {
    return *internal_default_instance();
  }
  static inline const AbsorbBegin* internal_default_instance() {
    return reinterpret_cast<const AbsorbBegin*>(
        &_AbsorbBegin_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 120;
  friend void swap(AbsorbBegin& a, AbsorbBegin& b) { a.Swap(&b); }
  inline void Swap(AbsorbBegin* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsorbBegin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AbsorbBegin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AbsorbBegin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AbsorbBegin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AbsorbBegin& from) { AbsorbBegin::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AbsorbBegin* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.AbsorbBegin"; }

 protected:
  explicit AbsorbBegin(::google::protobuf::Arena* arena);
  AbsorbBegin(::google::protobuf::Arena* arena, const AbsorbBegin& from);
  AbsorbBegin(::google::protobuf::Arena* arena, AbsorbBegin&& from) noexcept
      : AbsorbBegin(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kMonsterguidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint64 monsterguid = 3;
  bool has_monsterguid() const;
  void clear_monsterguid() ;
  ::uint64_t monsterguid() const;
  void set_monsterguid(::uint64_t value);

  private:
  ::uint64_t _internal_monsterguid() const;
  void _internal_set_monsterguid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAbsorbBegin];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.AbsorbBegin)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint64_t monsterguid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class UsingSkillState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.UsingSkillState) */ {
 public:
  inline UsingSkillState() : UsingSkillState(nullptr) {}
  ~UsingSkillState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UsingSkillState(
      ::google::protobuf::internal::ConstantInitialized);

  inline UsingSkillState(const UsingSkillState& from) : UsingSkillState(nullptr, from) {}
  inline UsingSkillState(UsingSkillState&& from) noexcept
      : UsingSkillState(nullptr, std::move(from)) {}
  inline UsingSkillState& operator=(const UsingSkillState& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsingSkillState& operator=(UsingSkillState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsingSkillState& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsingSkillState* internal_default_instance() {
    return reinterpret_cast<const UsingSkillState*>(
        &_UsingSkillState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 95;
  friend void swap(UsingSkillState& a, UsingSkillState& b) { a.Swap(&b); }
  inline void Swap(UsingSkillState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsingSkillState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsingSkillState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UsingSkillState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UsingSkillState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UsingSkillState& from) { UsingSkillState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UsingSkillState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.UsingSkillState"; }

 protected:
  explicit UsingSkillState(::google::protobuf::Arena* arena);
  UsingSkillState(::google::protobuf::Arena* arena, const UsingSkillState& from);
  UsingSkillState(::google::protobuf::Arena* arena, UsingSkillState&& from) noexcept
      : UsingSkillState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 4,
    kDirFieldNumber = 5,
    kObjguidFieldNumber = 2,
    kTarguidFieldNumber = 6,
    kSkillidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional uint64 targuid = 6;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectUsingSkillState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.UsingSkillState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t objguid_;
    ::uint64_t targuid_;
    ::int32_t skillid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class SkillEntityInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.SkillEntityInfo) */ {
 public:
  inline SkillEntityInfo() : SkillEntityInfo(nullptr) {}
  ~SkillEntityInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SkillEntityInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SkillEntityInfo(const SkillEntityInfo& from) : SkillEntityInfo(nullptr, from) {}
  inline SkillEntityInfo(SkillEntityInfo&& from) noexcept
      : SkillEntityInfo(nullptr, std::move(from)) {}
  inline SkillEntityInfo& operator=(const SkillEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkillEntityInfo& operator=(SkillEntityInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SkillEntityInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SkillEntityInfo* internal_default_instance() {
    return reinterpret_cast<const SkillEntityInfo*>(
        &_SkillEntityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 109;
  friend void swap(SkillEntityInfo& a, SkillEntityInfo& b) { a.Swap(&b); }
  inline void Swap(SkillEntityInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SkillEntityInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SkillEntityInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SkillEntityInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SkillEntityInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SkillEntityInfo& from) { SkillEntityInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SkillEntityInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.SkillEntityInfo"; }

 protected:
  explicit SkillEntityInfo(::google::protobuf::Arena* arena);
  SkillEntityInfo(::google::protobuf::Arena* arena, const SkillEntityInfo& from);
  SkillEntityInfo(::google::protobuf::Arena* arena, SkillEntityInfo&& from) noexcept
      : SkillEntityInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirFieldNumber = 4,
    kTardirFieldNumber = 7,
    kGuidFieldNumber = 2,
    kTarguidFieldNumber = 5,
    kUniqueidFieldNumber = 6,
    kSkillidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Dir dir = 4;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional .GSToGC.Dir tardir = 7;
  bool has_tardir() const;
  void clear_tardir() ;
  const ::GSToGC::Dir& tardir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_tardir();
  ::GSToGC::Dir* mutable_tardir();
  void set_allocated_tardir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_tardir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_tardir();

  private:
  const ::GSToGC::Dir& _internal_tardir() const;
  ::GSToGC::Dir* _internal_mutable_tardir();

  public:
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional int64 targuid = 5;
  bool has_targuid() const;
  void clear_targuid() ;
  ::int64_t targuid() const;
  void set_targuid(::int64_t value);

  private:
  ::int64_t _internal_targuid() const;
  void _internal_set_targuid(::int64_t value);

  public:
  // optional int64 uniqueid = 6;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::int64_t uniqueid() const;
  void set_uniqueid(::int64_t value);

  private:
  ::int64_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::int64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillEntityInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.SkillEntityInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Dir* dir_;
    ::GSToGC::Dir* tardir_;
    ::int64_t guid_;
    ::int64_t targuid_;
    ::int64_t uniqueid_;
    ::int32_t skillid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class SecondGuideTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.SecondGuideTask) */ {
 public:
  inline SecondGuideTask() : SecondGuideTask(nullptr) {}
  ~SecondGuideTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SecondGuideTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline SecondGuideTask(const SecondGuideTask& from) : SecondGuideTask(nullptr, from) {}
  inline SecondGuideTask(SecondGuideTask&& from) noexcept
      : SecondGuideTask(nullptr, std::move(from)) {}
  inline SecondGuideTask& operator=(const SecondGuideTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecondGuideTask& operator=(SecondGuideTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecondGuideTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecondGuideTask* internal_default_instance() {
    return reinterpret_cast<const SecondGuideTask*>(
        &_SecondGuideTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 48;
  friend void swap(SecondGuideTask& a, SecondGuideTask& b) { a.Swap(&b); }
  inline void Swap(SecondGuideTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecondGuideTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecondGuideTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SecondGuideTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SecondGuideTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SecondGuideTask& from) { SecondGuideTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SecondGuideTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.SecondGuideTask"; }

 protected:
  explicit SecondGuideTask(::google::protobuf::Arena* arena);
  SecondGuideTask(::google::protobuf::Arena* arena, const SecondGuideTask& from);
  SecondGuideTask(::google::protobuf::Arena* arena, SecondGuideTask&& from) noexcept
      : SecondGuideTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using task_info = SecondGuideTask_task_info;

  // accessors -------------------------------------------------------
  enum : int {
    kTaskinfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.SecondGuideTask.task_info taskinfo = 2;
  int taskinfo_size() const;
  private:
  int _internal_taskinfo_size() const;

  public:
  void clear_taskinfo() ;
  ::GSToGC::SecondGuideTask_task_info* mutable_taskinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>* mutable_taskinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>& _internal_taskinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>* _internal_mutable_taskinfo();
  public:
  const ::GSToGC::SecondGuideTask_task_info& taskinfo(int index) const;
  ::GSToGC::SecondGuideTask_task_info* add_taskinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>& taskinfo() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGs_NotifySecondaryGuideTask];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.SecondGuideTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::SecondGuideTask_task_info > taskinfo_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RunningState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RunningState) */ {
 public:
  inline RunningState() : RunningState(nullptr) {}
  ~RunningState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RunningState(
      ::google::protobuf::internal::ConstantInitialized);

  inline RunningState(const RunningState& from) : RunningState(nullptr, from) {}
  inline RunningState(RunningState&& from) noexcept
      : RunningState(nullptr, std::move(from)) {}
  inline RunningState& operator=(const RunningState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunningState& operator=(RunningState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunningState& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunningState* internal_default_instance() {
    return reinterpret_cast<const RunningState*>(
        &_RunningState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 92;
  friend void swap(RunningState& a, RunningState& b) { a.Swap(&b); }
  inline void Swap(RunningState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunningState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunningState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RunningState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunningState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RunningState& from) { RunningState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunningState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RunningState"; }

 protected:
  explicit RunningState(::google::protobuf::Arena* arena);
  RunningState(::google::protobuf::Arena* arena, const RunningState& from);
  RunningState(::google::protobuf::Arena* arena, RunningState&& from) noexcept
      : RunningState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 3,
    kDirFieldNumber = 4,
    kObjguidFieldNumber = 2,
    kMovespeedFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 4;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional int32 movespeed = 5;
  bool has_movespeed() const;
  void clear_movespeed() ;
  ::int32_t movespeed() const;
  void set_movespeed(::int32_t value);

  private:
  ::int32_t _internal_movespeed() const;
  void _internal_set_movespeed(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectRunState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RunningState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t objguid_;
    ::int32_t movespeed_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class ReleasingSkillState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.ReleasingSkillState) */ {
 public:
  inline ReleasingSkillState() : ReleasingSkillState(nullptr) {}
  ~ReleasingSkillState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReleasingSkillState(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReleasingSkillState(const ReleasingSkillState& from) : ReleasingSkillState(nullptr, from) {}
  inline ReleasingSkillState(ReleasingSkillState&& from) noexcept
      : ReleasingSkillState(nullptr, std::move(from)) {}
  inline ReleasingSkillState& operator=(const ReleasingSkillState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReleasingSkillState& operator=(ReleasingSkillState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReleasingSkillState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReleasingSkillState* internal_default_instance() {
    return reinterpret_cast<const ReleasingSkillState*>(
        &_ReleasingSkillState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 94;
  friend void swap(ReleasingSkillState& a, ReleasingSkillState& b) { a.Swap(&b); }
  inline void Swap(ReleasingSkillState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReleasingSkillState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReleasingSkillState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReleasingSkillState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReleasingSkillState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReleasingSkillState& from) { ReleasingSkillState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReleasingSkillState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.ReleasingSkillState"; }

 protected:
  explicit ReleasingSkillState(::google::protobuf::Arena* arena);
  ReleasingSkillState(::google::protobuf::Arena* arena, const ReleasingSkillState& from);
  ReleasingSkillState(::google::protobuf::Arena* arena, ReleasingSkillState&& from) noexcept
      : ReleasingSkillState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 4,
    kDirFieldNumber = 5,
    kObjguidFieldNumber = 2,
    kTarguidFieldNumber = 6,
    kSkillidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional uint64 targuid = 6;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectReleaseSkillState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.ReleasingSkillState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t objguid_;
    ::uint64_t targuid_;
    ::int32_t skillid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class RangeEffect final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.RangeEffect) */ {
 public:
  inline RangeEffect() : RangeEffect(nullptr) {}
  ~RangeEffect() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RangeEffect(
      ::google::protobuf::internal::ConstantInitialized);

  inline RangeEffect(const RangeEffect& from) : RangeEffect(nullptr, from) {}
  inline RangeEffect(RangeEffect&& from) noexcept
      : RangeEffect(nullptr, std::move(from)) {}
  inline RangeEffect& operator=(const RangeEffect& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeEffect& operator=(RangeEffect&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeEffect& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeEffect* internal_default_instance() {
    return reinterpret_cast<const RangeEffect*>(
        &_RangeEffect_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 150;
  friend void swap(RangeEffect& a, RangeEffect& b) { a.Swap(&b); }
  inline void Swap(RangeEffect* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeEffect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeEffect* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RangeEffect>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RangeEffect& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RangeEffect& from) { RangeEffect::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RangeEffect* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.RangeEffect"; }

 protected:
  explicit RangeEffect(::google::protobuf::Arena* arena);
  RangeEffect(::google::protobuf::Arena* arena, const RangeEffect& from);
  RangeEffect(::google::protobuf::Arena* arena, RangeEffect&& from) noexcept
      : RangeEffect(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirFieldNumber = 5,
    kPosFieldNumber = 6,
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kUniqueidFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Dir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional .GSToGC.Pos pos = 6;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::uint32_t effectid() const;
  void set_effectid(::uint32_t value);

  private:
  ::uint32_t _internal_effectid() const;
  void _internal_set_effectid(::uint32_t value);

  public:
  // optional uint32 uniqueid = 4;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::uint32_t uniqueid() const;
  void set_uniqueid(::uint32_t value);

  private:
  ::uint32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelRange];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.RangeEffect)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Dir* dir_;
    ::GSToGC::Pos* pos_;
    ::uint64_t guid_;
    ::uint32_t effectid_;
    ::uint32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class PrepareSkillState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.PrepareSkillState) */ {
 public:
  inline PrepareSkillState() : PrepareSkillState(nullptr) {}
  ~PrepareSkillState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PrepareSkillState(
      ::google::protobuf::internal::ConstantInitialized);

  inline PrepareSkillState(const PrepareSkillState& from) : PrepareSkillState(nullptr, from) {}
  inline PrepareSkillState(PrepareSkillState&& from) noexcept
      : PrepareSkillState(nullptr, std::move(from)) {}
  inline PrepareSkillState& operator=(const PrepareSkillState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareSkillState& operator=(PrepareSkillState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrepareSkillState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrepareSkillState* internal_default_instance() {
    return reinterpret_cast<const PrepareSkillState*>(
        &_PrepareSkillState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 93;
  friend void swap(PrepareSkillState& a, PrepareSkillState& b) { a.Swap(&b); }
  inline void Swap(PrepareSkillState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrepareSkillState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrepareSkillState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<PrepareSkillState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PrepareSkillState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PrepareSkillState& from) { PrepareSkillState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PrepareSkillState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.PrepareSkillState"; }

 protected:
  explicit PrepareSkillState(::google::protobuf::Arena* arena);
  PrepareSkillState(::google::protobuf::Arena* arena, const PrepareSkillState& from);
  PrepareSkillState(::google::protobuf::Arena* arena, PrepareSkillState&& from) noexcept
      : PrepareSkillState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 4,
    kDirFieldNumber = 5,
    kObjguidFieldNumber = 2,
    kSkillidFieldNumber = 3,
    kSpeedFieldNumber = 7,
    kTarguidFieldNumber = 6,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional int32 speed = 7;
  bool has_speed() const;
  void clear_speed() ;
  ::int32_t speed() const;
  void set_speed(::int32_t value);

  private:
  ::int32_t _internal_speed() const;
  void _internal_set_speed(::int32_t value);

  public:
  // optional uint64 targuid = 6;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectPrepareSkillState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.PrepareSkillState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t objguid_;
    ::int32_t skillid_;
    ::int32_t speed_;
    ::uint64_t targuid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUserSNSList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUserSNSList) */ {
 public:
  inline NotifyUserSNSList() : NotifyUserSNSList(nullptr) {}
  ~NotifyUserSNSList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUserSNSList(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUserSNSList(const NotifyUserSNSList& from) : NotifyUserSNSList(nullptr, from) {}
  inline NotifyUserSNSList(NotifyUserSNSList&& from) noexcept
      : NotifyUserSNSList(nullptr, std::move(from)) {}
  inline NotifyUserSNSList& operator=(const NotifyUserSNSList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUserSNSList& operator=(NotifyUserSNSList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUserSNSList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUserSNSList* internal_default_instance() {
    return reinterpret_cast<const NotifyUserSNSList*>(
        &_NotifyUserSNSList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 63;
  friend void swap(NotifyUserSNSList& a, NotifyUserSNSList& b) { a.Swap(&b); }
  inline void Swap(NotifyUserSNSList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUserSNSList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUserSNSList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUserSNSList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUserSNSList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUserSNSList& from) { NotifyUserSNSList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUserSNSList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUserSNSList"; }

 protected:
  explicit NotifyUserSNSList(::google::protobuf::Arena* arena);
  NotifyUserSNSList(::google::protobuf::Arena* arena, const NotifyUserSNSList& from);
  NotifyUserSNSList(::google::protobuf::Arena* arena, NotifyUserSNSList&& from) noexcept
      : NotifyUserSNSList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // repeated .GSToGC.SNSInfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::SNSInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>* _internal_mutable_info();
  public:
  const ::GSToGC::SNSInfo& info(int index) const;
  ::GSToGC::SNSInfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>& info() const;
  // optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyUserSNSList];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GSToGC::MsgID msgnum() const;
  void set_msgnum(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgnum() const;
  void _internal_set_msgnum(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUserSNSList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::SNSInfo > info_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUpdateOneTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUpdateOneTask) */ {
 public:
  inline NotifyUpdateOneTask() : NotifyUpdateOneTask(nullptr) {}
  ~NotifyUpdateOneTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUpdateOneTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUpdateOneTask(const NotifyUpdateOneTask& from) : NotifyUpdateOneTask(nullptr, from) {}
  inline NotifyUpdateOneTask(NotifyUpdateOneTask&& from) noexcept
      : NotifyUpdateOneTask(nullptr, std::move(from)) {}
  inline NotifyUpdateOneTask& operator=(const NotifyUpdateOneTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUpdateOneTask& operator=(NotifyUpdateOneTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUpdateOneTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUpdateOneTask* internal_default_instance() {
    return reinterpret_cast<const NotifyUpdateOneTask*>(
        &_NotifyUpdateOneTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(NotifyUpdateOneTask& a, NotifyUpdateOneTask& b) { a.Swap(&b); }
  inline void Swap(NotifyUpdateOneTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUpdateOneTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUpdateOneTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUpdateOneTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUpdateOneTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUpdateOneTask& from) { NotifyUpdateOneTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUpdateOneTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUpdateOneTask"; }

 protected:
  explicit NotifyUpdateOneTask(::google::protobuf::Arena* arena);
  NotifyUpdateOneTask(::google::protobuf::Arena* arena, const NotifyUpdateOneTask& from);
  NotifyUpdateOneTask(::google::protobuf::Arena* arena, NotifyUpdateOneTask&& from) noexcept
      : NotifyUpdateOneTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOneTaskFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.TaskData oneTask = 2;
  bool has_onetask() const;
  void clear_onetask() ;
  const ::GSToGC::TaskData& onetask() const;
  PROTOBUF_NODISCARD ::GSToGC::TaskData* release_onetask();
  ::GSToGC::TaskData* mutable_onetask();
  void set_allocated_onetask(::GSToGC::TaskData* value);
  void unsafe_arena_set_allocated_onetask(::GSToGC::TaskData* value);
  ::GSToGC::TaskData* unsafe_arena_release_onetask();

  private:
  const ::GSToGC::TaskData& _internal_onetask() const;
  ::GSToGC::TaskData* _internal_mutable_onetask();

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UpdateOneTask];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUpdateOneTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::TaskData* onetask_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUpdateAllTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUpdateAllTask) */ {
 public:
  inline NotifyUpdateAllTask() : NotifyUpdateAllTask(nullptr) {}
  ~NotifyUpdateAllTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUpdateAllTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUpdateAllTask(const NotifyUpdateAllTask& from) : NotifyUpdateAllTask(nullptr, from) {}
  inline NotifyUpdateAllTask(NotifyUpdateAllTask&& from) noexcept
      : NotifyUpdateAllTask(nullptr, std::move(from)) {}
  inline NotifyUpdateAllTask& operator=(const NotifyUpdateAllTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUpdateAllTask& operator=(NotifyUpdateAllTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUpdateAllTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUpdateAllTask* internal_default_instance() {
    return reinterpret_cast<const NotifyUpdateAllTask*>(
        &_NotifyUpdateAllTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(NotifyUpdateAllTask& a, NotifyUpdateAllTask& b) { a.Swap(&b); }
  inline void Swap(NotifyUpdateAllTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUpdateAllTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUpdateAllTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUpdateAllTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUpdateAllTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUpdateAllTask& from) { NotifyUpdateAllTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUpdateAllTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUpdateAllTask"; }

 protected:
  explicit NotifyUpdateAllTask(::google::protobuf::Arena* arena);
  NotifyUpdateAllTask(::google::protobuf::Arena* arena, const NotifyUpdateAllTask& from);
  NotifyUpdateAllTask(::google::protobuf::Arena* arena, NotifyUpdateAllTask&& from) noexcept
      : NotifyUpdateAllTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskListFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.TaskData taskList = 2;
  int tasklist_size() const;
  private:
  int _internal_tasklist_size() const;

  public:
  void clear_tasklist() ;
  ::GSToGC::TaskData* mutable_tasklist(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>* mutable_tasklist();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>& _internal_tasklist() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>* _internal_mutable_tasklist();
  public:
  const ::GSToGC::TaskData& tasklist(int index) const;
  ::GSToGC::TaskData* add_tasklist();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>& tasklist() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UpdateAllTask];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUpdateAllTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::TaskData > tasklist_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyUpdateAllDailyTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyUpdateAllDailyTask) */ {
 public:
  inline NotifyUpdateAllDailyTask() : NotifyUpdateAllDailyTask(nullptr) {}
  ~NotifyUpdateAllDailyTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyUpdateAllDailyTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyUpdateAllDailyTask(const NotifyUpdateAllDailyTask& from) : NotifyUpdateAllDailyTask(nullptr, from) {}
  inline NotifyUpdateAllDailyTask(NotifyUpdateAllDailyTask&& from) noexcept
      : NotifyUpdateAllDailyTask(nullptr, std::move(from)) {}
  inline NotifyUpdateAllDailyTask& operator=(const NotifyUpdateAllDailyTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyUpdateAllDailyTask& operator=(NotifyUpdateAllDailyTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyUpdateAllDailyTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyUpdateAllDailyTask* internal_default_instance() {
    return reinterpret_cast<const NotifyUpdateAllDailyTask*>(
        &_NotifyUpdateAllDailyTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NotifyUpdateAllDailyTask& a, NotifyUpdateAllDailyTask& b) { a.Swap(&b); }
  inline void Swap(NotifyUpdateAllDailyTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyUpdateAllDailyTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyUpdateAllDailyTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyUpdateAllDailyTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyUpdateAllDailyTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyUpdateAllDailyTask& from) { NotifyUpdateAllDailyTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyUpdateAllDailyTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyUpdateAllDailyTask"; }

 protected:
  explicit NotifyUpdateAllDailyTask(::google::protobuf::Arena* arena);
  NotifyUpdateAllDailyTask(::google::protobuf::Arena* arena, const NotifyUpdateAllDailyTask& from);
  NotifyUpdateAllDailyTask(::google::protobuf::Arena* arena, NotifyUpdateAllDailyTask&& from) noexcept
      : NotifyUpdateAllDailyTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTaskListFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.TaskData taskList = 2;
  int tasklist_size() const;
  private:
  int _internal_tasklist_size() const;

  public:
  void clear_tasklist() ;
  ::GSToGC::TaskData* mutable_tasklist(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>* mutable_tasklist();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>& _internal_tasklist() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>* _internal_mutable_tasklist();
  public:
  const ::GSToGC::TaskData& tasklist(int index) const;
  ::GSToGC::TaskData* add_tasklist();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>& tasklist() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UpdateAllDailyTask];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyUpdateAllDailyTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::TaskData > tasklist_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySummonLifeTime final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySummonLifeTime) */ {
 public:
  inline NotifySummonLifeTime() : NotifySummonLifeTime(nullptr) {}
  ~NotifySummonLifeTime() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySummonLifeTime(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySummonLifeTime(const NotifySummonLifeTime& from) : NotifySummonLifeTime(nullptr, from) {}
  inline NotifySummonLifeTime(NotifySummonLifeTime&& from) noexcept
      : NotifySummonLifeTime(nullptr, std::move(from)) {}
  inline NotifySummonLifeTime& operator=(const NotifySummonLifeTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySummonLifeTime& operator=(NotifySummonLifeTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySummonLifeTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySummonLifeTime* internal_default_instance() {
    return reinterpret_cast<const NotifySummonLifeTime*>(
        &_NotifySummonLifeTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 154;
  friend void swap(NotifySummonLifeTime& a, NotifySummonLifeTime& b) { a.Swap(&b); }
  inline void Swap(NotifySummonLifeTime* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySummonLifeTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySummonLifeTime* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySummonLifeTime>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySummonLifeTime& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySummonLifeTime& from) { NotifySummonLifeTime::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySummonLifeTime* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySummonLifeTime"; }

 protected:
  explicit NotifySummonLifeTime(::google::protobuf::Arena* arena);
  NotifySummonLifeTime(::google::protobuf::Arena* arena, const NotifySummonLifeTime& from);
  NotifySummonLifeTime(::google::protobuf::Arena* arena, NotifySummonLifeTime&& from) noexcept
      : NotifySummonLifeTime(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 5,
    kDirFieldNumber = 6,
    kGuidFieldNumber = 2,
    kLifetimeFieldNumber = 3,
    kResttimeFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 5;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 6;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 lifetime = 3;
  bool has_lifetime() const;
  void clear_lifetime() ;
  ::int32_t lifetime() const;
  void set_lifetime(::int32_t value);

  private:
  ::int32_t _internal_lifetime() const;
  void _internal_set_lifetime(::int32_t value);

  public:
  // optional int32 resttime = 4;
  bool has_resttime() const;
  void clear_resttime() ;
  ::int32_t resttime() const;
  void set_resttime(::int32_t value);

  private:
  ::int32_t _internal_resttime() const;
  void _internal_set_resttime(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySummonLifeTime];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySummonLifeTime)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t guid_;
    ::int32_t lifetime_;
    ::int32_t resttime_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelStartLink final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelStartLink) */ {
 public:
  inline NotifySkillModelStartLink() : NotifySkillModelStartLink(nullptr) {}
  ~NotifySkillModelStartLink() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelStartLink(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelStartLink(const NotifySkillModelStartLink& from) : NotifySkillModelStartLink(nullptr, from) {}
  inline NotifySkillModelStartLink(NotifySkillModelStartLink&& from) noexcept
      : NotifySkillModelStartLink(nullptr, std::move(from)) {}
  inline NotifySkillModelStartLink& operator=(const NotifySkillModelStartLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelStartLink& operator=(NotifySkillModelStartLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelStartLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelStartLink* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelStartLink*>(
        &_NotifySkillModelStartLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 159;
  friend void swap(NotifySkillModelStartLink& a, NotifySkillModelStartLink& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelStartLink* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelStartLink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelStartLink* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelStartLink>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelStartLink& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelStartLink& from) { NotifySkillModelStartLink::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelStartLink* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelStartLink"; }

 protected:
  explicit NotifySkillModelStartLink(::google::protobuf::Arena* arena);
  NotifySkillModelStartLink(::google::protobuf::Arena* arena, const NotifySkillModelStartLink& from);
  NotifySkillModelStartLink(::google::protobuf::Arena* arena, NotifySkillModelStartLink&& from) noexcept
      : NotifySkillModelStartLink(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeginposFieldNumber = 3,
    kGuidFieldNumber = 2,
    kTargetguidFieldNumber = 4,
    kEffectidFieldNumber = 5,
    kUniqueidFieldNumber = 6,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos beginpos = 3;
  bool has_beginpos() const;
  void clear_beginpos() ;
  const ::GSToGC::Pos& beginpos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_beginpos();
  ::GSToGC::Pos* mutable_beginpos();
  void set_allocated_beginpos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_beginpos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_beginpos();

  private:
  const ::GSToGC::Pos& _internal_beginpos() const;
  ::GSToGC::Pos* _internal_mutable_beginpos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint64 targetguid = 4;
  bool has_targetguid() const;
  void clear_targetguid() ;
  ::uint64_t targetguid() const;
  void set_targetguid(::uint64_t value);

  private:
  ::uint64_t _internal_targetguid() const;
  void _internal_set_targetguid(::uint64_t value);

  public:
  // optional int32 effectid = 5;
  bool has_effectid() const;
  void clear_effectid() ;
  ::int32_t effectid() const;
  void set_effectid(::int32_t value);

  private:
  ::int32_t _internal_effectid() const;
  void _internal_set_effectid(::int32_t value);

  public:
  // optional uint32 uniqueid = 6;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::uint32_t uniqueid() const;
  void set_uniqueid(::uint32_t value);

  private:
  ::uint32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::uint32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartLink];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelStartLink)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* beginpos_;
    ::uint64_t guid_;
    ::uint64_t targetguid_;
    ::int32_t effectid_;
    ::uint32_t uniqueid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelStartForceMoveTeleport final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelStartForceMoveTeleport) */ {
 public:
  inline NotifySkillModelStartForceMoveTeleport() : NotifySkillModelStartForceMoveTeleport(nullptr) {}
  ~NotifySkillModelStartForceMoveTeleport() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelStartForceMoveTeleport(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelStartForceMoveTeleport(const NotifySkillModelStartForceMoveTeleport& from) : NotifySkillModelStartForceMoveTeleport(nullptr, from) {}
  inline NotifySkillModelStartForceMoveTeleport(NotifySkillModelStartForceMoveTeleport&& from) noexcept
      : NotifySkillModelStartForceMoveTeleport(nullptr, std::move(from)) {}
  inline NotifySkillModelStartForceMoveTeleport& operator=(const NotifySkillModelStartForceMoveTeleport& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelStartForceMoveTeleport& operator=(NotifySkillModelStartForceMoveTeleport&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelStartForceMoveTeleport& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelStartForceMoveTeleport* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelStartForceMoveTeleport*>(
        &_NotifySkillModelStartForceMoveTeleport_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 157;
  friend void swap(NotifySkillModelStartForceMoveTeleport& a, NotifySkillModelStartForceMoveTeleport& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelStartForceMoveTeleport* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelStartForceMoveTeleport* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelStartForceMoveTeleport* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelStartForceMoveTeleport>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelStartForceMoveTeleport& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelStartForceMoveTeleport& from) { NotifySkillModelStartForceMoveTeleport::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelStartForceMoveTeleport* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelStartForceMoveTeleport"; }

 protected:
  explicit NotifySkillModelStartForceMoveTeleport(::google::protobuf::Arena* arena);
  NotifySkillModelStartForceMoveTeleport(::google::protobuf::Arena* arena, const NotifySkillModelStartForceMoveTeleport& from);
  NotifySkillModelStartForceMoveTeleport(::google::protobuf::Arena* arena, NotifySkillModelStartForceMoveTeleport&& from) noexcept
      : NotifySkillModelStartForceMoveTeleport(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBeginposFieldNumber = 4,
    kBegindirFieldNumber = 5,
    kTarposFieldNumber = 6,
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos beginpos = 4;
  bool has_beginpos() const;
  void clear_beginpos() ;
  const ::GSToGC::Pos& beginpos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_beginpos();
  ::GSToGC::Pos* mutable_beginpos();
  void set_allocated_beginpos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_beginpos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_beginpos();

  private:
  const ::GSToGC::Pos& _internal_beginpos() const;
  ::GSToGC::Pos* _internal_mutable_beginpos();

  public:
  // optional .GSToGC.Dir begindir = 5;
  bool has_begindir() const;
  void clear_begindir() ;
  const ::GSToGC::Dir& begindir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_begindir();
  ::GSToGC::Dir* mutable_begindir();
  void set_allocated_begindir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_begindir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_begindir();

  private:
  const ::GSToGC::Dir& _internal_begindir() const;
  ::GSToGC::Dir* _internal_mutable_begindir();

  public:
  // optional .GSToGC.Pos tarpos = 6;
  bool has_tarpos() const;
  void clear_tarpos() ;
  const ::GSToGC::Pos& tarpos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_tarpos();
  ::GSToGC::Pos* mutable_tarpos();
  void set_allocated_tarpos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_tarpos();

  private:
  const ::GSToGC::Pos& _internal_tarpos() const;
  ::GSToGC::Pos* _internal_mutable_tarpos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::int32_t effectid() const;
  void set_effectid(::int32_t value);

  private:
  ::int32_t _internal_effectid() const;
  void _internal_set_effectid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartForceMoveTeleport];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelStartForceMoveTeleport)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* beginpos_;
    ::GSToGC::Dir* begindir_;
    ::GSToGC::Pos* tarpos_;
    ::uint64_t guid_;
    ::int32_t effectid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelStartForceMoveStop final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelStartForceMoveStop) */ {
 public:
  inline NotifySkillModelStartForceMoveStop() : NotifySkillModelStartForceMoveStop(nullptr) {}
  ~NotifySkillModelStartForceMoveStop() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelStartForceMoveStop(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelStartForceMoveStop(const NotifySkillModelStartForceMoveStop& from) : NotifySkillModelStartForceMoveStop(nullptr, from) {}
  inline NotifySkillModelStartForceMoveStop(NotifySkillModelStartForceMoveStop&& from) noexcept
      : NotifySkillModelStartForceMoveStop(nullptr, std::move(from)) {}
  inline NotifySkillModelStartForceMoveStop& operator=(const NotifySkillModelStartForceMoveStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelStartForceMoveStop& operator=(NotifySkillModelStartForceMoveStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelStartForceMoveStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelStartForceMoveStop* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelStartForceMoveStop*>(
        &_NotifySkillModelStartForceMoveStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 156;
  friend void swap(NotifySkillModelStartForceMoveStop& a, NotifySkillModelStartForceMoveStop& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelStartForceMoveStop* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelStartForceMoveStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelStartForceMoveStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelStartForceMoveStop>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelStartForceMoveStop& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelStartForceMoveStop& from) { NotifySkillModelStartForceMoveStop::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelStartForceMoveStop* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelStartForceMoveStop"; }

 protected:
  explicit NotifySkillModelStartForceMoveStop(::google::protobuf::Arena* arena);
  NotifySkillModelStartForceMoveStop(::google::protobuf::Arena* arena, const NotifySkillModelStartForceMoveStop& from);
  NotifySkillModelStartForceMoveStop(::google::protobuf::Arena* arena, NotifySkillModelStartForceMoveStop&& from) noexcept
      : NotifySkillModelStartForceMoveStop(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 4,
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::int32_t effectid() const;
  void set_effectid(::int32_t value);

  private:
  ::int32_t _internal_effectid() const;
  void _internal_set_effectid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartForceMoveStop];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelStartForceMoveStop)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::uint64_t guid_;
    ::int32_t effectid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelStartForceMove final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelStartForceMove) */ {
 public:
  inline NotifySkillModelStartForceMove() : NotifySkillModelStartForceMove(nullptr) {}
  ~NotifySkillModelStartForceMove() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelStartForceMove(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelStartForceMove(const NotifySkillModelStartForceMove& from) : NotifySkillModelStartForceMove(nullptr, from) {}
  inline NotifySkillModelStartForceMove(NotifySkillModelStartForceMove&& from) noexcept
      : NotifySkillModelStartForceMove(nullptr, std::move(from)) {}
  inline NotifySkillModelStartForceMove& operator=(const NotifySkillModelStartForceMove& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelStartForceMove& operator=(NotifySkillModelStartForceMove&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelStartForceMove& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelStartForceMove* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelStartForceMove*>(
        &_NotifySkillModelStartForceMove_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 155;
  friend void swap(NotifySkillModelStartForceMove& a, NotifySkillModelStartForceMove& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelStartForceMove* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelStartForceMove* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelStartForceMove* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelStartForceMove>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelStartForceMove& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelStartForceMove& from) { NotifySkillModelStartForceMove::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelStartForceMove* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelStartForceMove"; }

 protected:
  explicit NotifySkillModelStartForceMove(::google::protobuf::Arena* arena);
  NotifySkillModelStartForceMove(::google::protobuf::Arena* arena, const NotifySkillModelStartForceMove& from);
  NotifySkillModelStartForceMove(::google::protobuf::Arena* arena, NotifySkillModelStartForceMove&& from) noexcept
      : NotifySkillModelStartForceMove(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirFieldNumber = 4,
    kPodFieldNumber = 5,
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kSpeedFieldNumber = 6,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Dir dir = 4;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional .GSToGC.Pos pod = 5;
  bool has_pod() const;
  void clear_pod() ;
  const ::GSToGC::Pos& pod() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pod();
  ::GSToGC::Pos* mutable_pod();
  void set_allocated_pod(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pod(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pod();

  private:
  const ::GSToGC::Pos& _internal_pod() const;
  ::GSToGC::Pos* _internal_mutable_pod();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::int32_t effectid() const;
  void set_effectid(::int32_t value);

  private:
  ::int32_t _internal_effectid() const;
  void _internal_set_effectid(::int32_t value);

  public:
  // optional int32 speed = 6;
  bool has_speed() const;
  void clear_speed() ;
  ::int32_t speed() const;
  void set_speed(::int32_t value);

  private:
  ::int32_t _internal_speed() const;
  void _internal_set_speed(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartForceMove];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelStartForceMove)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Dir* dir_;
    ::GSToGC::Pos* pod_;
    ::uint64_t guid_;
    ::int32_t effectid_;
    ::int32_t speed_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifySkillModelEmitTurn final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifySkillModelEmitTurn) */ {
 public:
  inline NotifySkillModelEmitTurn() : NotifySkillModelEmitTurn(nullptr) {}
  ~NotifySkillModelEmitTurn() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifySkillModelEmitTurn(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifySkillModelEmitTurn(const NotifySkillModelEmitTurn& from) : NotifySkillModelEmitTurn(nullptr, from) {}
  inline NotifySkillModelEmitTurn(NotifySkillModelEmitTurn&& from) noexcept
      : NotifySkillModelEmitTurn(nullptr, std::move(from)) {}
  inline NotifySkillModelEmitTurn& operator=(const NotifySkillModelEmitTurn& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifySkillModelEmitTurn& operator=(NotifySkillModelEmitTurn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifySkillModelEmitTurn& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifySkillModelEmitTurn* internal_default_instance() {
    return reinterpret_cast<const NotifySkillModelEmitTurn*>(
        &_NotifySkillModelEmitTurn_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 164;
  friend void swap(NotifySkillModelEmitTurn& a, NotifySkillModelEmitTurn& b) { a.Swap(&b); }
  inline void Swap(NotifySkillModelEmitTurn* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifySkillModelEmitTurn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifySkillModelEmitTurn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifySkillModelEmitTurn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifySkillModelEmitTurn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifySkillModelEmitTurn& from) { NotifySkillModelEmitTurn::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifySkillModelEmitTurn* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifySkillModelEmitTurn"; }

 protected:
  explicit NotifySkillModelEmitTurn(::google::protobuf::Arena* arena);
  NotifySkillModelEmitTurn(::google::protobuf::Arena* arena, const NotifySkillModelEmitTurn& from);
  NotifySkillModelEmitTurn(::google::protobuf::Arena* arena, NotifySkillModelEmitTurn&& from) noexcept
      : NotifySkillModelEmitTurn(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 5,
    kDirFieldNumber = 6,
    kTarposFieldNumber = 8,
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kProgectidFieldNumber = 4,
    kTarguidFieldNumber = 7,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 5;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 6;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional .GSToGC.Pos tarpos = 8;
  bool has_tarpos() const;
  void clear_tarpos() ;
  const ::GSToGC::Pos& tarpos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_tarpos();
  ::GSToGC::Pos* mutable_tarpos();
  void set_allocated_tarpos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_tarpos();

  private:
  const ::GSToGC::Pos& _internal_tarpos() const;
  ::GSToGC::Pos* _internal_mutable_tarpos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::uint32_t effectid() const;
  void set_effectid(::uint32_t value);

  private:
  ::uint32_t _internal_effectid() const;
  void _internal_set_effectid(::uint32_t value);

  public:
  // optional int32 progectid = 4;
  bool has_progectid() const;
  void clear_progectid() ;
  ::int32_t progectid() const;
  void set_progectid(::int32_t value);

  private:
  ::int32_t _internal_progectid() const;
  void _internal_set_progectid(::int32_t value);

  public:
  // optional uint64 targuid = 7;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelEmitTurn];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifySkillModelEmitTurn)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 4,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::GSToGC::Pos* tarpos_;
    ::uint64_t guid_;
    ::uint32_t effectid_;
    ::int32_t progectid_;
    ::uint64_t targuid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyRunesList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyRunesList) */ {
 public:
  inline NotifyRunesList() : NotifyRunesList(nullptr) {}
  ~NotifyRunesList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyRunesList(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyRunesList(const NotifyRunesList& from) : NotifyRunesList(nullptr, from) {}
  inline NotifyRunesList(NotifyRunesList&& from) noexcept
      : NotifyRunesList(nullptr, std::move(from)) {}
  inline NotifyRunesList& operator=(const NotifyRunesList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyRunesList& operator=(NotifyRunesList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyRunesList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyRunesList* internal_default_instance() {
    return reinterpret_cast<const NotifyRunesList*>(
        &_NotifyRunesList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(NotifyRunesList& a, NotifyRunesList& b) { a.Swap(&b); }
  inline void Swap(NotifyRunesList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyRunesList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyRunesList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyRunesList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyRunesList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyRunesList& from) { NotifyRunesList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyRunesList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyRunesList"; }

 protected:
  explicit NotifyRunesList(::google::protobuf::Arena* arena);
  NotifyRunesList(::google::protobuf::Arena* arena, const NotifyRunesList& from);
  NotifyRunesList(::google::protobuf::Arena* arena, NotifyRunesList&& from) noexcept
      : NotifyRunesList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRunesbaginfoFieldNumber = 2,
    kRunesSlotInfoFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.RunesBagInfo runesbaginfo = 2;
  int runesbaginfo_size() const;
  private:
  int _internal_runesbaginfo_size() const;

  public:
  void clear_runesbaginfo() ;
  ::GSToGC::RunesBagInfo* mutable_runesbaginfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>* mutable_runesbaginfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>& _internal_runesbaginfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>* _internal_mutable_runesbaginfo();
  public:
  const ::GSToGC::RunesBagInfo& runesbaginfo(int index) const;
  ::GSToGC::RunesBagInfo* add_runesbaginfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>& runesbaginfo() const;
  // repeated .GSToGC.RunesSlot runes_slot_info = 3;
  int runes_slot_info_size() const;
  private:
  int _internal_runes_slot_info_size() const;

  public:
  void clear_runes_slot_info() ;
  ::GSToGC::RunesSlot* mutable_runes_slot_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>* mutable_runes_slot_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>& _internal_runes_slot_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>* _internal_mutable_runes_slot_info();
  public:
  const ::GSToGC::RunesSlot& runes_slot_info(int index) const;
  ::GSToGC::RunesSlot* add_runes_slot_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>& runes_slot_info() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyRunesList];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyRunesList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::RunesBagInfo > runesbaginfo_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::RunesSlot > runes_slot_info_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyReconnectInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyReconnectInfo) */ {
 public:
  inline NotifyReconnectInfo() : NotifyReconnectInfo(nullptr) {}
  ~NotifyReconnectInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyReconnectInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyReconnectInfo(const NotifyReconnectInfo& from) : NotifyReconnectInfo(nullptr, from) {}
  inline NotifyReconnectInfo(NotifyReconnectInfo&& from) noexcept
      : NotifyReconnectInfo(nullptr, std::move(from)) {}
  inline NotifyReconnectInfo& operator=(const NotifyReconnectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyReconnectInfo& operator=(NotifyReconnectInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyReconnectInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyReconnectInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyReconnectInfo*>(
        &_NotifyReconnectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 167;
  friend void swap(NotifyReconnectInfo& a, NotifyReconnectInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyReconnectInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyReconnectInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyReconnectInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyReconnectInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyReconnectInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyReconnectInfo& from) { NotifyReconnectInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyReconnectInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyReconnectInfo"; }

 protected:
  explicit NotifyReconnectInfo(::google::protobuf::Arena* arena);
  NotifyReconnectInfo(::google::protobuf::Arena* arena, const NotifyReconnectInfo& from);
  NotifyReconnectInfo(::google::protobuf::Arena* arena, NotifyReconnectInfo&& from) noexcept
      : NotifyReconnectInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using ReconnectInfo = NotifyReconnectInfo_ReconnectInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kReconnectinfoFieldNumber = 5,
    kBattlestateFieldNumber = 2,
    kRemainTimesFieldNumber = 3,
    kIfobFieldNumber = 4,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyReconnectInfo.ReconnectInfo reconnectinfo = 5;
  int reconnectinfo_size() const;
  private:
  int _internal_reconnectinfo_size() const;

  public:
  void clear_reconnectinfo() ;
  ::GSToGC::NotifyReconnectInfo_ReconnectInfo* mutable_reconnectinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>* mutable_reconnectinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>& _internal_reconnectinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>* _internal_mutable_reconnectinfo();
  public:
  const ::GSToGC::NotifyReconnectInfo_ReconnectInfo& reconnectinfo(int index) const;
  ::GSToGC::NotifyReconnectInfo_ReconnectInfo* add_reconnectinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>& reconnectinfo() const;
  // optional int32 battlestate = 2;
  bool has_battlestate() const;
  void clear_battlestate() ;
  ::int32_t battlestate() const;
  void set_battlestate(::int32_t value);

  private:
  ::int32_t _internal_battlestate() const;
  void _internal_set_battlestate(::int32_t value);

  public:
  // optional int32 remain_times = 3;
  bool has_remain_times() const;
  void clear_remain_times() ;
  ::int32_t remain_times() const;
  void set_remain_times(::int32_t value);

  private:
  ::int32_t _internal_remain_times() const;
  void _internal_set_remain_times(::int32_t value);

  public:
  // optional bool ifob = 4;
  bool has_ifob() const;
  void clear_ifob() ;
  bool ifob() const;
  void set_ifob(bool value);

  private:
  bool _internal_ifob() const;
  void _internal_set_ifob(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_NotifyReconnectInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyReconnectInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyReconnectInfo_ReconnectInfo > reconnectinfo_;
    ::int32_t battlestate_;
    ::int32_t remain_times_;
    bool ifob_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyQueryNickNameRet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyQueryNickNameRet) */ {
 public:
  inline NotifyQueryNickNameRet() : NotifyQueryNickNameRet(nullptr) {}
  ~NotifyQueryNickNameRet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyQueryNickNameRet(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyQueryNickNameRet(const NotifyQueryNickNameRet& from) : NotifyQueryNickNameRet(nullptr, from) {}
  inline NotifyQueryNickNameRet(NotifyQueryNickNameRet&& from) noexcept
      : NotifyQueryNickNameRet(nullptr, std::move(from)) {}
  inline NotifyQueryNickNameRet& operator=(const NotifyQueryNickNameRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyQueryNickNameRet& operator=(NotifyQueryNickNameRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyQueryNickNameRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyQueryNickNameRet* internal_default_instance() {
    return reinterpret_cast<const NotifyQueryNickNameRet*>(
        &_NotifyQueryNickNameRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 61;
  friend void swap(NotifyQueryNickNameRet& a, NotifyQueryNickNameRet& b) { a.Swap(&b); }
  inline void Swap(NotifyQueryNickNameRet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyQueryNickNameRet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyQueryNickNameRet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyQueryNickNameRet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyQueryNickNameRet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyQueryNickNameRet& from) { NotifyQueryNickNameRet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyQueryNickNameRet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyQueryNickNameRet"; }

 protected:
  explicit NotifyQueryNickNameRet(::google::protobuf::Arena* arena);
  NotifyQueryNickNameRet(::google::protobuf::Arena* arena, const NotifyQueryNickNameRet& from);
  NotifyQueryNickNameRet(::google::protobuf::Arena* arena, NotifyQueryNickNameRet&& from) noexcept
      : NotifyQueryNickNameRet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using QueryInfo = NotifyQueryNickNameRet_QueryInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyQueryNickNameRet.QueryInfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::NotifyQueryNickNameRet_QueryInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>* _internal_mutable_info();
  public:
  const ::GSToGC::NotifyQueryNickNameRet_QueryInfo& info(int index) const;
  ::GSToGC::NotifyQueryNickNameRet_QueryInfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>& info() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyQueryNickNameRet];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyQueryNickNameRet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyQueryNickNameRet_QueryInfo > info_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyOtherItemInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyOtherItemInfo) */ {
 public:
  inline NotifyOtherItemInfo() : NotifyOtherItemInfo(nullptr) {}
  ~NotifyOtherItemInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyOtherItemInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyOtherItemInfo(const NotifyOtherItemInfo& from) : NotifyOtherItemInfo(nullptr, from) {}
  inline NotifyOtherItemInfo(NotifyOtherItemInfo&& from) noexcept
      : NotifyOtherItemInfo(nullptr, std::move(from)) {}
  inline NotifyOtherItemInfo& operator=(const NotifyOtherItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyOtherItemInfo& operator=(NotifyOtherItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyOtherItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyOtherItemInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyOtherItemInfo*>(
        &_NotifyOtherItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(NotifyOtherItemInfo& a, NotifyOtherItemInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyOtherItemInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyOtherItemInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyOtherItemInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyOtherItemInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyOtherItemInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyOtherItemInfo& from) { NotifyOtherItemInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyOtherItemInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyOtherItemInfo"; }

 protected:
  explicit NotifyOtherItemInfo(::google::protobuf::Arena* arena);
  NotifyOtherItemInfo(::google::protobuf::Arena* arena, const NotifyOtherItemInfo& from);
  NotifyOtherItemInfo(::google::protobuf::Arena* arena, NotifyOtherItemInfo&& from) noexcept
      : NotifyOtherItemInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using OtherItem = NotifyOtherItemInfo_OtherItem;

  // accessors -------------------------------------------------------
  enum : int {
    kItemFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyOtherItemInfo.OtherItem item = 2;
  int item_size() const;
  private:
  int _internal_item_size() const;

  public:
  void clear_item() ;
  ::GSToGC::NotifyOtherItemInfo_OtherItem* mutable_item(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>* mutable_item();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>& _internal_item() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>* _internal_mutable_item();
  public:
  const ::GSToGC::NotifyOtherItemInfo_OtherItem& item(int index) const;
  ::GSToGC::NotifyOtherItemInfo_OtherItem* add_item();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>& item() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOtherItemInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyOtherItemInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyOtherItemInfo_OtherItem > item_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMailList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMailList) */ {
 public:
  inline NotifyMailList() : NotifyMailList(nullptr) {}
  ~NotifyMailList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMailList(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMailList(const NotifyMailList& from) : NotifyMailList(nullptr, from) {}
  inline NotifyMailList(NotifyMailList&& from) noexcept
      : NotifyMailList(nullptr, std::move(from)) {}
  inline NotifyMailList& operator=(const NotifyMailList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMailList& operator=(NotifyMailList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMailList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMailList* internal_default_instance() {
    return reinterpret_cast<const NotifyMailList*>(
        &_NotifyMailList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(NotifyMailList& a, NotifyMailList& b) { a.Swap(&b); }
  inline void Swap(NotifyMailList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMailList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMailList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMailList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMailList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMailList& from) { NotifyMailList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMailList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMailList"; }

 protected:
  explicit NotifyMailList(::google::protobuf::Arena* arena);
  NotifyMailList(::google::protobuf::Arena* arena, const NotifyMailList& from);
  NotifyMailList(::google::protobuf::Arena* arena, NotifyMailList&& from) noexcept
      : NotifyMailList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailListFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.ShortMail mailList = 2;
  int maillist_size() const;
  private:
  int _internal_maillist_size() const;

  public:
  void clear_maillist() ;
  ::GSToGC::ShortMail* mutable_maillist(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>* mutable_maillist();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>& _internal_maillist() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>* _internal_mutable_maillist();
  public:
  const ::GSToGC::ShortMail& maillist(int index) const;
  ::GSToGC::ShortMail* add_maillist();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>& maillist() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserMail];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMailList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::ShortMail > maillist_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyMPInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyMPInfo) */ {
 public:
  inline NotifyMPInfo() : NotifyMPInfo(nullptr) {}
  ~NotifyMPInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyMPInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyMPInfo(const NotifyMPInfo& from) : NotifyMPInfo(nullptr, from) {}
  inline NotifyMPInfo(NotifyMPInfo&& from) noexcept
      : NotifyMPInfo(nullptr, std::move(from)) {}
  inline NotifyMPInfo& operator=(const NotifyMPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyMPInfo& operator=(NotifyMPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyMPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyMPInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyMPInfo*>(
        &_NotifyMPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 114;
  friend void swap(NotifyMPInfo& a, NotifyMPInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyMPInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyMPInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyMPInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyMPInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyMPInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyMPInfo& from) { NotifyMPInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyMPInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyMPInfo"; }

 protected:
  explicit NotifyMPInfo(::google::protobuf::Arena* arena);
  NotifyMPInfo(::google::protobuf::Arena* arena, const NotifyMPInfo& from);
  NotifyMPInfo(::google::protobuf::Arena* arena, NotifyMPInfo&& from) noexcept
      : NotifyMPInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using MPInfo = NotifyMPInfo_MPInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kMpinfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyMPInfo.MPInfo mpinfo = 2;
  int mpinfo_size() const;
  private:
  int _internal_mpinfo_size() const;

  public:
  void clear_mpinfo() ;
  ::GSToGC::NotifyMPInfo_MPInfo* mutable_mpinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>* mutable_mpinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>& _internal_mpinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>* _internal_mutable_mpinfo();
  public:
  const ::GSToGC::NotifyMPInfo_MPInfo& mpinfo(int index) const;
  ::GSToGC::NotifyMPInfo_MPInfo* add_mpinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>& mpinfo() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMPInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyMPInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyMPInfo_MPInfo > mpinfo_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyHerosInfo_heropanelinfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyHerosInfo.heropanelinfo) */ {
 public:
  inline NotifyHerosInfo_heropanelinfo() : NotifyHerosInfo_heropanelinfo(nullptr) {}
  ~NotifyHerosInfo_heropanelinfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyHerosInfo_heropanelinfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyHerosInfo_heropanelinfo(const NotifyHerosInfo_heropanelinfo& from) : NotifyHerosInfo_heropanelinfo(nullptr, from) {}
  inline NotifyHerosInfo_heropanelinfo(NotifyHerosInfo_heropanelinfo&& from) noexcept
      : NotifyHerosInfo_heropanelinfo(nullptr, std::move(from)) {}
  inline NotifyHerosInfo_heropanelinfo& operator=(const NotifyHerosInfo_heropanelinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyHerosInfo_heropanelinfo& operator=(NotifyHerosInfo_heropanelinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyHerosInfo_heropanelinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyHerosInfo_heropanelinfo* internal_default_instance() {
    return reinterpret_cast<const NotifyHerosInfo_heropanelinfo*>(
        &_NotifyHerosInfo_heropanelinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(NotifyHerosInfo_heropanelinfo& a, NotifyHerosInfo_heropanelinfo& b) { a.Swap(&b); }
  inline void Swap(NotifyHerosInfo_heropanelinfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyHerosInfo_heropanelinfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyHerosInfo_heropanelinfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyHerosInfo_heropanelinfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyHerosInfo_heropanelinfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyHerosInfo_heropanelinfo& from) { NotifyHerosInfo_heropanelinfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyHerosInfo_heropanelinfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyHerosInfo.heropanelinfo"; }

 protected:
  explicit NotifyHerosInfo_heropanelinfo(::google::protobuf::Arena* arena);
  NotifyHerosInfo_heropanelinfo(::google::protobuf::Arena* arena, const NotifyHerosInfo_heropanelinfo& from);
  NotifyHerosInfo_heropanelinfo(::google::protobuf::Arena* arena, NotifyHerosInfo_heropanelinfo&& from) noexcept
      : NotifyHerosInfo_heropanelinfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using goodsmsg = NotifyHerosInfo_heropanelinfo_goodsmsg;

  // accessors -------------------------------------------------------
  enum : int {
    kGoodsFieldNumber = 9,
    kNicknameFieldNumber = 4,
    kGuidFieldNumber = 2,
    kCamgpidFieldNumber = 1,
    kHerolvFieldNumber = 3,
    kKillnumFieldNumber = 5,
    kDeadtimesFieldNumber = 6,
    kAsstimesFieldNumber = 7,
    kLasthitFieldNumber = 8,
    kHeroidFieldNumber = 10,
  };
  // repeated .GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg goods = 9;
  int goods_size() const;
  private:
  int _internal_goods_size() const;

  public:
  void clear_goods() ;
  ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg* mutable_goods(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>* mutable_goods();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>& _internal_goods() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>* _internal_mutable_goods();
  public:
  const ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg& goods(int index) const;
  ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg* add_goods();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>& goods() const;
  // optional string nickname = 4;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional int32 camgpid = 1;
  bool has_camgpid() const;
  void clear_camgpid() ;
  ::int32_t camgpid() const;
  void set_camgpid(::int32_t value);

  private:
  ::int32_t _internal_camgpid() const;
  void _internal_set_camgpid(::int32_t value);

  public:
  // optional int32 herolv = 3;
  bool has_herolv() const;
  void clear_herolv() ;
  ::int32_t herolv() const;
  void set_herolv(::int32_t value);

  private:
  ::int32_t _internal_herolv() const;
  void _internal_set_herolv(::int32_t value);

  public:
  // optional int32 killnum = 5;
  bool has_killnum() const;
  void clear_killnum() ;
  ::int32_t killnum() const;
  void set_killnum(::int32_t value);

  private:
  ::int32_t _internal_killnum() const;
  void _internal_set_killnum(::int32_t value);

  public:
  // optional int32 deadtimes = 6;
  bool has_deadtimes() const;
  void clear_deadtimes() ;
  ::int32_t deadtimes() const;
  void set_deadtimes(::int32_t value);

  private:
  ::int32_t _internal_deadtimes() const;
  void _internal_set_deadtimes(::int32_t value);

  public:
  // optional int32 asstimes = 7;
  bool has_asstimes() const;
  void clear_asstimes() ;
  ::int32_t asstimes() const;
  void set_asstimes(::int32_t value);

  private:
  ::int32_t _internal_asstimes() const;
  void _internal_set_asstimes(::int32_t value);

  public:
  // optional int32 lasthit = 8;
  bool has_lasthit() const;
  void clear_lasthit() ;
  ::int32_t lasthit() const;
  void set_lasthit(::int32_t value);

  private:
  ::int32_t _internal_lasthit() const;
  void _internal_set_lasthit(::int32_t value);

  public:
  // optional uint32 heroid = 10;
  bool has_heroid() const;
  void clear_heroid() ;
  ::uint32_t heroid() const;
  void set_heroid(::uint32_t value);

  private:
  ::uint32_t _internal_heroid() const;
  void _internal_set_heroid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyHerosInfo.heropanelinfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      61, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg > goods_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::int64_t guid_;
    ::int32_t camgpid_;
    ::int32_t herolv_;
    ::int32_t killnum_;
    ::int32_t deadtimes_;
    ::int32_t asstimes_;
    ::int32_t lasthit_;
    ::uint32_t heroid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyHPInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyHPInfo) */ {
 public:
  inline NotifyHPInfo() : NotifyHPInfo(nullptr) {}
  ~NotifyHPInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyHPInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyHPInfo(const NotifyHPInfo& from) : NotifyHPInfo(nullptr, from) {}
  inline NotifyHPInfo(NotifyHPInfo&& from) noexcept
      : NotifyHPInfo(nullptr, std::move(from)) {}
  inline NotifyHPInfo& operator=(const NotifyHPInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyHPInfo& operator=(NotifyHPInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyHPInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyHPInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyHPInfo*>(
        &_NotifyHPInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 112;
  friend void swap(NotifyHPInfo& a, NotifyHPInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyHPInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyHPInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyHPInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyHPInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyHPInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyHPInfo& from) { NotifyHPInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyHPInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyHPInfo"; }

 protected:
  explicit NotifyHPInfo(::google::protobuf::Arena* arena);
  NotifyHPInfo(::google::protobuf::Arena* arena, const NotifyHPInfo& from);
  NotifyHPInfo(::google::protobuf::Arena* arena, NotifyHPInfo&& from) noexcept
      : NotifyHPInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using HPInfo = NotifyHPInfo_HPInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kHpinfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyHPInfo.HPInfo hpinfo = 2;
  int hpinfo_size() const;
  private:
  int _internal_hpinfo_size() const;

  public:
  void clear_hpinfo() ;
  ::GSToGC::NotifyHPInfo_HPInfo* mutable_hpinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>* mutable_hpinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>& _internal_hpinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>* _internal_mutable_hpinfo();
  public:
  const ::GSToGC::NotifyHPInfo_HPInfo& hpinfo(int index) const;
  ::GSToGC::NotifyHPInfo_HPInfo* add_hpinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>& hpinfo() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHPInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyHPInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyHPInfo_HPInfo > hpinfo_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyGoodsInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyGoodsInfo) */ {
 public:
  inline NotifyGoodsInfo() : NotifyGoodsInfo(nullptr) {}
  ~NotifyGoodsInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyGoodsInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyGoodsInfo(const NotifyGoodsInfo& from) : NotifyGoodsInfo(nullptr, from) {}
  inline NotifyGoodsInfo(NotifyGoodsInfo&& from) noexcept
      : NotifyGoodsInfo(nullptr, std::move(from)) {}
  inline NotifyGoodsInfo& operator=(const NotifyGoodsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyGoodsInfo& operator=(NotifyGoodsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyGoodsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyGoodsInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyGoodsInfo*>(
        &_NotifyGoodsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 99;
  friend void swap(NotifyGoodsInfo& a, NotifyGoodsInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyGoodsInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyGoodsInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyGoodsInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyGoodsInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyGoodsInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyGoodsInfo& from) { NotifyGoodsInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyGoodsInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyGoodsInfo"; }

 protected:
  explicit NotifyGoodsInfo(::google::protobuf::Arena* arena);
  NotifyGoodsInfo(::google::protobuf::Arena* arena, const NotifyGoodsInfo& from);
  NotifyGoodsInfo(::google::protobuf::Arena* arena, NotifyGoodsInfo&& from) noexcept
      : NotifyGoodsInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using GoodsInfo = NotifyGoodsInfo_GoodsInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 3,
    kGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyGoodsInfo.GoodsInfo info = 3;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::NotifyGoodsInfo_GoodsInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>* _internal_mutable_info();
  public:
  const ::GSToGC::NotifyGoodsInfo_GoodsInfo& info(int index) const;
  ::GSToGC::NotifyGoodsInfo_GoodsInfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>& info() const;
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGoodsInf];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyGoodsInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyGoodsInfo_GoodsInfo > info_;
    ::uint64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyGameObjectReliveState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyGameObjectReliveState) */ {
 public:
  inline NotifyGameObjectReliveState() : NotifyGameObjectReliveState(nullptr) {}
  ~NotifyGameObjectReliveState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyGameObjectReliveState(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyGameObjectReliveState(const NotifyGameObjectReliveState& from) : NotifyGameObjectReliveState(nullptr, from) {}
  inline NotifyGameObjectReliveState(NotifyGameObjectReliveState&& from) noexcept
      : NotifyGameObjectReliveState(nullptr, std::move(from)) {}
  inline NotifyGameObjectReliveState& operator=(const NotifyGameObjectReliveState& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyGameObjectReliveState& operator=(NotifyGameObjectReliveState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyGameObjectReliveState& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyGameObjectReliveState* internal_default_instance() {
    return reinterpret_cast<const NotifyGameObjectReliveState*>(
        &_NotifyGameObjectReliveState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 174;
  friend void swap(NotifyGameObjectReliveState& a, NotifyGameObjectReliveState& b) { a.Swap(&b); }
  inline void Swap(NotifyGameObjectReliveState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyGameObjectReliveState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyGameObjectReliveState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyGameObjectReliveState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyGameObjectReliveState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyGameObjectReliveState& from) { NotifyGameObjectReliveState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyGameObjectReliveState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyGameObjectReliveState"; }

 protected:
  explicit NotifyGameObjectReliveState(::google::protobuf::Arena* arena);
  NotifyGameObjectReliveState(::google::protobuf::Arena* arena, const NotifyGameObjectReliveState& from);
  NotifyGameObjectReliveState(::google::protobuf::Arena* arena, NotifyGameObjectReliveState&& from) noexcept
      : NotifyGameObjectReliveState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 3,
    kDirFieldNumber = 4,
    kGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 4;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectReliveState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyGameObjectReliveState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyChooseHeroTimeEnd final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyChooseHeroTimeEnd) */ {
 public:
  inline NotifyChooseHeroTimeEnd() : NotifyChooseHeroTimeEnd(nullptr) {}
  ~NotifyChooseHeroTimeEnd() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyChooseHeroTimeEnd(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyChooseHeroTimeEnd(const NotifyChooseHeroTimeEnd& from) : NotifyChooseHeroTimeEnd(nullptr, from) {}
  inline NotifyChooseHeroTimeEnd(NotifyChooseHeroTimeEnd&& from) noexcept
      : NotifyChooseHeroTimeEnd(nullptr, std::move(from)) {}
  inline NotifyChooseHeroTimeEnd& operator=(const NotifyChooseHeroTimeEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyChooseHeroTimeEnd& operator=(NotifyChooseHeroTimeEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyChooseHeroTimeEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyChooseHeroTimeEnd* internal_default_instance() {
    return reinterpret_cast<const NotifyChooseHeroTimeEnd*>(
        &_NotifyChooseHeroTimeEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 108;
  friend void swap(NotifyChooseHeroTimeEnd& a, NotifyChooseHeroTimeEnd& b) { a.Swap(&b); }
  inline void Swap(NotifyChooseHeroTimeEnd* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyChooseHeroTimeEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyChooseHeroTimeEnd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyChooseHeroTimeEnd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyChooseHeroTimeEnd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyChooseHeroTimeEnd& from) { NotifyChooseHeroTimeEnd::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyChooseHeroTimeEnd* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyChooseHeroTimeEnd"; }

 protected:
  explicit NotifyChooseHeroTimeEnd(::google::protobuf::Arena* arena);
  NotifyChooseHeroTimeEnd(::google::protobuf::Arena* arena, const NotifyChooseHeroTimeEnd& from);
  NotifyChooseHeroTimeEnd(::google::protobuf::Arena* arena, NotifyChooseHeroTimeEnd&& from) noexcept
      : NotifyChooseHeroTimeEnd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeroposinfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.HeroPosInfo heroposinfo = 2;
  int heroposinfo_size() const;
  private:
  int _internal_heroposinfo_size() const;

  public:
  void clear_heroposinfo() ;
  ::GSToGC::HeroPosInfo* mutable_heroposinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>* mutable_heroposinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>& _internal_heroposinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>* _internal_mutable_heroposinfo();
  public:
  const ::GSToGC::HeroPosInfo& heroposinfo(int index) const;
  ::GSToGC::HeroPosInfo* add_heroposinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>& heroposinfo() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyChooseHeroTimeEnd];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyChooseHeroTimeEnd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::HeroPosInfo > heroposinfo_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyCSHeroList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyCSHeroList) */ {
 public:
  inline NotifyCSHeroList() : NotifyCSHeroList(nullptr) {}
  ~NotifyCSHeroList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyCSHeroList(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyCSHeroList(const NotifyCSHeroList& from) : NotifyCSHeroList(nullptr, from) {}
  inline NotifyCSHeroList(NotifyCSHeroList&& from) noexcept
      : NotifyCSHeroList(nullptr, std::move(from)) {}
  inline NotifyCSHeroList& operator=(const NotifyCSHeroList& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyCSHeroList& operator=(NotifyCSHeroList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyCSHeroList& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyCSHeroList* internal_default_instance() {
    return reinterpret_cast<const NotifyCSHeroList*>(
        &_NotifyCSHeroList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 78;
  friend void swap(NotifyCSHeroList& a, NotifyCSHeroList& b) { a.Swap(&b); }
  inline void Swap(NotifyCSHeroList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyCSHeroList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyCSHeroList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyCSHeroList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyCSHeroList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyCSHeroList& from) { NotifyCSHeroList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyCSHeroList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyCSHeroList"; }

 protected:
  explicit NotifyCSHeroList(::google::protobuf::Arena* arena);
  NotifyCSHeroList(::google::protobuf::Arena* arena, const NotifyCSHeroList& from);
  NotifyCSHeroList(::google::protobuf::Arena* arena, NotifyCSHeroList&& from) noexcept
      : NotifyCSHeroList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using HeroListCfg = NotifyCSHeroList_HeroListCfg;

  // accessors -------------------------------------------------------
  enum : int {
    kHerocfgFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyCSHeroList.HeroListCfg herocfg = 2;
  int herocfg_size() const;
  private:
  int _internal_herocfg_size() const;

  public:
  void clear_herocfg() ;
  ::GSToGC::NotifyCSHeroList_HeroListCfg* mutable_herocfg(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>* mutable_herocfg();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>& _internal_herocfg() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>* _internal_mutable_herocfg();
  public:
  const ::GSToGC::NotifyCSHeroList_HeroListCfg& herocfg(int index) const;
  ::GSToGC::NotifyCSHeroList_HeroListCfg* add_herocfg();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>& herocfg() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCSHeroList];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyCSHeroList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyCSHeroList_HeroListCfg > herocfg_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyAddOneTask final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyAddOneTask) */ {
 public:
  inline NotifyAddOneTask() : NotifyAddOneTask(nullptr) {}
  ~NotifyAddOneTask() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyAddOneTask(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyAddOneTask(const NotifyAddOneTask& from) : NotifyAddOneTask(nullptr, from) {}
  inline NotifyAddOneTask(NotifyAddOneTask&& from) noexcept
      : NotifyAddOneTask(nullptr, std::move(from)) {}
  inline NotifyAddOneTask& operator=(const NotifyAddOneTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyAddOneTask& operator=(NotifyAddOneTask&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyAddOneTask& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyAddOneTask* internal_default_instance() {
    return reinterpret_cast<const NotifyAddOneTask*>(
        &_NotifyAddOneTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NotifyAddOneTask& a, NotifyAddOneTask& b) { a.Swap(&b); }
  inline void Swap(NotifyAddOneTask* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyAddOneTask* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyAddOneTask* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyAddOneTask>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyAddOneTask& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyAddOneTask& from) { NotifyAddOneTask::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyAddOneTask* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyAddOneTask"; }

 protected:
  explicit NotifyAddOneTask(::google::protobuf::Arena* arena);
  NotifyAddOneTask(::google::protobuf::Arena* arena, const NotifyAddOneTask& from);
  NotifyAddOneTask(::google::protobuf::Arena* arena, NotifyAddOneTask&& from) noexcept
      : NotifyAddOneTask(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOneTaskFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.TaskData oneTask = 2;
  bool has_onetask() const;
  void clear_onetask() ;
  const ::GSToGC::TaskData& onetask() const;
  PROTOBUF_NODISCARD ::GSToGC::TaskData* release_onetask();
  ::GSToGC::TaskData* mutable_onetask();
  void set_allocated_onetask(::GSToGC::TaskData* value);
  void unsafe_arena_set_allocated_onetask(::GSToGC::TaskData* value);
  ::GSToGC::TaskData* unsafe_arena_release_onetask();

  private:
  const ::GSToGC::TaskData& _internal_onetask() const;
  ::GSToGC::TaskData* _internal_mutable_onetask();

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_AddOneTask];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyAddOneTask)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::TaskData* onetask_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyAFPData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyAFPData) */ {
 public:
  inline NotifyAFPData() : NotifyAFPData(nullptr) {}
  ~NotifyAFPData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyAFPData(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyAFPData(const NotifyAFPData& from) : NotifyAFPData(nullptr, from) {}
  inline NotifyAFPData(NotifyAFPData&& from) noexcept
      : NotifyAFPData(nullptr, std::move(from)) {}
  inline NotifyAFPData& operator=(const NotifyAFPData& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyAFPData& operator=(NotifyAFPData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyAFPData& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyAFPData* internal_default_instance() {
    return reinterpret_cast<const NotifyAFPData*>(
        &_NotifyAFPData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 70;
  friend void swap(NotifyAFPData& a, NotifyAFPData& b) { a.Swap(&b); }
  inline void Swap(NotifyAFPData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyAFPData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyAFPData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyAFPData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyAFPData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyAFPData& from) { NotifyAFPData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyAFPData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyAFPData"; }

 protected:
  explicit NotifyAFPData(::google::protobuf::Arena* arena);
  NotifyAFPData(::google::protobuf::Arena* arena, const NotifyAFPData& from);
  NotifyAFPData(::google::protobuf::Arena* arena, NotifyAFPData&& from) noexcept
      : NotifyAFPData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using FPInfo = NotifyAFPData_FPInfo;
  using EnumFpType = NotifyAFPData_EnumFpType;
  static constexpr EnumFpType PhyHurt = NotifyAFPData_EnumFpType_PhyHurt;
  static constexpr EnumFpType MagicHurt = NotifyAFPData_EnumFpType_MagicHurt;
  static constexpr EnumFpType CurHP = NotifyAFPData_EnumFpType_CurHP;
  static constexpr EnumFpType CurMP = NotifyAFPData_EnumFpType_CurMP;
  static constexpr EnumFpType PhyAttack = NotifyAFPData_EnumFpType_PhyAttack;
  static constexpr EnumFpType MagicAttack = NotifyAFPData_EnumFpType_MagicAttack;
  static constexpr EnumFpType PhyDefense = NotifyAFPData_EnumFpType_PhyDefense;
  static constexpr EnumFpType MagicDefense = NotifyAFPData_EnumFpType_MagicDefense;
  static constexpr EnumFpType MoveSpeed = NotifyAFPData_EnumFpType_MoveSpeed;
  static constexpr EnumFpType AttackSpeed = NotifyAFPData_EnumFpType_AttackSpeed;
  static constexpr EnumFpType MaxHP = NotifyAFPData_EnumFpType_MaxHP;
  static constexpr EnumFpType MaxMP = NotifyAFPData_EnumFpType_MaxMP;
  static constexpr EnumFpType HPRecoverRate = NotifyAFPData_EnumFpType_HPRecoverRate;
  static constexpr EnumFpType MPRecoverRate = NotifyAFPData_EnumFpType_MPRecoverRate;
  static constexpr EnumFpType ReliveTime = NotifyAFPData_EnumFpType_ReliveTime;
  static constexpr EnumFpType Dizziness = NotifyAFPData_EnumFpType_Dizziness;
  static constexpr EnumFpType Silence = NotifyAFPData_EnumFpType_Silence;
  static constexpr EnumFpType PosMove = NotifyAFPData_EnumFpType_PosMove;
  static constexpr EnumFpType Rebound = NotifyAFPData_EnumFpType_Rebound;
  static constexpr EnumFpType PhySuckBlood = NotifyAFPData_EnumFpType_PhySuckBlood;
  static constexpr EnumFpType Disarm = NotifyAFPData_EnumFpType_Disarm;
  static constexpr EnumFpType Restrain = NotifyAFPData_EnumFpType_Restrain;
  static constexpr EnumFpType CriPersent = NotifyAFPData_EnumFpType_CriPersent;
  static constexpr EnumFpType CriHarm = NotifyAFPData_EnumFpType_CriHarm;
  static constexpr EnumFpType CPRecover = NotifyAFPData_EnumFpType_CPRecover;
  static constexpr EnumFpType PassitiveSkill = NotifyAFPData_EnumFpType_PassitiveSkill;
  static constexpr EnumFpType Invisible = NotifyAFPData_EnumFpType_Invisible;
  static constexpr EnumFpType AttackDist = NotifyAFPData_EnumFpType_AttackDist;
  static constexpr EnumFpType TrueHurt = NotifyAFPData_EnumFpType_TrueHurt;
  static constexpr EnumFpType PhyPassNum = NotifyAFPData_EnumFpType_PhyPassNum;
  static constexpr EnumFpType PhyPassPercent = NotifyAFPData_EnumFpType_PhyPassPercent;
  static constexpr EnumFpType MagicPassNum = NotifyAFPData_EnumFpType_MagicPassNum;
  static constexpr EnumFpType MagicPassPercent = NotifyAFPData_EnumFpType_MagicPassPercent;
  static constexpr EnumFpType CooldownReduce = NotifyAFPData_EnumFpType_CooldownReduce;
  static constexpr EnumFpType PhyDmgReduce = NotifyAFPData_EnumFpType_PhyDmgReduce;
  static constexpr EnumFpType MagicDmgReduce = NotifyAFPData_EnumFpType_MagicDmgReduce;
  static constexpr EnumFpType TrueDmgReduce = NotifyAFPData_EnumFpType_TrueDmgReduce;
  static constexpr EnumFpType PhyDmgReduceNum = NotifyAFPData_EnumFpType_PhyDmgReduceNum;
  static constexpr EnumFpType MagicDmgReduceNum = NotifyAFPData_EnumFpType_MagicDmgReduceNum;
  static constexpr EnumFpType TrueDmgReduceNum = NotifyAFPData_EnumFpType_TrueDmgReduceNum;
  static constexpr EnumFpType MagicSuckBlood = NotifyAFPData_EnumFpType_MagicSuckBlood;
  static inline bool EnumFpType_IsValid(int value) {
    return NotifyAFPData_EnumFpType_IsValid(value);
  }
  static constexpr EnumFpType EnumFpType_MIN = NotifyAFPData_EnumFpType_EnumFpType_MIN;
  static constexpr EnumFpType EnumFpType_MAX = NotifyAFPData_EnumFpType_EnumFpType_MAX;
  static constexpr int EnumFpType_ARRAYSIZE = NotifyAFPData_EnumFpType_EnumFpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* EnumFpType_descriptor() {
    return NotifyAFPData_EnumFpType_descriptor();
  }
  template <typename T>
  static inline const std::string& EnumFpType_Name(T value) {
    return NotifyAFPData_EnumFpType_Name(value);
  }
  static inline bool EnumFpType_Parse(absl::string_view name, EnumFpType* value) {
    return NotifyAFPData_EnumFpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 3,
    kGuidFieldNumber = 2,
    kMsgnumFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyAFPData.FPInfo info = 3;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::NotifyAFPData_FPInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>* _internal_mutable_info();
  public:
  const ::GSToGC::NotifyAFPData_FPInfo& info(int index) const;
  ::GSToGC::NotifyAFPData_FPInfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>& info() const;
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyAFPData];
  bool has_msgnum() const;
  void clear_msgnum() ;
  ::GSToGC::MsgID msgnum() const;
  void set_msgnum(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgnum() const;
  void _internal_set_msgnum(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyAFPData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyAFPData_FPInfo > info_;
    ::uint64_t guid_;
    int msgnum_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class LastingSkillState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.LastingSkillState) */ {
 public:
  inline LastingSkillState() : LastingSkillState(nullptr) {}
  ~LastingSkillState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR LastingSkillState(
      ::google::protobuf::internal::ConstantInitialized);

  inline LastingSkillState(const LastingSkillState& from) : LastingSkillState(nullptr, from) {}
  inline LastingSkillState(LastingSkillState&& from) noexcept
      : LastingSkillState(nullptr, std::move(from)) {}
  inline LastingSkillState& operator=(const LastingSkillState& from) {
    CopyFrom(from);
    return *this;
  }
  inline LastingSkillState& operator=(LastingSkillState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LastingSkillState& default_instance() {
    return *internal_default_instance();
  }
  static inline const LastingSkillState* internal_default_instance() {
    return reinterpret_cast<const LastingSkillState*>(
        &_LastingSkillState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 96;
  friend void swap(LastingSkillState& a, LastingSkillState& b) { a.Swap(&b); }
  inline void Swap(LastingSkillState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LastingSkillState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LastingSkillState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<LastingSkillState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LastingSkillState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const LastingSkillState& from) { LastingSkillState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LastingSkillState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.LastingSkillState"; }

 protected:
  explicit LastingSkillState(::google::protobuf::Arena* arena);
  LastingSkillState(::google::protobuf::Arena* arena, const LastingSkillState& from);
  LastingSkillState(::google::protobuf::Arena* arena, LastingSkillState&& from) noexcept
      : LastingSkillState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 4,
    kDirFieldNumber = 5,
    kObjguidFieldNumber = 2,
    kTarguidFieldNumber = 6,
    kSkillidFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional uint64 targuid = 6;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectLastingSkillState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.LastingSkillState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t objguid_;
    ::uint64_t targuid_;
    ::int32_t skillid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HeroMoveInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HeroMoveInfo) */ {
 public:
  inline HeroMoveInfo() : HeroMoveInfo(nullptr) {}
  ~HeroMoveInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroMoveInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroMoveInfo(const HeroMoveInfo& from) : HeroMoveInfo(nullptr, from) {}
  inline HeroMoveInfo(HeroMoveInfo&& from) noexcept
      : HeroMoveInfo(nullptr, std::move(from)) {}
  inline HeroMoveInfo& operator=(const HeroMoveInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroMoveInfo& operator=(HeroMoveInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroMoveInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroMoveInfo* internal_default_instance() {
    return reinterpret_cast<const HeroMoveInfo*>(
        &_HeroMoveInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 139;
  friend void swap(HeroMoveInfo& a, HeroMoveInfo& b) { a.Swap(&b); }
  inline void Swap(HeroMoveInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroMoveInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroMoveInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroMoveInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroMoveInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroMoveInfo& from) { HeroMoveInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroMoveInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HeroMoveInfo"; }

 protected:
  explicit HeroMoveInfo(::google::protobuf::Arena* arena);
  HeroMoveInfo(::google::protobuf::Arena* arena, const HeroMoveInfo& from);
  HeroMoveInfo(::google::protobuf::Arena* arena, HeroMoveInfo&& from) noexcept
      : HeroMoveInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirFieldNumber = 3,
    kPosFieldNumber = 4,
    kGuidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Dir dir = 3;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleSeatPosInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HeroMoveInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Dir* dir_;
    ::GSToGC::Pos* pos_;
    ::uint64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class HeroInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.HeroInfo) */ {
 public:
  inline HeroInfo() : HeroInfo(nullptr) {}
  ~HeroInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroInfo(const HeroInfo& from) : HeroInfo(nullptr, from) {}
  inline HeroInfo(HeroInfo&& from) noexcept
      : HeroInfo(nullptr, std::move(from)) {}
  inline HeroInfo& operator=(const HeroInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroInfo& operator=(HeroInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroInfo* internal_default_instance() {
    return reinterpret_cast<const HeroInfo*>(
        &_HeroInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 102;
  friend void swap(HeroInfo& a, HeroInfo& b) { a.Swap(&b); }
  inline void Swap(HeroInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroInfo& from) { HeroInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.HeroInfo"; }

 protected:
  explicit HeroInfo(::google::protobuf::Arena* arena);
  HeroInfo(::google::protobuf::Arena* arena, const HeroInfo& from);
  HeroInfo(::google::protobuf::Arena* arena, HeroInfo&& from) noexcept
      : HeroInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeroposinfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.HeroPosInfo heroposinfo = 2;
  bool has_heroposinfo() const;
  void clear_heroposinfo() ;
  const ::GSToGC::HeroPosInfo& heroposinfo() const;
  PROTOBUF_NODISCARD ::GSToGC::HeroPosInfo* release_heroposinfo();
  ::GSToGC::HeroPosInfo* mutable_heroposinfo();
  void set_allocated_heroposinfo(::GSToGC::HeroPosInfo* value);
  void unsafe_arena_set_allocated_heroposinfo(::GSToGC::HeroPosInfo* value);
  ::GSToGC::HeroPosInfo* unsafe_arena_release_heroposinfo();

  private:
  const ::GSToGC::HeroPosInfo& _internal_heroposinfo() const;
  ::GSToGC::HeroPosInfo* _internal_mutable_heroposinfo();

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleHeroInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.HeroInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::HeroPosInfo* heroposinfo_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GuideAward final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GuideAward) */ {
 public:
  inline GuideAward() : GuideAward(nullptr) {}
  ~GuideAward() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GuideAward(
      ::google::protobuf::internal::ConstantInitialized);

  inline GuideAward(const GuideAward& from) : GuideAward(nullptr, from) {}
  inline GuideAward(GuideAward&& from) noexcept
      : GuideAward(nullptr, std::move(from)) {}
  inline GuideAward& operator=(const GuideAward& from) {
    CopyFrom(from);
    return *this;
  }
  inline GuideAward& operator=(GuideAward&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GuideAward& default_instance() {
    return *internal_default_instance();
  }
  static inline const GuideAward* internal_default_instance() {
    return reinterpret_cast<const GuideAward*>(
        &_GuideAward_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(GuideAward& a, GuideAward& b) { a.Swap(&b); }
  inline void Swap(GuideAward* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GuideAward* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GuideAward* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GuideAward>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GuideAward& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GuideAward& from) { GuideAward::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GuideAward* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GuideAward"; }

 protected:
  explicit GuideAward(::google::protobuf::Arena* arena);
  GuideAward(::google::protobuf::Arena* arena, const GuideAward& from);
  GuideAward(::google::protobuf::Arena* arena, GuideAward&& from) noexcept
      : GuideAward(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using awardtype = GuideAward_awardtype;
  using dtype = GuideAward_dtype;
  static constexpr dtype type_gold = GuideAward_dtype_type_gold;
  static constexpr dtype type_diamond = GuideAward_dtype_type_diamond;
  static constexpr dtype type_goodsid = GuideAward_dtype_type_goodsid;
  static inline bool dtype_IsValid(int value) {
    return GuideAward_dtype_IsValid(value);
  }
  static constexpr dtype dtype_MIN = GuideAward_dtype_dtype_MIN;
  static constexpr dtype dtype_MAX = GuideAward_dtype_dtype_MAX;
  static constexpr int dtype_ARRAYSIZE = GuideAward_dtype_dtype_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* dtype_descriptor() {
    return GuideAward_dtype_descriptor();
  }
  template <typename T>
  static inline const std::string& dtype_Name(T value) {
    return GuideAward_dtype_Name(value);
  }
  static inline bool dtype_Parse(absl::string_view name, dtype* value) {
    return GuideAward_dtype_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kAwardlistFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.GuideAward.awardtype awardlist = 2;
  int awardlist_size() const;
  private:
  int _internal_awardlist_size() const;

  public:
  void clear_awardlist() ;
  ::GSToGC::GuideAward_awardtype* mutable_awardlist(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>* mutable_awardlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>& _internal_awardlist() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>* _internal_mutable_awardlist();
  public:
  const ::GSToGC::GuideAward_awardtype& awardlist(int index) const;
  ::GSToGC::GuideAward_awardtype* add_awardlist();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>& awardlist() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GuideAward];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GuideAward)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::GuideAward_awardtype > awardlist_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GoodsCfgInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GoodsCfgInfo) */ {
 public:
  inline GoodsCfgInfo() : GoodsCfgInfo(nullptr) {}
  ~GoodsCfgInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoodsCfgInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoodsCfgInfo(const GoodsCfgInfo& from) : GoodsCfgInfo(nullptr, from) {}
  inline GoodsCfgInfo(GoodsCfgInfo&& from) noexcept
      : GoodsCfgInfo(nullptr, std::move(from)) {}
  inline GoodsCfgInfo& operator=(const GoodsCfgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoodsCfgInfo& operator=(GoodsCfgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoodsCfgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoodsCfgInfo* internal_default_instance() {
    return reinterpret_cast<const GoodsCfgInfo*>(
        &_GoodsCfgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 39;
  friend void swap(GoodsCfgInfo& a, GoodsCfgInfo& b) { a.Swap(&b); }
  inline void Swap(GoodsCfgInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoodsCfgInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoodsCfgInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GoodsCfgInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoodsCfgInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoodsCfgInfo& from) { GoodsCfgInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GoodsCfgInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GoodsCfgInfo"; }

 protected:
  explicit GoodsCfgInfo(::google::protobuf::Arena* arena);
  GoodsCfgInfo(::google::protobuf::Arena* arena, const GoodsCfgInfo& from);
  GoodsCfgInfo(::google::protobuf::Arena* arena, GoodsCfgInfo&& from) noexcept
      : GoodsCfgInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Consume = GoodsCfgInfo_Consume;
  using CfgType = GoodsCfgInfo_CfgType;
  static constexpr CfgType CfgType_Common = GoodsCfgInfo_CfgType_CfgType_Common;
  static constexpr CfgType CfgType_Discount = GoodsCfgInfo_CfgType_CfgType_Discount;
  static constexpr CfgType CfgType_hot = GoodsCfgInfo_CfgType_CfgType_hot;
  static constexpr CfgType CfgType_New = GoodsCfgInfo_CfgType_CfgType_New;
  static inline bool CfgType_IsValid(int value) {
    return GoodsCfgInfo_CfgType_IsValid(value);
  }
  static constexpr CfgType CfgType_MIN = GoodsCfgInfo_CfgType_CfgType_MIN;
  static constexpr CfgType CfgType_MAX = GoodsCfgInfo_CfgType_CfgType_MAX;
  static constexpr int CfgType_ARRAYSIZE = GoodsCfgInfo_CfgType_CfgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CfgType_descriptor() {
    return GoodsCfgInfo_CfgType_descriptor();
  }
  template <typename T>
  static inline const std::string& CfgType_Name(T value) {
    return GoodsCfgInfo_CfgType_Name(value);
  }
  static inline bool CfgType_Parse(absl::string_view name, CfgType* value) {
    return GoodsCfgInfo_CfgType_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kConsumeFieldNumber = 2,
    kGoodidFieldNumber = 1,
    kCfgTypeFieldNumber = 3,
  };
  // repeated .GSToGC.GoodsCfgInfo.Consume consume = 2;
  int consume_size() const;
  private:
  int _internal_consume_size() const;

  public:
  void clear_consume() ;
  ::GSToGC::GoodsCfgInfo_Consume* mutable_consume(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>* mutable_consume();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>& _internal_consume() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>* _internal_mutable_consume();
  public:
  const ::GSToGC::GoodsCfgInfo_Consume& consume(int index) const;
  ::GSToGC::GoodsCfgInfo_Consume* add_consume();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>& consume() const;
  // optional int32 goodid = 1;
  bool has_goodid() const;
  void clear_goodid() ;
  ::int32_t goodid() const;
  void set_goodid(::int32_t value);

  private:
  ::int32_t _internal_goodid() const;
  void _internal_set_goodid(::int32_t value);

  public:
  // optional .GSToGC.GoodsCfgInfo.CfgType cfg_type = 3;
  bool has_cfg_type() const;
  void clear_cfg_type() ;
  ::GSToGC::GoodsCfgInfo_CfgType cfg_type() const;
  void set_cfg_type(::GSToGC::GoodsCfgInfo_CfgType value);

  private:
  ::GSToGC::GoodsCfgInfo_CfgType _internal_cfg_type() const;
  void _internal_set_cfg_type(::GSToGC::GoodsCfgInfo_CfgType value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GoodsCfgInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::GoodsCfgInfo_Consume > consume_;
    ::int32_t goodid_;
    int cfg_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GameNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GameNotice) */ {
 public:
  inline GameNotice() : GameNotice(nullptr) {}
  ~GameNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline GameNotice(const GameNotice& from) : GameNotice(nullptr, from) {}
  inline GameNotice(GameNotice&& from) noexcept
      : GameNotice(nullptr, std::move(from)) {}
  inline GameNotice& operator=(const GameNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameNotice& operator=(GameNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameNotice* internal_default_instance() {
    return reinterpret_cast<const GameNotice*>(
        &_GameNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 57;
  friend void swap(GameNotice& a, GameNotice& b) { a.Swap(&b); }
  inline void Swap(GameNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GameNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GameNotice& from) { GameNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GameNotice"; }

 protected:
  explicit GameNotice(::google::protobuf::Arena* arena);
  GameNotice(::google::protobuf::Arena* arena, const GameNotice& from);
  GameNotice(::google::protobuf::Arena* arena, GameNotice&& from) noexcept
      : GameNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Notice = GameNotice_Notice;

  // accessors -------------------------------------------------------
  enum : int {
    kNoticeFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.GameNotice.Notice notice = 2;
  int notice_size() const;
  private:
  int _internal_notice_size() const;

  public:
  void clear_notice() ;
  ::GSToGC::GameNotice_Notice* mutable_notice(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>* mutable_notice();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>& _internal_notice() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>* _internal_mutable_notice();
  public:
  const ::GSToGC::GameNotice_Notice& notice(int index) const;
  ::GSToGC::GameNotice_Notice* add_notice();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>& notice() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNotice];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GameNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::GameNotice_Notice > notice_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GOReleaseSkill final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GOReleaseSkill) */ {
 public:
  inline GOReleaseSkill() : GOReleaseSkill(nullptr) {}
  ~GOReleaseSkill() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GOReleaseSkill(
      ::google::protobuf::internal::ConstantInitialized);

  inline GOReleaseSkill(const GOReleaseSkill& from) : GOReleaseSkill(nullptr, from) {}
  inline GOReleaseSkill(GOReleaseSkill&& from) noexcept
      : GOReleaseSkill(nullptr, std::move(from)) {}
  inline GOReleaseSkill& operator=(const GOReleaseSkill& from) {
    CopyFrom(from);
    return *this;
  }
  inline GOReleaseSkill& operator=(GOReleaseSkill&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GOReleaseSkill& default_instance() {
    return *internal_default_instance();
  }
  static inline const GOReleaseSkill* internal_default_instance() {
    return reinterpret_cast<const GOReleaseSkill*>(
        &_GOReleaseSkill_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 145;
  friend void swap(GOReleaseSkill& a, GOReleaseSkill& b) { a.Swap(&b); }
  inline void Swap(GOReleaseSkill* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GOReleaseSkill* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GOReleaseSkill* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GOReleaseSkill>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GOReleaseSkill& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GOReleaseSkill& from) { GOReleaseSkill::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GOReleaseSkill* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GOReleaseSkill"; }

 protected:
  explicit GOReleaseSkill(::google::protobuf::Arena* arena);
  GOReleaseSkill(::google::protobuf::Arena* arena, const GOReleaseSkill& from);
  GOReleaseSkill(::google::protobuf::Arena* arena, GOReleaseSkill&& from) noexcept
      : GOReleaseSkill(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCurPosFieldNumber = 5,
    kCurDirFieldNumber = 6,
    kTarposFieldNumber = 8,
    kGuidFieldNumber = 2,
    kSkillidFieldNumber = 3,
    kStateFieldNumber = 4,
    kTarguidFieldNumber = 7,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos curPos = 5;
  bool has_curpos() const;
  void clear_curpos() ;
  const ::GSToGC::Pos& curpos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_curpos();
  ::GSToGC::Pos* mutable_curpos();
  void set_allocated_curpos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_curpos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_curpos();

  private:
  const ::GSToGC::Pos& _internal_curpos() const;
  ::GSToGC::Pos* _internal_mutable_curpos();

  public:
  // optional .GSToGC.Dir curDir = 6;
  bool has_curdir() const;
  void clear_curdir() ;
  const ::GSToGC::Dir& curdir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_curdir();
  ::GSToGC::Dir* mutable_curdir();
  void set_allocated_curdir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_curdir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_curdir();

  private:
  const ::GSToGC::Dir& _internal_curdir() const;
  ::GSToGC::Dir* _internal_mutable_curdir();

  public:
  // optional .GSToGC.Pos tarpos = 8;
  bool has_tarpos() const;
  void clear_tarpos() ;
  const ::GSToGC::Pos& tarpos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_tarpos();
  ::GSToGC::Pos* mutable_tarpos();
  void set_allocated_tarpos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_tarpos();

  private:
  const ::GSToGC::Pos& _internal_tarpos() const;
  ::GSToGC::Pos* _internal_mutable_tarpos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 skillid = 3;
  bool has_skillid() const;
  void clear_skillid() ;
  ::int32_t skillid() const;
  void set_skillid(::int32_t value);

  private:
  ::int32_t _internal_skillid() const;
  void _internal_set_skillid(::int32_t value);

  public:
  // optional .GSToGC.SkillState state = 4;
  bool has_state() const;
  void clear_state() ;
  ::GSToGC::SkillState state() const;
  void set_state(::GSToGC::SkillState value);

  private:
  ::GSToGC::SkillState _internal_state() const;
  void _internal_set_state(::GSToGC::SkillState value);

  public:
  // optional uint64 targuid = 7;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectReleaseSkill];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GOReleaseSkill)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* curpos_;
    ::GSToGC::Dir* curdir_;
    ::GSToGC::Pos* tarpos_;
    ::uint64_t guid_;
    ::int32_t skillid_;
    int state_;
    ::uint64_t targuid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GOAppear_AppearInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GOAppear.AppearInfo) */ {
 public:
  inline GOAppear_AppearInfo() : GOAppear_AppearInfo(nullptr) {}
  ~GOAppear_AppearInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GOAppear_AppearInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GOAppear_AppearInfo(const GOAppear_AppearInfo& from) : GOAppear_AppearInfo(nullptr, from) {}
  inline GOAppear_AppearInfo(GOAppear_AppearInfo&& from) noexcept
      : GOAppear_AppearInfo(nullptr, std::move(from)) {}
  inline GOAppear_AppearInfo& operator=(const GOAppear_AppearInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GOAppear_AppearInfo& operator=(GOAppear_AppearInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GOAppear_AppearInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GOAppear_AppearInfo* internal_default_instance() {
    return reinterpret_cast<const GOAppear_AppearInfo*>(
        &_GOAppear_AppearInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 88;
  friend void swap(GOAppear_AppearInfo& a, GOAppear_AppearInfo& b) { a.Swap(&b); }
  inline void Swap(GOAppear_AppearInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GOAppear_AppearInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GOAppear_AppearInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GOAppear_AppearInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GOAppear_AppearInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GOAppear_AppearInfo& from) { GOAppear_AppearInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GOAppear_AppearInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GOAppear.AppearInfo"; }

 protected:
  explicit GOAppear_AppearInfo(::google::protobuf::Arena* arena);
  GOAppear_AppearInfo(::google::protobuf::Arena* arena, const GOAppear_AppearInfo& from);
  GOAppear_AppearInfo(::google::protobuf::Arena* arena, GOAppear_AppearInfo&& from) noexcept
      : GOAppear_AppearInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 4,
    kDirFieldNumber = 5,
    kMasterguidFieldNumber = 1,
    kObjguidFieldNumber = 2,
    kCampFieldNumber = 3,
    kHpFieldNumber = 6,
    kMpFieldNumber = 7,
    kObjTypeIdFieldNumber = 9,
    kObjTypeFieldNumber = 8,
  };
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 masterguid = 1;
  bool has_masterguid() const;
  void clear_masterguid() ;
  ::uint64_t masterguid() const;
  void set_masterguid(::uint64_t value);

  private:
  ::uint64_t _internal_masterguid() const;
  void _internal_set_masterguid(::uint64_t value);

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional int32 camp = 3;
  bool has_camp() const;
  void clear_camp() ;
  ::int32_t camp() const;
  void set_camp(::int32_t value);

  private:
  ::int32_t _internal_camp() const;
  void _internal_set_camp(::int32_t value);

  public:
  // optional uint32 hp = 6;
  bool has_hp() const;
  void clear_hp() ;
  ::uint32_t hp() const;
  void set_hp(::uint32_t value);

  private:
  ::uint32_t _internal_hp() const;
  void _internal_set_hp(::uint32_t value);

  public:
  // optional uint32 mp = 7;
  bool has_mp() const;
  void clear_mp() ;
  ::uint32_t mp() const;
  void set_mp(::uint32_t value);

  private:
  ::uint32_t _internal_mp() const;
  void _internal_set_mp(::uint32_t value);

  public:
  // optional uint32 obj_type_id = 9;
  bool has_obj_type_id() const;
  void clear_obj_type_id() ;
  ::uint32_t obj_type_id() const;
  void set_obj_type_id(::uint32_t value);

  private:
  ::uint32_t _internal_obj_type_id() const;
  void _internal_set_obj_type_id(::uint32_t value);

  public:
  // optional .GSToGC.ObjType obj_type = 8;
  bool has_obj_type() const;
  void clear_obj_type() ;
  ::GSToGC::ObjType obj_type() const;
  void set_obj_type(::GSToGC::ObjType value);

  private:
  ::GSToGC::ObjType _internal_obj_type() const;
  void _internal_set_obj_type(::GSToGC::ObjType value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GOAppear.AppearInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t masterguid_;
    ::uint64_t objguid_;
    ::int32_t camp_;
    ::uint32_t hp_;
    ::uint32_t mp_;
    ::uint32_t obj_type_id_;
    int obj_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class FreeState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.FreeState) */ {
 public:
  inline FreeState() : FreeState(nullptr) {}
  ~FreeState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FreeState(
      ::google::protobuf::internal::ConstantInitialized);

  inline FreeState(const FreeState& from) : FreeState(nullptr, from) {}
  inline FreeState(FreeState&& from) noexcept
      : FreeState(nullptr, std::move(from)) {}
  inline FreeState& operator=(const FreeState& from) {
    CopyFrom(from);
    return *this;
  }
  inline FreeState& operator=(FreeState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FreeState& default_instance() {
    return *internal_default_instance();
  }
  static inline const FreeState* internal_default_instance() {
    return reinterpret_cast<const FreeState*>(
        &_FreeState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 91;
  friend void swap(FreeState& a, FreeState& b) { a.Swap(&b); }
  inline void Swap(FreeState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FreeState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FreeState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FreeState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FreeState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FreeState& from) { FreeState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FreeState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.FreeState"; }

 protected:
  explicit FreeState(::google::protobuf::Arena* arena);
  FreeState(::google::protobuf::Arena* arena, const FreeState& from);
  FreeState(::google::protobuf::Arena* arena, FreeState&& from) noexcept
      : FreeState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 3,
    kDirFieldNumber = 4,
    kObjguidFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 4;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectFreeState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.FreeState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t objguid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class EmitSkill final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.EmitSkill) */ {
 public:
  inline EmitSkill() : EmitSkill(nullptr) {}
  ~EmitSkill() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmitSkill(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmitSkill(const EmitSkill& from) : EmitSkill(nullptr, from) {}
  inline EmitSkill(EmitSkill&& from) noexcept
      : EmitSkill(nullptr, std::move(from)) {}
  inline EmitSkill& operator=(const EmitSkill& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmitSkill& operator=(EmitSkill&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmitSkill& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmitSkill* internal_default_instance() {
    return reinterpret_cast<const EmitSkill*>(
        &_EmitSkill_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 147;
  friend void swap(EmitSkill& a, EmitSkill& b) { a.Swap(&b); }
  inline void Swap(EmitSkill* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmitSkill* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmitSkill* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EmitSkill>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmitSkill& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EmitSkill& from) { EmitSkill::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmitSkill* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.EmitSkill"; }

 protected:
  explicit EmitSkill(::google::protobuf::Arena* arena);
  EmitSkill(::google::protobuf::Arena* arena, const EmitSkill& from);
  EmitSkill(::google::protobuf::Arena* arena, EmitSkill&& from) noexcept
      : EmitSkill(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDirFieldNumber = 5,
    kTarposFieldNumber = 7,
    kGuidFieldNumber = 2,
    kEffectidFieldNumber = 3,
    kUniqueidFieldNumber = 4,
    kTarguidFieldNumber = 6,
    kIfAbsorbSkillFieldNumber = 8,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Dir dir = 5;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional .GSToGC.Pos tarpos = 7;
  bool has_tarpos() const;
  void clear_tarpos() ;
  const ::GSToGC::Pos& tarpos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_tarpos();
  ::GSToGC::Pos* mutable_tarpos();
  void set_allocated_tarpos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_tarpos();

  private:
  const ::GSToGC::Pos& _internal_tarpos() const;
  ::GSToGC::Pos* _internal_mutable_tarpos();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 effectid = 3;
  bool has_effectid() const;
  void clear_effectid() ;
  ::uint32_t effectid() const;
  void set_effectid(::uint32_t value);

  private:
  ::uint32_t _internal_effectid() const;
  void _internal_set_effectid(::uint32_t value);

  public:
  // optional int32 uniqueid = 4;
  bool has_uniqueid() const;
  void clear_uniqueid() ;
  ::int32_t uniqueid() const;
  void set_uniqueid(::int32_t value);

  private:
  ::int32_t _internal_uniqueid() const;
  void _internal_set_uniqueid(::int32_t value);

  public:
  // optional uint64 targuid = 6;
  bool has_targuid() const;
  void clear_targuid() ;
  ::uint64_t targuid() const;
  void set_targuid(::uint64_t value);

  private:
  ::uint64_t _internal_targuid() const;
  void _internal_set_targuid(::uint64_t value);

  public:
  // optional bool ifAbsorbSkill = 8;
  bool has_ifabsorbskill() const;
  void clear_ifabsorbskill() ;
  bool ifabsorbskill() const;
  void set_ifabsorbskill(bool value);

  private:
  bool _internal_ifabsorbskill() const;
  void _internal_set_ifabsorbskill(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelEmit];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.EmitSkill)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 8, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Dir* dir_;
    ::GSToGC::Pos* tarpos_;
    ::uint64_t guid_;
    ::uint32_t effectid_;
    ::int32_t uniqueid_;
    ::uint64_t targuid_;
    bool ifabsorbskill_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class DeadState final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.DeadState) */ {
 public:
  inline DeadState() : DeadState(nullptr) {}
  ~DeadState() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeadState(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeadState(const DeadState& from) : DeadState(nullptr, from) {}
  inline DeadState(DeadState&& from) noexcept
      : DeadState(nullptr, std::move(from)) {}
  inline DeadState& operator=(const DeadState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeadState& operator=(DeadState&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeadState& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeadState* internal_default_instance() {
    return reinterpret_cast<const DeadState*>(
        &_DeadState_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 97;
  friend void swap(DeadState& a, DeadState& b) { a.Swap(&b); }
  inline void Swap(DeadState* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeadState* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeadState* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<DeadState>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeadState& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeadState& from) { DeadState::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeadState* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.DeadState"; }

 protected:
  explicit DeadState(::google::protobuf::Arena* arena);
  DeadState(::google::protobuf::Arena* arena, const DeadState& from);
  DeadState(::google::protobuf::Arena* arena, DeadState&& from) noexcept
      : DeadState(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 3,
    kDirFieldNumber = 4,
    kObjguidFieldNumber = 2,
    kSpotFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 3;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional .GSToGC.Dir dir = 4;
  bool has_dir() const;
  void clear_dir() ;
  const ::GSToGC::Dir& dir() const;
  PROTOBUF_NODISCARD ::GSToGC::Dir* release_dir();
  ::GSToGC::Dir* mutable_dir();
  void set_allocated_dir(::GSToGC::Dir* value);
  void unsafe_arena_set_allocated_dir(::GSToGC::Dir* value);
  ::GSToGC::Dir* unsafe_arena_release_dir();

  private:
  const ::GSToGC::Dir& _internal_dir() const;
  ::GSToGC::Dir* _internal_mutable_dir();

  public:
  // optional uint64 objguid = 2;
  bool has_objguid() const;
  void clear_objguid() ;
  ::uint64_t objguid() const;
  void set_objguid(::uint64_t value);

  private:
  ::uint64_t _internal_objguid() const;
  void _internal_set_objguid(::uint64_t value);

  public:
  // optional bool spot = 5;
  bool has_spot() const;
  void clear_spot() ;
  bool spot() const;
  void set_spot(bool value);

  private:
  bool _internal_spot() const;
  void _internal_set_spot(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectDeadState];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.DeadState)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::GSToGC::Dir* dir_;
    ::uint64_t objguid_;
    bool spot_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CurAtkSpeed final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CurAtkSpeed) */ {
 public:
  inline CurAtkSpeed() : CurAtkSpeed(nullptr) {}
  ~CurAtkSpeed() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CurAtkSpeed(
      ::google::protobuf::internal::ConstantInitialized);

  inline CurAtkSpeed(const CurAtkSpeed& from) : CurAtkSpeed(nullptr, from) {}
  inline CurAtkSpeed(CurAtkSpeed&& from) noexcept
      : CurAtkSpeed(nullptr, std::move(from)) {}
  inline CurAtkSpeed& operator=(const CurAtkSpeed& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurAtkSpeed& operator=(CurAtkSpeed&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurAtkSpeed& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurAtkSpeed* internal_default_instance() {
    return reinterpret_cast<const CurAtkSpeed*>(
        &_CurAtkSpeed_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 128;
  friend void swap(CurAtkSpeed& a, CurAtkSpeed& b) { a.Swap(&b); }
  inline void Swap(CurAtkSpeed* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurAtkSpeed* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurAtkSpeed* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CurAtkSpeed>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CurAtkSpeed& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CurAtkSpeed& from) { CurAtkSpeed::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CurAtkSpeed* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CurAtkSpeed"; }

 protected:
  explicit CurAtkSpeed(::google::protobuf::Arena* arena);
  CurAtkSpeed(::google::protobuf::Arena* arena, const CurAtkSpeed& from);
  CurAtkSpeed(::google::protobuf::Arena* arena, CurAtkSpeed&& from) noexcept
      : CurAtkSpeed(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using SpeedInfo = CurAtkSpeed_SpeedInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.CurAtkSpeed.SpeedInfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::CurAtkSpeed_SpeedInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>* _internal_mutable_info();
  public:
  const ::GSToGC::CurAtkSpeed_SpeedInfo& info(int index) const;
  ::GSToGC::CurAtkSpeed_SpeedInfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>& info() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurAtkSpeed];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CurAtkSpeed)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::CurAtkSpeed_SpeedInfo > info_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class CanInviteFriends final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.CanInviteFriends) */ {
 public:
  inline CanInviteFriends() : CanInviteFriends(nullptr) {}
  ~CanInviteFriends() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CanInviteFriends(
      ::google::protobuf::internal::ConstantInitialized);

  inline CanInviteFriends(const CanInviteFriends& from) : CanInviteFriends(nullptr, from) {}
  inline CanInviteFriends(CanInviteFriends&& from) noexcept
      : CanInviteFriends(nullptr, std::move(from)) {}
  inline CanInviteFriends& operator=(const CanInviteFriends& from) {
    CopyFrom(from);
    return *this;
  }
  inline CanInviteFriends& operator=(CanInviteFriends&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CanInviteFriends& default_instance() {
    return *internal_default_instance();
  }
  static inline const CanInviteFriends* internal_default_instance() {
    return reinterpret_cast<const CanInviteFriends*>(
        &_CanInviteFriends_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 182;
  friend void swap(CanInviteFriends& a, CanInviteFriends& b) { a.Swap(&b); }
  inline void Swap(CanInviteFriends* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CanInviteFriends* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CanInviteFriends* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CanInviteFriends>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CanInviteFriends& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CanInviteFriends& from) { CanInviteFriends::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CanInviteFriends* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.CanInviteFriends"; }

 protected:
  explicit CanInviteFriends(::google::protobuf::Arena* arena);
  CanInviteFriends(::google::protobuf::Arena* arena, const CanInviteFriends& from);
  CanInviteFriends(::google::protobuf::Arena* arena, CanInviteFriends&& from) noexcept
      : CanInviteFriends(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Friends = CanInviteFriends_Friends;

  // accessors -------------------------------------------------------
  enum : int {
    kFriendsFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.CanInviteFriends.Friends friends = 2;
  int friends_size() const;
  private:
  int _internal_friends_size() const;

  public:
  void clear_friends() ;
  ::GSToGC::CanInviteFriends_Friends* mutable_friends(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>* mutable_friends();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>& _internal_friends() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>* _internal_mutable_friends();
  public:
  const ::GSToGC::CanInviteFriends_Friends& friends(int index) const;
  ::GSToGC::CanInviteFriends_Friends* add_friends();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>& friends() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyCanInviteFriends];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.CanInviteFriends)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::CanInviteFriends_Friends > friends_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BroadcastBattleHeroInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BroadcastBattleHeroInfo) */ {
 public:
  inline BroadcastBattleHeroInfo() : BroadcastBattleHeroInfo(nullptr) {}
  ~BroadcastBattleHeroInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastBattleHeroInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BroadcastBattleHeroInfo(const BroadcastBattleHeroInfo& from) : BroadcastBattleHeroInfo(nullptr, from) {}
  inline BroadcastBattleHeroInfo(BroadcastBattleHeroInfo&& from) noexcept
      : BroadcastBattleHeroInfo(nullptr, std::move(from)) {}
  inline BroadcastBattleHeroInfo& operator=(const BroadcastBattleHeroInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastBattleHeroInfo& operator=(BroadcastBattleHeroInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastBattleHeroInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastBattleHeroInfo* internal_default_instance() {
    return reinterpret_cast<const BroadcastBattleHeroInfo*>(
        &_BroadcastBattleHeroInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 53;
  friend void swap(BroadcastBattleHeroInfo& a, BroadcastBattleHeroInfo& b) { a.Swap(&b); }
  inline void Swap(BroadcastBattleHeroInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastBattleHeroInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastBattleHeroInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BroadcastBattleHeroInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BroadcastBattleHeroInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BroadcastBattleHeroInfo& from) { BroadcastBattleHeroInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BroadcastBattleHeroInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BroadcastBattleHeroInfo"; }

 protected:
  explicit BroadcastBattleHeroInfo(::google::protobuf::Arena* arena);
  BroadcastBattleHeroInfo(::google::protobuf::Arena* arena, const BroadcastBattleHeroInfo& from);
  BroadcastBattleHeroInfo(::google::protobuf::Arena* arena, BroadcastBattleHeroInfo&& from) noexcept
      : BroadcastBattleHeroInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using HeroInfo = BroadcastBattleHeroInfo_HeroInfo;
  using BaseGoodsInfo = BroadcastBattleHeroInfo_BaseGoodsInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kHeroinfoFieldNumber = 2,
    kGoodsinfoFieldNumber = 3,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.BroadcastBattleHeroInfo.HeroInfo heroinfo = 2;
  int heroinfo_size() const;
  private:
  int _internal_heroinfo_size() const;

  public:
  void clear_heroinfo() ;
  ::GSToGC::BroadcastBattleHeroInfo_HeroInfo* mutable_heroinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>* mutable_heroinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>& _internal_heroinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>* _internal_mutable_heroinfo();
  public:
  const ::GSToGC::BroadcastBattleHeroInfo_HeroInfo& heroinfo(int index) const;
  ::GSToGC::BroadcastBattleHeroInfo_HeroInfo* add_heroinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>& heroinfo() const;
  // repeated .GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo goodsinfo = 3;
  int goodsinfo_size() const;
  private:
  int _internal_goodsinfo_size() const;

  public:
  void clear_goodsinfo() ;
  ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo* mutable_goodsinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>* mutable_goodsinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>& _internal_goodsinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>* _internal_mutable_goodsinfo();
  public:
  const ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo& goodsinfo(int index) const;
  ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo* add_goodsinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>& goodsinfo() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadcastBattleHeroInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BroadcastBattleHeroInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::BroadcastBattleHeroInfo_HeroInfo > heroinfo_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo > goodsinfo_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BroadcastBatteleRes final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BroadcastBatteleRes) */ {
 public:
  inline BroadcastBatteleRes() : BroadcastBatteleRes(nullptr) {}
  ~BroadcastBatteleRes() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BroadcastBatteleRes(
      ::google::protobuf::internal::ConstantInitialized);

  inline BroadcastBatteleRes(const BroadcastBatteleRes& from) : BroadcastBatteleRes(nullptr, from) {}
  inline BroadcastBatteleRes(BroadcastBatteleRes&& from) noexcept
      : BroadcastBatteleRes(nullptr, std::move(from)) {}
  inline BroadcastBatteleRes& operator=(const BroadcastBatteleRes& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastBatteleRes& operator=(BroadcastBatteleRes&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastBatteleRes& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastBatteleRes* internal_default_instance() {
    return reinterpret_cast<const BroadcastBatteleRes*>(
        &_BroadcastBatteleRes_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 136;
  friend void swap(BroadcastBatteleRes& a, BroadcastBatteleRes& b) { a.Swap(&b); }
  inline void Swap(BroadcastBatteleRes* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastBatteleRes* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastBatteleRes* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BroadcastBatteleRes>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BroadcastBatteleRes& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BroadcastBatteleRes& from) { BroadcastBatteleRes::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BroadcastBatteleRes* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BroadcastBatteleRes"; }

 protected:
  explicit BroadcastBatteleRes(::google::protobuf::Arena* arena);
  BroadcastBatteleRes(::google::protobuf::Arena* arena, const BroadcastBatteleRes& from);
  BroadcastBatteleRes(::google::protobuf::Arena* arena, BroadcastBatteleRes&& from) noexcept
      : BroadcastBatteleRes(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using ResInfo = BroadcastBatteleRes_ResInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kResinfoFieldNumber = 3,
    kIfwinFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.BroadcastBatteleRes.ResInfo resinfo = 3;
  int resinfo_size() const;
  private:
  int _internal_resinfo_size() const;

  public:
  void clear_resinfo() ;
  ::GSToGC::BroadcastBatteleRes_ResInfo* mutable_resinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>* mutable_resinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>& _internal_resinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>* _internal_mutable_resinfo();
  public:
  const ::GSToGC::BroadcastBatteleRes_ResInfo& resinfo(int index) const;
  ::GSToGC::BroadcastBatteleRes_ResInfo* add_resinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>& resinfo() const;
  // optional bool ifwin = 2;
  bool has_ifwin() const;
  void clear_ifwin() ;
  bool ifwin() const;
  void set_ifwin(bool value);

  private:
  bool _internal_ifwin() const;
  void _internal_set_ifwin(bool value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadCurBattleResult];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BroadcastBatteleRes)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::BroadcastBatteleRes_ResInfo > resinfo_;
    bool ifwin_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BornSoler final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BornSoler) */ {
 public:
  inline BornSoler() : BornSoler(nullptr) {}
  ~BornSoler() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BornSoler(
      ::google::protobuf::internal::ConstantInitialized);

  inline BornSoler(const BornSoler& from) : BornSoler(nullptr, from) {}
  inline BornSoler(BornSoler&& from) noexcept
      : BornSoler(nullptr, std::move(from)) {}
  inline BornSoler& operator=(const BornSoler& from) {
    CopyFrom(from);
    return *this;
  }
  inline BornSoler& operator=(BornSoler&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BornSoler& default_instance() {
    return *internal_default_instance();
  }
  static inline const BornSoler* internal_default_instance() {
    return reinterpret_cast<const BornSoler*>(
        &_BornSoler_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 142;
  friend void swap(BornSoler& a, BornSoler& b) { a.Swap(&b); }
  inline void Swap(BornSoler* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BornSoler* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BornSoler* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BornSoler>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BornSoler& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BornSoler& from) { BornSoler::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BornSoler* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BornSoler"; }

 protected:
  explicit BornSoler(::google::protobuf::Arena* arena);
  BornSoler(::google::protobuf::Arena* arena, const BornSoler& from);
  BornSoler(::google::protobuf::Arena* arena, BornSoler&& from) noexcept
      : BornSoler(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPosFieldNumber = 4,
    kTypeFieldNumber = 2,
    kCampFieldNumber = 3,
    kGuidFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // optional .GSToGC.Pos pos = 4;
  bool has_pos() const;
  void clear_pos() ;
  const ::GSToGC::Pos& pos() const;
  PROTOBUF_NODISCARD ::GSToGC::Pos* release_pos();
  ::GSToGC::Pos* mutable_pos();
  void set_allocated_pos(::GSToGC::Pos* value);
  void unsafe_arena_set_allocated_pos(::GSToGC::Pos* value);
  ::GSToGC::Pos* unsafe_arena_release_pos();

  private:
  const ::GSToGC::Pos& _internal_pos() const;
  ::GSToGC::Pos* _internal_mutable_pos();

  public:
  // optional int32 type = 2;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional int32 camp = 3;
  bool has_camp() const;
  void clear_camp() ;
  ::int32_t camp() const;
  void set_camp(::int32_t value);

  private:
  ::int32_t _internal_camp() const;
  void _internal_set_camp(::int32_t value);

  public:
  // optional uint64 guid = 5;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBornSolder];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BornSoler)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::GSToGC::Pos* pos_;
    ::int32_t type_;
    ::int32_t camp_;
    ::uint64_t guid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class BattleSeatPosInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.BattleSeatPosInfo) */ {
 public:
  inline BattleSeatPosInfo() : BattleSeatPosInfo(nullptr) {}
  ~BattleSeatPosInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleSeatPosInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleSeatPosInfo(const BattleSeatPosInfo& from) : BattleSeatPosInfo(nullptr, from) {}
  inline BattleSeatPosInfo(BattleSeatPosInfo&& from) noexcept
      : BattleSeatPosInfo(nullptr, std::move(from)) {}
  inline BattleSeatPosInfo& operator=(const BattleSeatPosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleSeatPosInfo& operator=(BattleSeatPosInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleSeatPosInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleSeatPosInfo* internal_default_instance() {
    return reinterpret_cast<const BattleSeatPosInfo*>(
        &_BattleSeatPosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 83;
  friend void swap(BattleSeatPosInfo& a, BattleSeatPosInfo& b) { a.Swap(&b); }
  inline void Swap(BattleSeatPosInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleSeatPosInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleSeatPosInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleSeatPosInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleSeatPosInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleSeatPosInfo& from) { BattleSeatPosInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleSeatPosInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.BattleSeatPosInfo"; }

 protected:
  explicit BattleSeatPosInfo(::google::protobuf::Arena* arena);
  BattleSeatPosInfo(::google::protobuf::Arena* arena, const BattleSeatPosInfo& from);
  BattleSeatPosInfo(::google::protobuf::Arena* arena, BattleSeatPosInfo&& from) noexcept
      : BattleSeatPosInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using PosInfo = BattleSeatPosInfo_PosInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kPosinfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.BattleSeatPosInfo.PosInfo posinfo = 2;
  int posinfo_size() const;
  private:
  int _internal_posinfo_size() const;

  public:
  void clear_posinfo() ;
  ::GSToGC::BattleSeatPosInfo_PosInfo* mutable_posinfo(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>* mutable_posinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>& _internal_posinfo() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>* _internal_mutable_posinfo();
  public:
  const ::GSToGC::BattleSeatPosInfo_PosInfo& posinfo(int index) const;
  ::GSToGC::BattleSeatPosInfo_PosInfo* add_posinfo();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>& posinfo() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleSeatPosInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.BattleSeatPosInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::BattleSeatPosInfo_PosInfo > posinfo_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class AskRoomListRet final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.AskRoomListRet) */ {
 public:
  inline AskRoomListRet() : AskRoomListRet(nullptr) {}
  ~AskRoomListRet() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRoomListRet(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRoomListRet(const AskRoomListRet& from) : AskRoomListRet(nullptr, from) {}
  inline AskRoomListRet(AskRoomListRet&& from) noexcept
      : AskRoomListRet(nullptr, std::move(from)) {}
  inline AskRoomListRet& operator=(const AskRoomListRet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRoomListRet& operator=(AskRoomListRet&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRoomListRet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRoomListRet* internal_default_instance() {
    return reinterpret_cast<const AskRoomListRet*>(
        &_AskRoomListRet_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 185;
  friend void swap(AskRoomListRet& a, AskRoomListRet& b) { a.Swap(&b); }
  inline void Swap(AskRoomListRet* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRoomListRet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRoomListRet* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRoomListRet>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRoomListRet& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRoomListRet& from) { AskRoomListRet::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRoomListRet* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.AskRoomListRet"; }

 protected:
  explicit AskRoomListRet(::google::protobuf::Arena* arena);
  AskRoomListRet(::google::protobuf::Arena* arena, const AskRoomListRet& from);
  AskRoomListRet(::google::protobuf::Arena* arena, AskRoomListRet&& from) noexcept
      : AskRoomListRet(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRoomlistFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.RoomInfo roomlist = 2;
  int roomlist_size() const;
  private:
  int _internal_roomlist_size() const;

  public:
  void clear_roomlist() ;
  ::GSToGC::RoomInfo* mutable_roomlist(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>* mutable_roomlist();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>& _internal_roomlist() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>* _internal_mutable_roomlist();
  public:
  const ::GSToGC::RoomInfo& roomlist(int index) const;
  ::GSToGC::RoomInfo* add_roomlist();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>& roomlist() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_AskRoomListRet];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.AskRoomListRet)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::RoomInfo > roomlist_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class NotifyHerosInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.NotifyHerosInfo) */ {
 public:
  inline NotifyHerosInfo() : NotifyHerosInfo(nullptr) {}
  ~NotifyHerosInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotifyHerosInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline NotifyHerosInfo(const NotifyHerosInfo& from) : NotifyHerosInfo(nullptr, from) {}
  inline NotifyHerosInfo(NotifyHerosInfo&& from) noexcept
      : NotifyHerosInfo(nullptr, std::move(from)) {}
  inline NotifyHerosInfo& operator=(const NotifyHerosInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotifyHerosInfo& operator=(NotifyHerosInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotifyHerosInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotifyHerosInfo* internal_default_instance() {
    return reinterpret_cast<const NotifyHerosInfo*>(
        &_NotifyHerosInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(NotifyHerosInfo& a, NotifyHerosInfo& b) { a.Swap(&b); }
  inline void Swap(NotifyHerosInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotifyHerosInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotifyHerosInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NotifyHerosInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotifyHerosInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotifyHerosInfo& from) { NotifyHerosInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotifyHerosInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.NotifyHerosInfo"; }

 protected:
  explicit NotifyHerosInfo(::google::protobuf::Arena* arena);
  NotifyHerosInfo(::google::protobuf::Arena* arena, const NotifyHerosInfo& from);
  NotifyHerosInfo(::google::protobuf::Arena* arena, NotifyHerosInfo&& from) noexcept
      : NotifyHerosInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using heropanelinfo = NotifyHerosInfo_heropanelinfo;

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.NotifyHerosInfo.heropanelinfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::NotifyHerosInfo_heropanelinfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>* _internal_mutable_info();
  public:
  const ::GSToGC::NotifyHerosInfo_heropanelinfo& info(int index) const;
  ::GSToGC::NotifyHerosInfo_heropanelinfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>& info() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyHerosInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.NotifyHerosInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::NotifyHerosInfo_heropanelinfo > info_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GoodsBuyCfgInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GoodsBuyCfgInfo) */ {
 public:
  inline GoodsBuyCfgInfo() : GoodsBuyCfgInfo(nullptr) {}
  ~GoodsBuyCfgInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoodsBuyCfgInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoodsBuyCfgInfo(const GoodsBuyCfgInfo& from) : GoodsBuyCfgInfo(nullptr, from) {}
  inline GoodsBuyCfgInfo(GoodsBuyCfgInfo&& from) noexcept
      : GoodsBuyCfgInfo(nullptr, std::move(from)) {}
  inline GoodsBuyCfgInfo& operator=(const GoodsBuyCfgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoodsBuyCfgInfo& operator=(GoodsBuyCfgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoodsBuyCfgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoodsBuyCfgInfo* internal_default_instance() {
    return reinterpret_cast<const GoodsBuyCfgInfo*>(
        &_GoodsBuyCfgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 40;
  friend void swap(GoodsBuyCfgInfo& a, GoodsBuyCfgInfo& b) { a.Swap(&b); }
  inline void Swap(GoodsBuyCfgInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoodsBuyCfgInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoodsBuyCfgInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GoodsBuyCfgInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoodsBuyCfgInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoodsBuyCfgInfo& from) { GoodsBuyCfgInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GoodsBuyCfgInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GoodsBuyCfgInfo"; }

 protected:
  explicit GoodsBuyCfgInfo(::google::protobuf::Arena* arena);
  GoodsBuyCfgInfo(::google::protobuf::Arena* arena, const GoodsBuyCfgInfo& from);
  GoodsBuyCfgInfo(::google::protobuf::Arena* arena, GoodsBuyCfgInfo&& from) noexcept
      : GoodsBuyCfgInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.GoodsCfgInfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::GoodsCfgInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>* _internal_mutable_info();
  public:
  const ::GSToGC::GoodsCfgInfo& info(int index) const;
  ::GSToGC::GoodsCfgInfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>& info() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGoodsCfgInfo];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GoodsBuyCfgInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::GoodsCfgInfo > info_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};
// -------------------------------------------------------------------

class GOAppear final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:GSToGC.GOAppear) */ {
 public:
  inline GOAppear() : GOAppear(nullptr) {}
  ~GOAppear() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GOAppear(
      ::google::protobuf::internal::ConstantInitialized);

  inline GOAppear(const GOAppear& from) : GOAppear(nullptr, from) {}
  inline GOAppear(GOAppear&& from) noexcept
      : GOAppear(nullptr, std::move(from)) {}
  inline GOAppear& operator=(const GOAppear& from) {
    CopyFrom(from);
    return *this;
  }
  inline GOAppear& operator=(GOAppear&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GOAppear& default_instance() {
    return *internal_default_instance();
  }
  static inline const GOAppear* internal_default_instance() {
    return reinterpret_cast<const GOAppear*>(
        &_GOAppear_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 89;
  friend void swap(GOAppear& a, GOAppear& b) { a.Swap(&b); }
  inline void Swap(GOAppear* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GOAppear* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GOAppear* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GOAppear>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GOAppear& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GOAppear& from) { GOAppear::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GOAppear* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "GSToGC.GOAppear"; }

 protected:
  explicit GOAppear(::google::protobuf::Arena* arena);
  GOAppear(::google::protobuf::Arena* arena, const GOAppear& from);
  GOAppear(::google::protobuf::Arena* arena, GOAppear&& from) noexcept
      : GOAppear(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using AppearInfo = GOAppear_AppearInfo;

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .GSToGC.GOAppear.AppearInfo info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::GSToGC::GOAppear_AppearInfo* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>* _internal_mutable_info();
  public:
  const ::GSToGC::GOAppear_AppearInfo& info(int index) const;
  ::GSToGC::GOAppear_AppearInfo* add_info();
  const ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>& info() const;
  // optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectAppear];
  bool has_msgid() const;
  void clear_msgid() ;
  ::GSToGC::MsgID msgid() const;
  void set_msgid(::GSToGC::MsgID value);

  private:
  ::GSToGC::MsgID _internal_msgid() const;
  void _internal_set_msgid(::GSToGC::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:GSToGC.GOAppear)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::GSToGC::GOAppear_AppearInfo > info_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_GSToGC_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TaskData

// optional uint32 task_id = 1;
inline bool TaskData::has_task_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TaskData::clear_task_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t TaskData::task_id() const {
  // @@protoc_insertion_point(field_get:GSToGC.TaskData.task_id)
  return _internal_task_id();
}
inline void TaskData::set_task_id(::uint32_t value) {
  _internal_set_task_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.TaskData.task_id)
}
inline ::uint32_t TaskData::_internal_task_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_id_;
}
inline void TaskData::_internal_set_task_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_id_ = value;
}

// optional uint32 task_guid = 2;
inline bool TaskData::has_task_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TaskData::clear_task_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t TaskData::task_guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.TaskData.task_guid)
  return _internal_task_guid();
}
inline void TaskData::set_task_guid(::uint32_t value) {
  _internal_set_task_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.TaskData.task_guid)
}
inline ::uint32_t TaskData::_internal_task_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_guid_;
}
inline void TaskData::_internal_set_task_guid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = value;
}

// optional uint32 task_curCount = 3;
inline bool TaskData::has_task_curcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TaskData::clear_task_curcount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_curcount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t TaskData::task_curcount() const {
  // @@protoc_insertion_point(field_get:GSToGC.TaskData.task_curCount)
  return _internal_task_curcount();
}
inline void TaskData::set_task_curcount(::uint32_t value) {
  _internal_set_task_curcount(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.TaskData.task_curCount)
}
inline ::uint32_t TaskData::_internal_task_curcount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_curcount_;
}
inline void TaskData::_internal_set_task_curcount(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_curcount_ = value;
}

// -------------------------------------------------------------------

// NotifyUpdateAllTask

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UpdateAllTask];
inline bool NotifyUpdateAllTask::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyUpdateAllTask::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 400;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyUpdateAllTask::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUpdateAllTask.msgid)
  return _internal_msgid();
}
inline void NotifyUpdateAllTask::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUpdateAllTask.msgid)
}
inline ::GSToGC::MsgID NotifyUpdateAllTask::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyUpdateAllTask::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.TaskData taskList = 2;
inline int NotifyUpdateAllTask::_internal_tasklist_size() const {
  return _internal_tasklist().size();
}
inline int NotifyUpdateAllTask::tasklist_size() const {
  return _internal_tasklist_size();
}
inline void NotifyUpdateAllTask::clear_tasklist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasklist_.Clear();
}
inline ::GSToGC::TaskData* NotifyUpdateAllTask::mutable_tasklist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyUpdateAllTask.taskList)
  return _internal_mutable_tasklist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>* NotifyUpdateAllTask::mutable_tasklist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyUpdateAllTask.taskList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasklist();
}
inline const ::GSToGC::TaskData& NotifyUpdateAllTask::tasklist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUpdateAllTask.taskList)
  return _internal_tasklist().Get(index);
}
inline ::GSToGC::TaskData* NotifyUpdateAllTask::add_tasklist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::TaskData* _add = _internal_mutable_tasklist()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyUpdateAllTask.taskList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>& NotifyUpdateAllTask::tasklist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyUpdateAllTask.taskList)
  return _internal_tasklist();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>&
NotifyUpdateAllTask::_internal_tasklist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasklist_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>*
NotifyUpdateAllTask::_internal_mutable_tasklist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasklist_;
}

// -------------------------------------------------------------------

// NotifyUpdateAllDailyTask

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UpdateAllDailyTask];
inline bool NotifyUpdateAllDailyTask::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyUpdateAllDailyTask::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 401;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyUpdateAllDailyTask::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUpdateAllDailyTask.msgid)
  return _internal_msgid();
}
inline void NotifyUpdateAllDailyTask::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUpdateAllDailyTask.msgid)
}
inline ::GSToGC::MsgID NotifyUpdateAllDailyTask::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyUpdateAllDailyTask::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.TaskData taskList = 2;
inline int NotifyUpdateAllDailyTask::_internal_tasklist_size() const {
  return _internal_tasklist().size();
}
inline int NotifyUpdateAllDailyTask::tasklist_size() const {
  return _internal_tasklist_size();
}
inline void NotifyUpdateAllDailyTask::clear_tasklist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tasklist_.Clear();
}
inline ::GSToGC::TaskData* NotifyUpdateAllDailyTask::mutable_tasklist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyUpdateAllDailyTask.taskList)
  return _internal_mutable_tasklist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>* NotifyUpdateAllDailyTask::mutable_tasklist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyUpdateAllDailyTask.taskList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_tasklist();
}
inline const ::GSToGC::TaskData& NotifyUpdateAllDailyTask::tasklist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUpdateAllDailyTask.taskList)
  return _internal_tasklist().Get(index);
}
inline ::GSToGC::TaskData* NotifyUpdateAllDailyTask::add_tasklist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::TaskData* _add = _internal_mutable_tasklist()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyUpdateAllDailyTask.taskList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>& NotifyUpdateAllDailyTask::tasklist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyUpdateAllDailyTask.taskList)
  return _internal_tasklist();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>&
NotifyUpdateAllDailyTask::_internal_tasklist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tasklist_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::TaskData>*
NotifyUpdateAllDailyTask::_internal_mutable_tasklist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.tasklist_;
}

// -------------------------------------------------------------------

// NotifyAddOneTask

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_AddOneTask];
inline bool NotifyAddOneTask::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyAddOneTask::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 402;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyAddOneTask::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAddOneTask.msgid)
  return _internal_msgid();
}
inline void NotifyAddOneTask::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAddOneTask.msgid)
}
inline ::GSToGC::MsgID NotifyAddOneTask::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyAddOneTask::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional .GSToGC.TaskData oneTask = 2;
inline bool NotifyAddOneTask::has_onetask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.onetask_ != nullptr);
  return value;
}
inline void NotifyAddOneTask::clear_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.onetask_ != nullptr) _impl_.onetask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::TaskData& NotifyAddOneTask::_internal_onetask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::TaskData* p = _impl_.onetask_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::TaskData&>(::GSToGC::_TaskData_default_instance_);
}
inline const ::GSToGC::TaskData& NotifyAddOneTask::onetask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAddOneTask.oneTask)
  return _internal_onetask();
}
inline void NotifyAddOneTask::unsafe_arena_set_allocated_onetask(::GSToGC::TaskData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.onetask_);
  }
  _impl_.onetask_ = reinterpret_cast<::GSToGC::TaskData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifyAddOneTask.oneTask)
}
inline ::GSToGC::TaskData* NotifyAddOneTask::release_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::TaskData* released = _impl_.onetask_;
  _impl_.onetask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::TaskData* NotifyAddOneTask::unsafe_arena_release_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyAddOneTask.oneTask)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::TaskData* temp = _impl_.onetask_;
  _impl_.onetask_ = nullptr;
  return temp;
}
inline ::GSToGC::TaskData* NotifyAddOneTask::_internal_mutable_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.onetask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::TaskData>(GetArena());
    _impl_.onetask_ = reinterpret_cast<::GSToGC::TaskData*>(p);
  }
  return _impl_.onetask_;
}
inline ::GSToGC::TaskData* NotifyAddOneTask::mutable_onetask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::TaskData* _msg = _internal_mutable_onetask();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyAddOneTask.oneTask)
  return _msg;
}
inline void NotifyAddOneTask::set_allocated_onetask(::GSToGC::TaskData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.onetask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.onetask_ = reinterpret_cast<::GSToGC::TaskData*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyAddOneTask.oneTask)
}

// -------------------------------------------------------------------

// NotifyUpdateOneTask

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UpdateOneTask];
inline bool NotifyUpdateOneTask::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyUpdateOneTask::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 403;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyUpdateOneTask::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUpdateOneTask.msgid)
  return _internal_msgid();
}
inline void NotifyUpdateOneTask::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUpdateOneTask.msgid)
}
inline ::GSToGC::MsgID NotifyUpdateOneTask::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyUpdateOneTask::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional .GSToGC.TaskData oneTask = 2;
inline bool NotifyUpdateOneTask::has_onetask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.onetask_ != nullptr);
  return value;
}
inline void NotifyUpdateOneTask::clear_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.onetask_ != nullptr) _impl_.onetask_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::TaskData& NotifyUpdateOneTask::_internal_onetask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::TaskData* p = _impl_.onetask_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::TaskData&>(::GSToGC::_TaskData_default_instance_);
}
inline const ::GSToGC::TaskData& NotifyUpdateOneTask::onetask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUpdateOneTask.oneTask)
  return _internal_onetask();
}
inline void NotifyUpdateOneTask::unsafe_arena_set_allocated_onetask(::GSToGC::TaskData* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.onetask_);
  }
  _impl_.onetask_ = reinterpret_cast<::GSToGC::TaskData*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifyUpdateOneTask.oneTask)
}
inline ::GSToGC::TaskData* NotifyUpdateOneTask::release_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::TaskData* released = _impl_.onetask_;
  _impl_.onetask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::TaskData* NotifyUpdateOneTask::unsafe_arena_release_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyUpdateOneTask.oneTask)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::TaskData* temp = _impl_.onetask_;
  _impl_.onetask_ = nullptr;
  return temp;
}
inline ::GSToGC::TaskData* NotifyUpdateOneTask::_internal_mutable_onetask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.onetask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::TaskData>(GetArena());
    _impl_.onetask_ = reinterpret_cast<::GSToGC::TaskData*>(p);
  }
  return _impl_.onetask_;
}
inline ::GSToGC::TaskData* NotifyUpdateOneTask::mutable_onetask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::TaskData* _msg = _internal_mutable_onetask();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyUpdateOneTask.oneTask)
  return _msg;
}
inline void NotifyUpdateOneTask::set_allocated_onetask(::GSToGC::TaskData* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.onetask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.onetask_ = reinterpret_cast<::GSToGC::TaskData*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyUpdateOneTask.oneTask)
}

// -------------------------------------------------------------------

// NotifyDelOneTask

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_DelOneTask];
inline bool NotifyDelOneTask::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyDelOneTask::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 404;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyDelOneTask::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyDelOneTask.msgid)
  return _internal_msgid();
}
inline void NotifyDelOneTask::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyDelOneTask.msgid)
}
inline ::GSToGC::MsgID NotifyDelOneTask::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyDelOneTask::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 task_guid = 2;
inline bool NotifyDelOneTask::has_task_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyDelOneTask::clear_task_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyDelOneTask::task_guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyDelOneTask.task_guid)
  return _internal_task_guid();
}
inline void NotifyDelOneTask::set_task_guid(::uint32_t value) {
  _internal_set_task_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyDelOneTask.task_guid)
}
inline ::uint32_t NotifyDelOneTask::_internal_task_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_guid_;
}
inline void NotifyDelOneTask::_internal_set_task_guid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = value;
}

// -------------------------------------------------------------------

// NotifyRewardsOneTask

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_RewardsOneTask];
inline bool NotifyRewardsOneTask::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyRewardsOneTask::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 405;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyRewardsOneTask::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyRewardsOneTask.msgid)
  return _internal_msgid();
}
inline void NotifyRewardsOneTask::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyRewardsOneTask.msgid)
}
inline ::GSToGC::MsgID NotifyRewardsOneTask::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyRewardsOneTask::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 task_guid = 2;
inline bool NotifyRewardsOneTask::has_task_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyRewardsOneTask::clear_task_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyRewardsOneTask::task_guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyRewardsOneTask.task_guid)
  return _internal_task_guid();
}
inline void NotifyRewardsOneTask::set_task_guid(::uint32_t value) {
  _internal_set_task_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyRewardsOneTask.task_guid)
}
inline ::uint32_t NotifyRewardsOneTask::_internal_task_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.task_guid_;
}
inline void NotifyRewardsOneTask::_internal_set_task_guid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.task_guid_ = value;
}

// -------------------------------------------------------------------

// NotifyMailRet

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMailRet];
inline bool NotifyMailRet::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyMailRet::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 601;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyMailRet::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMailRet.msgid)
  return _internal_msgid();
}
inline void NotifyMailRet::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMailRet.msgid)
}
inline ::GSToGC::MsgID NotifyMailRet::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyMailRet::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 mailid = 2;
inline bool NotifyMailRet::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMailRet::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t NotifyMailRet::mailid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMailRet.mailid)
  return _internal_mailid();
}
inline void NotifyMailRet::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMailRet.mailid)
}
inline ::int32_t NotifyMailRet::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void NotifyMailRet::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional int32 errcode = 3;
inline bool NotifyMailRet::has_errcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyMailRet::clear_errcode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyMailRet::errcode() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMailRet.errcode)
  return _internal_errcode();
}
inline void NotifyMailRet::set_errcode(::int32_t value) {
  _internal_set_errcode(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMailRet.errcode)
}
inline ::int32_t NotifyMailRet::_internal_errcode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errcode_;
}
inline void NotifyMailRet::_internal_set_errcode(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errcode_ = value;
}

// -------------------------------------------------------------------

// NotifyIsOnSS

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_NotifyIsOnSS];
inline bool NotifyIsOnSS::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyIsOnSS::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 238;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyIsOnSS::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyIsOnSS.msgid)
  return _internal_msgid();
}
inline void NotifyIsOnSS::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyIsOnSS.msgid)
}
inline ::GSToGC::MsgID NotifyIsOnSS::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyIsOnSS::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 ssid = 2;
inline bool NotifyIsOnSS::has_ssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyIsOnSS::clear_ssid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyIsOnSS::ssid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyIsOnSS.ssid)
  return _internal_ssid();
}
inline void NotifyIsOnSS::set_ssid(::uint32_t value) {
  _internal_set_ssid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyIsOnSS.ssid)
}
inline ::uint32_t NotifyIsOnSS::_internal_ssid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssid_;
}
inline void NotifyIsOnSS::_internal_set_ssid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssid_ = value;
}

// -------------------------------------------------------------------

// NotifyOtherItemInfo_OtherItem

// optional uint32 item_id = 1;
inline bool NotifyOtherItemInfo_OtherItem::has_item_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyOtherItemInfo_OtherItem::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyOtherItemInfo_OtherItem::item_id() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOtherItemInfo.OtherItem.item_id)
  return _internal_item_id();
}
inline void NotifyOtherItemInfo_OtherItem::set_item_id(::uint32_t value) {
  _internal_set_item_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOtherItemInfo.OtherItem.item_id)
}
inline ::uint32_t NotifyOtherItemInfo_OtherItem::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_;
}
inline void NotifyOtherItemInfo_OtherItem::_internal_set_item_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = value;
}

// optional uint32 item_num = 2;
inline bool NotifyOtherItemInfo_OtherItem::has_item_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyOtherItemInfo_OtherItem::clear_item_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyOtherItemInfo_OtherItem::item_num() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOtherItemInfo.OtherItem.item_num)
  return _internal_item_num();
}
inline void NotifyOtherItemInfo_OtherItem::set_item_num(::uint32_t value) {
  _internal_set_item_num(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOtherItemInfo.OtherItem.item_num)
}
inline ::uint32_t NotifyOtherItemInfo_OtherItem::_internal_item_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_num_;
}
inline void NotifyOtherItemInfo_OtherItem::_internal_set_item_num(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = value;
}

// optional int64 expired_time = 3;
inline bool NotifyOtherItemInfo_OtherItem::has_expired_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyOtherItemInfo_OtherItem::clear_expired_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expired_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t NotifyOtherItemInfo_OtherItem::expired_time() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOtherItemInfo.OtherItem.expired_time)
  return _internal_expired_time();
}
inline void NotifyOtherItemInfo_OtherItem::set_expired_time(::int64_t value) {
  _internal_set_expired_time(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOtherItemInfo.OtherItem.expired_time)
}
inline ::int64_t NotifyOtherItemInfo_OtherItem::_internal_expired_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expired_time_;
}
inline void NotifyOtherItemInfo_OtherItem::_internal_set_expired_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expired_time_ = value;
}

// -------------------------------------------------------------------

// NotifyOtherItemInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOtherItemInfo];
inline bool NotifyOtherItemInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyOtherItemInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 237;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyOtherItemInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOtherItemInfo.msgid)
  return _internal_msgid();
}
inline void NotifyOtherItemInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOtherItemInfo.msgid)
}
inline ::GSToGC::MsgID NotifyOtherItemInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyOtherItemInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.NotifyOtherItemInfo.OtherItem item = 2;
inline int NotifyOtherItemInfo::_internal_item_size() const {
  return _internal_item().size();
}
inline int NotifyOtherItemInfo::item_size() const {
  return _internal_item_size();
}
inline void NotifyOtherItemInfo::clear_item() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_.Clear();
}
inline ::GSToGC::NotifyOtherItemInfo_OtherItem* NotifyOtherItemInfo::mutable_item(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyOtherItemInfo.item)
  return _internal_mutable_item()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>* NotifyOtherItemInfo::mutable_item()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyOtherItemInfo.item)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item();
}
inline const ::GSToGC::NotifyOtherItemInfo_OtherItem& NotifyOtherItemInfo::item(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOtherItemInfo.item)
  return _internal_item().Get(index);
}
inline ::GSToGC::NotifyOtherItemInfo_OtherItem* NotifyOtherItemInfo::add_item() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyOtherItemInfo_OtherItem* _add = _internal_mutable_item()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyOtherItemInfo.item)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>& NotifyOtherItemInfo::item() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyOtherItemInfo.item)
  return _internal_item();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>&
NotifyOtherItemInfo::_internal_item() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyOtherItemInfo_OtherItem>*
NotifyOtherItemInfo::_internal_mutable_item() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_;
}

// -------------------------------------------------------------------

// RecoinRuneRet

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_RecoinRuneRet];
inline bool RecoinRuneRet::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RecoinRuneRet::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 236;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID RecoinRuneRet::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RecoinRuneRet.msgid)
  return _internal_msgid();
}
inline void RecoinRuneRet::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RecoinRuneRet.msgid)
}
inline ::GSToGC::MsgID RecoinRuneRet::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void RecoinRuneRet::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 rune_id = 2;
inline bool RecoinRuneRet::has_rune_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RecoinRuneRet::clear_rune_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rune_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t RecoinRuneRet::rune_id() const {
  // @@protoc_insertion_point(field_get:GSToGC.RecoinRuneRet.rune_id)
  return _internal_rune_id();
}
inline void RecoinRuneRet::set_rune_id(::uint32_t value) {
  _internal_set_rune_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.RecoinRuneRet.rune_id)
}
inline ::uint32_t RecoinRuneRet::_internal_rune_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rune_id_;
}
inline void RecoinRuneRet::_internal_set_rune_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rune_id_ = value;
}

// -------------------------------------------------------------------

// UnloadRune

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_UnloadRune];
inline bool UnloadRune::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UnloadRune::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 234;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID UnloadRune::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UnloadRune.msgid)
  return _internal_msgid();
}
inline void UnloadRune::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.UnloadRune.msgid)
}
inline ::GSToGC::MsgID UnloadRune::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void UnloadRune::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 page = 2;
inline bool UnloadRune::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UnloadRune::clear_page() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UnloadRune::page() const {
  // @@protoc_insertion_point(field_get:GSToGC.UnloadRune.page)
  return _internal_page();
}
inline void UnloadRune::set_page(::int32_t value) {
  _internal_set_page(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.UnloadRune.page)
}
inline ::int32_t UnloadRune::_internal_page() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_;
}
inline void UnloadRune::_internal_set_page(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_ = value;
}

// optional int32 pos = 3;
inline bool UnloadRune::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UnloadRune::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t UnloadRune::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.UnloadRune.pos)
  return _internal_pos();
}
inline void UnloadRune::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.UnloadRune.pos)
}
inline ::int32_t UnloadRune::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void UnloadRune::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// -------------------------------------------------------------------

// GuideCSStepInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GuideResp];
inline bool GuideCSStepInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GuideCSStepInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 300;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID GuideCSStepInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideCSStepInfo.msgid)
  return _internal_msgid();
}
inline void GuideCSStepInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideCSStepInfo.msgid)
}
inline ::GSToGC::MsgID GuideCSStepInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GuideCSStepInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional bool allcomp = 2;
inline bool GuideCSStepInfo::has_allcomp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideCSStepInfo::clear_allcomp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allcomp_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GuideCSStepInfo::allcomp() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideCSStepInfo.allcomp)
  return _internal_allcomp();
}
inline void GuideCSStepInfo::set_allcomp(bool value) {
  _internal_set_allcomp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideCSStepInfo.allcomp)
}
inline bool GuideCSStepInfo::_internal_allcomp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allcomp_;
}
inline void GuideCSStepInfo::_internal_set_allcomp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allcomp_ = value;
}

// repeated uint32 taskid = 3;
inline int GuideCSStepInfo::_internal_taskid_size() const {
  return _internal_taskid().size();
}
inline int GuideCSStepInfo::taskid_size() const {
  return _internal_taskid_size();
}
inline void GuideCSStepInfo::clear_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_.Clear();
}
inline ::uint32_t GuideCSStepInfo::taskid(int index) const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideCSStepInfo.taskid)
  return _internal_taskid().Get(index);
}
inline void GuideCSStepInfo::set_taskid(int index, ::uint32_t value) {
  _internal_mutable_taskid()->Set(index, value);
  // @@protoc_insertion_point(field_set:GSToGC.GuideCSStepInfo.taskid)
}
inline void GuideCSStepInfo::add_taskid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_taskid()->Add(value);
  // @@protoc_insertion_point(field_add:GSToGC.GuideCSStepInfo.taskid)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& GuideCSStepInfo::taskid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.GuideCSStepInfo.taskid)
  return _internal_taskid();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GuideCSStepInfo::mutable_taskid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.GuideCSStepInfo.taskid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_taskid();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& GuideCSStepInfo::_internal_taskid()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* GuideCSStepInfo::_internal_mutable_taskid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.taskid_;
}

// -------------------------------------------------------------------

// GuideAward_awardtype

// optional .GSToGC.GuideAward.dtype dt = 1;
inline bool GuideAward_awardtype::has_dt() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GuideAward_awardtype::clear_dt() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dt_ = 1;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::GuideAward_dtype GuideAward_awardtype::dt() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideAward.awardtype.dt)
  return _internal_dt();
}
inline void GuideAward_awardtype::set_dt(::GSToGC::GuideAward_dtype value) {
  _internal_set_dt(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideAward.awardtype.dt)
}
inline ::GSToGC::GuideAward_dtype GuideAward_awardtype::_internal_dt() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::GuideAward_dtype>(_impl_.dt_);
}
inline void GuideAward_awardtype::_internal_set_dt(::GSToGC::GuideAward_dtype value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::GuideAward_dtype_IsValid(value));
  _impl_.dt_ = value;
}

// optional uint32 idxn = 2;
inline bool GuideAward_awardtype::has_idxn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideAward_awardtype::clear_idxn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.idxn_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t GuideAward_awardtype::idxn() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideAward.awardtype.idxn)
  return _internal_idxn();
}
inline void GuideAward_awardtype::set_idxn(::uint32_t value) {
  _internal_set_idxn(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideAward.awardtype.idxn)
}
inline ::uint32_t GuideAward_awardtype::_internal_idxn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.idxn_;
}
inline void GuideAward_awardtype::_internal_set_idxn(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.idxn_ = value;
}

// -------------------------------------------------------------------

// GuideAward

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GuideAward];
inline bool GuideAward::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideAward::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 302;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID GuideAward::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideAward.msgid)
  return _internal_msgid();
}
inline void GuideAward::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideAward.msgid)
}
inline ::GSToGC::MsgID GuideAward::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GuideAward::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.GuideAward.awardtype awardlist = 2;
inline int GuideAward::_internal_awardlist_size() const {
  return _internal_awardlist().size();
}
inline int GuideAward::awardlist_size() const {
  return _internal_awardlist_size();
}
inline void GuideAward::clear_awardlist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.awardlist_.Clear();
}
inline ::GSToGC::GuideAward_awardtype* GuideAward::mutable_awardlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.GuideAward.awardlist)
  return _internal_mutable_awardlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>* GuideAward::mutable_awardlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.GuideAward.awardlist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_awardlist();
}
inline const ::GSToGC::GuideAward_awardtype& GuideAward::awardlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GuideAward.awardlist)
  return _internal_awardlist().Get(index);
}
inline ::GSToGC::GuideAward_awardtype* GuideAward::add_awardlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::GuideAward_awardtype* _add = _internal_mutable_awardlist()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.GuideAward.awardlist)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>& GuideAward::awardlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.GuideAward.awardlist)
  return _internal_awardlist();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>&
GuideAward::_internal_awardlist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.awardlist_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GuideAward_awardtype>*
GuideAward::_internal_mutable_awardlist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.awardlist_;
}

// -------------------------------------------------------------------

// GuideKillsInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_GuideKillsInfo];
inline bool GuideKillsInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GuideKillsInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 301;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID GuideKillsInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideKillsInfo.msgid)
  return _internal_msgid();
}
inline void GuideKillsInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideKillsInfo.msgid)
}
inline ::GSToGC::MsgID GuideKillsInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GuideKillsInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool GuideKillsInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideKillsInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t GuideKillsInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideKillsInfo.guid)
  return _internal_guid();
}
inline void GuideKillsInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideKillsInfo.guid)
}
inline ::uint64_t GuideKillsInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void GuideKillsInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 npctype = 3;
inline bool GuideKillsInfo::has_npctype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GuideKillsInfo::clear_npctype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npctype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t GuideKillsInfo::npctype() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideKillsInfo.npctype)
  return _internal_npctype();
}
inline void GuideKillsInfo::set_npctype(::int32_t value) {
  _internal_set_npctype(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideKillsInfo.npctype)
}
inline ::int32_t GuideKillsInfo::_internal_npctype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.npctype_;
}
inline void GuideKillsInfo::_internal_set_npctype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npctype_ = value;
}

// -------------------------------------------------------------------

// NotifyUserLvInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserLvInfo];
inline bool NotifyUserLvInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyUserLvInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 232;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyUserLvInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserLvInfo.msgid)
  return _internal_msgid();
}
inline void NotifyUserLvInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserLvInfo.msgid)
}
inline ::GSToGC::MsgID NotifyUserLvInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyUserLvInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 curlv = 2;
inline bool NotifyUserLvInfo::has_curlv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyUserLvInfo::clear_curlv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curlv_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyUserLvInfo::curlv() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserLvInfo.curlv)
  return _internal_curlv();
}
inline void NotifyUserLvInfo::set_curlv(::uint32_t value) {
  _internal_set_curlv(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserLvInfo.curlv)
}
inline ::uint32_t NotifyUserLvInfo::_internal_curlv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curlv_;
}
inline void NotifyUserLvInfo::_internal_set_curlv(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curlv_ = value;
}

// optional uint32 curexp = 3;
inline bool NotifyUserLvInfo::has_curexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyUserLvInfo::clear_curexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curexp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyUserLvInfo::curexp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserLvInfo.curexp)
  return _internal_curexp();
}
inline void NotifyUserLvInfo::set_curexp(::uint32_t value) {
  _internal_set_curexp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserLvInfo.curexp)
}
inline ::uint32_t NotifyUserLvInfo::_internal_curexp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curexp_;
}
inline void NotifyUserLvInfo::_internal_set_curexp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curexp_ = value;
}

// -------------------------------------------------------------------

// NotifyNewHeaderid

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNewHeaderid];
inline bool NotifyNewHeaderid::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyNewHeaderid::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 231;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyNewHeaderid::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyNewHeaderid.msgid)
  return _internal_msgid();
}
inline void NotifyNewHeaderid::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyNewHeaderid.msgid)
}
inline ::GSToGC::MsgID NotifyNewHeaderid::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyNewHeaderid::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyNewHeaderid::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyNewHeaderid::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyNewHeaderid::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyNewHeaderid.guid)
  return _internal_guid();
}
inline void NotifyNewHeaderid::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyNewHeaderid.guid)
}
inline ::uint64_t NotifyNewHeaderid::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyNewHeaderid::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 newheaderid = 3;
inline bool NotifyNewHeaderid::has_newheaderid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyNewHeaderid::clear_newheaderid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newheaderid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyNewHeaderid::newheaderid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyNewHeaderid.newheaderid)
  return _internal_newheaderid();
}
inline void NotifyNewHeaderid::set_newheaderid(::uint32_t value) {
  _internal_set_newheaderid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyNewHeaderid.newheaderid)
}
inline ::uint32_t NotifyNewHeaderid::_internal_newheaderid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newheaderid_;
}
inline void NotifyNewHeaderid::_internal_set_newheaderid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newheaderid_ = value;
}

// -------------------------------------------------------------------

// NotifyOneMatchNeedOne

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOneMatchNeedOne];
inline bool NotifyOneMatchNeedOne::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyOneMatchNeedOne::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 230;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyOneMatchNeedOne::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOneMatchNeedOne.msgid)
  return _internal_msgid();
}
inline void NotifyOneMatchNeedOne::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOneMatchNeedOne.msgid)
}
inline ::GSToGC::MsgID NotifyOneMatchNeedOne::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyOneMatchNeedOne::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 mapid = 2;
inline bool NotifyOneMatchNeedOne::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyOneMatchNeedOne::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyOneMatchNeedOne::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOneMatchNeedOne.mapid)
  return _internal_mapid();
}
inline void NotifyOneMatchNeedOne::set_mapid(::uint32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOneMatchNeedOne.mapid)
}
inline ::uint32_t NotifyOneMatchNeedOne::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void NotifyOneMatchNeedOne::_internal_set_mapid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional uint32 fightid = 3;
inline bool NotifyOneMatchNeedOne::has_fightid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyOneMatchNeedOne::clear_fightid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fightid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyOneMatchNeedOne::fightid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOneMatchNeedOne.fightid)
  return _internal_fightid();
}
inline void NotifyOneMatchNeedOne::set_fightid(::uint32_t value) {
  _internal_set_fightid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOneMatchNeedOne.fightid)
}
inline ::uint32_t NotifyOneMatchNeedOne::_internal_fightid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fightid_;
}
inline void NotifyOneMatchNeedOne::_internal_set_fightid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fightid_ = value;
}

// -------------------------------------------------------------------

// NotifyNewNickname

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNewNickname];
inline bool NotifyNewNickname::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyNewNickname::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 229;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyNewNickname::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyNewNickname.msgid)
  return _internal_msgid();
}
inline void NotifyNewNickname::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyNewNickname.msgid)
}
inline ::GSToGC::MsgID NotifyNewNickname::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyNewNickname::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyNewNickname::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyNewNickname::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t NotifyNewNickname::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyNewNickname.guid)
  return _internal_guid();
}
inline void NotifyNewNickname::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyNewNickname.guid)
}
inline ::uint64_t NotifyNewNickname::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyNewNickname::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional string newnickname = 3;
inline bool NotifyNewNickname::has_newnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyNewNickname::clear_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyNewNickname::newnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyNewNickname.newnickname)
  return _internal_newnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyNewNickname::set_newnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyNewNickname.newnickname)
}
inline std::string* NotifyNewNickname::mutable_newnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_newnickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyNewNickname.newnickname)
  return _s;
}
inline const std::string& NotifyNewNickname::_internal_newnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newnickname_.Get();
}
inline void NotifyNewNickname::_internal_set_newnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(value, GetArena());
}
inline std::string* NotifyNewNickname::_internal_mutable_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.newnickname_.Mutable( GetArena());
}
inline std::string* NotifyNewNickname::release_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyNewNickname.newnickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.newnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.newnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyNewNickname::set_allocated_newnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.newnickname_.IsDefault()) {
          _impl_.newnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyNewNickname.newnickname)
}

// -------------------------------------------------------------------

// RunesSlot

// optional int32 slotpos = 1;
inline bool RunesSlot::has_slotpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RunesSlot::clear_slotpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slotpos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t RunesSlot::slotpos() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunesSlot.slotpos)
  return _internal_slotpos();
}
inline void RunesSlot::set_slotpos(::int32_t value) {
  _internal_set_slotpos(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.RunesSlot.slotpos)
}
inline ::int32_t RunesSlot::_internal_slotpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slotpos_;
}
inline void RunesSlot::_internal_set_slotpos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slotpos_ = value;
}

// optional uint32 runeid = 2;
inline bool RunesSlot::has_runeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RunesSlot::clear_runeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t RunesSlot::runeid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunesSlot.runeid)
  return _internal_runeid();
}
inline void RunesSlot::set_runeid(::uint32_t value) {
  _internal_set_runeid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RunesSlot.runeid)
}
inline ::uint32_t RunesSlot::_internal_runeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runeid_;
}
inline void RunesSlot::_internal_set_runeid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = value;
}

// optional int32 page = 3;
inline bool RunesSlot::has_page() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RunesSlot::clear_page() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t RunesSlot::page() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunesSlot.page)
  return _internal_page();
}
inline void RunesSlot::set_page(::int32_t value) {
  _internal_set_page(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RunesSlot.page)
}
inline ::int32_t RunesSlot::_internal_page() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_;
}
inline void RunesSlot::_internal_set_page(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_ = value;
}

// -------------------------------------------------------------------

// RunesBagInfo

// optional uint32 runeid = 1;
inline bool RunesBagInfo::has_runeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RunesBagInfo::clear_runeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t RunesBagInfo::runeid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunesBagInfo.runeid)
  return _internal_runeid();
}
inline void RunesBagInfo::set_runeid(::uint32_t value) {
  _internal_set_runeid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.RunesBagInfo.runeid)
}
inline ::uint32_t RunesBagInfo::_internal_runeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runeid_;
}
inline void RunesBagInfo::_internal_set_runeid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = value;
}

// optional int32 num = 2;
inline bool RunesBagInfo::has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RunesBagInfo::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RunesBagInfo::num() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunesBagInfo.num)
  return _internal_num();
}
inline void RunesBagInfo::set_num(::int32_t value) {
  _internal_set_num(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RunesBagInfo.num)
}
inline ::int32_t RunesBagInfo::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void RunesBagInfo::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = value;
}

// optional int64 gottime = 3;
inline bool RunesBagInfo::has_gottime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RunesBagInfo::clear_gottime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gottime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t RunesBagInfo::gottime() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunesBagInfo.gottime)
  return _internal_gottime();
}
inline void RunesBagInfo::set_gottime(::int64_t value) {
  _internal_set_gottime(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RunesBagInfo.gottime)
}
inline ::int64_t RunesBagInfo::_internal_gottime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gottime_;
}
inline void RunesBagInfo::_internal_set_gottime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gottime_ = value;
}

// -------------------------------------------------------------------

// NotifyRunesList

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyRunesList];
inline bool NotifyRunesList::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyRunesList::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 228;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyRunesList::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyRunesList.msgid)
  return _internal_msgid();
}
inline void NotifyRunesList::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyRunesList.msgid)
}
inline ::GSToGC::MsgID NotifyRunesList::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyRunesList::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.RunesBagInfo runesbaginfo = 2;
inline int NotifyRunesList::_internal_runesbaginfo_size() const {
  return _internal_runesbaginfo().size();
}
inline int NotifyRunesList::runesbaginfo_size() const {
  return _internal_runesbaginfo_size();
}
inline void NotifyRunesList::clear_runesbaginfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runesbaginfo_.Clear();
}
inline ::GSToGC::RunesBagInfo* NotifyRunesList::mutable_runesbaginfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyRunesList.runesbaginfo)
  return _internal_mutable_runesbaginfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>* NotifyRunesList::mutable_runesbaginfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyRunesList.runesbaginfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_runesbaginfo();
}
inline const ::GSToGC::RunesBagInfo& NotifyRunesList::runesbaginfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyRunesList.runesbaginfo)
  return _internal_runesbaginfo().Get(index);
}
inline ::GSToGC::RunesBagInfo* NotifyRunesList::add_runesbaginfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::RunesBagInfo* _add = _internal_mutable_runesbaginfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyRunesList.runesbaginfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>& NotifyRunesList::runesbaginfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyRunesList.runesbaginfo)
  return _internal_runesbaginfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>&
NotifyRunesList::_internal_runesbaginfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runesbaginfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::RunesBagInfo>*
NotifyRunesList::_internal_mutable_runesbaginfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.runesbaginfo_;
}

// repeated .GSToGC.RunesSlot runes_slot_info = 3;
inline int NotifyRunesList::_internal_runes_slot_info_size() const {
  return _internal_runes_slot_info().size();
}
inline int NotifyRunesList::runes_slot_info_size() const {
  return _internal_runes_slot_info_size();
}
inline void NotifyRunesList::clear_runes_slot_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runes_slot_info_.Clear();
}
inline ::GSToGC::RunesSlot* NotifyRunesList::mutable_runes_slot_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyRunesList.runes_slot_info)
  return _internal_mutable_runes_slot_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>* NotifyRunesList::mutable_runes_slot_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyRunesList.runes_slot_info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_runes_slot_info();
}
inline const ::GSToGC::RunesSlot& NotifyRunesList::runes_slot_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyRunesList.runes_slot_info)
  return _internal_runes_slot_info().Get(index);
}
inline ::GSToGC::RunesSlot* NotifyRunesList::add_runes_slot_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::RunesSlot* _add = _internal_mutable_runes_slot_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyRunesList.runes_slot_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>& NotifyRunesList::runes_slot_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyRunesList.runes_slot_info)
  return _internal_runes_slot_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>&
NotifyRunesList::_internal_runes_slot_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runes_slot_info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::RunesSlot>*
NotifyRunesList::_internal_mutable_runes_slot_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.runes_slot_info_;
}

// -------------------------------------------------------------------

// NotifyRemoveCommodity

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyRemoveCommodity];
inline bool NotifyRemoveCommodity::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyRemoveCommodity::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 227;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyRemoveCommodity::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyRemoveCommodity.msgid)
  return _internal_msgid();
}
inline void NotifyRemoveCommodity::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyRemoveCommodity.msgid)
}
inline ::GSToGC::MsgID NotifyRemoveCommodity::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyRemoveCommodity::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated uint32 Commodityid = 2;
inline int NotifyRemoveCommodity::_internal_commodityid_size() const {
  return _internal_commodityid().size();
}
inline int NotifyRemoveCommodity::commodityid_size() const {
  return _internal_commodityid_size();
}
inline void NotifyRemoveCommodity::clear_commodityid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commodityid_.Clear();
}
inline ::uint32_t NotifyRemoveCommodity::commodityid(int index) const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyRemoveCommodity.Commodityid)
  return _internal_commodityid().Get(index);
}
inline void NotifyRemoveCommodity::set_commodityid(int index, ::uint32_t value) {
  _internal_mutable_commodityid()->Set(index, value);
  // @@protoc_insertion_point(field_set:GSToGC.NotifyRemoveCommodity.Commodityid)
}
inline void NotifyRemoveCommodity::add_commodityid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commodityid()->Add(value);
  // @@protoc_insertion_point(field_add:GSToGC.NotifyRemoveCommodity.Commodityid)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& NotifyRemoveCommodity::commodityid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyRemoveCommodity.Commodityid)
  return _internal_commodityid();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* NotifyRemoveCommodity::mutable_commodityid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyRemoveCommodity.Commodityid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_commodityid();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& NotifyRemoveCommodity::_internal_commodityid()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commodityid_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* NotifyRemoveCommodity::_internal_mutable_commodityid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.commodityid_;
}

// -------------------------------------------------------------------

// NotifyGetNewCommodity

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetNewCommodity];
inline bool NotifyGetNewCommodity::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyGetNewCommodity::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 226;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyGetNewCommodity::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGetNewCommodity.msgid)
  return _internal_msgid();
}
inline void NotifyGetNewCommodity::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGetNewCommodity.msgid)
}
inline ::GSToGC::MsgID NotifyGetNewCommodity::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyGetNewCommodity::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 Commodityid = 2;
inline bool NotifyGetNewCommodity::has_commodityid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyGetNewCommodity::clear_commodityid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commodityid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyGetNewCommodity::commodityid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGetNewCommodity.Commodityid)
  return _internal_commodityid();
}
inline void NotifyGetNewCommodity::set_commodityid(::uint32_t value) {
  _internal_set_commodityid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGetNewCommodity.Commodityid)
}
inline ::uint32_t NotifyGetNewCommodity::_internal_commodityid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commodityid_;
}
inline void NotifyGetNewCommodity::_internal_set_commodityid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commodityid_ = value;
}

// -------------------------------------------------------------------

// NotifyMatchTeamBaseInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchTeamBaseInfo];
inline bool NotifyMatchTeamBaseInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyMatchTeamBaseInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 222;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyMatchTeamBaseInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamBaseInfo.msgid)
  return _internal_msgid();
}
inline void NotifyMatchTeamBaseInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamBaseInfo.msgid)
}
inline ::GSToGC::MsgID NotifyMatchTeamBaseInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyMatchTeamBaseInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 teamid = 2;
inline bool NotifyMatchTeamBaseInfo::has_teamid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMatchTeamBaseInfo::clear_teamid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyMatchTeamBaseInfo::teamid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamBaseInfo.teamid)
  return _internal_teamid();
}
inline void NotifyMatchTeamBaseInfo::set_teamid(::uint32_t value) {
  _internal_set_teamid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamBaseInfo.teamid)
}
inline ::uint32_t NotifyMatchTeamBaseInfo::_internal_teamid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.teamid_;
}
inline void NotifyMatchTeamBaseInfo::_internal_set_teamid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.teamid_ = value;
}

// optional uint32 matchtype = 3;
inline bool NotifyMatchTeamBaseInfo::has_matchtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyMatchTeamBaseInfo::clear_matchtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matchtype_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyMatchTeamBaseInfo::matchtype() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamBaseInfo.matchtype)
  return _internal_matchtype();
}
inline void NotifyMatchTeamBaseInfo::set_matchtype(::uint32_t value) {
  _internal_set_matchtype(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamBaseInfo.matchtype)
}
inline ::uint32_t NotifyMatchTeamBaseInfo::_internal_matchtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.matchtype_;
}
inline void NotifyMatchTeamBaseInfo::_internal_set_matchtype(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.matchtype_ = value;
}

// optional uint32 mapid = 4;
inline bool NotifyMatchTeamBaseInfo::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyMatchTeamBaseInfo::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t NotifyMatchTeamBaseInfo::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamBaseInfo.mapid)
  return _internal_mapid();
}
inline void NotifyMatchTeamBaseInfo::set_mapid(::uint32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamBaseInfo.mapid)
}
inline ::uint32_t NotifyMatchTeamBaseInfo::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void NotifyMatchTeamBaseInfo::_internal_set_mapid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// -------------------------------------------------------------------

// NotifyMatchTeamPlayerInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchTeamPlayerInfo];
inline bool NotifyMatchTeamPlayerInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifyMatchTeamPlayerInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 223;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID NotifyMatchTeamPlayerInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamPlayerInfo.msgid)
  return _internal_msgid();
}
inline void NotifyMatchTeamPlayerInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamPlayerInfo.msgid)
}
inline ::GSToGC::MsgID NotifyMatchTeamPlayerInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyMatchTeamPlayerInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 postion = 2;
inline bool NotifyMatchTeamPlayerInfo::has_postion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyMatchTeamPlayerInfo::clear_postion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.postion_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyMatchTeamPlayerInfo::postion() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamPlayerInfo.postion)
  return _internal_postion();
}
inline void NotifyMatchTeamPlayerInfo::set_postion(::uint32_t value) {
  _internal_set_postion(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamPlayerInfo.postion)
}
inline ::uint32_t NotifyMatchTeamPlayerInfo::_internal_postion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.postion_;
}
inline void NotifyMatchTeamPlayerInfo::_internal_set_postion(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.postion_ = value;
}

// optional bool isInsert = 3;
inline bool NotifyMatchTeamPlayerInfo::has_isinsert() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyMatchTeamPlayerInfo::clear_isinsert() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isinsert_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool NotifyMatchTeamPlayerInfo::isinsert() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamPlayerInfo.isInsert)
  return _internal_isinsert();
}
inline void NotifyMatchTeamPlayerInfo::set_isinsert(bool value) {
  _internal_set_isinsert(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamPlayerInfo.isInsert)
}
inline bool NotifyMatchTeamPlayerInfo::_internal_isinsert() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.isinsert_;
}
inline void NotifyMatchTeamPlayerInfo::_internal_set_isinsert(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.isinsert_ = value;
}

// optional string nickname = 4;
inline bool NotifyMatchTeamPlayerInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMatchTeamPlayerInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyMatchTeamPlayerInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamPlayerInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyMatchTeamPlayerInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamPlayerInfo.nickname)
}
inline std::string* NotifyMatchTeamPlayerInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyMatchTeamPlayerInfo.nickname)
  return _s;
}
inline const std::string& NotifyMatchTeamPlayerInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void NotifyMatchTeamPlayerInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* NotifyMatchTeamPlayerInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* NotifyMatchTeamPlayerInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyMatchTeamPlayerInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyMatchTeamPlayerInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyMatchTeamPlayerInfo.nickname)
}

// optional uint32 headid = 5;
inline bool NotifyMatchTeamPlayerInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyMatchTeamPlayerInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t NotifyMatchTeamPlayerInfo::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamPlayerInfo.headid)
  return _internal_headid();
}
inline void NotifyMatchTeamPlayerInfo::set_headid(::uint32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamPlayerInfo.headid)
}
inline ::uint32_t NotifyMatchTeamPlayerInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void NotifyMatchTeamPlayerInfo::_internal_set_headid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional uint32 userlevel = 6;
inline bool NotifyMatchTeamPlayerInfo::has_userlevel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifyMatchTeamPlayerInfo::clear_userlevel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userlevel_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t NotifyMatchTeamPlayerInfo::userlevel() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamPlayerInfo.userlevel)
  return _internal_userlevel();
}
inline void NotifyMatchTeamPlayerInfo::set_userlevel(::uint32_t value) {
  _internal_set_userlevel(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamPlayerInfo.userlevel)
}
inline ::uint32_t NotifyMatchTeamPlayerInfo::_internal_userlevel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userlevel_;
}
inline void NotifyMatchTeamPlayerInfo::_internal_set_userlevel(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userlevel_ = value;
}

// -------------------------------------------------------------------

// NotifyMatchTeamSwitch

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchTeamSwitch];
inline bool NotifyMatchTeamSwitch::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyMatchTeamSwitch::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 224;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyMatchTeamSwitch::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamSwitch.msgid)
  return _internal_msgid();
}
inline void NotifyMatchTeamSwitch::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamSwitch.msgid)
}
inline ::GSToGC::MsgID NotifyMatchTeamSwitch::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyMatchTeamSwitch::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional bool startflag = 2;
inline bool NotifyMatchTeamSwitch::has_startflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMatchTeamSwitch::clear_startflag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.startflag_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool NotifyMatchTeamSwitch::startflag() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchTeamSwitch.startflag)
  return _internal_startflag();
}
inline void NotifyMatchTeamSwitch::set_startflag(bool value) {
  _internal_set_startflag(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchTeamSwitch.startflag)
}
inline bool NotifyMatchTeamSwitch::_internal_startflag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.startflag_;
}
inline void NotifyMatchTeamSwitch::_internal_set_startflag(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.startflag_ = value;
}

// -------------------------------------------------------------------

// NotifyMatchInviteJoin

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMatchInviteJoin];
inline bool NotifyMatchInviteJoin::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyMatchInviteJoin::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 225;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyMatchInviteJoin::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchInviteJoin.msgid)
  return _internal_msgid();
}
inline void NotifyMatchInviteJoin::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchInviteJoin.msgid)
}
inline ::GSToGC::MsgID NotifyMatchInviteJoin::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyMatchInviteJoin::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string nickname = 2;
inline bool NotifyMatchInviteJoin::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMatchInviteJoin::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyMatchInviteJoin::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMatchInviteJoin.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyMatchInviteJoin::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMatchInviteJoin.nickname)
}
inline std::string* NotifyMatchInviteJoin::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyMatchInviteJoin.nickname)
  return _s;
}
inline const std::string& NotifyMatchInviteJoin::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void NotifyMatchInviteJoin::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* NotifyMatchInviteJoin::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* NotifyMatchInviteJoin::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyMatchInviteJoin.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyMatchInviteJoin::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyMatchInviteJoin.nickname)
}

// -------------------------------------------------------------------

// NotifyHerosInfo_heropanelinfo_goodsmsg

// optional int32 grid = 1;
inline bool NotifyHerosInfo_heropanelinfo_goodsmsg::has_grid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo_goodsmsg::clear_grid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.grid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo_goodsmsg::grid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg.grid)
  return _internal_grid();
}
inline void NotifyHerosInfo_heropanelinfo_goodsmsg::set_grid(::int32_t value) {
  _internal_set_grid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg.grid)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo_goodsmsg::_internal_grid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.grid_;
}
inline void NotifyHerosInfo_heropanelinfo_goodsmsg::_internal_set_grid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.grid_ = value;
}

// optional int32 goodid = 2;
inline bool NotifyHerosInfo_heropanelinfo_goodsmsg::has_goodid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo_goodsmsg::clear_goodid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo_goodsmsg::goodid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg.goodid)
  return _internal_goodid();
}
inline void NotifyHerosInfo_heropanelinfo_goodsmsg::set_goodid(::int32_t value) {
  _internal_set_goodid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg.goodid)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo_goodsmsg::_internal_goodid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goodid_;
}
inline void NotifyHerosInfo_heropanelinfo_goodsmsg::_internal_set_goodid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodid_ = value;
}

// -------------------------------------------------------------------

// NotifyHerosInfo_heropanelinfo

// optional int32 camgpid = 1;
inline bool NotifyHerosInfo_heropanelinfo::has_camgpid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_camgpid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camgpid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::camgpid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.camgpid)
  return _internal_camgpid();
}
inline void NotifyHerosInfo_heropanelinfo::set_camgpid(::int32_t value) {
  _internal_set_camgpid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.camgpid)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::_internal_camgpid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camgpid_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_camgpid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camgpid_ = value;
}

// optional int64 guid = 2;
inline bool NotifyHerosInfo_heropanelinfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t NotifyHerosInfo_heropanelinfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.guid)
  return _internal_guid();
}
inline void NotifyHerosInfo_heropanelinfo::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.guid)
}
inline ::int64_t NotifyHerosInfo_heropanelinfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 herolv = 3;
inline bool NotifyHerosInfo_heropanelinfo::has_herolv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_herolv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herolv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::herolv() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.herolv)
  return _internal_herolv();
}
inline void NotifyHerosInfo_heropanelinfo::set_herolv(::int32_t value) {
  _internal_set_herolv(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.herolv)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::_internal_herolv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herolv_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_herolv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herolv_ = value;
}

// optional string nickname = 4;
inline bool NotifyHerosInfo_heropanelinfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyHerosInfo_heropanelinfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyHerosInfo_heropanelinfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.nickname)
}
inline std::string* NotifyHerosInfo_heropanelinfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyHerosInfo.heropanelinfo.nickname)
  return _s;
}
inline const std::string& NotifyHerosInfo_heropanelinfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* NotifyHerosInfo_heropanelinfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* NotifyHerosInfo_heropanelinfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyHerosInfo.heropanelinfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyHerosInfo_heropanelinfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyHerosInfo.heropanelinfo.nickname)
}

// optional int32 killnum = 5;
inline bool NotifyHerosInfo_heropanelinfo::has_killnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_killnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::killnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.killnum)
  return _internal_killnum();
}
inline void NotifyHerosInfo_heropanelinfo::set_killnum(::int32_t value) {
  _internal_set_killnum(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.killnum)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::_internal_killnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.killnum_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_killnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killnum_ = value;
}

// optional int32 deadtimes = 6;
inline bool NotifyHerosInfo_heropanelinfo::has_deadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_deadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::deadtimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.deadtimes)
  return _internal_deadtimes();
}
inline void NotifyHerosInfo_heropanelinfo::set_deadtimes(::int32_t value) {
  _internal_set_deadtimes(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.deadtimes)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::_internal_deadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadtimes_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_deadtimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = value;
}

// optional int32 asstimes = 7;
inline bool NotifyHerosInfo_heropanelinfo::has_asstimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_asstimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.asstimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::asstimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.asstimes)
  return _internal_asstimes();
}
inline void NotifyHerosInfo_heropanelinfo::set_asstimes(::int32_t value) {
  _internal_set_asstimes(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.asstimes)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::_internal_asstimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.asstimes_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_asstimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.asstimes_ = value;
}

// optional int32 lasthit = 8;
inline bool NotifyHerosInfo_heropanelinfo::has_lasthit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_lasthit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lasthit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::lasthit() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.lasthit)
  return _internal_lasthit();
}
inline void NotifyHerosInfo_heropanelinfo::set_lasthit(::int32_t value) {
  _internal_set_lasthit(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.lasthit)
}
inline ::int32_t NotifyHerosInfo_heropanelinfo::_internal_lasthit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lasthit_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_lasthit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lasthit_ = value;
}

// repeated .GSToGC.NotifyHerosInfo.heropanelinfo.goodsmsg goods = 9;
inline int NotifyHerosInfo_heropanelinfo::_internal_goods_size() const {
  return _internal_goods().size();
}
inline int NotifyHerosInfo_heropanelinfo::goods_size() const {
  return _internal_goods_size();
}
inline void NotifyHerosInfo_heropanelinfo::clear_goods() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goods_.Clear();
}
inline ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg* NotifyHerosInfo_heropanelinfo::mutable_goods(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyHerosInfo.heropanelinfo.goods)
  return _internal_mutable_goods()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>* NotifyHerosInfo_heropanelinfo::mutable_goods()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyHerosInfo.heropanelinfo.goods)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_goods();
}
inline const ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg& NotifyHerosInfo_heropanelinfo::goods(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.goods)
  return _internal_goods().Get(index);
}
inline ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg* NotifyHerosInfo_heropanelinfo::add_goods() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg* _add = _internal_mutable_goods()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyHerosInfo.heropanelinfo.goods)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>& NotifyHerosInfo_heropanelinfo::goods() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyHerosInfo.heropanelinfo.goods)
  return _internal_goods();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>&
NotifyHerosInfo_heropanelinfo::_internal_goods() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goods_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo_goodsmsg>*
NotifyHerosInfo_heropanelinfo::_internal_mutable_goods() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.goods_;
}

// optional uint32 heroid = 10;
inline bool NotifyHerosInfo_heropanelinfo::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void NotifyHerosInfo_heropanelinfo::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t NotifyHerosInfo_heropanelinfo::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.heropanelinfo.heroid)
  return _internal_heroid();
}
inline void NotifyHerosInfo_heropanelinfo::set_heroid(::uint32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.heropanelinfo.heroid)
}
inline ::uint32_t NotifyHerosInfo_heropanelinfo::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void NotifyHerosInfo_heropanelinfo::_internal_set_heroid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// -------------------------------------------------------------------

// NotifyHerosInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyHerosInfo];
inline bool NotifyHerosInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyHerosInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 144;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyHerosInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.msgid)
  return _internal_msgid();
}
inline void NotifyHerosInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHerosInfo.msgid)
}
inline ::GSToGC::MsgID NotifyHerosInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyHerosInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.NotifyHerosInfo.heropanelinfo info = 2;
inline int NotifyHerosInfo::_internal_info_size() const {
  return _internal_info().size();
}
inline int NotifyHerosInfo::info_size() const {
  return _internal_info_size();
}
inline void NotifyHerosInfo::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::NotifyHerosInfo_heropanelinfo* NotifyHerosInfo::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyHerosInfo.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>* NotifyHerosInfo::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyHerosInfo.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::NotifyHerosInfo_heropanelinfo& NotifyHerosInfo::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHerosInfo.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::NotifyHerosInfo_heropanelinfo* NotifyHerosInfo::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyHerosInfo_heropanelinfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyHerosInfo.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>& NotifyHerosInfo::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyHerosInfo.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>&
NotifyHerosInfo::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHerosInfo_heropanelinfo>*
NotifyHerosInfo::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// NotifyGoodsExpired

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyGoodsExpired];
inline bool NotifyGoodsExpired::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyGoodsExpired::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 145;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyGoodsExpired::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsExpired.msgid)
  return _internal_msgid();
}
inline void NotifyGoodsExpired::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsExpired.msgid)
}
inline ::GSToGC::MsgID NotifyGoodsExpired::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyGoodsExpired::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated int32 commondityid = 2;
inline int NotifyGoodsExpired::_internal_commondityid_size() const {
  return _internal_commondityid().size();
}
inline int NotifyGoodsExpired::commondityid_size() const {
  return _internal_commondityid_size();
}
inline void NotifyGoodsExpired::clear_commondityid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commondityid_.Clear();
}
inline ::int32_t NotifyGoodsExpired::commondityid(int index) const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsExpired.commondityid)
  return _internal_commondityid().Get(index);
}
inline void NotifyGoodsExpired::set_commondityid(int index, ::int32_t value) {
  _internal_mutable_commondityid()->Set(index, value);
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsExpired.commondityid)
}
inline void NotifyGoodsExpired::add_commondityid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_commondityid()->Add(value);
  // @@protoc_insertion_point(field_add:GSToGC.NotifyGoodsExpired.commondityid)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& NotifyGoodsExpired::commondityid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyGoodsExpired.commondityid)
  return _internal_commondityid();
}
inline ::google::protobuf::RepeatedField<::int32_t>* NotifyGoodsExpired::mutable_commondityid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyGoodsExpired.commondityid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_commondityid();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& NotifyGoodsExpired::_internal_commondityid()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commondityid_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* NotifyGoodsExpired::_internal_mutable_commondityid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.commondityid_;
}

// -------------------------------------------------------------------

// ShortMail

// optional int32 mailid = 1;
inline bool ShortMail::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ShortMail::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ShortMail::mailid() const {
  // @@protoc_insertion_point(field_get:GSToGC.ShortMail.mailid)
  return _internal_mailid();
}
inline void ShortMail::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.ShortMail.mailid)
}
inline ::int32_t ShortMail::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void ShortMail::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional .GSToGC.MailType mailType = 2;
inline bool ShortMail::has_mailtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ShortMail::clear_mailtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MailType ShortMail::mailtype() const {
  // @@protoc_insertion_point(field_get:GSToGC.ShortMail.mailType)
  return _internal_mailtype();
}
inline void ShortMail::set_mailtype(::GSToGC::MailType value) {
  _internal_set_mailtype(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.ShortMail.mailType)
}
inline ::GSToGC::MailType ShortMail::_internal_mailtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MailType>(_impl_.mailtype_);
}
inline void ShortMail::_internal_set_mailtype(::GSToGC::MailType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MailType_IsValid(value));
  _impl_.mailtype_ = value;
}

// optional string mailTitle = 3;
inline bool ShortMail::has_mailtitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ShortMail::clear_mailtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailtitle_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ShortMail::mailtitle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.ShortMail.mailTitle)
  return _internal_mailtitle();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ShortMail::set_mailtitle(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mailtitle_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.ShortMail.mailTitle)
}
inline std::string* ShortMail::mutable_mailtitle() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mailtitle();
  // @@protoc_insertion_point(field_mutable:GSToGC.ShortMail.mailTitle)
  return _s;
}
inline const std::string& ShortMail::_internal_mailtitle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailtitle_.Get();
}
inline void ShortMail::_internal_set_mailtitle(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mailtitle_.Set(value, GetArena());
}
inline std::string* ShortMail::_internal_mutable_mailtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mailtitle_.Mutable( GetArena());
}
inline std::string* ShortMail::release_mailtitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.ShortMail.mailTitle)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.mailtitle_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mailtitle_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ShortMail::set_allocated_mailtitle(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mailtitle_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mailtitle_.IsDefault()) {
          _impl_.mailtitle_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.ShortMail.mailTitle)
}

// optional .GSToGC.EMailCurtState mailState = 4;
inline bool ShortMail::has_mailstate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ShortMail::clear_mailstate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailstate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::EMailCurtState ShortMail::mailstate() const {
  // @@protoc_insertion_point(field_get:GSToGC.ShortMail.mailState)
  return _internal_mailstate();
}
inline void ShortMail::set_mailstate(::GSToGC::EMailCurtState value) {
  _internal_set_mailstate(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.ShortMail.mailState)
}
inline ::GSToGC::EMailCurtState ShortMail::_internal_mailstate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::EMailCurtState>(_impl_.mailstate_);
}
inline void ShortMail::_internal_set_mailstate(::GSToGC::EMailCurtState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::EMailCurtState_IsValid(value));
  _impl_.mailstate_ = value;
}

// -------------------------------------------------------------------

// DelAndSortMail

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyIfMailDelAndSort];
inline bool DelAndSortMail::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DelAndSortMail::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 136;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID DelAndSortMail::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.DelAndSortMail.msgid)
  return _internal_msgid();
}
inline void DelAndSortMail::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.DelAndSortMail.msgid)
}
inline ::GSToGC::MsgID DelAndSortMail::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void DelAndSortMail::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 mailid = 2;
inline bool DelAndSortMail::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DelAndSortMail::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t DelAndSortMail::mailid() const {
  // @@protoc_insertion_point(field_get:GSToGC.DelAndSortMail.mailid)
  return _internal_mailid();
}
inline void DelAndSortMail::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.DelAndSortMail.mailid)
}
inline ::int32_t DelAndSortMail::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void DelAndSortMail::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional bool mailidDel = 3;
inline bool DelAndSortMail::has_mailiddel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DelAndSortMail::clear_mailiddel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailiddel_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool DelAndSortMail::mailiddel() const {
  // @@protoc_insertion_point(field_get:GSToGC.DelAndSortMail.mailidDel)
  return _internal_mailiddel();
}
inline void DelAndSortMail::set_mailiddel(bool value) {
  _internal_set_mailiddel(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.DelAndSortMail.mailidDel)
}
inline bool DelAndSortMail::_internal_mailiddel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailiddel_;
}
inline void DelAndSortMail::_internal_set_mailiddel(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailiddel_ = value;
}

// optional bool sort = 4;
inline bool DelAndSortMail::has_sort() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DelAndSortMail::clear_sort() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool DelAndSortMail::sort() const {
  // @@protoc_insertion_point(field_get:GSToGC.DelAndSortMail.sort)
  return _internal_sort();
}
inline void DelAndSortMail::set_sort(bool value) {
  _internal_set_sort(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.DelAndSortMail.sort)
}
inline bool DelAndSortMail::_internal_sort() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sort_;
}
inline void DelAndSortMail::_internal_set_sort(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sort_ = value;
}

// -------------------------------------------------------------------

// MailInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMailInfo];
inline bool MailInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MailInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 135;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID MailInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.MailInfo.msgid)
  return _internal_msgid();
}
inline void MailInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.MailInfo.msgid)
}
inline ::GSToGC::MsgID MailInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void MailInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 mailid = 2;
inline bool MailInfo::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MailInfo::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t MailInfo::mailid() const {
  // @@protoc_insertion_point(field_get:GSToGC.MailInfo.mailid)
  return _internal_mailid();
}
inline void MailInfo::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.MailInfo.mailid)
}
inline ::int32_t MailInfo::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void MailInfo::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional string mailcontent = 3;
inline bool MailInfo::has_mailcontent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MailInfo::clear_mailcontent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailcontent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MailInfo::mailcontent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.MailInfo.mailcontent)
  return _internal_mailcontent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailInfo::set_mailcontent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mailcontent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.MailInfo.mailcontent)
}
inline std::string* MailInfo::mutable_mailcontent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mailcontent();
  // @@protoc_insertion_point(field_mutable:GSToGC.MailInfo.mailcontent)
  return _s;
}
inline const std::string& MailInfo::_internal_mailcontent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailcontent_.Get();
}
inline void MailInfo::_internal_set_mailcontent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mailcontent_.Set(value, GetArena());
}
inline std::string* MailInfo::_internal_mutable_mailcontent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mailcontent_.Mutable( GetArena());
}
inline std::string* MailInfo::release_mailcontent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.MailInfo.mailcontent)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.mailcontent_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mailcontent_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailInfo::set_allocated_mailcontent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mailcontent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mailcontent_.IsDefault()) {
          _impl_.mailcontent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.MailInfo.mailcontent)
}

// optional string sender = 4;
inline bool MailInfo::has_sender() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MailInfo::clear_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MailInfo::sender() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.MailInfo.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailInfo::set_sender(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.MailInfo.sender)
}
inline std::string* MailInfo::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:GSToGC.MailInfo.sender)
  return _s;
}
inline const std::string& MailInfo::_internal_sender() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_.Get();
}
inline void MailInfo::_internal_set_sender(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.sender_.Set(value, GetArena());
}
inline std::string* MailInfo::_internal_mutable_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.sender_.Mutable( GetArena());
}
inline std::string* MailInfo::release_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.MailInfo.sender)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.sender_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sender_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailInfo::set_allocated_sender(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.sender_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.MailInfo.sender)
}

// optional string createTime = 5;
inline bool MailInfo::has_createtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MailInfo::clear_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MailInfo::createtime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.MailInfo.createTime)
  return _internal_createtime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailInfo::set_createtime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.createtime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.MailInfo.createTime)
}
inline std::string* MailInfo::mutable_createtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:GSToGC.MailInfo.createTime)
  return _s;
}
inline const std::string& MailInfo::_internal_createtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.createtime_.Get();
}
inline void MailInfo::_internal_set_createtime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.createtime_.Set(value, GetArena());
}
inline std::string* MailInfo::_internal_mutable_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.createtime_.Mutable( GetArena());
}
inline std::string* MailInfo::release_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.MailInfo.createTime)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.createtime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.createtime_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailInfo::set_allocated_createtime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.createtime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.createtime_.IsDefault()) {
          _impl_.createtime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.MailInfo.createTime)
}

// optional string mailgift = 6;
inline bool MailInfo::has_mailgift() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MailInfo::clear_mailgift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailgift_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MailInfo::mailgift() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.MailInfo.mailgift)
  return _internal_mailgift();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailInfo::set_mailgift(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mailgift_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.MailInfo.mailgift)
}
inline std::string* MailInfo::mutable_mailgift() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_mailgift();
  // @@protoc_insertion_point(field_mutable:GSToGC.MailInfo.mailgift)
  return _s;
}
inline const std::string& MailInfo::_internal_mailgift() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailgift_.Get();
}
inline void MailInfo::_internal_set_mailgift(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mailgift_.Set(value, GetArena());
}
inline std::string* MailInfo::_internal_mutable_mailgift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.mailgift_.Mutable( GetArena());
}
inline std::string* MailInfo::release_mailgift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.MailInfo.mailgift)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.mailgift_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.mailgift_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailInfo::set_allocated_mailgift(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.mailgift_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.mailgift_.IsDefault()) {
          _impl_.mailgift_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.MailInfo.mailgift)
}

// -------------------------------------------------------------------

// NotifyMailList

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserMail];
inline bool NotifyMailList::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMailList::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 134;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyMailList::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMailList.msgid)
  return _internal_msgid();
}
inline void NotifyMailList::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMailList.msgid)
}
inline ::GSToGC::MsgID NotifyMailList::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyMailList::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.ShortMail mailList = 2;
inline int NotifyMailList::_internal_maillist_size() const {
  return _internal_maillist().size();
}
inline int NotifyMailList::maillist_size() const {
  return _internal_maillist_size();
}
inline void NotifyMailList::clear_maillist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maillist_.Clear();
}
inline ::GSToGC::ShortMail* NotifyMailList::mutable_maillist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyMailList.mailList)
  return _internal_mutable_maillist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>* NotifyMailList::mutable_maillist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyMailList.mailList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_maillist();
}
inline const ::GSToGC::ShortMail& NotifyMailList::maillist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMailList.mailList)
  return _internal_maillist().Get(index);
}
inline ::GSToGC::ShortMail* NotifyMailList::add_maillist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::ShortMail* _add = _internal_mutable_maillist()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyMailList.mailList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>& NotifyMailList::maillist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyMailList.mailList)
  return _internal_maillist();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>&
NotifyMailList::_internal_maillist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maillist_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::ShortMail>*
NotifyMailList::_internal_mutable_maillist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.maillist_;
}

// -------------------------------------------------------------------

// GoodsCfgInfo_Consume

// optional int32 consumetype = 1;
inline bool GoodsCfgInfo_Consume::has_consumetype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GoodsCfgInfo_Consume::clear_consumetype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumetype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t GoodsCfgInfo_Consume::consumetype() const {
  // @@protoc_insertion_point(field_get:GSToGC.GoodsCfgInfo.Consume.consumetype)
  return _internal_consumetype();
}
inline void GoodsCfgInfo_Consume::set_consumetype(::int32_t value) {
  _internal_set_consumetype(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GoodsCfgInfo.Consume.consumetype)
}
inline ::int32_t GoodsCfgInfo_Consume::_internal_consumetype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consumetype_;
}
inline void GoodsCfgInfo_Consume::_internal_set_consumetype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consumetype_ = value;
}

// optional int32 price = 2;
inline bool GoodsCfgInfo_Consume::has_price() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GoodsCfgInfo_Consume::clear_price() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.price_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t GoodsCfgInfo_Consume::price() const {
  // @@protoc_insertion_point(field_get:GSToGC.GoodsCfgInfo.Consume.price)
  return _internal_price();
}
inline void GoodsCfgInfo_Consume::set_price(::int32_t value) {
  _internal_set_price(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GoodsCfgInfo.Consume.price)
}
inline ::int32_t GoodsCfgInfo_Consume::_internal_price() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.price_;
}
inline void GoodsCfgInfo_Consume::_internal_set_price(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.price_ = value;
}

// -------------------------------------------------------------------

// GoodsCfgInfo

// optional int32 goodid = 1;
inline bool GoodsCfgInfo::has_goodid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GoodsCfgInfo::clear_goodid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t GoodsCfgInfo::goodid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GoodsCfgInfo.goodid)
  return _internal_goodid();
}
inline void GoodsCfgInfo::set_goodid(::int32_t value) {
  _internal_set_goodid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GoodsCfgInfo.goodid)
}
inline ::int32_t GoodsCfgInfo::_internal_goodid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goodid_;
}
inline void GoodsCfgInfo::_internal_set_goodid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodid_ = value;
}

// repeated .GSToGC.GoodsCfgInfo.Consume consume = 2;
inline int GoodsCfgInfo::_internal_consume_size() const {
  return _internal_consume().size();
}
inline int GoodsCfgInfo::consume_size() const {
  return _internal_consume_size();
}
inline void GoodsCfgInfo::clear_consume() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.consume_.Clear();
}
inline ::GSToGC::GoodsCfgInfo_Consume* GoodsCfgInfo::mutable_consume(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.GoodsCfgInfo.consume)
  return _internal_mutable_consume()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>* GoodsCfgInfo::mutable_consume()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.GoodsCfgInfo.consume)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_consume();
}
inline const ::GSToGC::GoodsCfgInfo_Consume& GoodsCfgInfo::consume(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GoodsCfgInfo.consume)
  return _internal_consume().Get(index);
}
inline ::GSToGC::GoodsCfgInfo_Consume* GoodsCfgInfo::add_consume() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::GoodsCfgInfo_Consume* _add = _internal_mutable_consume()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.GoodsCfgInfo.consume)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>& GoodsCfgInfo::consume() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.GoodsCfgInfo.consume)
  return _internal_consume();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>&
GoodsCfgInfo::_internal_consume() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.consume_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo_Consume>*
GoodsCfgInfo::_internal_mutable_consume() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.consume_;
}

// optional .GSToGC.GoodsCfgInfo.CfgType cfg_type = 3;
inline bool GoodsCfgInfo::has_cfg_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GoodsCfgInfo::clear_cfg_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cfg_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::GoodsCfgInfo_CfgType GoodsCfgInfo::cfg_type() const {
  // @@protoc_insertion_point(field_get:GSToGC.GoodsCfgInfo.cfg_type)
  return _internal_cfg_type();
}
inline void GoodsCfgInfo::set_cfg_type(::GSToGC::GoodsCfgInfo_CfgType value) {
  _internal_set_cfg_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GoodsCfgInfo.cfg_type)
}
inline ::GSToGC::GoodsCfgInfo_CfgType GoodsCfgInfo::_internal_cfg_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::GoodsCfgInfo_CfgType>(_impl_.cfg_type_);
}
inline void GoodsCfgInfo::_internal_set_cfg_type(::GSToGC::GoodsCfgInfo_CfgType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::GoodsCfgInfo_CfgType_IsValid(value));
  _impl_.cfg_type_ = value;
}

// -------------------------------------------------------------------

// GoodsBuyCfgInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGoodsCfgInfo];
inline bool GoodsBuyCfgInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GoodsBuyCfgInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 133;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID GoodsBuyCfgInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GoodsBuyCfgInfo.msgid)
  return _internal_msgid();
}
inline void GoodsBuyCfgInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GoodsBuyCfgInfo.msgid)
}
inline ::GSToGC::MsgID GoodsBuyCfgInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GoodsBuyCfgInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.GoodsCfgInfo info = 2;
inline int GoodsBuyCfgInfo::_internal_info_size() const {
  return _internal_info().size();
}
inline int GoodsBuyCfgInfo::info_size() const {
  return _internal_info_size();
}
inline void GoodsBuyCfgInfo::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::GoodsCfgInfo* GoodsBuyCfgInfo::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.GoodsBuyCfgInfo.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>* GoodsBuyCfgInfo::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.GoodsBuyCfgInfo.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::GoodsCfgInfo& GoodsBuyCfgInfo::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GoodsBuyCfgInfo.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::GoodsCfgInfo* GoodsBuyCfgInfo::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::GoodsCfgInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.GoodsBuyCfgInfo.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>& GoodsBuyCfgInfo::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.GoodsBuyCfgInfo.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>&
GoodsBuyCfgInfo::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GoodsCfgInfo>*
GoodsBuyCfgInfo::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// HeroAttributes

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroAttributes];
inline bool HeroAttributes::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void HeroAttributes::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 132;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::GSToGC::MsgID HeroAttributes::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.msgid)
  return _internal_msgid();
}
inline void HeroAttributes::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.msgid)
}
inline ::GSToGC::MsgID HeroAttributes::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HeroAttributes::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool HeroAttributes::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HeroAttributes::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t HeroAttributes::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.guid)
  return _internal_guid();
}
inline void HeroAttributes::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.guid)
}
inline ::uint64_t HeroAttributes::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void HeroAttributes::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 PlayerSpeed = 3;
inline bool HeroAttributes::has_playerspeed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HeroAttributes::clear_playerspeed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playerspeed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t HeroAttributes::playerspeed() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.PlayerSpeed)
  return _internal_playerspeed();
}
inline void HeroAttributes::set_playerspeed(::int32_t value) {
  _internal_set_playerspeed(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.PlayerSpeed)
}
inline ::int32_t HeroAttributes::_internal_playerspeed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playerspeed_;
}
inline void HeroAttributes::_internal_set_playerspeed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playerspeed_ = value;
}

// optional int32 AttackInterval = 4;
inline bool HeroAttributes::has_attackinterval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HeroAttributes::clear_attackinterval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attackinterval_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t HeroAttributes::attackinterval() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.AttackInterval)
  return _internal_attackinterval();
}
inline void HeroAttributes::set_attackinterval(::int32_t value) {
  _internal_set_attackinterval(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.AttackInterval)
}
inline ::int32_t HeroAttributes::_internal_attackinterval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attackinterval_;
}
inline void HeroAttributes::_internal_set_attackinterval(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attackinterval_ = value;
}

// optional int32 AttackRange = 5;
inline bool HeroAttributes::has_attackrange() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void HeroAttributes::clear_attackrange() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attackrange_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t HeroAttributes::attackrange() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.AttackRange)
  return _internal_attackrange();
}
inline void HeroAttributes::set_attackrange(::int32_t value) {
  _internal_set_attackrange(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.AttackRange)
}
inline ::int32_t HeroAttributes::_internal_attackrange() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attackrange_;
}
inline void HeroAttributes::_internal_set_attackrange(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attackrange_ = value;
}

// optional int32 ResurgenceTime = 6;
inline bool HeroAttributes::has_resurgencetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void HeroAttributes::clear_resurgencetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resurgencetime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t HeroAttributes::resurgencetime() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.ResurgenceTime)
  return _internal_resurgencetime();
}
inline void HeroAttributes::set_resurgencetime(::int32_t value) {
  _internal_set_resurgencetime(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.ResurgenceTime)
}
inline ::int32_t HeroAttributes::_internal_resurgencetime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resurgencetime_;
}
inline void HeroAttributes::_internal_set_resurgencetime(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resurgencetime_ = value;
}

// optional int32 PhysicAttack = 7;
inline bool HeroAttributes::has_physicattack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void HeroAttributes::clear_physicattack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.physicattack_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t HeroAttributes::physicattack() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.PhysicAttack)
  return _internal_physicattack();
}
inline void HeroAttributes::set_physicattack(::int32_t value) {
  _internal_set_physicattack(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.PhysicAttack)
}
inline ::int32_t HeroAttributes::_internal_physicattack() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.physicattack_;
}
inline void HeroAttributes::_internal_set_physicattack(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.physicattack_ = value;
}

// optional int32 SpellsAttack = 8;
inline bool HeroAttributes::has_spellsattack() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void HeroAttributes::clear_spellsattack() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spellsattack_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t HeroAttributes::spellsattack() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.SpellsAttack)
  return _internal_spellsattack();
}
inline void HeroAttributes::set_spellsattack(::int32_t value) {
  _internal_set_spellsattack(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.SpellsAttack)
}
inline ::int32_t HeroAttributes::_internal_spellsattack() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.spellsattack_;
}
inline void HeroAttributes::_internal_set_spellsattack(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spellsattack_ = value;
}

// optional int32 PhysicDef = 9;
inline bool HeroAttributes::has_physicdef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void HeroAttributes::clear_physicdef() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.physicdef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t HeroAttributes::physicdef() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.PhysicDef)
  return _internal_physicdef();
}
inline void HeroAttributes::set_physicdef(::int32_t value) {
  _internal_set_physicdef(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.PhysicDef)
}
inline ::int32_t HeroAttributes::_internal_physicdef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.physicdef_;
}
inline void HeroAttributes::_internal_set_physicdef(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.physicdef_ = value;
}

// optional int32 SpellsDef = 10;
inline bool HeroAttributes::has_spellsdef() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void HeroAttributes::clear_spellsdef() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spellsdef_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t HeroAttributes::spellsdef() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAttributes.SpellsDef)
  return _internal_spellsdef();
}
inline void HeroAttributes::set_spellsdef(::int32_t value) {
  _internal_set_spellsdef(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAttributes.SpellsDef)
}
inline ::int32_t HeroAttributes::_internal_spellsdef() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.spellsdef_;
}
inline void HeroAttributes::_internal_set_spellsdef(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spellsdef_ = value;
}

// -------------------------------------------------------------------

// HeroAssist

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroAssist];
inline bool HeroAssist::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HeroAssist::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 131;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID HeroAssist::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAssist.msgid)
  return _internal_msgid();
}
inline void HeroAssist::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAssist.msgid)
}
inline ::GSToGC::MsgID HeroAssist::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HeroAssist::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool HeroAssist::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HeroAssist::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t HeroAssist::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAssist.guid)
  return _internal_guid();
}
inline void HeroAssist::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAssist.guid)
}
inline ::uint64_t HeroAssist::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void HeroAssist::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 assist = 3;
inline bool HeroAssist::has_assist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HeroAssist::clear_assist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t HeroAssist::assist() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroAssist.assist)
  return _internal_assist();
}
inline void HeroAssist::set_assist(::int32_t value) {
  _internal_set_assist(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroAssist.assist)
}
inline ::int32_t HeroAssist::_internal_assist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assist_;
}
inline void HeroAssist::_internal_set_assist(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assist_ = value;
}

// -------------------------------------------------------------------

// BattleMatcherCount

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleMatherCount];
inline bool BattleMatcherCount::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BattleMatcherCount::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 130;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID BattleMatcherCount::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleMatcherCount.msgid)
  return _internal_msgid();
}
inline void BattleMatcherCount::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleMatcherCount.msgid)
}
inline ::GSToGC::MsgID BattleMatcherCount::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleMatcherCount::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 count = 2;
inline bool BattleMatcherCount::has_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleMatcherCount::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t BattleMatcherCount::count() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleMatcherCount.count)
  return _internal_count();
}
inline void BattleMatcherCount::set_count(::int32_t value) {
  _internal_set_count(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleMatcherCount.count)
}
inline ::int32_t BattleMatcherCount::_internal_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_;
}
inline void BattleMatcherCount::_internal_set_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_ = value;
}

// optional int32 maxcount = 3;
inline bool BattleMatcherCount::has_maxcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleMatcherCount::clear_maxcount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BattleMatcherCount::maxcount() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleMatcherCount.maxcount)
  return _internal_maxcount();
}
inline void BattleMatcherCount::set_maxcount(::int32_t value) {
  _internal_set_maxcount(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleMatcherCount.maxcount)
}
inline ::int32_t BattleMatcherCount::_internal_maxcount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxcount_;
}
inline void BattleMatcherCount::_internal_set_maxcount(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxcount_ = value;
}

// -------------------------------------------------------------------

// BattleSpanTime

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleSpanTime];
inline bool BattleSpanTime::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleSpanTime::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 129;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID BattleSpanTime::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSpanTime.msgid)
  return _internal_msgid();
}
inline void BattleSpanTime::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSpanTime.msgid)
}
inline ::GSToGC::MsgID BattleSpanTime::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleSpanTime::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 spanTime = 2;
inline bool BattleSpanTime::has_spantime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleSpanTime::clear_spantime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spantime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BattleSpanTime::spantime() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSpanTime.spanTime)
  return _internal_spantime();
}
inline void BattleSpanTime::set_spantime(::int64_t value) {
  _internal_set_spantime(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSpanTime.spanTime)
}
inline ::int64_t BattleSpanTime::_internal_spantime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.spantime_;
}
inline void BattleSpanTime::_internal_set_spantime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spantime_ = value;
}

// -------------------------------------------------------------------

// BattleDelayTime

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleDelayTime];
inline bool BattleDelayTime::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleDelayTime::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 235;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID BattleDelayTime::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleDelayTime.msgid)
  return _internal_msgid();
}
inline void BattleDelayTime::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleDelayTime.msgid)
}
inline ::GSToGC::MsgID BattleDelayTime::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleDelayTime::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 delayTime = 2;
inline bool BattleDelayTime::has_delaytime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleDelayTime::clear_delaytime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.delaytime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BattleDelayTime::delaytime() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleDelayTime.delayTime)
  return _internal_delaytime();
}
inline void BattleDelayTime::set_delaytime(::int64_t value) {
  _internal_set_delaytime(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleDelayTime.delayTime)
}
inline ::int64_t BattleDelayTime::_internal_delaytime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.delaytime_;
}
inline void BattleDelayTime::_internal_set_delaytime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.delaytime_ = value;
}

// -------------------------------------------------------------------

// UserBaseUpLv

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserBaseUpLv];
inline bool UserBaseUpLv::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserBaseUpLv::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 128;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID UserBaseUpLv::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseUpLv.msgid)
  return _internal_msgid();
}
inline void UserBaseUpLv::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseUpLv.msgid)
}
inline ::GSToGC::MsgID UserBaseUpLv::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void UserBaseUpLv::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 lv = 2;
inline bool UserBaseUpLv::has_lv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserBaseUpLv::clear_lv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UserBaseUpLv::lv() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseUpLv.lv)
  return _internal_lv();
}
inline void UserBaseUpLv::set_lv(::int32_t value) {
  _internal_set_lv(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseUpLv.lv)
}
inline ::int32_t UserBaseUpLv::_internal_lv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lv_;
}
inline void UserBaseUpLv::_internal_set_lv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lv_ = value;
}

// -------------------------------------------------------------------

// SecondGuideTask_task_info

// optional int32 taskid = 1;
inline bool SecondGuideTask_task_info::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SecondGuideTask_task_info::clear_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t SecondGuideTask_task_info::taskid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SecondGuideTask.task_info.taskid)
  return _internal_taskid();
}
inline void SecondGuideTask_task_info::set_taskid(::int32_t value) {
  _internal_set_taskid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.SecondGuideTask.task_info.taskid)
}
inline ::int32_t SecondGuideTask_task_info::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_;
}
inline void SecondGuideTask_task_info::_internal_set_taskid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_ = value;
}

// optional int32 num = 2;
inline bool SecondGuideTask_task_info::has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SecondGuideTask_task_info::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SecondGuideTask_task_info::num() const {
  // @@protoc_insertion_point(field_get:GSToGC.SecondGuideTask.task_info.num)
  return _internal_num();
}
inline void SecondGuideTask_task_info::set_num(::int32_t value) {
  _internal_set_num(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.SecondGuideTask.task_info.num)
}
inline ::int32_t SecondGuideTask_task_info::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void SecondGuideTask_task_info::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = value;
}

// -------------------------------------------------------------------

// SecondGuideTask

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGs_NotifySecondaryGuideTask];
inline bool SecondGuideTask::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SecondGuideTask::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 121;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID SecondGuideTask::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SecondGuideTask.msgid)
  return _internal_msgid();
}
inline void SecondGuideTask::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.SecondGuideTask.msgid)
}
inline ::GSToGC::MsgID SecondGuideTask::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void SecondGuideTask::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.SecondGuideTask.task_info taskinfo = 2;
inline int SecondGuideTask::_internal_taskinfo_size() const {
  return _internal_taskinfo().size();
}
inline int SecondGuideTask::taskinfo_size() const {
  return _internal_taskinfo_size();
}
inline void SecondGuideTask::clear_taskinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskinfo_.Clear();
}
inline ::GSToGC::SecondGuideTask_task_info* SecondGuideTask::mutable_taskinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.SecondGuideTask.taskinfo)
  return _internal_mutable_taskinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>* SecondGuideTask::mutable_taskinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.SecondGuideTask.taskinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_taskinfo();
}
inline const ::GSToGC::SecondGuideTask_task_info& SecondGuideTask::taskinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.SecondGuideTask.taskinfo)
  return _internal_taskinfo().Get(index);
}
inline ::GSToGC::SecondGuideTask_task_info* SecondGuideTask::add_taskinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::SecondGuideTask_task_info* _add = _internal_mutable_taskinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.SecondGuideTask.taskinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>& SecondGuideTask::taskinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.SecondGuideTask.taskinfo)
  return _internal_taskinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>&
SecondGuideTask::_internal_taskinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::SecondGuideTask_task_info>*
SecondGuideTask::_internal_mutable_taskinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.taskinfo_;
}

// -------------------------------------------------------------------

// GameTips

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGuideTips];
inline bool GameTips::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GameTips::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 118;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID GameTips::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GameTips.msgid)
  return _internal_msgid();
}
inline void GameTips::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GameTips.msgid)
}
inline ::GSToGC::MsgID GameTips::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GameTips::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 errocode = 2;
inline bool GameTips::has_errocode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GameTips::clear_errocode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errocode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t GameTips::errocode() const {
  // @@protoc_insertion_point(field_get:GSToGC.GameTips.errocode)
  return _internal_errocode();
}
inline void GameTips::set_errocode(::int32_t value) {
  _internal_set_errocode(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GameTips.errocode)
}
inline ::int32_t GameTips::_internal_errocode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errocode_;
}
inline void GameTips::_internal_set_errocode(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errocode_ = value;
}

// optional int32 campid = 3;
inline bool GameTips::has_campid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GameTips::clear_campid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.campid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t GameTips::campid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GameTips.campid)
  return _internal_campid();
}
inline void GameTips::set_campid(::int32_t value) {
  _internal_set_campid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GameTips.campid)
}
inline ::int32_t GameTips::_internal_campid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.campid_;
}
inline void GameTips::_internal_set_campid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.campid_ = value;
}

// -------------------------------------------------------------------

// NotifyUserReturnBattleRoom

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserReturnBattleRoom];
inline bool NotifyUserReturnBattleRoom::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyUserReturnBattleRoom::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 91;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyUserReturnBattleRoom::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserReturnBattleRoom.msgid)
  return _internal_msgid();
}
inline void NotifyUserReturnBattleRoom::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserReturnBattleRoom.msgid)
}
inline ::GSToGC::MsgID NotifyUserReturnBattleRoom::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyUserReturnBattleRoom::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// BroadcastBattleHeroInfo_HeroInfo

// optional uint64 guid = 1;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BroadcastBattleHeroInfo_HeroInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.guid)
  return _internal_guid();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.guid)
}
inline ::uint64_t BroadcastBattleHeroInfo_HeroInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional string nickname = 2;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BroadcastBattleHeroInfo_HeroInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastBattleHeroInfo_HeroInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.nickname)
}
inline std::string* BroadcastBattleHeroInfo_HeroInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.BroadcastBattleHeroInfo.HeroInfo.nickname)
  return _s;
}
inline const std::string& BroadcastBattleHeroInfo_HeroInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* BroadcastBattleHeroInfo_HeroInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* BroadcastBattleHeroInfo_HeroInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.BroadcastBattleHeroInfo.HeroInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.BroadcastBattleHeroInfo.HeroInfo.nickname)
}

// optional int32 level = 3;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::level() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.level)
  return _internal_level();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.level)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = value;
}

// optional int32 deadtimes = 4;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_deadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_deadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::deadtimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.deadtimes)
  return _internal_deadtimes();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_deadtimes(::int32_t value) {
  _internal_set_deadtimes(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.deadtimes)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_deadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadtimes_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_deadtimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = value;
}

// optional int32 campid = 5;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_campid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_campid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.campid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::campid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.campid)
  return _internal_campid();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_campid(::int32_t value) {
  _internal_set_campid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.campid)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_campid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.campid_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_campid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.campid_ = value;
}

// optional int32 headid = 6;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.headid)
  return _internal_headid();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_headid(::int32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.headid)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_headid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional int32 hp = 7;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_hp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_hp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::hp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.hp)
  return _internal_hp();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_hp(::int32_t value) {
  _internal_set_hp(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.hp)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_hp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hp_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_hp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = value;
}

// optional int32 mp = 8;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_mp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_mp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::mp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.mp)
  return _internal_mp();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_mp(::int32_t value) {
  _internal_set_mp(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.mp)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_mp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_mp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_ = value;
}

// optional int32 pos = 9;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.pos)
  return _internal_pos();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.pos)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// optional uint64 masterguid = 10;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_masterguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_masterguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.masterguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t BroadcastBattleHeroInfo_HeroInfo::masterguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.masterguid)
  return _internal_masterguid();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_masterguid(::uint64_t value) {
  _internal_set_masterguid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.masterguid)
}
inline ::uint64_t BroadcastBattleHeroInfo_HeroInfo::_internal_masterguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.masterguid_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_masterguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.masterguid_ = value;
}

// optional int32 kills = 11;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_kills() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::kills() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.kills)
  return _internal_kills();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_kills(::int32_t value) {
  _internal_set_kills(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.kills)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_kills() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kills_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_kills(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kills_ = value;
}

// optional int32 assist = 12;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_assist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_assist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::assist() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.assist)
  return _internal_assist();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_assist(::int32_t value) {
  _internal_set_assist(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.assist)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_assist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assist_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_assist(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assist_ = value;
}

// optional int32 heroid = 13;
inline bool BroadcastBattleHeroInfo_HeroInfo::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_HeroInfo::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.HeroInfo.heroid)
  return _internal_heroid();
}
inline void BroadcastBattleHeroInfo_HeroInfo::set_heroid(::int32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.HeroInfo.heroid)
}
inline ::int32_t BroadcastBattleHeroInfo_HeroInfo::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void BroadcastBattleHeroInfo_HeroInfo::_internal_set_heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// -------------------------------------------------------------------

// BroadcastBattleHeroInfo_BaseGoodsInfo

// optional int32 index = 13;
inline bool BroadcastBattleHeroInfo_BaseGoodsInfo::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_BaseGoodsInfo::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t BroadcastBattleHeroInfo_BaseGoodsInfo::index() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo.index)
  return _internal_index();
}
inline void BroadcastBattleHeroInfo_BaseGoodsInfo::set_index(::int32_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo.index)
}
inline ::int32_t BroadcastBattleHeroInfo_BaseGoodsInfo::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void BroadcastBattleHeroInfo_BaseGoodsInfo::_internal_set_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = value;
}

// optional int32 id = 14;
inline bool BroadcastBattleHeroInfo_BaseGoodsInfo::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo_BaseGoodsInfo::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BroadcastBattleHeroInfo_BaseGoodsInfo::id() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo.id)
  return _internal_id();
}
inline void BroadcastBattleHeroInfo_BaseGoodsInfo::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo.id)
}
inline ::int32_t BroadcastBattleHeroInfo_BaseGoodsInfo::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void BroadcastBattleHeroInfo_BaseGoodsInfo::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// BroadcastBattleHeroInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadcastBattleHeroInfo];
inline bool BroadcastBattleHeroInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BroadcastBattleHeroInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 55;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID BroadcastBattleHeroInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.msgid)
  return _internal_msgid();
}
inline void BroadcastBattleHeroInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattleHeroInfo.msgid)
}
inline ::GSToGC::MsgID BroadcastBattleHeroInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BroadcastBattleHeroInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.BroadcastBattleHeroInfo.HeroInfo heroinfo = 2;
inline int BroadcastBattleHeroInfo::_internal_heroinfo_size() const {
  return _internal_heroinfo().size();
}
inline int BroadcastBattleHeroInfo::heroinfo_size() const {
  return _internal_heroinfo_size();
}
inline void BroadcastBattleHeroInfo::clear_heroinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroinfo_.Clear();
}
inline ::GSToGC::BroadcastBattleHeroInfo_HeroInfo* BroadcastBattleHeroInfo::mutable_heroinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.BroadcastBattleHeroInfo.heroinfo)
  return _internal_mutable_heroinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>* BroadcastBattleHeroInfo::mutable_heroinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.BroadcastBattleHeroInfo.heroinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_heroinfo();
}
inline const ::GSToGC::BroadcastBattleHeroInfo_HeroInfo& BroadcastBattleHeroInfo::heroinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.heroinfo)
  return _internal_heroinfo().Get(index);
}
inline ::GSToGC::BroadcastBattleHeroInfo_HeroInfo* BroadcastBattleHeroInfo::add_heroinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::BroadcastBattleHeroInfo_HeroInfo* _add = _internal_mutable_heroinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.BroadcastBattleHeroInfo.heroinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>& BroadcastBattleHeroInfo::heroinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.BroadcastBattleHeroInfo.heroinfo)
  return _internal_heroinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>&
BroadcastBattleHeroInfo::_internal_heroinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_HeroInfo>*
BroadcastBattleHeroInfo::_internal_mutable_heroinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.heroinfo_;
}

// repeated .GSToGC.BroadcastBattleHeroInfo.BaseGoodsInfo goodsinfo = 3;
inline int BroadcastBattleHeroInfo::_internal_goodsinfo_size() const {
  return _internal_goodsinfo().size();
}
inline int BroadcastBattleHeroInfo::goodsinfo_size() const {
  return _internal_goodsinfo_size();
}
inline void BroadcastBattleHeroInfo::clear_goodsinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goodsinfo_.Clear();
}
inline ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo* BroadcastBattleHeroInfo::mutable_goodsinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.BroadcastBattleHeroInfo.goodsinfo)
  return _internal_mutable_goodsinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>* BroadcastBattleHeroInfo::mutable_goodsinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.BroadcastBattleHeroInfo.goodsinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_goodsinfo();
}
inline const ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo& BroadcastBattleHeroInfo::goodsinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattleHeroInfo.goodsinfo)
  return _internal_goodsinfo().Get(index);
}
inline ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo* BroadcastBattleHeroInfo::add_goodsinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo* _add = _internal_mutable_goodsinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.BroadcastBattleHeroInfo.goodsinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>& BroadcastBattleHeroInfo::goodsinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.BroadcastBattleHeroInfo.goodsinfo)
  return _internal_goodsinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>&
BroadcastBattleHeroInfo::_internal_goodsinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goodsinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBattleHeroInfo_BaseGoodsInfo>*
BroadcastBattleHeroInfo::_internal_mutable_goodsinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.goodsinfo_;
}

// -------------------------------------------------------------------

// GuideLastStep

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_NotifyGuideLastComStep];
inline bool GuideLastStep::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GuideLastStep::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 106;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID GuideLastStep::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideLastStep.msgid)
  return _internal_msgid();
}
inline void GuideLastStep::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideLastStep.msgid)
}
inline ::GSToGC::MsgID GuideLastStep::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GuideLastStep::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional bool ifComp = 2;
inline bool GuideLastStep::has_ifcomp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideLastStep::clear_ifcomp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifcomp_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool GuideLastStep::ifcomp() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideLastStep.ifComp)
  return _internal_ifcomp();
}
inline void GuideLastStep::set_ifcomp(bool value) {
  _internal_set_ifcomp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideLastStep.ifComp)
}
inline bool GuideLastStep::_internal_ifcomp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifcomp_;
}
inline void GuideLastStep::_internal_set_ifcomp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifcomp_ = value;
}

// optional int32 stepid = 3;
inline bool GuideLastStep::has_stepid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GuideLastStep::clear_stepid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t GuideLastStep::stepid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideLastStep.stepid)
  return _internal_stepid();
}
inline void GuideLastStep::set_stepid(::int32_t value) {
  _internal_set_stepid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideLastStep.stepid)
}
inline ::int32_t GuideLastStep::_internal_stepid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stepid_;
}
inline void GuideLastStep::_internal_set_stepid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = value;
}

// -------------------------------------------------------------------

// NotifyUserCLDays

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserCLDays];
inline bool NotifyUserCLDays::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifyUserCLDays::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 119;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID NotifyUserCLDays::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserCLDays.msgid)
  return _internal_msgid();
}
inline void NotifyUserCLDays::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserCLDays.msgid)
}
inline ::GSToGC::MsgID NotifyUserCLDays::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyUserCLDays::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 month = 2;
inline bool NotifyUserCLDays::has_month() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyUserCLDays::clear_month() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.month_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyUserCLDays::month() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserCLDays.month)
  return _internal_month();
}
inline void NotifyUserCLDays::set_month(::uint32_t value) {
  _internal_set_month(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserCLDays.month)
}
inline ::uint32_t NotifyUserCLDays::_internal_month() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.month_;
}
inline void NotifyUserCLDays::_internal_set_month(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.month_ = value;
}

// optional uint32 today = 3;
inline bool NotifyUserCLDays::has_today() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyUserCLDays::clear_today() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.today_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyUserCLDays::today() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserCLDays.today)
  return _internal_today();
}
inline void NotifyUserCLDays::set_today(::uint32_t value) {
  _internal_set_today(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserCLDays.today)
}
inline ::uint32_t NotifyUserCLDays::_internal_today() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.today_;
}
inline void NotifyUserCLDays::_internal_set_today(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.today_ = value;
}

// optional uint32 totalCldays = 4;
inline bool NotifyUserCLDays::has_totalcldays() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyUserCLDays::clear_totalcldays() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalcldays_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t NotifyUserCLDays::totalcldays() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserCLDays.totalCldays)
  return _internal_totalcldays();
}
inline void NotifyUserCLDays::set_totalcldays(::uint32_t value) {
  _internal_set_totalcldays(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserCLDays.totalCldays)
}
inline ::uint32_t NotifyUserCLDays::_internal_totalcldays() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalcldays_;
}
inline void NotifyUserCLDays::_internal_set_totalcldays(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalcldays_ = value;
}

// optional uint32 cldays = 5;
inline bool NotifyUserCLDays::has_cldays() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyUserCLDays::clear_cldays() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cldays_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t NotifyUserCLDays::cldays() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserCLDays.cldays)
  return _internal_cldays();
}
inline void NotifyUserCLDays::set_cldays(::uint32_t value) {
  _internal_set_cldays(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserCLDays.cldays)
}
inline ::uint32_t NotifyUserCLDays::_internal_cldays() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cldays_;
}
inline void NotifyUserCLDays::_internal_set_cldays(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cldays_ = value;
}

// optional bool isTodayCan = 6;
inline bool NotifyUserCLDays::has_istodaycan() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifyUserCLDays::clear_istodaycan() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.istodaycan_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool NotifyUserCLDays::istodaycan() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserCLDays.isTodayCan)
  return _internal_istodaycan();
}
inline void NotifyUserCLDays::set_istodaycan(bool value) {
  _internal_set_istodaycan(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserCLDays.isTodayCan)
}
inline bool NotifyUserCLDays::_internal_istodaycan() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.istodaycan_;
}
inline void NotifyUserCLDays::_internal_set_istodaycan(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.istodaycan_ = value;
}

// -------------------------------------------------------------------

// GameNotice_Notice

// optional string title = 1;
inline bool GameNotice_Notice::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GameNotice_Notice::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameNotice_Notice::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GameNotice.Notice.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameNotice_Notice::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.GameNotice.Notice.title)
}
inline std::string* GameNotice_Notice::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:GSToGC.GameNotice.Notice.title)
  return _s;
}
inline const std::string& GameNotice_Notice::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void GameNotice_Notice::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* GameNotice_Notice::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* GameNotice_Notice::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GameNotice.Notice.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameNotice_Notice::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GameNotice.Notice.title)
}

// optional uint32 flag = 2;
inline bool GameNotice_Notice::has_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GameNotice_Notice::clear_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t GameNotice_Notice::flag() const {
  // @@protoc_insertion_point(field_get:GSToGC.GameNotice.Notice.flag)
  return _internal_flag();
}
inline void GameNotice_Notice::set_flag(::uint32_t value) {
  _internal_set_flag(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GameNotice.Notice.flag)
}
inline ::uint32_t GameNotice_Notice::_internal_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_;
}
inline void GameNotice_Notice::_internal_set_flag(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = value;
}

// optional uint32 status = 3;
inline bool GameNotice_Notice::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GameNotice_Notice::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t GameNotice_Notice::status() const {
  // @@protoc_insertion_point(field_get:GSToGC.GameNotice.Notice.status)
  return _internal_status();
}
inline void GameNotice_Notice::set_status(::uint32_t value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.GameNotice.Notice.status)
}
inline ::uint32_t GameNotice_Notice::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void GameNotice_Notice::_internal_set_status(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = value;
}

// optional uint32 priority = 4;
inline bool GameNotice_Notice::has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GameNotice_Notice::clear_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t GameNotice_Notice::priority() const {
  // @@protoc_insertion_point(field_get:GSToGC.GameNotice.Notice.priority)
  return _internal_priority();
}
inline void GameNotice_Notice::set_priority(::uint32_t value) {
  _internal_set_priority(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.GameNotice.Notice.priority)
}
inline ::uint32_t GameNotice_Notice::_internal_priority() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.priority_;
}
inline void GameNotice_Notice::_internal_set_priority(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_ = value;
}

// optional string notice = 5;
inline bool GameNotice_Notice::has_notice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GameNotice_Notice::clear_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GameNotice_Notice::notice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GameNotice.Notice.notice)
  return _internal_notice();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GameNotice_Notice::set_notice(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.notice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.GameNotice.Notice.notice)
}
inline std::string* GameNotice_Notice::mutable_notice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_notice();
  // @@protoc_insertion_point(field_mutable:GSToGC.GameNotice.Notice.notice)
  return _s;
}
inline const std::string& GameNotice_Notice::_internal_notice() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notice_.Get();
}
inline void GameNotice_Notice::_internal_set_notice(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.notice_.Set(value, GetArena());
}
inline std::string* GameNotice_Notice::_internal_mutable_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.notice_.Mutable( GetArena());
}
inline std::string* GameNotice_Notice::release_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GameNotice.Notice.notice)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.notice_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.notice_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GameNotice_Notice::set_allocated_notice(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.notice_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.notice_.IsDefault()) {
          _impl_.notice_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GameNotice.Notice.notice)
}

// -------------------------------------------------------------------

// GameNotice

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNotice];
inline bool GameNotice::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GameNotice::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 117;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID GameNotice::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GameNotice.msgid)
  return _internal_msgid();
}
inline void GameNotice::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GameNotice.msgid)
}
inline ::GSToGC::MsgID GameNotice::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GameNotice::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.GameNotice.Notice notice = 2;
inline int GameNotice::_internal_notice_size() const {
  return _internal_notice().size();
}
inline int GameNotice::notice_size() const {
  return _internal_notice_size();
}
inline void GameNotice::clear_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notice_.Clear();
}
inline ::GSToGC::GameNotice_Notice* GameNotice::mutable_notice(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.GameNotice.notice)
  return _internal_mutable_notice()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>* GameNotice::mutable_notice()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.GameNotice.notice)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_notice();
}
inline const ::GSToGC::GameNotice_Notice& GameNotice::notice(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GameNotice.notice)
  return _internal_notice().Get(index);
}
inline ::GSToGC::GameNotice_Notice* GameNotice::add_notice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::GameNotice_Notice* _add = _internal_mutable_notice()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.GameNotice.notice)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>& GameNotice::notice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.GameNotice.notice)
  return _internal_notice();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>&
GameNotice::_internal_notice() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notice_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GameNotice_Notice>*
GameNotice::_internal_mutable_notice() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.notice_;
}

// -------------------------------------------------------------------

// GuideSteps

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserGuideSetups];
inline bool GuideSteps::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GuideSteps::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 112;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID GuideSteps::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideSteps.msgid)
  return _internal_msgid();
}
inline void GuideSteps::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideSteps.msgid)
}
inline ::GSToGC::MsgID GuideSteps::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GuideSteps::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool GuideSteps::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GuideSteps::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t GuideSteps::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideSteps.guid)
  return _internal_guid();
}
inline void GuideSteps::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideSteps.guid)
}
inline ::uint64_t GuideSteps::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void GuideSteps::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 type = 3;
inline bool GuideSteps::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GuideSteps::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t GuideSteps::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideSteps.type)
  return _internal_type();
}
inline void GuideSteps::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideSteps.type)
}
inline ::int32_t GuideSteps::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void GuideSteps::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional bool ifComp = 4;
inline bool GuideSteps::has_ifcomp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GuideSteps::clear_ifcomp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifcomp_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool GuideSteps::ifcomp() const {
  // @@protoc_insertion_point(field_get:GSToGC.GuideSteps.ifComp)
  return _internal_ifcomp();
}
inline void GuideSteps::set_ifcomp(bool value) {
  _internal_set_ifcomp(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.GuideSteps.ifComp)
}
inline bool GuideSteps::_internal_ifcomp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifcomp_;
}
inline void GuideSteps::_internal_set_ifcomp(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifcomp_ = value;
}

// optional string steps = 5;
inline bool GuideSteps::has_steps() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GuideSteps::clear_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.steps_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GuideSteps::steps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GuideSteps.steps)
  return _internal_steps();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GuideSteps::set_steps(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.steps_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.GuideSteps.steps)
}
inline std::string* GuideSteps::mutable_steps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_steps();
  // @@protoc_insertion_point(field_mutable:GSToGC.GuideSteps.steps)
  return _s;
}
inline const std::string& GuideSteps::_internal_steps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.steps_.Get();
}
inline void GuideSteps::_internal_set_steps(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.steps_.Set(value, GetArena());
}
inline std::string* GuideSteps::_internal_mutable_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.steps_.Mutable( GetArena());
}
inline std::string* GuideSteps::release_steps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GuideSteps.steps)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.steps_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.steps_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void GuideSteps::set_allocated_steps(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.steps_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.steps_.IsDefault()) {
          _impl_.steps_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GuideSteps.steps)
}

// -------------------------------------------------------------------

// PingRet

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GCAskPingRet];
inline bool PingRet::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PingRet::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 1;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID PingRet::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PingRet.msgid)
  return _internal_msgid();
}
inline void PingRet::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.PingRet.msgid)
}
inline ::GSToGC::MsgID PingRet::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void PingRet::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 time = 2;
inline bool PingRet::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PingRet::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t PingRet::time() const {
  // @@protoc_insertion_point(field_get:GSToGC.PingRet.time)
  return _internal_time();
}
inline void PingRet::set_time(::int64_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.PingRet.time)
}
inline ::int64_t PingRet::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void PingRet::_internal_set_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = value;
}

// optional int32 flag = 3;
inline bool PingRet::has_flag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PingRet::clear_flag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t PingRet::flag() const {
  // @@protoc_insertion_point(field_get:GSToGC.PingRet.flag)
  return _internal_flag();
}
inline void PingRet::set_flag(::int32_t value) {
  _internal_set_flag(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.PingRet.flag)
}
inline ::int32_t PingRet::_internal_flag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.flag_;
}
inline void PingRet::_internal_set_flag(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.flag_ = value;
}

// -------------------------------------------------------------------

// NotifyQueryNickNameRet_QueryInfo

// optional string nickname = 1;
inline bool NotifyQueryNickNameRet_QueryInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyQueryNickNameRet_QueryInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyQueryNickNameRet_QueryInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyQueryNickNameRet.QueryInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyQueryNickNameRet_QueryInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyQueryNickNameRet.QueryInfo.nickname)
}
inline std::string* NotifyQueryNickNameRet_QueryInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyQueryNickNameRet.QueryInfo.nickname)
  return _s;
}
inline const std::string& NotifyQueryNickNameRet_QueryInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void NotifyQueryNickNameRet_QueryInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* NotifyQueryNickNameRet_QueryInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* NotifyQueryNickNameRet_QueryInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyQueryNickNameRet.QueryInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyQueryNickNameRet_QueryInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyQueryNickNameRet.QueryInfo.nickname)
}

// optional int32 headid = 2;
inline bool NotifyQueryNickNameRet_QueryInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyQueryNickNameRet_QueryInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyQueryNickNameRet_QueryInfo::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyQueryNickNameRet.QueryInfo.headid)
  return _internal_headid();
}
inline void NotifyQueryNickNameRet_QueryInfo::set_headid(::int32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyQueryNickNameRet.QueryInfo.headid)
}
inline ::int32_t NotifyQueryNickNameRet_QueryInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void NotifyQueryNickNameRet_QueryInfo::_internal_set_headid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// -------------------------------------------------------------------

// NotifyQueryNickNameRet

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyQueryNickNameRet];
inline bool NotifyQueryNickNameRet::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyQueryNickNameRet::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 104;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyQueryNickNameRet::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyQueryNickNameRet.msgid)
  return _internal_msgid();
}
inline void NotifyQueryNickNameRet::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyQueryNickNameRet.msgid)
}
inline ::GSToGC::MsgID NotifyQueryNickNameRet::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyQueryNickNameRet::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.NotifyQueryNickNameRet.QueryInfo info = 2;
inline int NotifyQueryNickNameRet::_internal_info_size() const {
  return _internal_info().size();
}
inline int NotifyQueryNickNameRet::info_size() const {
  return _internal_info_size();
}
inline void NotifyQueryNickNameRet::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::NotifyQueryNickNameRet_QueryInfo* NotifyQueryNickNameRet::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyQueryNickNameRet.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>* NotifyQueryNickNameRet::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyQueryNickNameRet.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::NotifyQueryNickNameRet_QueryInfo& NotifyQueryNickNameRet::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyQueryNickNameRet.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::NotifyQueryNickNameRet_QueryInfo* NotifyQueryNickNameRet::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyQueryNickNameRet_QueryInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyQueryNickNameRet.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>& NotifyQueryNickNameRet::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyQueryNickNameRet.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>&
NotifyQueryNickNameRet::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyQueryNickNameRet_QueryInfo>*
NotifyQueryNickNameRet::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// SNSInfo

// optional int32 type = 1;
inline bool SNSInfo::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SNSInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t SNSInfo::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.SNSInfo.type)
  return _internal_type();
}
inline void SNSInfo::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.SNSInfo.type)
}
inline ::int32_t SNSInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void SNSInfo::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional string nickname = 2;
inline bool SNSInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SNSInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SNSInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.SNSInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SNSInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.SNSInfo.nickname)
}
inline std::string* SNSInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.SNSInfo.nickname)
  return _s;
}
inline const std::string& SNSInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void SNSInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* SNSInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* SNSInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.SNSInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SNSInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.SNSInfo.nickname)
}

// optional uint32 headid = 3;
inline bool SNSInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SNSInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t SNSInfo::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SNSInfo.headid)
  return _internal_headid();
}
inline void SNSInfo::set_headid(::uint32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.SNSInfo.headid)
}
inline ::uint32_t SNSInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void SNSInfo::_internal_set_headid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional int32 status = 4;
inline bool SNSInfo::has_status() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SNSInfo::clear_status() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t SNSInfo::status() const {
  // @@protoc_insertion_point(field_get:GSToGC.SNSInfo.status)
  return _internal_status();
}
inline void SNSInfo::set_status(::int32_t value) {
  _internal_set_status(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.SNSInfo.status)
}
inline ::int32_t SNSInfo::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.status_;
}
inline void SNSInfo::_internal_set_status(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_ = value;
}

// optional uint64 guididx = 5;
inline bool SNSInfo::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SNSInfo::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t SNSInfo::guididx() const {
  // @@protoc_insertion_point(field_get:GSToGC.SNSInfo.guididx)
  return _internal_guididx();
}
inline void SNSInfo::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.SNSInfo.guididx)
}
inline ::uint64_t SNSInfo::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void SNSInfo::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// optional uint32 viplv = 6;
inline bool SNSInfo::has_viplv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SNSInfo::clear_viplv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.viplv_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t SNSInfo::viplv() const {
  // @@protoc_insertion_point(field_get:GSToGC.SNSInfo.viplv)
  return _internal_viplv();
}
inline void SNSInfo::set_viplv(::uint32_t value) {
  _internal_set_viplv(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.SNSInfo.viplv)
}
inline ::uint32_t SNSInfo::_internal_viplv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.viplv_;
}
inline void SNSInfo::_internal_set_viplv(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.viplv_ = value;
}

// -------------------------------------------------------------------

// NotifyUserSNSList

// optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyUserSNSList];
inline bool NotifyUserSNSList::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyUserSNSList::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 99;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyUserSNSList::msgnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserSNSList.msgnum)
  return _internal_msgnum();
}
inline void NotifyUserSNSList::set_msgnum(::GSToGC::MsgID value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserSNSList.msgnum)
}
inline ::GSToGC::MsgID NotifyUserSNSList::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgnum_);
}
inline void NotifyUserSNSList::_internal_set_msgnum(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgnum_ = value;
}

// repeated .GSToGC.SNSInfo info = 2;
inline int NotifyUserSNSList::_internal_info_size() const {
  return _internal_info().size();
}
inline int NotifyUserSNSList::info_size() const {
  return _internal_info_size();
}
inline void NotifyUserSNSList::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::SNSInfo* NotifyUserSNSList::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyUserSNSList.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>* NotifyUserSNSList::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyUserSNSList.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::SNSInfo& NotifyUserSNSList::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserSNSList.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::SNSInfo* NotifyUserSNSList::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::SNSInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyUserSNSList.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>& NotifyUserSNSList::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyUserSNSList.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>&
NotifyUserSNSList::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::SNSInfo>*
NotifyUserSNSList::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// NotifyBattleManagerChange

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleManagerChange];
inline bool NotifyBattleManagerChange::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyBattleManagerChange::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 86;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyBattleManagerChange::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBattleManagerChange.msgid)
  return _internal_msgid();
}
inline void NotifyBattleManagerChange::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBattleManagerChange.msgid)
}
inline ::GSToGC::MsgID NotifyBattleManagerChange::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyBattleManagerChange::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// NotifyBeAddFriendMs

// optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyBeAddFriendMsg];
inline bool NotifyBeAddFriendMs::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyBeAddFriendMs::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 103;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyBeAddFriendMs::msgnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBeAddFriendMs.msgnum)
  return _internal_msgnum();
}
inline void NotifyBeAddFriendMs::set_msgnum(::GSToGC::MsgID value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBeAddFriendMs.msgnum)
}
inline ::GSToGC::MsgID NotifyBeAddFriendMs::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgnum_);
}
inline void NotifyBeAddFriendMs::_internal_set_msgnum(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional string sendnickname = 2;
inline bool NotifyBeAddFriendMs::has_sendnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyBeAddFriendMs::clear_sendnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sendnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyBeAddFriendMs::sendnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBeAddFriendMs.sendnickname)
  return _internal_sendnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyBeAddFriendMs::set_sendnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sendnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBeAddFriendMs.sendnickname)
}
inline std::string* NotifyBeAddFriendMs::mutable_sendnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sendnickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyBeAddFriendMs.sendnickname)
  return _s;
}
inline const std::string& NotifyBeAddFriendMs::_internal_sendnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sendnickname_.Get();
}
inline void NotifyBeAddFriendMs::_internal_set_sendnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.sendnickname_.Set(value, GetArena());
}
inline std::string* NotifyBeAddFriendMs::_internal_mutable_sendnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.sendnickname_.Mutable( GetArena());
}
inline std::string* NotifyBeAddFriendMs::release_sendnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyBeAddFriendMs.sendnickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.sendnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sendnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyBeAddFriendMs::set_allocated_sendnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.sendnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sendnickname_.IsDefault()) {
          _impl_.sendnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyBeAddFriendMs.sendnickname)
}

// optional string recnickname = 3;
inline bool NotifyBeAddFriendMs::has_recnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyBeAddFriendMs::clear_recnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.recnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NotifyBeAddFriendMs::recnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBeAddFriendMs.recnickname)
  return _internal_recnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyBeAddFriendMs::set_recnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.recnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBeAddFriendMs.recnickname)
}
inline std::string* NotifyBeAddFriendMs::mutable_recnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_recnickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyBeAddFriendMs.recnickname)
  return _s;
}
inline const std::string& NotifyBeAddFriendMs::_internal_recnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.recnickname_.Get();
}
inline void NotifyBeAddFriendMs::_internal_set_recnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.recnickname_.Set(value, GetArena());
}
inline std::string* NotifyBeAddFriendMs::_internal_mutable_recnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.recnickname_.Mutable( GetArena());
}
inline std::string* NotifyBeAddFriendMs::release_recnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyBeAddFriendMs.recnickname)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.recnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.recnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyBeAddFriendMs::set_allocated_recnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.recnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.recnickname_.IsDefault()) {
          _impl_.recnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyBeAddFriendMs.recnickname)
}

// optional uint64 sdnder_guididx = 4;
inline bool NotifyBeAddFriendMs::has_sdnder_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyBeAddFriendMs::clear_sdnder_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdnder_guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t NotifyBeAddFriendMs::sdnder_guididx() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBeAddFriendMs.sdnder_guididx)
  return _internal_sdnder_guididx();
}
inline void NotifyBeAddFriendMs::set_sdnder_guididx(::uint64_t value) {
  _internal_set_sdnder_guididx(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBeAddFriendMs.sdnder_guididx)
}
inline ::uint64_t NotifyBeAddFriendMs::_internal_sdnder_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdnder_guididx_;
}
inline void NotifyBeAddFriendMs::_internal_set_sdnder_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdnder_guididx_ = value;
}

// -------------------------------------------------------------------

// NotifyMsgFromUser

// optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyMsgFromUser];
inline bool NotifyMsgFromUser::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifyMsgFromUser::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 102;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID NotifyMsgFromUser::msgnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMsgFromUser.msgnum)
  return _internal_msgnum();
}
inline void NotifyMsgFromUser::set_msgnum(::GSToGC::MsgID value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMsgFromUser.msgnum)
}
inline ::GSToGC::MsgID NotifyMsgFromUser::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgnum_);
}
inline void NotifyMsgFromUser::_internal_set_msgnum(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 guididx = 2;
inline bool NotifyMsgFromUser::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyMsgFromUser::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t NotifyMsgFromUser::guididx() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMsgFromUser.guididx)
  return _internal_guididx();
}
inline void NotifyMsgFromUser::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMsgFromUser.guididx)
}
inline ::uint64_t NotifyMsgFromUser::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void NotifyMsgFromUser::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// optional string nickname = 3;
inline bool NotifyMsgFromUser::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMsgFromUser::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyMsgFromUser::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMsgFromUser.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyMsgFromUser::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMsgFromUser.nickname)
}
inline std::string* NotifyMsgFromUser::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyMsgFromUser.nickname)
  return _s;
}
inline const std::string& NotifyMsgFromUser::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void NotifyMsgFromUser::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* NotifyMsgFromUser::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* NotifyMsgFromUser::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyMsgFromUser.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyMsgFromUser::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyMsgFromUser.nickname)
}

// optional int32 headid = 4;
inline bool NotifyMsgFromUser::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyMsgFromUser::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifyMsgFromUser::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMsgFromUser.headid)
  return _internal_headid();
}
inline void NotifyMsgFromUser::set_headid(::int32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMsgFromUser.headid)
}
inline ::int32_t NotifyMsgFromUser::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void NotifyMsgFromUser::_internal_set_headid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional string chatstr = 5;
inline bool NotifyMsgFromUser::has_chatstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyMsgFromUser::clear_chatstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chatstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NotifyMsgFromUser::chatstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMsgFromUser.chatstr)
  return _internal_chatstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyMsgFromUser::set_chatstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chatstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMsgFromUser.chatstr)
}
inline std::string* NotifyMsgFromUser::mutable_chatstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_chatstr();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyMsgFromUser.chatstr)
  return _s;
}
inline const std::string& NotifyMsgFromUser::_internal_chatstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chatstr_.Get();
}
inline void NotifyMsgFromUser::_internal_set_chatstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.chatstr_.Set(value, GetArena());
}
inline std::string* NotifyMsgFromUser::_internal_mutable_chatstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.chatstr_.Mutable( GetArena());
}
inline std::string* NotifyMsgFromUser::release_chatstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyMsgFromUser.chatstr)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.chatstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chatstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyMsgFromUser::set_allocated_chatstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.chatstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chatstr_.IsDefault()) {
          _impl_.chatstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyMsgFromUser.chatstr)
}

// -------------------------------------------------------------------

// NotifyUserSNSListChange

// optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyUserSNSListChange];
inline bool NotifyUserSNSListChange::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyUserSNSListChange::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 100;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyUserSNSListChange::msgnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserSNSListChange.msgnum)
  return _internal_msgnum();
}
inline void NotifyUserSNSListChange::set_msgnum(::GSToGC::MsgID value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserSNSListChange.msgnum)
}
inline ::GSToGC::MsgID NotifyUserSNSListChange::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgnum_);
}
inline void NotifyUserSNSListChange::_internal_set_msgnum(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 guididx = 2;
inline bool NotifyUserSNSListChange::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyUserSNSListChange::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyUserSNSListChange::guididx() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserSNSListChange.guididx)
  return _internal_guididx();
}
inline void NotifyUserSNSListChange::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserSNSListChange.guididx)
}
inline ::uint64_t NotifyUserSNSListChange::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void NotifyUserSNSListChange::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// optional uint32 type = 3;
inline bool NotifyUserSNSListChange::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyUserSNSListChange::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyUserSNSListChange::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyUserSNSListChange.type)
  return _internal_type();
}
inline void NotifyUserSNSListChange::set_type(::uint32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyUserSNSListChange.type)
}
inline ::uint32_t NotifyUserSNSListChange::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void NotifyUserSNSListChange::_internal_set_type(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// UserBeInvitedToBattle

// optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_UserBeInvitedToBattle];
inline bool UserBeInvitedToBattle::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserBeInvitedToBattle::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 101;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID UserBeInvitedToBattle::msgnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBeInvitedToBattle.msgnum)
  return _internal_msgnum();
}
inline void UserBeInvitedToBattle::set_msgnum(::GSToGC::MsgID value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBeInvitedToBattle.msgnum)
}
inline ::GSToGC::MsgID UserBeInvitedToBattle::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgnum_);
}
inline void UserBeInvitedToBattle::_internal_set_msgnum(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional int32 battleid = 2;
inline bool UserBeInvitedToBattle::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserBeInvitedToBattle::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t UserBeInvitedToBattle::battleid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBeInvitedToBattle.battleid)
  return _internal_battleid();
}
inline void UserBeInvitedToBattle::set_battleid(::int32_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBeInvitedToBattle.battleid)
}
inline ::int32_t UserBeInvitedToBattle::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void UserBeInvitedToBattle::_internal_set_battleid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional string pwd = 3;
inline bool UserBeInvitedToBattle::has_pwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserBeInvitedToBattle::clear_pwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pwd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserBeInvitedToBattle::pwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UserBeInvitedToBattle.pwd)
  return _internal_pwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserBeInvitedToBattle::set_pwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.UserBeInvitedToBattle.pwd)
}
inline std::string* UserBeInvitedToBattle::mutable_pwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pwd();
  // @@protoc_insertion_point(field_mutable:GSToGC.UserBeInvitedToBattle.pwd)
  return _s;
}
inline const std::string& UserBeInvitedToBattle::_internal_pwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pwd_.Get();
}
inline void UserBeInvitedToBattle::_internal_set_pwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.pwd_.Set(value, GetArena());
}
inline std::string* UserBeInvitedToBattle::_internal_mutable_pwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.pwd_.Mutable( GetArena());
}
inline std::string* UserBeInvitedToBattle::release_pwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UserBeInvitedToBattle.pwd)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.pwd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pwd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserBeInvitedToBattle::set_allocated_pwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.pwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pwd_.IsDefault()) {
          _impl_.pwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UserBeInvitedToBattle.pwd)
}

// optional string Invitor = 4;
inline bool UserBeInvitedToBattle::has_invitor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserBeInvitedToBattle::clear_invitor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.invitor_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserBeInvitedToBattle::invitor() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UserBeInvitedToBattle.Invitor)
  return _internal_invitor();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserBeInvitedToBattle::set_invitor(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.invitor_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.UserBeInvitedToBattle.Invitor)
}
inline std::string* UserBeInvitedToBattle::mutable_invitor() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_invitor();
  // @@protoc_insertion_point(field_mutable:GSToGC.UserBeInvitedToBattle.Invitor)
  return _s;
}
inline const std::string& UserBeInvitedToBattle::_internal_invitor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.invitor_.Get();
}
inline void UserBeInvitedToBattle::_internal_set_invitor(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.invitor_.Set(value, GetArena());
}
inline std::string* UserBeInvitedToBattle::_internal_mutable_invitor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.invitor_.Mutable( GetArena());
}
inline std::string* UserBeInvitedToBattle::release_invitor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UserBeInvitedToBattle.Invitor)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.invitor_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.invitor_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserBeInvitedToBattle::set_allocated_invitor(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.invitor_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.invitor_.IsDefault()) {
          _impl_.invitor_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UserBeInvitedToBattle.Invitor)
}

// -------------------------------------------------------------------

// NotifyAFPData_FPInfo

// optional int32 type = 1;
inline bool NotifyAFPData_FPInfo::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyAFPData_FPInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t NotifyAFPData_FPInfo::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAFPData.FPInfo.type)
  return _internal_type();
}
inline void NotifyAFPData_FPInfo::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAFPData.FPInfo.type)
}
inline ::int32_t NotifyAFPData_FPInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void NotifyAFPData_FPInfo::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional int32 value = 2;
inline bool NotifyAFPData_FPInfo::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyAFPData_FPInfo::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyAFPData_FPInfo::value() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAFPData.FPInfo.value)
  return _internal_value();
}
inline void NotifyAFPData_FPInfo::set_value(::int32_t value) {
  _internal_set_value(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAFPData.FPInfo.value)
}
inline ::int32_t NotifyAFPData_FPInfo::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void NotifyAFPData_FPInfo::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// NotifyAFPData

// optional .GSToGC.MsgID msgnum = 1 [default = eMsgToGCFromGS_NotifyAFPData];
inline bool NotifyAFPData::has_msgnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyAFPData::clear_msgnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgnum_ = 85;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyAFPData::msgnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAFPData.msgnum)
  return _internal_msgnum();
}
inline void NotifyAFPData::set_msgnum(::GSToGC::MsgID value) {
  _internal_set_msgnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAFPData.msgnum)
}
inline ::GSToGC::MsgID NotifyAFPData::_internal_msgnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgnum_);
}
inline void NotifyAFPData::_internal_set_msgnum(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgnum_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyAFPData::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyAFPData::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyAFPData::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAFPData.guid)
  return _internal_guid();
}
inline void NotifyAFPData::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAFPData.guid)
}
inline ::uint64_t NotifyAFPData::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyAFPData::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// repeated .GSToGC.NotifyAFPData.FPInfo info = 3;
inline int NotifyAFPData::_internal_info_size() const {
  return _internal_info().size();
}
inline int NotifyAFPData::info_size() const {
  return _internal_info_size();
}
inline void NotifyAFPData::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::NotifyAFPData_FPInfo* NotifyAFPData::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyAFPData.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>* NotifyAFPData::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyAFPData.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::NotifyAFPData_FPInfo& NotifyAFPData::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAFPData.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::NotifyAFPData_FPInfo* NotifyAFPData::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyAFPData_FPInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyAFPData.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>& NotifyAFPData::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyAFPData.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>&
NotifyAFPData::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyAFPData_FPInfo>*
NotifyAFPData::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// UserBaseInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserBaseInfo];
inline bool UserBaseInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void UserBaseInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 2;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::GSToGC::MsgID UserBaseInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.msgid)
  return _internal_msgid();
}
inline void UserBaseInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.msgid)
}
inline ::GSToGC::MsgID UserBaseInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void UserBaseInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool UserBaseInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserBaseInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t UserBaseInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.guid)
  return _internal_guid();
}
inline void UserBaseInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.guid)
}
inline ::uint64_t UserBaseInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void UserBaseInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional string name = 3;
inline bool UserBaseInfo::has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserBaseInfo::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserBaseInfo::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserBaseInfo::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.name)
}
inline std::string* UserBaseInfo::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GSToGC.UserBaseInfo.name)
  return _s;
}
inline const std::string& UserBaseInfo::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void UserBaseInfo::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* UserBaseInfo::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* UserBaseInfo::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UserBaseInfo.name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserBaseInfo::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UserBaseInfo.name)
}

// optional string nickname = 4;
inline bool UserBaseInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserBaseInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserBaseInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserBaseInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.nickname)
}
inline std::string* UserBaseInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.UserBaseInfo.nickname)
  return _s;
}
inline const std::string& UserBaseInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void UserBaseInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* UserBaseInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* UserBaseInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UserBaseInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserBaseInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UserBaseInfo.nickname)
}

// optional int32 headid = 5;
inline bool UserBaseInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserBaseInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t UserBaseInfo::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.headid)
  return _internal_headid();
}
inline void UserBaseInfo::set_headid(::int32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.headid)
}
inline ::int32_t UserBaseInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void UserBaseInfo::_internal_set_headid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional int32 sex = 6;
inline bool UserBaseInfo::has_sex() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserBaseInfo::clear_sex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sex_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t UserBaseInfo::sex() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.sex)
  return _internal_sex();
}
inline void UserBaseInfo::set_sex(::int32_t value) {
  _internal_set_sex(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.sex)
}
inline ::int32_t UserBaseInfo::_internal_sex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sex_;
}
inline void UserBaseInfo::_internal_set_sex(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sex_ = value;
}

// optional int64 curscore = 7;
inline bool UserBaseInfo::has_curscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserBaseInfo::clear_curscore() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curscore_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t UserBaseInfo::curscore() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.curscore)
  return _internal_curscore();
}
inline void UserBaseInfo::set_curscore(::int64_t value) {
  _internal_set_curscore(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.curscore)
}
inline ::int64_t UserBaseInfo::_internal_curscore() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curscore_;
}
inline void UserBaseInfo::_internal_set_curscore(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curscore_ = value;
}

// optional int64 curdiamoand = 8;
inline bool UserBaseInfo::has_curdiamoand() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UserBaseInfo::clear_curdiamoand() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curdiamoand_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int64_t UserBaseInfo::curdiamoand() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.curdiamoand)
  return _internal_curdiamoand();
}
inline void UserBaseInfo::set_curdiamoand(::int64_t value) {
  _internal_set_curdiamoand(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.curdiamoand)
}
inline ::int64_t UserBaseInfo::_internal_curdiamoand() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curdiamoand_;
}
inline void UserBaseInfo::_internal_set_curdiamoand(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curdiamoand_ = value;
}

// optional int64 curgold = 9;
inline bool UserBaseInfo::has_curgold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void UserBaseInfo::clear_curgold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curgold_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t UserBaseInfo::curgold() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.curgold)
  return _internal_curgold();
}
inline void UserBaseInfo::set_curgold(::int64_t value) {
  _internal_set_curgold(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.curgold)
}
inline ::int64_t UserBaseInfo::_internal_curgold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curgold_;
}
inline void UserBaseInfo::_internal_set_curgold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curgold_ = value;
}

// optional int32 mapid = 11;
inline bool UserBaseInfo::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void UserBaseInfo::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t UserBaseInfo::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.mapid)
  return _internal_mapid();
}
inline void UserBaseInfo::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.mapid)
}
inline ::int32_t UserBaseInfo::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void UserBaseInfo::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional bool ifreconnect = 12;
inline bool UserBaseInfo::has_ifreconnect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void UserBaseInfo::clear_ifreconnect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifreconnect_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool UserBaseInfo::ifreconnect() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.ifreconnect)
  return _internal_ifreconnect();
}
inline void UserBaseInfo::set_ifreconnect(bool value) {
  _internal_set_ifreconnect(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.ifreconnect)
}
inline bool UserBaseInfo::_internal_ifreconnect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifreconnect_;
}
inline void UserBaseInfo::_internal_set_ifreconnect(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifreconnect_ = value;
}

// optional uint64 battleid = 13;
inline bool UserBaseInfo::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void UserBaseInfo::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::uint64_t UserBaseInfo::battleid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.battleid)
  return _internal_battleid();
}
inline void UserBaseInfo::set_battleid(::uint64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.battleid)
}
inline ::uint64_t UserBaseInfo::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void UserBaseInfo::_internal_set_battleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional int32 level = 14;
inline bool UserBaseInfo::has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void UserBaseInfo::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t UserBaseInfo::level() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.level)
  return _internal_level();
}
inline void UserBaseInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.level)
}
inline ::int32_t UserBaseInfo::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void UserBaseInfo::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = value;
}

// optional int32 vip_level = 15;
inline bool UserBaseInfo::has_vip_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void UserBaseInfo::clear_vip_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vip_level_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t UserBaseInfo::vip_level() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.vip_level)
  return _internal_vip_level();
}
inline void UserBaseInfo::set_vip_level(::int32_t value) {
  _internal_set_vip_level(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.vip_level)
}
inline ::int32_t UserBaseInfo::_internal_vip_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vip_level_;
}
inline void UserBaseInfo::_internal_set_vip_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vip_level_ = value;
}

// optional int32 vip_score = 16;
inline bool UserBaseInfo::has_vip_score() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void UserBaseInfo::clear_vip_score() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vip_score_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t UserBaseInfo::vip_score() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.vip_score)
  return _internal_vip_score();
}
inline void UserBaseInfo::set_vip_score(::int32_t value) {
  _internal_set_vip_score(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.vip_score)
}
inline ::int32_t UserBaseInfo::_internal_vip_score() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vip_score_;
}
inline void UserBaseInfo::_internal_set_vip_score(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vip_score_ = value;
}

// optional int32 cur_exp = 17;
inline bool UserBaseInfo::has_cur_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void UserBaseInfo::clear_cur_exp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cur_exp_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t UserBaseInfo::cur_exp() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserBaseInfo.cur_exp)
  return _internal_cur_exp();
}
inline void UserBaseInfo::set_cur_exp(::int32_t value) {
  _internal_set_cur_exp(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserBaseInfo.cur_exp)
}
inline ::int32_t UserBaseInfo::_internal_cur_exp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cur_exp_;
}
inline void UserBaseInfo::_internal_set_cur_exp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cur_exp_ = value;
}

// -------------------------------------------------------------------

// NotifySystemAnnounce

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySystemAnnounce];
inline bool NotifySystemAnnounce::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySystemAnnounce::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 3;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifySystemAnnounce::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySystemAnnounce.msgid)
  return _internal_msgid();
}
inline void NotifySystemAnnounce::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySystemAnnounce.msgid)
}
inline ::GSToGC::MsgID NotifySystemAnnounce::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySystemAnnounce::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 type = 2;
inline bool NotifySystemAnnounce::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySystemAnnounce::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifySystemAnnounce::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySystemAnnounce.type)
  return _internal_type();
}
inline void NotifySystemAnnounce::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySystemAnnounce.type)
}
inline ::int32_t NotifySystemAnnounce::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void NotifySystemAnnounce::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional string announce = 3;
inline bool NotifySystemAnnounce::has_announce() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifySystemAnnounce::clear_announce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.announce_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifySystemAnnounce::announce() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySystemAnnounce.announce)
  return _internal_announce();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifySystemAnnounce::set_announce(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.announce_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifySystemAnnounce.announce)
}
inline std::string* NotifySystemAnnounce::mutable_announce() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_announce();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySystemAnnounce.announce)
  return _s;
}
inline const std::string& NotifySystemAnnounce::_internal_announce() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.announce_.Get();
}
inline void NotifySystemAnnounce::_internal_set_announce(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.announce_.Set(value, GetArena());
}
inline std::string* NotifySystemAnnounce::_internal_mutable_announce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.announce_.Mutable( GetArena());
}
inline std::string* NotifySystemAnnounce::release_announce() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySystemAnnounce.announce)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.announce_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.announce_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifySystemAnnounce::set_allocated_announce(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.announce_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.announce_.IsDefault()) {
          _impl_.announce_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySystemAnnounce.announce)
}

// -------------------------------------------------------------------

// NetClash

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyNetClash];
inline bool NetClash::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NetClash::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 4;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NetClash::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NetClash.msgid)
  return _internal_msgid();
}
inline void NetClash::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NetClash.msgid)
}
inline ::GSToGC::MsgID NetClash::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NetClash::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// WarningToSelectHero

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_WarningToSelectHero];
inline bool WarningToSelectHero::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void WarningToSelectHero::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 66;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID WarningToSelectHero::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.WarningToSelectHero.msgid)
  return _internal_msgid();
}
inline void WarningToSelectHero::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.WarningToSelectHero.msgid)
}
inline ::GSToGC::MsgID WarningToSelectHero::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void WarningToSelectHero::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// NotifySkillModelLeading

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelLeading];
inline bool NotifySkillModelLeading::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifySkillModelLeading::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 74;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID NotifySkillModelLeading::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelLeading.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelLeading::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelLeading.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelLeading::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelLeading::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillModelLeading::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifySkillModelLeading::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifySkillModelLeading::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelLeading.guid)
  return _internal_guid();
}
inline void NotifySkillModelLeading::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelLeading.guid)
}
inline ::uint64_t NotifySkillModelLeading::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillModelLeading::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 effectid = 3;
inline bool NotifySkillModelLeading::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySkillModelLeading::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifySkillModelLeading::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelLeading.effectid)
  return _internal_effectid();
}
inline void NotifySkillModelLeading::set_effectid(::uint32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelLeading.effectid)
}
inline ::uint32_t NotifySkillModelLeading::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void NotifySkillModelLeading::_internal_set_effectid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional int32 uniqueid = 4;
inline bool NotifySkillModelLeading::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySkillModelLeading::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifySkillModelLeading::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelLeading.uniqueid)
  return _internal_uniqueid();
}
inline void NotifySkillModelLeading::set_uniqueid(::int32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelLeading.uniqueid)
}
inline ::int32_t NotifySkillModelLeading::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void NotifySkillModelLeading::_internal_set_uniqueid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// optional uint64 targuid = 5;
inline bool NotifySkillModelLeading::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillModelLeading::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t NotifySkillModelLeading::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelLeading.targuid)
  return _internal_targuid();
}
inline void NotifySkillModelLeading::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelLeading.targuid)
}
inline ::uint64_t NotifySkillModelLeading::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void NotifySkillModelLeading::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional int32 state = 6;
inline bool NotifySkillModelLeading::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifySkillModelLeading::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NotifySkillModelLeading::state() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelLeading.state)
  return _internal_state();
}
inline void NotifySkillModelLeading::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelLeading.state)
}
inline ::int32_t NotifySkillModelLeading::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void NotifySkillModelLeading::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// AskRet

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_GCAskRet];
inline bool AskRet::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskRet::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 5;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID AskRet::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AskRet.msgid)
  return _internal_msgid();
}
inline void AskRet::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.AskRet.msgid)
}
inline ::GSToGC::MsgID AskRet::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void AskRet::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 askid = 2;
inline bool AskRet::has_askid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRet::clear_askid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.askid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskRet::askid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AskRet.askid)
  return _internal_askid();
}
inline void AskRet::set_askid(::int32_t value) {
  _internal_set_askid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.AskRet.askid)
}
inline ::int32_t AskRet::_internal_askid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.askid_;
}
inline void AskRet::_internal_set_askid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.askid_ = value;
}

// optional int32 errorcode = 3;
inline bool AskRet::has_errorcode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskRet::clear_errorcode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskRet::errorcode() const {
  // @@protoc_insertion_point(field_get:GSToGC.AskRet.errorcode)
  return _internal_errorcode();
}
inline void AskRet::set_errorcode(::int32_t value) {
  _internal_set_errorcode(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.AskRet.errorcode)
}
inline ::int32_t AskRet::_internal_errorcode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.errorcode_;
}
inline void AskRet::_internal_set_errorcode(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.errorcode_ = value;
}

// -------------------------------------------------------------------

// NotifyCSHeroList_HeroListCfg

// optional uint32 heroid = 1;
inline bool NotifyCSHeroList_HeroListCfg::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyCSHeroList_HeroListCfg::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyCSHeroList_HeroListCfg::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCSHeroList.HeroListCfg.heroid)
  return _internal_heroid();
}
inline void NotifyCSHeroList_HeroListCfg::set_heroid(::uint32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCSHeroList.HeroListCfg.heroid)
}
inline ::uint32_t NotifyCSHeroList_HeroListCfg::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void NotifyCSHeroList_HeroListCfg::_internal_set_heroid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// optional int64 expired_time = 2;
inline bool NotifyCSHeroList_HeroListCfg::has_expired_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyCSHeroList_HeroListCfg::clear_expired_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expired_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t NotifyCSHeroList_HeroListCfg::expired_time() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCSHeroList.HeroListCfg.expired_time)
  return _internal_expired_time();
}
inline void NotifyCSHeroList_HeroListCfg::set_expired_time(::int64_t value) {
  _internal_set_expired_time(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCSHeroList.HeroListCfg.expired_time)
}
inline ::int64_t NotifyCSHeroList_HeroListCfg::_internal_expired_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expired_time_;
}
inline void NotifyCSHeroList_HeroListCfg::_internal_set_expired_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expired_time_ = value;
}

// optional bool if_free = 3;
inline bool NotifyCSHeroList_HeroListCfg::has_if_free() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyCSHeroList_HeroListCfg::clear_if_free() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.if_free_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool NotifyCSHeroList_HeroListCfg::if_free() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCSHeroList.HeroListCfg.if_free)
  return _internal_if_free();
}
inline void NotifyCSHeroList_HeroListCfg::set_if_free(bool value) {
  _internal_set_if_free(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCSHeroList.HeroListCfg.if_free)
}
inline bool NotifyCSHeroList_HeroListCfg::_internal_if_free() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.if_free_;
}
inline void NotifyCSHeroList_HeroListCfg::_internal_set_if_free(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.if_free_ = value;
}

// -------------------------------------------------------------------

// NotifyCSHeroList

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCSHeroList];
inline bool NotifyCSHeroList::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyCSHeroList::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 221;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyCSHeroList::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCSHeroList.msgid)
  return _internal_msgid();
}
inline void NotifyCSHeroList::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCSHeroList.msgid)
}
inline ::GSToGC::MsgID NotifyCSHeroList::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyCSHeroList::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.NotifyCSHeroList.HeroListCfg herocfg = 2;
inline int NotifyCSHeroList::_internal_herocfg_size() const {
  return _internal_herocfg().size();
}
inline int NotifyCSHeroList::herocfg_size() const {
  return _internal_herocfg_size();
}
inline void NotifyCSHeroList::clear_herocfg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herocfg_.Clear();
}
inline ::GSToGC::NotifyCSHeroList_HeroListCfg* NotifyCSHeroList::mutable_herocfg(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyCSHeroList.herocfg)
  return _internal_mutable_herocfg()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>* NotifyCSHeroList::mutable_herocfg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyCSHeroList.herocfg)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_herocfg();
}
inline const ::GSToGC::NotifyCSHeroList_HeroListCfg& NotifyCSHeroList::herocfg(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCSHeroList.herocfg)
  return _internal_herocfg().Get(index);
}
inline ::GSToGC::NotifyCSHeroList_HeroListCfg* NotifyCSHeroList::add_herocfg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyCSHeroList_HeroListCfg* _add = _internal_mutable_herocfg()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyCSHeroList.herocfg)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>& NotifyCSHeroList::herocfg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyCSHeroList.herocfg)
  return _internal_herocfg();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>&
NotifyCSHeroList::_internal_herocfg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herocfg_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyCSHeroList_HeroListCfg>*
NotifyCSHeroList::_internal_mutable_herocfg() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.herocfg_;
}

// -------------------------------------------------------------------

// HeroList

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroList];
inline bool HeroList::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HeroList::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 7;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID HeroList::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroList.msgid)
  return _internal_msgid();
}
inline void HeroList::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroList.msgid)
}
inline ::GSToGC::MsgID HeroList::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HeroList::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated uint32 heroid = 2;
inline int HeroList::_internal_heroid_size() const {
  return _internal_heroid().size();
}
inline int HeroList::heroid_size() const {
  return _internal_heroid_size();
}
inline void HeroList::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_.Clear();
}
inline ::uint32_t HeroList::heroid(int index) const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroList.heroid)
  return _internal_heroid().Get(index);
}
inline void HeroList::set_heroid(int index, ::uint32_t value) {
  _internal_mutable_heroid()->Set(index, value);
  // @@protoc_insertion_point(field_set:GSToGC.HeroList.heroid)
}
inline void HeroList::add_heroid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_heroid()->Add(value);
  // @@protoc_insertion_point(field_add:GSToGC.HeroList.heroid)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& HeroList::heroid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.HeroList.heroid)
  return _internal_heroid();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* HeroList::mutable_heroid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.HeroList.heroid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_heroid();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& HeroList::_internal_heroid()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* HeroList::_internal_mutable_heroid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.heroid_;
}

// optional int64 timeDiff = 3;
inline bool HeroList::has_timediff() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HeroList::clear_timediff() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timediff_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t HeroList::timediff() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroList.timeDiff)
  return _internal_timediff();
}
inline void HeroList::set_timediff(::int64_t value) {
  _internal_set_timediff(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroList.timeDiff)
}
inline ::int64_t HeroList::_internal_timediff() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timediff_;
}
inline void HeroList::_internal_set_timediff(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timediff_ = value;
}

// -------------------------------------------------------------------

// BattleBaseInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleBaseInfo];
inline bool BattleBaseInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BattleBaseInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 8;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID BattleBaseInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleBaseInfo.msgid)
  return _internal_msgid();
}
inline void BattleBaseInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleBaseInfo.msgid)
}
inline ::GSToGC::MsgID BattleBaseInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleBaseInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 battleid = 2;
inline bool BattleBaseInfo::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleBaseInfo::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t BattleBaseInfo::battleid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleBaseInfo.battleid)
  return _internal_battleid();
}
inline void BattleBaseInfo::set_battleid(::uint64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleBaseInfo.battleid)
}
inline ::uint64_t BattleBaseInfo::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void BattleBaseInfo::_internal_set_battleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional uint32 mapid = 3;
inline bool BattleBaseInfo::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleBaseInfo::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t BattleBaseInfo::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleBaseInfo.mapid)
  return _internal_mapid();
}
inline void BattleBaseInfo::set_mapid(::uint32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleBaseInfo.mapid)
}
inline ::uint32_t BattleBaseInfo::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void BattleBaseInfo::_internal_set_mapid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional bool ifReconnect = 4;
inline bool BattleBaseInfo::has_ifreconnect() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BattleBaseInfo::clear_ifreconnect() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifreconnect_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool BattleBaseInfo::ifreconnect() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleBaseInfo.ifReconnect)
  return _internal_ifreconnect();
}
inline void BattleBaseInfo::set_ifreconnect(bool value) {
  _internal_set_ifreconnect(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleBaseInfo.ifReconnect)
}
inline bool BattleBaseInfo::_internal_ifreconnect() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifreconnect_;
}
inline void BattleBaseInfo::_internal_set_ifreconnect(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifreconnect_ = value;
}

// -------------------------------------------------------------------

// RoomBaseInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyRoomBaseInfo];
inline bool RoomBaseInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RoomBaseInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 140;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID RoomBaseInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomBaseInfo.msgid)
  return _internal_msgid();
}
inline void RoomBaseInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomBaseInfo.msgid)
}
inline ::GSToGC::MsgID RoomBaseInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void RoomBaseInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 roomid = 2;
inline bool RoomBaseInfo::has_roomid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RoomBaseInfo::clear_roomid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roomid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t RoomBaseInfo::roomid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomBaseInfo.roomid)
  return _internal_roomid();
}
inline void RoomBaseInfo::set_roomid(::uint64_t value) {
  _internal_set_roomid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomBaseInfo.roomid)
}
inline ::uint64_t RoomBaseInfo::_internal_roomid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roomid_;
}
inline void RoomBaseInfo::_internal_set_roomid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roomid_ = value;
}

// optional uint32 mapid = 3;
inline bool RoomBaseInfo::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RoomBaseInfo::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t RoomBaseInfo::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomBaseInfo.mapid)
  return _internal_mapid();
}
inline void RoomBaseInfo::set_mapid(::uint32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomBaseInfo.mapid)
}
inline ::uint32_t RoomBaseInfo::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void RoomBaseInfo::_internal_set_mapid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// -------------------------------------------------------------------

// BattleSeatPosInfo_PosInfo

// optional int32 pos = 1;
inline bool BattleSeatPosInfo_PosInfo::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BattleSeatPosInfo_PosInfo::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BattleSeatPosInfo_PosInfo::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.PosInfo.pos)
  return _internal_pos();
}
inline void BattleSeatPosInfo_PosInfo::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.PosInfo.pos)
}
inline ::int32_t BattleSeatPosInfo_PosInfo::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void BattleSeatPosInfo_PosInfo::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// optional uint64 guid = 2;
inline bool BattleSeatPosInfo_PosInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleSeatPosInfo_PosInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BattleSeatPosInfo_PosInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.PosInfo.guid)
  return _internal_guid();
}
inline void BattleSeatPosInfo_PosInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.PosInfo.guid)
}
inline ::uint64_t BattleSeatPosInfo_PosInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void BattleSeatPosInfo_PosInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional string nickname = 3;
inline bool BattleSeatPosInfo_PosInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleSeatPosInfo_PosInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BattleSeatPosInfo_PosInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.PosInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BattleSeatPosInfo_PosInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.PosInfo.nickname)
}
inline std::string* BattleSeatPosInfo_PosInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.BattleSeatPosInfo.PosInfo.nickname)
  return _s;
}
inline const std::string& BattleSeatPosInfo_PosInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void BattleSeatPosInfo_PosInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* BattleSeatPosInfo_PosInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* BattleSeatPosInfo_PosInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.BattleSeatPosInfo.PosInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BattleSeatPosInfo_PosInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.BattleSeatPosInfo.PosInfo.nickname)
}

// optional bool ifmaster = 4;
inline bool BattleSeatPosInfo_PosInfo::has_ifmaster() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BattleSeatPosInfo_PosInfo::clear_ifmaster() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifmaster_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool BattleSeatPosInfo_PosInfo::ifmaster() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.PosInfo.ifmaster)
  return _internal_ifmaster();
}
inline void BattleSeatPosInfo_PosInfo::set_ifmaster(bool value) {
  _internal_set_ifmaster(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.PosInfo.ifmaster)
}
inline bool BattleSeatPosInfo_PosInfo::_internal_ifmaster() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifmaster_;
}
inline void BattleSeatPosInfo_PosInfo::_internal_set_ifmaster(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifmaster_ = value;
}

// optional bool ifready = 5;
inline bool BattleSeatPosInfo_PosInfo::has_ifready() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BattleSeatPosInfo_PosInfo::clear_ifready() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifready_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool BattleSeatPosInfo_PosInfo::ifready() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.PosInfo.ifready)
  return _internal_ifready();
}
inline void BattleSeatPosInfo_PosInfo::set_ifready(bool value) {
  _internal_set_ifready(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.PosInfo.ifready)
}
inline bool BattleSeatPosInfo_PosInfo::_internal_ifready() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifready_;
}
inline void BattleSeatPosInfo_PosInfo::_internal_set_ifready(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifready_ = value;
}

// optional int32 headid = 6;
inline bool BattleSeatPosInfo_PosInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BattleSeatPosInfo_PosInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t BattleSeatPosInfo_PosInfo::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.PosInfo.headid)
  return _internal_headid();
}
inline void BattleSeatPosInfo_PosInfo::set_headid(::int32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.PosInfo.headid)
}
inline ::int32_t BattleSeatPosInfo_PosInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void BattleSeatPosInfo_PosInfo::_internal_set_headid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional int64 gold = 7;
inline bool BattleSeatPosInfo_PosInfo::has_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BattleSeatPosInfo_PosInfo::clear_gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t BattleSeatPosInfo_PosInfo::gold() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.PosInfo.gold)
  return _internal_gold();
}
inline void BattleSeatPosInfo_PosInfo::set_gold(::int64_t value) {
  _internal_set_gold(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.PosInfo.gold)
}
inline ::int64_t BattleSeatPosInfo_PosInfo::_internal_gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gold_;
}
inline void BattleSeatPosInfo_PosInfo::_internal_set_gold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = value;
}

// -------------------------------------------------------------------

// BattleSeatPosInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleSeatPosInfo];
inline bool BattleSeatPosInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleSeatPosInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 9;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID BattleSeatPosInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.msgid)
  return _internal_msgid();
}
inline void BattleSeatPosInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleSeatPosInfo.msgid)
}
inline ::GSToGC::MsgID BattleSeatPosInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleSeatPosInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.BattleSeatPosInfo.PosInfo posinfo = 2;
inline int BattleSeatPosInfo::_internal_posinfo_size() const {
  return _internal_posinfo().size();
}
inline int BattleSeatPosInfo::posinfo_size() const {
  return _internal_posinfo_size();
}
inline void BattleSeatPosInfo::clear_posinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.posinfo_.Clear();
}
inline ::GSToGC::BattleSeatPosInfo_PosInfo* BattleSeatPosInfo::mutable_posinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.BattleSeatPosInfo.posinfo)
  return _internal_mutable_posinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>* BattleSeatPosInfo::mutable_posinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.BattleSeatPosInfo.posinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_posinfo();
}
inline const ::GSToGC::BattleSeatPosInfo_PosInfo& BattleSeatPosInfo::posinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BattleSeatPosInfo.posinfo)
  return _internal_posinfo().Get(index);
}
inline ::GSToGC::BattleSeatPosInfo_PosInfo* BattleSeatPosInfo::add_posinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::BattleSeatPosInfo_PosInfo* _add = _internal_mutable_posinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.BattleSeatPosInfo.posinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>& BattleSeatPosInfo::posinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.BattleSeatPosInfo.posinfo)
  return _internal_posinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>&
BattleSeatPosInfo::_internal_posinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.posinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BattleSeatPosInfo_PosInfo>*
BattleSeatPosInfo::_internal_mutable_posinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.posinfo_;
}

// -------------------------------------------------------------------

// BattleStateChange

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleStateChange];
inline bool BattleStateChange::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BattleStateChange::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 10;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID BattleStateChange::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleStateChange.msgid)
  return _internal_msgid();
}
inline void BattleStateChange::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleStateChange.msgid)
}
inline ::GSToGC::MsgID BattleStateChange::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleStateChange::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 state = 2;
inline bool BattleStateChange::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleStateChange::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t BattleStateChange::state() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleStateChange.state)
  return _internal_state();
}
inline void BattleStateChange::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleStateChange.state)
}
inline ::int32_t BattleStateChange::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void BattleStateChange::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// optional int32 statetimeleft = 3;
inline bool BattleStateChange::has_statetimeleft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleStateChange::clear_statetimeleft() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statetimeleft_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BattleStateChange::statetimeleft() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleStateChange.statetimeleft)
  return _internal_statetimeleft();
}
inline void BattleStateChange::set_statetimeleft(::int32_t value) {
  _internal_set_statetimeleft(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleStateChange.statetimeleft)
}
inline ::int32_t BattleStateChange::_internal_statetimeleft() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.statetimeleft_;
}
inline void BattleStateChange::_internal_set_statetimeleft(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statetimeleft_ = value;
}

// -------------------------------------------------------------------

// CurBattleChange

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurBattleChange];
inline bool CurBattleChange::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CurBattleChange::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 11;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID CurBattleChange::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurBattleChange.msgid)
  return _internal_msgid();
}
inline void CurBattleChange::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.CurBattleChange.msgid)
}
inline ::GSToGC::MsgID CurBattleChange::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void CurBattleChange::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 ssid = 2;
inline bool CurBattleChange::has_ssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CurBattleChange::clear_ssid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CurBattleChange::ssid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurBattleChange.ssid)
  return _internal_ssid();
}
inline void CurBattleChange::set_ssid(::int32_t value) {
  _internal_set_ssid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.CurBattleChange.ssid)
}
inline ::int32_t CurBattleChange::_internal_ssid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssid_;
}
inline void CurBattleChange::_internal_set_ssid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssid_ = value;
}

// optional uint64 battleid = 3;
inline bool CurBattleChange::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CurBattleChange::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CurBattleChange::battleid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurBattleChange.battleid)
  return _internal_battleid();
}
inline void CurBattleChange::set_battleid(::uint64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.CurBattleChange.battleid)
}
inline ::uint64_t CurBattleChange::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void CurBattleChange::_internal_set_battleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional int32 mapid = 4;
inline bool CurBattleChange::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CurBattleChange::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CurBattleChange::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurBattleChange.mapid)
  return _internal_mapid();
}
inline void CurBattleChange::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.CurBattleChange.mapid)
}
inline ::int32_t CurBattleChange::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void CurBattleChange::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// -------------------------------------------------------------------

// Pos

// optional int32 x = 1;
inline bool Pos::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Pos::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Pos::x() const {
  // @@protoc_insertion_point(field_get:GSToGC.Pos.x)
  return _internal_x();
}
inline void Pos::set_x(::int32_t value) {
  _internal_set_x(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.Pos.x)
}
inline ::int32_t Pos::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Pos::_internal_set_x(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = value;
}

// optional int32 z = 3;
inline bool Pos::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Pos::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Pos::z() const {
  // @@protoc_insertion_point(field_get:GSToGC.Pos.z)
  return _internal_z();
}
inline void Pos::set_z(::int32_t value) {
  _internal_set_z(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.Pos.z)
}
inline ::int32_t Pos::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Pos::_internal_set_z(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Dir

// optional int32 angle = 4;
inline bool Dir::has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Dir::clear_angle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t Dir::angle() const {
  // @@protoc_insertion_point(field_get:GSToGC.Dir.angle)
  return _internal_angle();
}
inline void Dir::set_angle(::int32_t value) {
  _internal_set_angle(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.Dir.angle)
}
inline ::int32_t Dir::_internal_angle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.angle_;
}
inline void Dir::_internal_set_angle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.angle_ = value;
}

// -------------------------------------------------------------------

// GOAppear_AppearInfo

// optional uint64 masterguid = 1;
inline bool GOAppear_AppearInfo::has_masterguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GOAppear_AppearInfo::clear_masterguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.masterguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t GOAppear_AppearInfo::masterguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.masterguid)
  return _internal_masterguid();
}
inline void GOAppear_AppearInfo::set_masterguid(::uint64_t value) {
  _internal_set_masterguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.AppearInfo.masterguid)
}
inline ::uint64_t GOAppear_AppearInfo::_internal_masterguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.masterguid_;
}
inline void GOAppear_AppearInfo::_internal_set_masterguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.masterguid_ = value;
}

// optional uint64 objguid = 2;
inline bool GOAppear_AppearInfo::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GOAppear_AppearInfo::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t GOAppear_AppearInfo::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.objguid)
  return _internal_objguid();
}
inline void GOAppear_AppearInfo::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.AppearInfo.objguid)
}
inline ::uint64_t GOAppear_AppearInfo::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void GOAppear_AppearInfo::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional int32 camp = 3;
inline bool GOAppear_AppearInfo::has_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GOAppear_AppearInfo::clear_camp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t GOAppear_AppearInfo::camp() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.camp)
  return _internal_camp();
}
inline void GOAppear_AppearInfo::set_camp(::int32_t value) {
  _internal_set_camp(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.AppearInfo.camp)
}
inline ::int32_t GOAppear_AppearInfo::_internal_camp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camp_;
}
inline void GOAppear_AppearInfo::_internal_set_camp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = value;
}

// optional .GSToGC.Pos pos = 4;
inline bool GOAppear_AppearInfo::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void GOAppear_AppearInfo::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& GOAppear_AppearInfo::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& GOAppear_AppearInfo::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.pos)
  return _internal_pos();
}
inline void GOAppear_AppearInfo::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.GOAppear.AppearInfo.pos)
}
inline ::GSToGC::Pos* GOAppear_AppearInfo::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* GOAppear_AppearInfo::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GOAppear.AppearInfo.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* GOAppear_AppearInfo::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* GOAppear_AppearInfo::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.GOAppear.AppearInfo.pos)
  return _msg;
}
inline void GOAppear_AppearInfo::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GOAppear.AppearInfo.pos)
}

// optional .GSToGC.Dir dir = 5;
inline bool GOAppear_AppearInfo::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void GOAppear_AppearInfo::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& GOAppear_AppearInfo::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& GOAppear_AppearInfo::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.dir)
  return _internal_dir();
}
inline void GOAppear_AppearInfo::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.GOAppear.AppearInfo.dir)
}
inline ::GSToGC::Dir* GOAppear_AppearInfo::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* GOAppear_AppearInfo::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GOAppear.AppearInfo.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* GOAppear_AppearInfo::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* GOAppear_AppearInfo::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.GOAppear.AppearInfo.dir)
  return _msg;
}
inline void GOAppear_AppearInfo::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GOAppear.AppearInfo.dir)
}

// optional uint32 hp = 6;
inline bool GOAppear_AppearInfo::has_hp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GOAppear_AppearInfo::clear_hp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t GOAppear_AppearInfo::hp() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.hp)
  return _internal_hp();
}
inline void GOAppear_AppearInfo::set_hp(::uint32_t value) {
  _internal_set_hp(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.AppearInfo.hp)
}
inline ::uint32_t GOAppear_AppearInfo::_internal_hp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hp_;
}
inline void GOAppear_AppearInfo::_internal_set_hp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = value;
}

// optional uint32 mp = 7;
inline bool GOAppear_AppearInfo::has_mp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GOAppear_AppearInfo::clear_mp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t GOAppear_AppearInfo::mp() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.mp)
  return _internal_mp();
}
inline void GOAppear_AppearInfo::set_mp(::uint32_t value) {
  _internal_set_mp(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.AppearInfo.mp)
}
inline ::uint32_t GOAppear_AppearInfo::_internal_mp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_;
}
inline void GOAppear_AppearInfo::_internal_set_mp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_ = value;
}

// optional .GSToGC.ObjType obj_type = 8;
inline bool GOAppear_AppearInfo::has_obj_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void GOAppear_AppearInfo::clear_obj_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obj_type_ = 1;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::GSToGC::ObjType GOAppear_AppearInfo::obj_type() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.obj_type)
  return _internal_obj_type();
}
inline void GOAppear_AppearInfo::set_obj_type(::GSToGC::ObjType value) {
  _internal_set_obj_type(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.AppearInfo.obj_type)
}
inline ::GSToGC::ObjType GOAppear_AppearInfo::_internal_obj_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::ObjType>(_impl_.obj_type_);
}
inline void GOAppear_AppearInfo::_internal_set_obj_type(::GSToGC::ObjType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::ObjType_IsValid(value));
  _impl_.obj_type_ = value;
}

// optional uint32 obj_type_id = 9;
inline bool GOAppear_AppearInfo::has_obj_type_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void GOAppear_AppearInfo::clear_obj_type_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obj_type_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t GOAppear_AppearInfo::obj_type_id() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.AppearInfo.obj_type_id)
  return _internal_obj_type_id();
}
inline void GOAppear_AppearInfo::set_obj_type_id(::uint32_t value) {
  _internal_set_obj_type_id(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.AppearInfo.obj_type_id)
}
inline ::uint32_t GOAppear_AppearInfo::_internal_obj_type_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.obj_type_id_;
}
inline void GOAppear_AppearInfo::_internal_set_obj_type_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obj_type_id_ = value;
}

// -------------------------------------------------------------------

// GOAppear

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectAppear];
inline bool GOAppear::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GOAppear::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 12;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID GOAppear::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.msgid)
  return _internal_msgid();
}
inline void GOAppear::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GOAppear.msgid)
}
inline ::GSToGC::MsgID GOAppear::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GOAppear::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.GOAppear.AppearInfo info = 2;
inline int GOAppear::_internal_info_size() const {
  return _internal_info().size();
}
inline int GOAppear::info_size() const {
  return _internal_info_size();
}
inline void GOAppear::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::GOAppear_AppearInfo* GOAppear::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.GOAppear.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>* GOAppear::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.GOAppear.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::GOAppear_AppearInfo& GOAppear::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GOAppear.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::GOAppear_AppearInfo* GOAppear::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::GOAppear_AppearInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.GOAppear.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>& GOAppear::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.GOAppear.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>&
GOAppear::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::GOAppear_AppearInfo>*
GOAppear::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// DisappearInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectDisappear];
inline bool DisappearInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DisappearInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 13;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID DisappearInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.DisappearInfo.msgid)
  return _internal_msgid();
}
inline void DisappearInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.DisappearInfo.msgid)
}
inline ::GSToGC::MsgID DisappearInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void DisappearInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated uint64 guid = 2;
inline int DisappearInfo::_internal_guid_size() const {
  return _internal_guid().size();
}
inline int DisappearInfo::guid_size() const {
  return _internal_guid_size();
}
inline void DisappearInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_.Clear();
}
inline ::uint64_t DisappearInfo::guid(int index) const {
  // @@protoc_insertion_point(field_get:GSToGC.DisappearInfo.guid)
  return _internal_guid().Get(index);
}
inline void DisappearInfo::set_guid(int index, ::uint64_t value) {
  _internal_mutable_guid()->Set(index, value);
  // @@protoc_insertion_point(field_set:GSToGC.DisappearInfo.guid)
}
inline void DisappearInfo::add_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_guid()->Add(value);
  // @@protoc_insertion_point(field_add:GSToGC.DisappearInfo.guid)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& DisappearInfo::guid() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.DisappearInfo.guid)
  return _internal_guid();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* DisappearInfo::mutable_guid()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.DisappearInfo.guid)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_guid();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& DisappearInfo::_internal_guid()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* DisappearInfo::_internal_mutable_guid() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.guid_;
}

// -------------------------------------------------------------------

// FreeState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectFreeState];
inline bool FreeState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FreeState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 14;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID FreeState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FreeState.msgid)
  return _internal_msgid();
}
inline void FreeState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.FreeState.msgid)
}
inline ::GSToGC::MsgID FreeState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void FreeState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool FreeState::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FreeState::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t FreeState::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FreeState.objguid)
  return _internal_objguid();
}
inline void FreeState::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.FreeState.objguid)
}
inline ::uint64_t FreeState::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void FreeState::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional .GSToGC.Pos pos = 3;
inline bool FreeState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void FreeState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& FreeState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& FreeState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.FreeState.pos)
  return _internal_pos();
}
inline void FreeState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.FreeState.pos)
}
inline ::GSToGC::Pos* FreeState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* FreeState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.FreeState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* FreeState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* FreeState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.FreeState.pos)
  return _msg;
}
inline void FreeState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.FreeState.pos)
}

// optional .GSToGC.Dir dir = 4;
inline bool FreeState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void FreeState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& FreeState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& FreeState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.FreeState.dir)
  return _internal_dir();
}
inline void FreeState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.FreeState.dir)
}
inline ::GSToGC::Dir* FreeState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* FreeState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.FreeState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* FreeState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* FreeState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.FreeState.dir)
  return _msg;
}
inline void FreeState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.FreeState.dir)
}

// -------------------------------------------------------------------

// RunningState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectRunState];
inline bool RunningState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RunningState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 15;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID RunningState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunningState.msgid)
  return _internal_msgid();
}
inline void RunningState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.RunningState.msgid)
}
inline ::GSToGC::MsgID RunningState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void RunningState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool RunningState::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RunningState::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RunningState::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunningState.objguid)
  return _internal_objguid();
}
inline void RunningState::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RunningState.objguid)
}
inline ::uint64_t RunningState::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void RunningState::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional .GSToGC.Pos pos = 3;
inline bool RunningState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void RunningState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& RunningState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& RunningState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.RunningState.pos)
  return _internal_pos();
}
inline void RunningState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.RunningState.pos)
}
inline ::GSToGC::Pos* RunningState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* RunningState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.RunningState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* RunningState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* RunningState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.RunningState.pos)
  return _msg;
}
inline void RunningState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.RunningState.pos)
}

// optional .GSToGC.Dir dir = 4;
inline bool RunningState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void RunningState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& RunningState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& RunningState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.RunningState.dir)
  return _internal_dir();
}
inline void RunningState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.RunningState.dir)
}
inline ::GSToGC::Dir* RunningState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* RunningState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.RunningState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* RunningState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* RunningState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.RunningState.dir)
  return _msg;
}
inline void RunningState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.RunningState.dir)
}

// optional int32 movespeed = 5;
inline bool RunningState::has_movespeed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RunningState::clear_movespeed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.movespeed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t RunningState::movespeed() const {
  // @@protoc_insertion_point(field_get:GSToGC.RunningState.movespeed)
  return _internal_movespeed();
}
inline void RunningState::set_movespeed(::int32_t value) {
  _internal_set_movespeed(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.RunningState.movespeed)
}
inline ::int32_t RunningState::_internal_movespeed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.movespeed_;
}
inline void RunningState::_internal_set_movespeed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.movespeed_ = value;
}

// -------------------------------------------------------------------

// PrepareSkillState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectPrepareSkillState];
inline bool PrepareSkillState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void PrepareSkillState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 16;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::GSToGC::MsgID PrepareSkillState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PrepareSkillState.msgid)
  return _internal_msgid();
}
inline void PrepareSkillState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.PrepareSkillState.msgid)
}
inline ::GSToGC::MsgID PrepareSkillState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void PrepareSkillState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool PrepareSkillState::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PrepareSkillState::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t PrepareSkillState::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PrepareSkillState.objguid)
  return _internal_objguid();
}
inline void PrepareSkillState::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.PrepareSkillState.objguid)
}
inline ::uint64_t PrepareSkillState::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void PrepareSkillState::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional int32 skillid = 3;
inline bool PrepareSkillState::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PrepareSkillState::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t PrepareSkillState::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PrepareSkillState.skillid)
  return _internal_skillid();
}
inline void PrepareSkillState::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.PrepareSkillState.skillid)
}
inline ::int32_t PrepareSkillState::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void PrepareSkillState::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional .GSToGC.Pos pos = 4;
inline bool PrepareSkillState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void PrepareSkillState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& PrepareSkillState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& PrepareSkillState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.PrepareSkillState.pos)
  return _internal_pos();
}
inline void PrepareSkillState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.PrepareSkillState.pos)
}
inline ::GSToGC::Pos* PrepareSkillState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* PrepareSkillState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.PrepareSkillState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* PrepareSkillState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* PrepareSkillState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.PrepareSkillState.pos)
  return _msg;
}
inline void PrepareSkillState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.PrepareSkillState.pos)
}

// optional .GSToGC.Dir dir = 5;
inline bool PrepareSkillState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void PrepareSkillState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& PrepareSkillState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& PrepareSkillState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.PrepareSkillState.dir)
  return _internal_dir();
}
inline void PrepareSkillState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.PrepareSkillState.dir)
}
inline ::GSToGC::Dir* PrepareSkillState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* PrepareSkillState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.PrepareSkillState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* PrepareSkillState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* PrepareSkillState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.PrepareSkillState.dir)
  return _msg;
}
inline void PrepareSkillState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.PrepareSkillState.dir)
}

// optional uint64 targuid = 6;
inline bool PrepareSkillState::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void PrepareSkillState::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t PrepareSkillState::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PrepareSkillState.targuid)
  return _internal_targuid();
}
inline void PrepareSkillState::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.PrepareSkillState.targuid)
}
inline ::uint64_t PrepareSkillState::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void PrepareSkillState::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional int32 speed = 7;
inline bool PrepareSkillState::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PrepareSkillState::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t PrepareSkillState::speed() const {
  // @@protoc_insertion_point(field_get:GSToGC.PrepareSkillState.speed)
  return _internal_speed();
}
inline void PrepareSkillState::set_speed(::int32_t value) {
  _internal_set_speed(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.PrepareSkillState.speed)
}
inline ::int32_t PrepareSkillState::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void PrepareSkillState::_internal_set_speed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// ReleasingSkillState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectReleaseSkillState];
inline bool ReleasingSkillState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void ReleasingSkillState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 17;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID ReleasingSkillState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.ReleasingSkillState.msgid)
  return _internal_msgid();
}
inline void ReleasingSkillState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.ReleasingSkillState.msgid)
}
inline ::GSToGC::MsgID ReleasingSkillState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void ReleasingSkillState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool ReleasingSkillState::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReleasingSkillState::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t ReleasingSkillState::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.ReleasingSkillState.objguid)
  return _internal_objguid();
}
inline void ReleasingSkillState::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.ReleasingSkillState.objguid)
}
inline ::uint64_t ReleasingSkillState::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void ReleasingSkillState::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional int32 skillid = 3;
inline bool ReleasingSkillState::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ReleasingSkillState::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t ReleasingSkillState::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.ReleasingSkillState.skillid)
  return _internal_skillid();
}
inline void ReleasingSkillState::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.ReleasingSkillState.skillid)
}
inline ::int32_t ReleasingSkillState::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void ReleasingSkillState::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional .GSToGC.Pos pos = 4;
inline bool ReleasingSkillState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void ReleasingSkillState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& ReleasingSkillState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& ReleasingSkillState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.ReleasingSkillState.pos)
  return _internal_pos();
}
inline void ReleasingSkillState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.ReleasingSkillState.pos)
}
inline ::GSToGC::Pos* ReleasingSkillState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* ReleasingSkillState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.ReleasingSkillState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* ReleasingSkillState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* ReleasingSkillState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.ReleasingSkillState.pos)
  return _msg;
}
inline void ReleasingSkillState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.ReleasingSkillState.pos)
}

// optional .GSToGC.Dir dir = 5;
inline bool ReleasingSkillState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void ReleasingSkillState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& ReleasingSkillState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& ReleasingSkillState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.ReleasingSkillState.dir)
  return _internal_dir();
}
inline void ReleasingSkillState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.ReleasingSkillState.dir)
}
inline ::GSToGC::Dir* ReleasingSkillState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* ReleasingSkillState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.ReleasingSkillState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* ReleasingSkillState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* ReleasingSkillState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.ReleasingSkillState.dir)
  return _msg;
}
inline void ReleasingSkillState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.ReleasingSkillState.dir)
}

// optional uint64 targuid = 6;
inline bool ReleasingSkillState::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ReleasingSkillState::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t ReleasingSkillState::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.ReleasingSkillState.targuid)
  return _internal_targuid();
}
inline void ReleasingSkillState::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.ReleasingSkillState.targuid)
}
inline ::uint64_t ReleasingSkillState::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void ReleasingSkillState::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// -------------------------------------------------------------------

// UsingSkillState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectUsingSkillState];
inline bool UsingSkillState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UsingSkillState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 240;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID UsingSkillState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UsingSkillState.msgid)
  return _internal_msgid();
}
inline void UsingSkillState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.UsingSkillState.msgid)
}
inline ::GSToGC::MsgID UsingSkillState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void UsingSkillState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool UsingSkillState::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UsingSkillState::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t UsingSkillState::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UsingSkillState.objguid)
  return _internal_objguid();
}
inline void UsingSkillState::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.UsingSkillState.objguid)
}
inline ::uint64_t UsingSkillState::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void UsingSkillState::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional int32 skillid = 3;
inline bool UsingSkillState::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UsingSkillState::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t UsingSkillState::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UsingSkillState.skillid)
  return _internal_skillid();
}
inline void UsingSkillState::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.UsingSkillState.skillid)
}
inline ::int32_t UsingSkillState::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void UsingSkillState::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional .GSToGC.Pos pos = 4;
inline bool UsingSkillState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void UsingSkillState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& UsingSkillState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& UsingSkillState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UsingSkillState.pos)
  return _internal_pos();
}
inline void UsingSkillState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.UsingSkillState.pos)
}
inline ::GSToGC::Pos* UsingSkillState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* UsingSkillState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UsingSkillState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* UsingSkillState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* UsingSkillState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.UsingSkillState.pos)
  return _msg;
}
inline void UsingSkillState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UsingSkillState.pos)
}

// optional .GSToGC.Dir dir = 5;
inline bool UsingSkillState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void UsingSkillState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& UsingSkillState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& UsingSkillState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UsingSkillState.dir)
  return _internal_dir();
}
inline void UsingSkillState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.UsingSkillState.dir)
}
inline ::GSToGC::Dir* UsingSkillState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* UsingSkillState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UsingSkillState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* UsingSkillState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* UsingSkillState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.UsingSkillState.dir)
  return _msg;
}
inline void UsingSkillState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UsingSkillState.dir)
}

// optional uint64 targuid = 6;
inline bool UsingSkillState::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UsingSkillState::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t UsingSkillState::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UsingSkillState.targuid)
  return _internal_targuid();
}
inline void UsingSkillState::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.UsingSkillState.targuid)
}
inline ::uint64_t UsingSkillState::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void UsingSkillState::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// -------------------------------------------------------------------

// LastingSkillState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectLastingSkillState];
inline bool LastingSkillState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void LastingSkillState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 241;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID LastingSkillState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LastingSkillState.msgid)
  return _internal_msgid();
}
inline void LastingSkillState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.LastingSkillState.msgid)
}
inline ::GSToGC::MsgID LastingSkillState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void LastingSkillState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool LastingSkillState::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LastingSkillState::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t LastingSkillState::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LastingSkillState.objguid)
  return _internal_objguid();
}
inline void LastingSkillState::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.LastingSkillState.objguid)
}
inline ::uint64_t LastingSkillState::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void LastingSkillState::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional int32 skillid = 3;
inline bool LastingSkillState::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void LastingSkillState::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t LastingSkillState::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LastingSkillState.skillid)
  return _internal_skillid();
}
inline void LastingSkillState::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.LastingSkillState.skillid)
}
inline ::int32_t LastingSkillState::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void LastingSkillState::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional .GSToGC.Pos pos = 4;
inline bool LastingSkillState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void LastingSkillState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& LastingSkillState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& LastingSkillState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.LastingSkillState.pos)
  return _internal_pos();
}
inline void LastingSkillState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.LastingSkillState.pos)
}
inline ::GSToGC::Pos* LastingSkillState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* LastingSkillState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.LastingSkillState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* LastingSkillState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* LastingSkillState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.LastingSkillState.pos)
  return _msg;
}
inline void LastingSkillState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.LastingSkillState.pos)
}

// optional .GSToGC.Dir dir = 5;
inline bool LastingSkillState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void LastingSkillState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& LastingSkillState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& LastingSkillState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.LastingSkillState.dir)
  return _internal_dir();
}
inline void LastingSkillState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.LastingSkillState.dir)
}
inline ::GSToGC::Dir* LastingSkillState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* LastingSkillState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.LastingSkillState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* LastingSkillState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* LastingSkillState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.LastingSkillState.dir)
  return _msg;
}
inline void LastingSkillState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.LastingSkillState.dir)
}

// optional uint64 targuid = 6;
inline bool LastingSkillState::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void LastingSkillState::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t LastingSkillState::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LastingSkillState.targuid)
  return _internal_targuid();
}
inline void LastingSkillState::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.LastingSkillState.targuid)
}
inline ::uint64_t LastingSkillState::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void LastingSkillState::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// -------------------------------------------------------------------

// DeadState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectDeadState];
inline bool DeadState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DeadState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 18;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID DeadState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.DeadState.msgid)
  return _internal_msgid();
}
inline void DeadState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.DeadState.msgid)
}
inline ::GSToGC::MsgID DeadState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void DeadState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool DeadState::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DeadState::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t DeadState::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.DeadState.objguid)
  return _internal_objguid();
}
inline void DeadState::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.DeadState.objguid)
}
inline ::uint64_t DeadState::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void DeadState::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional .GSToGC.Pos pos = 3;
inline bool DeadState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void DeadState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& DeadState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& DeadState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.DeadState.pos)
  return _internal_pos();
}
inline void DeadState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.DeadState.pos)
}
inline ::GSToGC::Pos* DeadState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* DeadState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.DeadState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* DeadState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* DeadState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.DeadState.pos)
  return _msg;
}
inline void DeadState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.DeadState.pos)
}

// optional .GSToGC.Dir dir = 4;
inline bool DeadState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void DeadState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& DeadState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& DeadState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.DeadState.dir)
  return _internal_dir();
}
inline void DeadState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.DeadState.dir)
}
inline ::GSToGC::Dir* DeadState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* DeadState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.DeadState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* DeadState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* DeadState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.DeadState.dir)
  return _msg;
}
inline void DeadState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.DeadState.dir)
}

// optional bool spot = 5;
inline bool DeadState::has_spot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DeadState::clear_spot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spot_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool DeadState::spot() const {
  // @@protoc_insertion_point(field_get:GSToGC.DeadState.spot)
  return _internal_spot();
}
inline void DeadState::set_spot(bool value) {
  _internal_set_spot(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.DeadState.spot)
}
inline bool DeadState::_internal_spot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.spot_;
}
inline void DeadState::_internal_set_spot(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.spot_ = value;
}

// -------------------------------------------------------------------

// NotifyGoodsInfo_GoodsInfo

// optional int32 num = 1;
inline bool NotifyGoodsInfo_GoodsInfo::has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyGoodsInfo_GoodsInfo::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::num() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.GoodsInfo.num)
  return _internal_num();
}
inline void NotifyGoodsInfo_GoodsInfo::set_num(::int32_t value) {
  _internal_set_num(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.GoodsInfo.num)
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void NotifyGoodsInfo_GoodsInfo::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = value;
}

// optional int32 pos = 2;
inline bool NotifyGoodsInfo_GoodsInfo::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyGoodsInfo_GoodsInfo::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.GoodsInfo.pos)
  return _internal_pos();
}
inline void NotifyGoodsInfo_GoodsInfo::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.GoodsInfo.pos)
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void NotifyGoodsInfo_GoodsInfo::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// optional bool ifComposed = 3;
inline bool NotifyGoodsInfo_GoodsInfo::has_ifcomposed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyGoodsInfo_GoodsInfo::clear_ifcomposed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifcomposed_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool NotifyGoodsInfo_GoodsInfo::ifcomposed() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.GoodsInfo.ifComposed)
  return _internal_ifcomposed();
}
inline void NotifyGoodsInfo_GoodsInfo::set_ifcomposed(bool value) {
  _internal_set_ifcomposed(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.GoodsInfo.ifComposed)
}
inline bool NotifyGoodsInfo_GoodsInfo::_internal_ifcomposed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifcomposed_;
}
inline void NotifyGoodsInfo_GoodsInfo::_internal_set_ifcomposed(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifcomposed_ = value;
}

// optional int32 tyepid = 4;
inline bool NotifyGoodsInfo_GoodsInfo::has_tyepid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyGoodsInfo_GoodsInfo::clear_tyepid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tyepid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::tyepid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.GoodsInfo.tyepid)
  return _internal_tyepid();
}
inline void NotifyGoodsInfo_GoodsInfo::set_tyepid(::int32_t value) {
  _internal_set_tyepid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.GoodsInfo.tyepid)
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::_internal_tyepid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tyepid_;
}
inline void NotifyGoodsInfo_GoodsInfo::_internal_set_tyepid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tyepid_ = value;
}

// optional int32 state = 5;
inline bool NotifyGoodsInfo_GoodsInfo::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifyGoodsInfo_GoodsInfo::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::state() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.GoodsInfo.state)
  return _internal_state();
}
inline void NotifyGoodsInfo_GoodsInfo::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.GoodsInfo.state)
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void NotifyGoodsInfo_GoodsInfo::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// optional int32 statetime = 6;
inline bool NotifyGoodsInfo_GoodsInfo::has_statetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifyGoodsInfo_GoodsInfo::clear_statetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statetime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::statetime() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.GoodsInfo.statetime)
  return _internal_statetime();
}
inline void NotifyGoodsInfo_GoodsInfo::set_statetime(::int32_t value) {
  _internal_set_statetime(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.GoodsInfo.statetime)
}
inline ::int32_t NotifyGoodsInfo_GoodsInfo::_internal_statetime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.statetime_;
}
inline void NotifyGoodsInfo_GoodsInfo::_internal_set_statetime(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.statetime_ = value;
}

// -------------------------------------------------------------------

// NotifyGoodsInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGoodsInf];
inline bool NotifyGoodsInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyGoodsInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 19;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyGoodsInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.msgid)
  return _internal_msgid();
}
inline void NotifyGoodsInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.msgid)
}
inline ::GSToGC::MsgID NotifyGoodsInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyGoodsInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyGoodsInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyGoodsInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyGoodsInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.guid)
  return _internal_guid();
}
inline void NotifyGoodsInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGoodsInfo.guid)
}
inline ::uint64_t NotifyGoodsInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyGoodsInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// repeated .GSToGC.NotifyGoodsInfo.GoodsInfo info = 3;
inline int NotifyGoodsInfo::_internal_info_size() const {
  return _internal_info().size();
}
inline int NotifyGoodsInfo::info_size() const {
  return _internal_info_size();
}
inline void NotifyGoodsInfo::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::NotifyGoodsInfo_GoodsInfo* NotifyGoodsInfo::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyGoodsInfo.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>* NotifyGoodsInfo::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyGoodsInfo.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::NotifyGoodsInfo_GoodsInfo& NotifyGoodsInfo::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGoodsInfo.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::NotifyGoodsInfo_GoodsInfo* NotifyGoodsInfo::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyGoodsInfo_GoodsInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyGoodsInfo.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>& NotifyGoodsInfo::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyGoodsInfo.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>&
NotifyGoodsInfo::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyGoodsInfo_GoodsInfo>*
NotifyGoodsInfo::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// BattleLoadingState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleLoadingState];
inline bool BattleLoadingState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BattleLoadingState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 20;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID BattleLoadingState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleLoadingState.msgid)
  return _internal_msgid();
}
inline void BattleLoadingState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleLoadingState.msgid)
}
inline ::GSToGC::MsgID BattleLoadingState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleLoadingState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 guid = 2;
inline bool BattleLoadingState::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleLoadingState::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BattleLoadingState::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleLoadingState.guid)
  return _internal_guid();
}
inline void BattleLoadingState::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleLoadingState.guid)
}
inline ::int64_t BattleLoadingState::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void BattleLoadingState::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 loadper = 3;
inline bool BattleLoadingState::has_loadper() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleLoadingState::clear_loadper() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loadper_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BattleLoadingState::loadper() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleLoadingState.loadper)
  return _internal_loadper();
}
inline void BattleLoadingState::set_loadper(::int32_t value) {
  _internal_set_loadper(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleLoadingState.loadper)
}
inline ::int32_t BattleLoadingState::_internal_loadper() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.loadper_;
}
inline void BattleLoadingState::_internal_set_loadper(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.loadper_ = value;
}

// -------------------------------------------------------------------

// HeroPosInfo

// optional int32 pos = 2;
inline bool HeroPosInfo::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HeroPosInfo::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t HeroPosInfo::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroPosInfo.pos)
  return _internal_pos();
}
inline void HeroPosInfo::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroPosInfo.pos)
}
inline ::int32_t HeroPosInfo::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void HeroPosInfo::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// optional int32 heroid = 3;
inline bool HeroPosInfo::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HeroPosInfo::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t HeroPosInfo::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroPosInfo.heroid)
  return _internal_heroid();
}
inline void HeroPosInfo::set_heroid(::int32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroPosInfo.heroid)
}
inline ::int32_t HeroPosInfo::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void HeroPosInfo::_internal_set_heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// -------------------------------------------------------------------

// HeroInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleHeroInfo];
inline bool HeroInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HeroInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 21;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID HeroInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroInfo.msgid)
  return _internal_msgid();
}
inline void HeroInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroInfo.msgid)
}
inline ::GSToGC::MsgID HeroInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HeroInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional .GSToGC.HeroPosInfo heroposinfo = 2;
inline bool HeroInfo::has_heroposinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.heroposinfo_ != nullptr);
  return value;
}
inline void HeroInfo::clear_heroposinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.heroposinfo_ != nullptr) _impl_.heroposinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::HeroPosInfo& HeroInfo::_internal_heroposinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::HeroPosInfo* p = _impl_.heroposinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::HeroPosInfo&>(::GSToGC::_HeroPosInfo_default_instance_);
}
inline const ::GSToGC::HeroPosInfo& HeroInfo::heroposinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.HeroInfo.heroposinfo)
  return _internal_heroposinfo();
}
inline void HeroInfo::unsafe_arena_set_allocated_heroposinfo(::GSToGC::HeroPosInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.heroposinfo_);
  }
  _impl_.heroposinfo_ = reinterpret_cast<::GSToGC::HeroPosInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.HeroInfo.heroposinfo)
}
inline ::GSToGC::HeroPosInfo* HeroInfo::release_heroposinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::HeroPosInfo* released = _impl_.heroposinfo_;
  _impl_.heroposinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::HeroPosInfo* HeroInfo::unsafe_arena_release_heroposinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.HeroInfo.heroposinfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::HeroPosInfo* temp = _impl_.heroposinfo_;
  _impl_.heroposinfo_ = nullptr;
  return temp;
}
inline ::GSToGC::HeroPosInfo* HeroInfo::_internal_mutable_heroposinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.heroposinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::HeroPosInfo>(GetArena());
    _impl_.heroposinfo_ = reinterpret_cast<::GSToGC::HeroPosInfo*>(p);
  }
  return _impl_.heroposinfo_;
}
inline ::GSToGC::HeroPosInfo* HeroInfo::mutable_heroposinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::HeroPosInfo* _msg = _internal_mutable_heroposinfo();
  // @@protoc_insertion_point(field_mutable:GSToGC.HeroInfo.heroposinfo)
  return _msg;
}
inline void HeroInfo::set_allocated_heroposinfo(::GSToGC::HeroPosInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.heroposinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.heroposinfo_ = reinterpret_cast<::GSToGC::HeroPosInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.HeroInfo.heroposinfo)
}

// -------------------------------------------------------------------

// ChatInRoom

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_ChatInRoom];
inline bool ChatInRoom::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChatInRoom::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 24;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID ChatInRoom::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.ChatInRoom.msgid)
  return _internal_msgid();
}
inline void ChatInRoom::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.ChatInRoom.msgid)
}
inline ::GSToGC::MsgID ChatInRoom::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void ChatInRoom::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 pos = 2;
inline bool ChatInRoom::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChatInRoom::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ChatInRoom::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.ChatInRoom.pos)
  return _internal_pos();
}
inline void ChatInRoom::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.ChatInRoom.pos)
}
inline ::int32_t ChatInRoom::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void ChatInRoom::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// optional string chat = 3;
inline bool ChatInRoom::has_chat() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChatInRoom::clear_chat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chat_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChatInRoom::chat() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.ChatInRoom.chat)
  return _internal_chat();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatInRoom::set_chat(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chat_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.ChatInRoom.chat)
}
inline std::string* ChatInRoom::mutable_chat() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_chat();
  // @@protoc_insertion_point(field_mutable:GSToGC.ChatInRoom.chat)
  return _s;
}
inline const std::string& ChatInRoom::_internal_chat() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chat_.Get();
}
inline void ChatInRoom::_internal_set_chat(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.chat_.Set(value, GetArena());
}
inline std::string* ChatInRoom::_internal_mutable_chat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.chat_.Mutable( GetArena());
}
inline std::string* ChatInRoom::release_chat() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.ChatInRoom.chat)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.chat_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.chat_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChatInRoom::set_allocated_chat(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.chat_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.chat_.IsDefault()) {
          _impl_.chat_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.ChatInRoom.chat)
}

// -------------------------------------------------------------------

// SkillHitTar

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillHitTarget];
inline bool SkillHitTar::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SkillHitTar::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 25;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID SkillHitTar::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillHitTar.msgid)
  return _internal_msgid();
}
inline void SkillHitTar::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillHitTar.msgid)
}
inline ::GSToGC::MsgID SkillHitTar::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void SkillHitTar::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 guid = 2;
inline bool SkillHitTar::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SkillHitTar::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SkillHitTar::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillHitTar.guid)
  return _internal_guid();
}
inline void SkillHitTar::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillHitTar.guid)
}
inline ::int64_t SkillHitTar::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void SkillHitTar::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool SkillHitTar::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SkillHitTar::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SkillHitTar::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillHitTar.skillid)
  return _internal_skillid();
}
inline void SkillHitTar::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillHitTar.skillid)
}
inline ::int32_t SkillHitTar::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void SkillHitTar::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional int64 targuid = 4;
inline bool SkillHitTar::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SkillHitTar::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t SkillHitTar::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillHitTar.targuid)
  return _internal_targuid();
}
inline void SkillHitTar::set_targuid(::int64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillHitTar.targuid)
}
inline ::int64_t SkillHitTar::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void SkillHitTar::_internal_set_targuid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// -------------------------------------------------------------------

// HPChange

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHPChange];
inline bool HPChange::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void HPChange::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 26;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID HPChange::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HPChange.msgid)
  return _internal_msgid();
}
inline void HPChange::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.HPChange.msgid)
}
inline ::GSToGC::MsgID HPChange::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HPChange::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool HPChange::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HPChange::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t HPChange::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HPChange.guid)
  return _internal_guid();
}
inline void HPChange::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.HPChange.guid)
}
inline ::uint64_t HPChange::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void HPChange::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 hp = 3;
inline bool HPChange::has_hp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HPChange::clear_hp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t HPChange::hp() const {
  // @@protoc_insertion_point(field_get:GSToGC.HPChange.hp)
  return _internal_hp();
}
inline void HPChange::set_hp(::int32_t value) {
  _internal_set_hp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HPChange.hp)
}
inline ::int32_t HPChange::_internal_hp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hp_;
}
inline void HPChange::_internal_set_hp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = value;
}

// optional .GSToGC.HPMPChangeReason reason = 4;
inline bool HPChange::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HPChange::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::HPMPChangeReason HPChange::reason() const {
  // @@protoc_insertion_point(field_get:GSToGC.HPChange.reason)
  return _internal_reason();
}
inline void HPChange::set_reason(::GSToGC::HPMPChangeReason value) {
  _internal_set_reason(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.HPChange.reason)
}
inline ::GSToGC::HPMPChangeReason HPChange::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::HPMPChangeReason>(_impl_.reason_);
}
inline void HPChange::_internal_set_reason(::GSToGC::HPMPChangeReason value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::HPMPChangeReason_IsValid(value));
  _impl_.reason_ = value;
}

// -------------------------------------------------------------------

// MpChange

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMPChange];
inline bool MpChange::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MpChange::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 27;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID MpChange::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.MpChange.msgid)
  return _internal_msgid();
}
inline void MpChange::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.MpChange.msgid)
}
inline ::GSToGC::MsgID MpChange::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void MpChange::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool MpChange::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MpChange::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t MpChange::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.MpChange.guid)
  return _internal_guid();
}
inline void MpChange::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.MpChange.guid)
}
inline ::uint64_t MpChange::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void MpChange::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 mp = 3;
inline bool MpChange::has_mp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MpChange::clear_mp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MpChange::mp() const {
  // @@protoc_insertion_point(field_get:GSToGC.MpChange.mp)
  return _internal_mp();
}
inline void MpChange::set_mp(::int32_t value) {
  _internal_set_mp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.MpChange.mp)
}
inline ::int32_t MpChange::_internal_mp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mp_;
}
inline void MpChange::_internal_set_mp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mp_ = value;
}

// optional .GSToGC.HPMPChangeReason reason = 4;
inline bool MpChange::has_reason() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MpChange::clear_reason() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reason_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::HPMPChangeReason MpChange::reason() const {
  // @@protoc_insertion_point(field_get:GSToGC.MpChange.reason)
  return _internal_reason();
}
inline void MpChange::set_reason(::GSToGC::HPMPChangeReason value) {
  _internal_set_reason(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.MpChange.reason)
}
inline ::GSToGC::HPMPChangeReason MpChange::_internal_reason() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::HPMPChangeReason>(_impl_.reason_);
}
inline void MpChange::_internal_set_reason(::GSToGC::HPMPChangeReason value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::HPMPChangeReason_IsValid(value));
  _impl_.reason_ = value;
}

// -------------------------------------------------------------------

// TryToChooseHero

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyTryToChooseHero];
inline bool TryToChooseHero::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void TryToChooseHero::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 28;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID TryToChooseHero::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.TryToChooseHero.msgid)
  return _internal_msgid();
}
inline void TryToChooseHero::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.TryToChooseHero.msgid)
}
inline ::GSToGC::MsgID TryToChooseHero::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void TryToChooseHero::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 pos = 2;
inline bool TryToChooseHero::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void TryToChooseHero::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t TryToChooseHero::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.TryToChooseHero.pos)
  return _internal_pos();
}
inline void TryToChooseHero::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.TryToChooseHero.pos)
}
inline ::int32_t TryToChooseHero::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void TryToChooseHero::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// optional int32 heroid = 3;
inline bool TryToChooseHero::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void TryToChooseHero::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t TryToChooseHero::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.TryToChooseHero.heroid)
  return _internal_heroid();
}
inline void TryToChooseHero::set_heroid(::int32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.TryToChooseHero.heroid)
}
inline ::int32_t TryToChooseHero::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void TryToChooseHero::_internal_set_heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// -------------------------------------------------------------------

// NotifyChooseHeroTimeEnd

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyChooseHeroTimeEnd];
inline bool NotifyChooseHeroTimeEnd::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyChooseHeroTimeEnd::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 29;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyChooseHeroTimeEnd::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyChooseHeroTimeEnd.msgid)
  return _internal_msgid();
}
inline void NotifyChooseHeroTimeEnd::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyChooseHeroTimeEnd.msgid)
}
inline ::GSToGC::MsgID NotifyChooseHeroTimeEnd::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyChooseHeroTimeEnd::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.HeroPosInfo heroposinfo = 2;
inline int NotifyChooseHeroTimeEnd::_internal_heroposinfo_size() const {
  return _internal_heroposinfo().size();
}
inline int NotifyChooseHeroTimeEnd::heroposinfo_size() const {
  return _internal_heroposinfo_size();
}
inline void NotifyChooseHeroTimeEnd::clear_heroposinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroposinfo_.Clear();
}
inline ::GSToGC::HeroPosInfo* NotifyChooseHeroTimeEnd::mutable_heroposinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyChooseHeroTimeEnd.heroposinfo)
  return _internal_mutable_heroposinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>* NotifyChooseHeroTimeEnd::mutable_heroposinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyChooseHeroTimeEnd.heroposinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_heroposinfo();
}
inline const ::GSToGC::HeroPosInfo& NotifyChooseHeroTimeEnd::heroposinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyChooseHeroTimeEnd.heroposinfo)
  return _internal_heroposinfo().Get(index);
}
inline ::GSToGC::HeroPosInfo* NotifyChooseHeroTimeEnd::add_heroposinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::HeroPosInfo* _add = _internal_mutable_heroposinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyChooseHeroTimeEnd.heroposinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>& NotifyChooseHeroTimeEnd::heroposinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyChooseHeroTimeEnd.heroposinfo)
  return _internal_heroposinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>&
NotifyChooseHeroTimeEnd::_internal_heroposinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroposinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::HeroPosInfo>*
NotifyChooseHeroTimeEnd::_internal_mutable_heroposinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.heroposinfo_;
}

// -------------------------------------------------------------------

// SkillEntityInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillEntityInfo];
inline bool SkillEntityInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void SkillEntityInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 30;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::GSToGC::MsgID SkillEntityInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEntityInfo.msgid)
  return _internal_msgid();
}
inline void SkillEntityInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEntityInfo.msgid)
}
inline ::GSToGC::MsgID SkillEntityInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void SkillEntityInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 guid = 2;
inline bool SkillEntityInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SkillEntityInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t SkillEntityInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEntityInfo.guid)
  return _internal_guid();
}
inline void SkillEntityInfo::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEntityInfo.guid)
}
inline ::int64_t SkillEntityInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void SkillEntityInfo::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool SkillEntityInfo::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void SkillEntityInfo::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t SkillEntityInfo::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEntityInfo.skillid)
  return _internal_skillid();
}
inline void SkillEntityInfo::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEntityInfo.skillid)
}
inline ::int32_t SkillEntityInfo::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void SkillEntityInfo::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional .GSToGC.Dir dir = 4;
inline bool SkillEntityInfo::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void SkillEntityInfo::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Dir& SkillEntityInfo::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& SkillEntityInfo::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEntityInfo.dir)
  return _internal_dir();
}
inline void SkillEntityInfo::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.SkillEntityInfo.dir)
}
inline ::GSToGC::Dir* SkillEntityInfo::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* SkillEntityInfo::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.SkillEntityInfo.dir)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* SkillEntityInfo::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* SkillEntityInfo::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.SkillEntityInfo.dir)
  return _msg;
}
inline void SkillEntityInfo::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.SkillEntityInfo.dir)
}

// optional int64 targuid = 5;
inline bool SkillEntityInfo::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SkillEntityInfo::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int64_t SkillEntityInfo::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEntityInfo.targuid)
  return _internal_targuid();
}
inline void SkillEntityInfo::set_targuid(::int64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEntityInfo.targuid)
}
inline ::int64_t SkillEntityInfo::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void SkillEntityInfo::_internal_set_targuid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional int64 uniqueid = 6;
inline bool SkillEntityInfo::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SkillEntityInfo::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t SkillEntityInfo::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEntityInfo.uniqueid)
  return _internal_uniqueid();
}
inline void SkillEntityInfo::set_uniqueid(::int64_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEntityInfo.uniqueid)
}
inline ::int64_t SkillEntityInfo::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void SkillEntityInfo::_internal_set_uniqueid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// optional .GSToGC.Dir tardir = 7;
inline bool SkillEntityInfo::has_tardir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tardir_ != nullptr);
  return value;
}
inline void SkillEntityInfo::clear_tardir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tardir_ != nullptr) _impl_.tardir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& SkillEntityInfo::_internal_tardir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.tardir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& SkillEntityInfo::tardir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEntityInfo.tardir)
  return _internal_tardir();
}
inline void SkillEntityInfo::unsafe_arena_set_allocated_tardir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tardir_);
  }
  _impl_.tardir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.SkillEntityInfo.tardir)
}
inline ::GSToGC::Dir* SkillEntityInfo::release_tardir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.tardir_;
  _impl_.tardir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* SkillEntityInfo::unsafe_arena_release_tardir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.SkillEntityInfo.tardir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.tardir_;
  _impl_.tardir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* SkillEntityInfo::_internal_mutable_tardir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tardir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.tardir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.tardir_;
}
inline ::GSToGC::Dir* SkillEntityInfo::mutable_tardir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_tardir();
  // @@protoc_insertion_point(field_mutable:GSToGC.SkillEntityInfo.tardir)
  return _msg;
}
inline void SkillEntityInfo::set_allocated_tardir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.tardir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.tardir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.SkillEntityInfo.tardir)
}

// -------------------------------------------------------------------

// FPInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyFightPropertyInfo];
inline bool FPInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FPInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 31;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID FPInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FPInfo.msgid)
  return _internal_msgid();
}
inline void FPInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.FPInfo.msgid)
}
inline ::GSToGC::MsgID FPInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void FPInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool FPInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FPInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t FPInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FPInfo.guid)
  return _internal_guid();
}
inline void FPInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.FPInfo.guid)
}
inline ::uint64_t FPInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void FPInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// repeated int32 info = 3;
inline int FPInfo::_internal_info_size() const {
  return _internal_info().size();
}
inline int FPInfo::info_size() const {
  return _internal_info_size();
}
inline void FPInfo::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::int32_t FPInfo::info(int index) const {
  // @@protoc_insertion_point(field_get:GSToGC.FPInfo.info)
  return _internal_info().Get(index);
}
inline void FPInfo::set_info(int index, ::int32_t value) {
  _internal_mutable_info()->Set(index, value);
  // @@protoc_insertion_point(field_set:GSToGC.FPInfo.info)
}
inline void FPInfo::add_info(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_info()->Add(value);
  // @@protoc_insertion_point(field_add:GSToGC.FPInfo.info)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& FPInfo::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.FPInfo.info)
  return _internal_info();
}
inline ::google::protobuf::RepeatedField<::int32_t>* FPInfo::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.FPInfo.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::google::protobuf::RepeatedField<::int32_t>& FPInfo::_internal_info()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* FPInfo::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// NotifyHPInfo_HPInfo

// optional uint64 guid = 1;
inline bool NotifyHPInfo_HPInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyHPInfo_HPInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyHPInfo_HPInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHPInfo.HPInfo.guid)
  return _internal_guid();
}
inline void NotifyHPInfo_HPInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHPInfo.HPInfo.guid)
}
inline ::uint64_t NotifyHPInfo_HPInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyHPInfo_HPInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 curhp = 2;
inline bool NotifyHPInfo_HPInfo::has_curhp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyHPInfo_HPInfo::clear_curhp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curhp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyHPInfo_HPInfo::curhp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHPInfo.HPInfo.curhp)
  return _internal_curhp();
}
inline void NotifyHPInfo_HPInfo::set_curhp(::int32_t value) {
  _internal_set_curhp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHPInfo.HPInfo.curhp)
}
inline ::int32_t NotifyHPInfo_HPInfo::_internal_curhp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curhp_;
}
inline void NotifyHPInfo_HPInfo::_internal_set_curhp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curhp_ = value;
}

// optional int32 maxhp = 3;
inline bool NotifyHPInfo_HPInfo::has_maxhp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyHPInfo_HPInfo::clear_maxhp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxhp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyHPInfo_HPInfo::maxhp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHPInfo.HPInfo.maxhp)
  return _internal_maxhp();
}
inline void NotifyHPInfo_HPInfo::set_maxhp(::int32_t value) {
  _internal_set_maxhp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHPInfo.HPInfo.maxhp)
}
inline ::int32_t NotifyHPInfo_HPInfo::_internal_maxhp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxhp_;
}
inline void NotifyHPInfo_HPInfo::_internal_set_maxhp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxhp_ = value;
}

// -------------------------------------------------------------------

// NotifyHPInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHPInfo];
inline bool NotifyHPInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyHPInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 34;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyHPInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHPInfo.msgid)
  return _internal_msgid();
}
inline void NotifyHPInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHPInfo.msgid)
}
inline ::GSToGC::MsgID NotifyHPInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyHPInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.NotifyHPInfo.HPInfo hpinfo = 2;
inline int NotifyHPInfo::_internal_hpinfo_size() const {
  return _internal_hpinfo().size();
}
inline int NotifyHPInfo::hpinfo_size() const {
  return _internal_hpinfo_size();
}
inline void NotifyHPInfo::clear_hpinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hpinfo_.Clear();
}
inline ::GSToGC::NotifyHPInfo_HPInfo* NotifyHPInfo::mutable_hpinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyHPInfo.hpinfo)
  return _internal_mutable_hpinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>* NotifyHPInfo::mutable_hpinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyHPInfo.hpinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_hpinfo();
}
inline const ::GSToGC::NotifyHPInfo_HPInfo& NotifyHPInfo::hpinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHPInfo.hpinfo)
  return _internal_hpinfo().Get(index);
}
inline ::GSToGC::NotifyHPInfo_HPInfo* NotifyHPInfo::add_hpinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyHPInfo_HPInfo* _add = _internal_mutable_hpinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyHPInfo.hpinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>& NotifyHPInfo::hpinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyHPInfo.hpinfo)
  return _internal_hpinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>&
NotifyHPInfo::_internal_hpinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hpinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyHPInfo_HPInfo>*
NotifyHPInfo::_internal_mutable_hpinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.hpinfo_;
}

// -------------------------------------------------------------------

// NotifyMPInfo_MPInfo

// optional uint64 guid = 1;
inline bool NotifyMPInfo_MPInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMPInfo_MPInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyMPInfo_MPInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMPInfo.MPInfo.guid)
  return _internal_guid();
}
inline void NotifyMPInfo_MPInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMPInfo.MPInfo.guid)
}
inline ::uint64_t NotifyMPInfo_MPInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyMPInfo_MPInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 curmp = 2;
inline bool NotifyMPInfo_MPInfo::has_curmp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyMPInfo_MPInfo::clear_curmp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curmp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyMPInfo_MPInfo::curmp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMPInfo.MPInfo.curmp)
  return _internal_curmp();
}
inline void NotifyMPInfo_MPInfo::set_curmp(::int32_t value) {
  _internal_set_curmp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMPInfo.MPInfo.curmp)
}
inline ::int32_t NotifyMPInfo_MPInfo::_internal_curmp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curmp_;
}
inline void NotifyMPInfo_MPInfo::_internal_set_curmp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curmp_ = value;
}

// optional int32 maxmp = 3;
inline bool NotifyMPInfo_MPInfo::has_maxmp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyMPInfo_MPInfo::clear_maxmp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxmp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyMPInfo_MPInfo::maxmp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMPInfo.MPInfo.maxmp)
  return _internal_maxmp();
}
inline void NotifyMPInfo_MPInfo::set_maxmp(::int32_t value) {
  _internal_set_maxmp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMPInfo.MPInfo.maxmp)
}
inline ::int32_t NotifyMPInfo_MPInfo::_internal_maxmp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxmp_;
}
inline void NotifyMPInfo_MPInfo::_internal_set_maxmp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxmp_ = value;
}

// -------------------------------------------------------------------

// NotifyMPInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyMPInfo];
inline bool NotifyMPInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyMPInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 35;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyMPInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMPInfo.msgid)
  return _internal_msgid();
}
inline void NotifyMPInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyMPInfo.msgid)
}
inline ::GSToGC::MsgID NotifyMPInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyMPInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.NotifyMPInfo.MPInfo mpinfo = 2;
inline int NotifyMPInfo::_internal_mpinfo_size() const {
  return _internal_mpinfo().size();
}
inline int NotifyMPInfo::mpinfo_size() const {
  return _internal_mpinfo_size();
}
inline void NotifyMPInfo::clear_mpinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mpinfo_.Clear();
}
inline ::GSToGC::NotifyMPInfo_MPInfo* NotifyMPInfo::mutable_mpinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyMPInfo.mpinfo)
  return _internal_mutable_mpinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>* NotifyMPInfo::mutable_mpinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyMPInfo.mpinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_mpinfo();
}
inline const ::GSToGC::NotifyMPInfo_MPInfo& NotifyMPInfo::mpinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyMPInfo.mpinfo)
  return _internal_mpinfo().Get(index);
}
inline ::GSToGC::NotifyMPInfo_MPInfo* NotifyMPInfo::add_mpinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyMPInfo_MPInfo* _add = _internal_mutable_mpinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyMPInfo.mpinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>& NotifyMPInfo::mpinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyMPInfo.mpinfo)
  return _internal_mpinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>&
NotifyMPInfo::_internal_mpinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mpinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyMPInfo_MPInfo>*
NotifyMPInfo::_internal_mutable_mpinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.mpinfo_;
}

// -------------------------------------------------------------------

// NotifyHeroInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroInfo];
inline bool NotifyHeroInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void NotifyHeroInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 36;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::GSToGC::MsgID NotifyHeroInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroInfo.msgid)
  return _internal_msgid();
}
inline void NotifyHeroInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroInfo.msgid)
}
inline ::GSToGC::MsgID NotifyHeroInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyHeroInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyHeroInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyHeroInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyHeroInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroInfo.guid)
  return _internal_guid();
}
inline void NotifyHeroInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroInfo.guid)
}
inline ::uint64_t NotifyHeroInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyHeroInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 level = 3;
inline bool NotifyHeroInfo::has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyHeroInfo::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyHeroInfo::level() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroInfo.level)
  return _internal_level();
}
inline void NotifyHeroInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroInfo.level)
}
inline ::int32_t NotifyHeroInfo::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void NotifyHeroInfo::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = value;
}

// optional int32 exp = 4;
inline bool NotifyHeroInfo::has_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyHeroInfo::clear_exp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyHeroInfo::exp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroInfo.exp)
  return _internal_exp();
}
inline void NotifyHeroInfo::set_exp(::int32_t value) {
  _internal_set_exp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroInfo.exp)
}
inline ::int32_t NotifyHeroInfo::_internal_exp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_;
}
inline void NotifyHeroInfo::_internal_set_exp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_ = value;
}

// optional int32 fury = 5;
inline bool NotifyHeroInfo::has_fury() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyHeroInfo::clear_fury() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fury_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifyHeroInfo::fury() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroInfo.fury)
  return _internal_fury();
}
inline void NotifyHeroInfo::set_fury(::int32_t value) {
  _internal_set_fury(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroInfo.fury)
}
inline ::int32_t NotifyHeroInfo::_internal_fury() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fury_;
}
inline void NotifyHeroInfo::_internal_set_fury(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fury_ = value;
}

// optional int32 absorb1 = 6;
inline bool NotifyHeroInfo::has_absorb1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifyHeroInfo::clear_absorb1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NotifyHeroInfo::absorb1() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroInfo.absorb1)
  return _internal_absorb1();
}
inline void NotifyHeroInfo::set_absorb1(::int32_t value) {
  _internal_set_absorb1(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroInfo.absorb1)
}
inline ::int32_t NotifyHeroInfo::_internal_absorb1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absorb1_;
}
inline void NotifyHeroInfo::_internal_set_absorb1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb1_ = value;
}

// optional int32 absorb2 = 7;
inline bool NotifyHeroInfo::has_absorb2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifyHeroInfo::clear_absorb2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t NotifyHeroInfo::absorb2() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroInfo.absorb2)
  return _internal_absorb2();
}
inline void NotifyHeroInfo::set_absorb2(::int32_t value) {
  _internal_set_absorb2(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroInfo.absorb2)
}
inline ::int32_t NotifyHeroInfo::_internal_absorb2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absorb2_;
}
inline void NotifyHeroInfo::_internal_set_absorb2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb2_ = value;
}

// -------------------------------------------------------------------

// NotifySkillInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillInfo];
inline bool NotifySkillInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifySkillInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 39;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID NotifySkillInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillInfo.msgid)
  return _internal_msgid();
}
inline void NotifySkillInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillInfo.msgid)
}
inline ::GSToGC::MsgID NotifySkillInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifySkillInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifySkillInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillInfo.guid)
  return _internal_guid();
}
inline void NotifySkillInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillInfo.guid)
}
inline ::uint64_t NotifySkillInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillslot = 3;
inline bool NotifySkillInfo::has_skillslot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySkillInfo::clear_skillslot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillslot_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifySkillInfo::skillslot() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillInfo.skillslot)
  return _internal_skillslot();
}
inline void NotifySkillInfo::set_skillslot(::int32_t value) {
  _internal_set_skillslot(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillInfo.skillslot)
}
inline ::int32_t NotifySkillInfo::_internal_skillslot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillslot_;
}
inline void NotifySkillInfo::_internal_set_skillslot(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillslot_ = value;
}

// optional int32 skillid = 4;
inline bool NotifySkillInfo::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySkillInfo::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifySkillInfo::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillInfo.skillid)
  return _internal_skillid();
}
inline void NotifySkillInfo::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillInfo.skillid)
}
inline ::int32_t NotifySkillInfo::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void NotifySkillInfo::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional int32 time = 5;
inline bool NotifySkillInfo::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillInfo::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifySkillInfo::time() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillInfo.time)
  return _internal_time();
}
inline void NotifySkillInfo::set_time(::int32_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillInfo.time)
}
inline ::int32_t NotifySkillInfo::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void NotifySkillInfo::_internal_set_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// BattleFinish

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleFinish];
inline bool BattleFinish::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleFinish::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 40;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID BattleFinish::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleFinish.msgid)
  return _internal_msgid();
}
inline void BattleFinish::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleFinish.msgid)
}
inline ::GSToGC::MsgID BattleFinish::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BattleFinish::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 bulidguid = 2;
inline bool BattleFinish::has_bulidguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleFinish::clear_bulidguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bulidguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t BattleFinish::bulidguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BattleFinish.bulidguid)
  return _internal_bulidguid();
}
inline void BattleFinish::set_bulidguid(::uint64_t value) {
  _internal_set_bulidguid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BattleFinish.bulidguid)
}
inline ::uint64_t BattleFinish::_internal_bulidguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bulidguid_;
}
inline void BattleFinish::_internal_set_bulidguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bulidguid_ = value;
}

// -------------------------------------------------------------------

// Exp

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyExpInfo];
inline bool Exp::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Exp::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 41;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID Exp::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.Exp.msgid)
  return _internal_msgid();
}
inline void Exp::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.Exp.msgid)
}
inline ::GSToGC::MsgID Exp::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void Exp::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool Exp::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Exp::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t Exp::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.Exp.guid)
  return _internal_guid();
}
inline void Exp::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.Exp.guid)
}
inline ::uint64_t Exp::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void Exp::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 exp = 3;
inline bool Exp::has_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Exp::clear_exp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t Exp::exp() const {
  // @@protoc_insertion_point(field_get:GSToGC.Exp.exp)
  return _internal_exp();
}
inline void Exp::set_exp(::int32_t value) {
  _internal_set_exp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.Exp.exp)
}
inline ::int32_t Exp::_internal_exp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_;
}
inline void Exp::_internal_set_exp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_ = value;
}

// -------------------------------------------------------------------

// LevelInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroLevelInfo];
inline bool LevelInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LevelInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 42;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID LevelInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LevelInfo.msgid)
  return _internal_msgid();
}
inline void LevelInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.LevelInfo.msgid)
}
inline ::GSToGC::MsgID LevelInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void LevelInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool LevelInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LevelInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t LevelInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LevelInfo.guid)
  return _internal_guid();
}
inline void LevelInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.LevelInfo.guid)
}
inline ::uint64_t LevelInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void LevelInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 level = 3;
inline bool LevelInfo::has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LevelInfo::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t LevelInfo::level() const {
  // @@protoc_insertion_point(field_get:GSToGC.LevelInfo.level)
  return _internal_level();
}
inline void LevelInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.LevelInfo.level)
}
inline ::int32_t LevelInfo::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void LevelInfo::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = value;
}

// -------------------------------------------------------------------

// AbsorbBegin

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAbsorbBegin];
inline bool AbsorbBegin::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AbsorbBegin::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 43;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID AbsorbBegin::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbBegin.msgid)
  return _internal_msgid();
}
inline void AbsorbBegin::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbBegin.msgid)
}
inline ::GSToGC::MsgID AbsorbBegin::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void AbsorbBegin::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool AbsorbBegin::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AbsorbBegin::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AbsorbBegin::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbBegin.guid)
  return _internal_guid();
}
inline void AbsorbBegin::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbBegin.guid)
}
inline ::uint64_t AbsorbBegin::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void AbsorbBegin::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint64 monsterguid = 3;
inline bool AbsorbBegin::has_monsterguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AbsorbBegin::clear_monsterguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.monsterguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t AbsorbBegin::monsterguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbBegin.monsterguid)
  return _internal_monsterguid();
}
inline void AbsorbBegin::set_monsterguid(::uint64_t value) {
  _internal_set_monsterguid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbBegin.monsterguid)
}
inline ::uint64_t AbsorbBegin::_internal_monsterguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.monsterguid_;
}
inline void AbsorbBegin::_internal_set_monsterguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.monsterguid_ = value;
}

// -------------------------------------------------------------------

// AbsorbRes

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAbsorbMonsterResult];
inline bool AbsorbRes::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AbsorbRes::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 44;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID AbsorbRes::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbRes.msgid)
  return _internal_msgid();
}
inline void AbsorbRes::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbRes.msgid)
}
inline ::GSToGC::MsgID AbsorbRes::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void AbsorbRes::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool AbsorbRes::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AbsorbRes::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AbsorbRes::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbRes.guid)
  return _internal_guid();
}
inline void AbsorbRes::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbRes.guid)
}
inline ::uint64_t AbsorbRes::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void AbsorbRes::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional bool res = 3;
inline bool AbsorbRes::has_res() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AbsorbRes::clear_res() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.res_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool AbsorbRes::res() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbRes.res)
  return _internal_res();
}
inline void AbsorbRes::set_res(bool value) {
  _internal_set_res(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbRes.res)
}
inline bool AbsorbRes::_internal_res() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.res_;
}
inline void AbsorbRes::_internal_set_res(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.res_ = value;
}

// optional int32 absorb1 = 4;
inline bool AbsorbRes::has_absorb1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AbsorbRes::clear_absorb1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb1_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AbsorbRes::absorb1() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbRes.absorb1)
  return _internal_absorb1();
}
inline void AbsorbRes::set_absorb1(::int32_t value) {
  _internal_set_absorb1(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbRes.absorb1)
}
inline ::int32_t AbsorbRes::_internal_absorb1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absorb1_;
}
inline void AbsorbRes::_internal_set_absorb1(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb1_ = value;
}

// optional int32 absorb2 = 5;
inline bool AbsorbRes::has_absorb2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AbsorbRes::clear_absorb2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb2_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t AbsorbRes::absorb2() const {
  // @@protoc_insertion_point(field_get:GSToGC.AbsorbRes.absorb2)
  return _internal_absorb2();
}
inline void AbsorbRes::set_absorb2(::int32_t value) {
  _internal_set_absorb2(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.AbsorbRes.absorb2)
}
inline ::int32_t AbsorbRes::_internal_absorb2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.absorb2_;
}
inline void AbsorbRes::_internal_set_absorb2(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.absorb2_ = value;
}

// -------------------------------------------------------------------

// CancelAbsorb

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCancelAbsorbSkill];
inline bool CancelAbsorb::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CancelAbsorb::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 45;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID CancelAbsorb::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CancelAbsorb.msgid)
  return _internal_msgid();
}
inline void CancelAbsorb::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.CancelAbsorb.msgid)
}
inline ::GSToGC::MsgID CancelAbsorb::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void CancelAbsorb::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 monsterid = 2;
inline bool CancelAbsorb::has_monsterid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CancelAbsorb::clear_monsterid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.monsterid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t CancelAbsorb::monsterid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CancelAbsorb.monsterid)
  return _internal_monsterid();
}
inline void CancelAbsorb::set_monsterid(::int32_t value) {
  _internal_set_monsterid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.CancelAbsorb.monsterid)
}
inline ::int32_t CancelAbsorb::_internal_monsterid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.monsterid_;
}
inline void CancelAbsorb::_internal_set_monsterid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.monsterid_ = value;
}

// -------------------------------------------------------------------

// UserGameInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyUserGameInfo];
inline bool UserGameInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline void UserGameInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 46;
  _impl_._has_bits_[0] &= ~0x00040000u;
}
inline ::GSToGC::MsgID UserGameInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.msgid)
  return _internal_msgid();
}
inline void UserGameInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00040000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.msgid)
}
inline ::GSToGC::MsgID UserGameInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void UserGameInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 headid = 2;
inline bool UserGameInfo::has_headid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UserGameInfo::clear_headid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t UserGameInfo::headid() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.headid)
  return _internal_headid();
}
inline void UserGameInfo::set_headid(::int32_t value) {
  _internal_set_headid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.headid)
}
inline ::int32_t UserGameInfo::_internal_headid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headid_;
}
inline void UserGameInfo::_internal_set_headid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headid_ = value;
}

// optional string nickname = 3;
inline bool UserGameInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserGameInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserGameInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserGameInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.nickname)
}
inline std::string* UserGameInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.UserGameInfo.nickname)
  return _s;
}
inline const std::string& UserGameInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void UserGameInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* UserGameInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* UserGameInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UserGameInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserGameInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UserGameInfo.nickname)
}

// optional int32 level = 4;
inline bool UserGameInfo::has_level() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UserGameInfo::clear_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t UserGameInfo::level() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.level)
  return _internal_level();
}
inline void UserGameInfo::set_level(::int32_t value) {
  _internal_set_level(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.level)
}
inline ::int32_t UserGameInfo::_internal_level() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.level_;
}
inline void UserGameInfo::_internal_set_level(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.level_ = value;
}

// optional int32 upgradeexp = 5;
inline bool UserGameInfo::has_upgradeexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UserGameInfo::clear_upgradeexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upgradeexp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t UserGameInfo::upgradeexp() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.upgradeexp)
  return _internal_upgradeexp();
}
inline void UserGameInfo::set_upgradeexp(::int32_t value) {
  _internal_set_upgradeexp(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.upgradeexp)
}
inline ::int32_t UserGameInfo::_internal_upgradeexp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.upgradeexp_;
}
inline void UserGameInfo::_internal_set_upgradeexp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.upgradeexp_ = value;
}

// optional int32 curexp = 6;
inline bool UserGameInfo::has_curexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UserGameInfo::clear_curexp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curexp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t UserGameInfo::curexp() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.curexp)
  return _internal_curexp();
}
inline void UserGameInfo::set_curexp(::int32_t value) {
  _internal_set_curexp(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.curexp)
}
inline ::int32_t UserGameInfo::_internal_curexp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curexp_;
}
inline void UserGameInfo::_internal_set_curexp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curexp_ = value;
}

// optional int32 totalgameinns = 7;
inline bool UserGameInfo::has_totalgameinns() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UserGameInfo::clear_totalgameinns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalgameinns_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t UserGameInfo::totalgameinns() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.totalgameinns)
  return _internal_totalgameinns();
}
inline void UserGameInfo::set_totalgameinns(::int32_t value) {
  _internal_set_totalgameinns(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.totalgameinns)
}
inline ::int32_t UserGameInfo::_internal_totalgameinns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalgameinns_;
}
inline void UserGameInfo::_internal_set_totalgameinns(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalgameinns_ = value;
}

// optional int32 totalwintimes = 8;
inline bool UserGameInfo::has_totalwintimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void UserGameInfo::clear_totalwintimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalwintimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t UserGameInfo::totalwintimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.totalwintimes)
  return _internal_totalwintimes();
}
inline void UserGameInfo::set_totalwintimes(::int32_t value) {
  _internal_set_totalwintimes(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.totalwintimes)
}
inline ::int32_t UserGameInfo::_internal_totalwintimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalwintimes_;
}
inline void UserGameInfo::_internal_set_totalwintimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalwintimes_ = value;
}

// optional int32 herokills = 9;
inline bool UserGameInfo::has_herokills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void UserGameInfo::clear_herokills() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herokills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t UserGameInfo::herokills() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.herokills)
  return _internal_herokills();
}
inline void UserGameInfo::set_herokills(::int32_t value) {
  _internal_set_herokills(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.herokills)
}
inline ::int32_t UserGameInfo::_internal_herokills() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herokills_;
}
inline void UserGameInfo::_internal_set_herokills(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herokills_ = value;
}

// optional int32 destorybuildings = 10;
inline bool UserGameInfo::has_destorybuildings() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void UserGameInfo::clear_destorybuildings() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destorybuildings_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t UserGameInfo::destorybuildings() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.destorybuildings)
  return _internal_destorybuildings();
}
inline void UserGameInfo::set_destorybuildings(::int32_t value) {
  _internal_set_destorybuildings(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.destorybuildings)
}
inline ::int32_t UserGameInfo::_internal_destorybuildings() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destorybuildings_;
}
inline void UserGameInfo::_internal_set_destorybuildings(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destorybuildings_ = value;
}

// optional int32 deadtimes = 11;
inline bool UserGameInfo::has_deadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void UserGameInfo::clear_deadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::int32_t UserGameInfo::deadtimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.deadtimes)
  return _internal_deadtimes();
}
inline void UserGameInfo::set_deadtimes(::int32_t value) {
  _internal_set_deadtimes(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.deadtimes)
}
inline ::int32_t UserGameInfo::_internal_deadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadtimes_;
}
inline void UserGameInfo::_internal_set_deadtimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = value;
}

// optional int32 total_achnum = 12;
inline bool UserGameInfo::has_total_achnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void UserGameInfo::clear_total_achnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_achnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t UserGameInfo::total_achnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.total_achnum)
  return _internal_total_achnum();
}
inline void UserGameInfo::set_total_achnum(::int32_t value) {
  _internal_set_total_achnum(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.total_achnum)
}
inline ::int32_t UserGameInfo::_internal_total_achnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_achnum_;
}
inline void UserGameInfo::_internal_set_total_achnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.total_achnum_ = value;
}

// optional int32 achnum = 13;
inline bool UserGameInfo::has_achnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void UserGameInfo::clear_achnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int32_t UserGameInfo::achnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.achnum)
  return _internal_achnum();
}
inline void UserGameInfo::set_achnum(::int32_t value) {
  _internal_set_achnum(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.achnum)
}
inline ::int32_t UserGameInfo::_internal_achnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.achnum_;
}
inline void UserGameInfo::_internal_set_achnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.achnum_ = value;
}

// optional int32 vipscore = 14;
inline bool UserGameInfo::has_vipscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void UserGameInfo::clear_vipscore() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vipscore_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t UserGameInfo::vipscore() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.vipscore)
  return _internal_vipscore();
}
inline void UserGameInfo::set_vipscore(::int32_t value) {
  _internal_set_vipscore(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.vipscore)
}
inline ::int32_t UserGameInfo::_internal_vipscore() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vipscore_;
}
inline void UserGameInfo::_internal_set_vipscore(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.vipscore_ = value;
}

// optional int32 assistnum = 15;
inline bool UserGameInfo::has_assistnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void UserGameInfo::clear_assistnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assistnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t UserGameInfo::assistnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.assistnum)
  return _internal_assistnum();
}
inline void UserGameInfo::set_assistnum(::int32_t value) {
  _internal_set_assistnum(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.assistnum)
}
inline ::int32_t UserGameInfo::_internal_assistnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assistnum_;
}
inline void UserGameInfo::_internal_set_assistnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assistnum_ = value;
}

// optional int32 ladderscore = 16;
inline bool UserGameInfo::has_ladderscore() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void UserGameInfo::clear_ladderscore() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ladderscore_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::int32_t UserGameInfo::ladderscore() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.ladderscore)
  return _internal_ladderscore();
}
inline void UserGameInfo::set_ladderscore(::int32_t value) {
  _internal_set_ladderscore(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.ladderscore)
}
inline ::int32_t UserGameInfo::_internal_ladderscore() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ladderscore_;
}
inline void UserGameInfo::_internal_set_ladderscore(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ladderscore_ = value;
}

// optional string guildname = 17;
inline bool UserGameInfo::has_guildname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserGameInfo::clear_guildname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guildname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UserGameInfo::guildname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.guildname)
  return _internal_guildname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UserGameInfo::set_guildname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.guildname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.guildname)
}
inline std::string* UserGameInfo::mutable_guildname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_guildname();
  // @@protoc_insertion_point(field_mutable:GSToGC.UserGameInfo.guildname)
  return _s;
}
inline const std::string& UserGameInfo::_internal_guildname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guildname_.Get();
}
inline void UserGameInfo::_internal_set_guildname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.guildname_.Set(value, GetArena());
}
inline std::string* UserGameInfo::_internal_mutable_guildname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.guildname_.Mutable( GetArena());
}
inline std::string* UserGameInfo::release_guildname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.UserGameInfo.guildname)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.guildname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.guildname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void UserGameInfo::set_allocated_guildname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.guildname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.guildname_.IsDefault()) {
          _impl_.guildname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.UserGameInfo.guildname)
}

// optional int64 exp_adtime = 18;
inline bool UserGameInfo::has_exp_adtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline void UserGameInfo::clear_exp_adtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_adtime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::int64_t UserGameInfo::exp_adtime() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.exp_adtime)
  return _internal_exp_adtime();
}
inline void UserGameInfo::set_exp_adtime(::int64_t value) {
  _internal_set_exp_adtime(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.exp_adtime)
}
inline ::int64_t UserGameInfo::_internal_exp_adtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_adtime_;
}
inline void UserGameInfo::_internal_set_exp_adtime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_adtime_ = value;
}

// optional int64 gold_addtime = 19;
inline bool UserGameInfo::has_gold_addtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline void UserGameInfo::clear_gold_addtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_addtime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00020000u;
}
inline ::int64_t UserGameInfo::gold_addtime() const {
  // @@protoc_insertion_point(field_get:GSToGC.UserGameInfo.gold_addtime)
  return _internal_gold_addtime();
}
inline void UserGameInfo::set_gold_addtime(::int64_t value) {
  _internal_set_gold_addtime(value);
  _impl_._has_bits_[0] |= 0x00020000u;
  // @@protoc_insertion_point(field_set:GSToGC.UserGameInfo.gold_addtime)
}
inline ::int64_t UserGameInfo::_internal_gold_addtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gold_addtime_;
}
inline void UserGameInfo::_internal_set_gold_addtime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_addtime_ = value;
}

// -------------------------------------------------------------------

// HeroKills

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroKills];
inline bool HeroKills::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HeroKills::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 47;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID HeroKills::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroKills.msgid)
  return _internal_msgid();
}
inline void HeroKills::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroKills.msgid)
}
inline ::GSToGC::MsgID HeroKills::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HeroKills::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool HeroKills::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HeroKills::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t HeroKills::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroKills.guid)
  return _internal_guid();
}
inline void HeroKills::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroKills.guid)
}
inline ::uint64_t HeroKills::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void HeroKills::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 kills = 3;
inline bool HeroKills::has_kills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HeroKills::clear_kills() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kills_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t HeroKills::kills() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroKills.kills)
  return _internal_kills();
}
inline void HeroKills::set_kills(::int32_t value) {
  _internal_set_kills(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroKills.kills)
}
inline ::int32_t HeroKills::_internal_kills() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.kills_;
}
inline void HeroKills::_internal_set_kills(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.kills_ = value;
}

// -------------------------------------------------------------------

// CurDeadTimes

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurDeadTimes];
inline bool CurDeadTimes::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CurDeadTimes::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 48;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::GSToGC::MsgID CurDeadTimes::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.msgid)
  return _internal_msgid();
}
inline void CurDeadTimes::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.msgid)
}
inline ::GSToGC::MsgID CurDeadTimes::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void CurDeadTimes::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 objguid = 2;
inline bool CurDeadTimes::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CurDeadTimes::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CurDeadTimes::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.objguid)
  return _internal_objguid();
}
inline void CurDeadTimes::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.objguid)
}
inline ::uint64_t CurDeadTimes::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void CurDeadTimes::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional int32 deadtimes = 3;
inline bool CurDeadTimes::has_deadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CurDeadTimes::clear_deadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CurDeadTimes::deadtimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.deadtimes)
  return _internal_deadtimes();
}
inline void CurDeadTimes::set_deadtimes(::int32_t value) {
  _internal_set_deadtimes(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.deadtimes)
}
inline ::int32_t CurDeadTimes::_internal_deadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadtimes_;
}
inline void CurDeadTimes::_internal_set_deadtimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = value;
}

// optional int32 killer_camp = 4;
inline bool CurDeadTimes::has_killer_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CurDeadTimes::clear_killer_camp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_camp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CurDeadTimes::killer_camp() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.killer_camp)
  return _internal_killer_camp();
}
inline void CurDeadTimes::set_killer_camp(::int32_t value) {
  _internal_set_killer_camp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.killer_camp)
}
inline ::int32_t CurDeadTimes::_internal_killer_camp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.killer_camp_;
}
inline void CurDeadTimes::_internal_set_killer_camp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_camp_ = value;
}

// optional uint64 reasonheroguid = 5;
inline bool CurDeadTimes::has_reasonheroguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CurDeadTimes::clear_reasonheroguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reasonheroguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t CurDeadTimes::reasonheroguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.reasonheroguid)
  return _internal_reasonheroguid();
}
inline void CurDeadTimes::set_reasonheroguid(::uint64_t value) {
  _internal_set_reasonheroguid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.reasonheroguid)
}
inline ::uint64_t CurDeadTimes::_internal_reasonheroguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reasonheroguid_;
}
inline void CurDeadTimes::_internal_set_reasonheroguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reasonheroguid_ = value;
}

// optional bool ifAced = 6;
inline bool CurDeadTimes::has_ifaced() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CurDeadTimes::clear_ifaced() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifaced_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CurDeadTimes::ifaced() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.ifAced)
  return _internal_ifaced();
}
inline void CurDeadTimes::set_ifaced(bool value) {
  _internal_set_ifaced(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.ifAced)
}
inline bool CurDeadTimes::_internal_ifaced() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifaced_;
}
inline void CurDeadTimes::_internal_set_ifaced(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifaced_ = value;
}

// optional int32 camp = 7;
inline bool CurDeadTimes::has_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CurDeadTimes::clear_camp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t CurDeadTimes::camp() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.camp)
  return _internal_camp();
}
inline void CurDeadTimes::set_camp(::int32_t value) {
  _internal_set_camp(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.camp)
}
inline ::int32_t CurDeadTimes::_internal_camp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camp_;
}
inline void CurDeadTimes::_internal_set_camp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = value;
}

// optional int32 herostate = 8;
inline bool CurDeadTimes::has_herostate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CurDeadTimes::clear_herostate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herostate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t CurDeadTimes::herostate() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.herostate)
  return _internal_herostate();
}
inline void CurDeadTimes::set_herostate(::int32_t value) {
  _internal_set_herostate(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.herostate)
}
inline ::int32_t CurDeadTimes::_internal_herostate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herostate_;
}
inline void CurDeadTimes::_internal_set_herostate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herostate_ = value;
}

// optional int32 herotitle = 9;
inline bool CurDeadTimes::has_herotitle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CurDeadTimes::clear_herotitle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herotitle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t CurDeadTimes::herotitle() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurDeadTimes.herotitle)
  return _internal_herotitle();
}
inline void CurDeadTimes::set_herotitle(::int32_t value) {
  _internal_set_herotitle(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.CurDeadTimes.herotitle)
}
inline ::int32_t CurDeadTimes::_internal_herotitle() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herotitle_;
}
inline void CurDeadTimes::_internal_set_herotitle(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herotitle_ = value;
}

// -------------------------------------------------------------------

// CurCP

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurCP];
inline bool CurCP::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CurCP::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 49;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID CurCP::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurCP.msgid)
  return _internal_msgid();
}
inline void CurCP::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.CurCP.msgid)
}
inline ::GSToGC::MsgID CurCP::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void CurCP::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 targetguid = 2;
inline bool CurCP::has_targetguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CurCP::clear_targetguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CurCP::targetguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurCP.targetguid)
  return _internal_targetguid();
}
inline void CurCP::set_targetguid(::uint64_t value) {
  _internal_set_targetguid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.CurCP.targetguid)
}
inline ::uint64_t CurCP::_internal_targetguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetguid_;
}
inline void CurCP::_internal_set_targetguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetguid_ = value;
}

// optional int32 person_cp = 3;
inline bool CurCP::has_person_cp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CurCP::clear_person_cp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.person_cp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CurCP::person_cp() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurCP.person_cp)
  return _internal_person_cp();
}
inline void CurCP::set_person_cp(::int32_t value) {
  _internal_set_person_cp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.CurCP.person_cp)
}
inline ::int32_t CurCP::_internal_person_cp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.person_cp_;
}
inline void CurCP::_internal_set_person_cp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.person_cp_ = value;
}

// optional int32 team_cp = 4;
inline bool CurCP::has_team_cp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CurCP::clear_team_cp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_cp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CurCP::team_cp() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurCP.team_cp)
  return _internal_team_cp();
}
inline void CurCP::set_team_cp(::int32_t value) {
  _internal_set_team_cp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.CurCP.team_cp)
}
inline ::int32_t CurCP::_internal_team_cp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.team_cp_;
}
inline void CurCP::_internal_set_team_cp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.team_cp_ = value;
}

// -------------------------------------------------------------------

// CurAtkSpeed_SpeedInfo

// optional uint64 guid = 1;
inline bool CurAtkSpeed_SpeedInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CurAtkSpeed_SpeedInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t CurAtkSpeed_SpeedInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurAtkSpeed.SpeedInfo.guid)
  return _internal_guid();
}
inline void CurAtkSpeed_SpeedInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.CurAtkSpeed.SpeedInfo.guid)
}
inline ::uint64_t CurAtkSpeed_SpeedInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void CurAtkSpeed_SpeedInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 speed = 2;
inline bool CurAtkSpeed_SpeedInfo::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CurAtkSpeed_SpeedInfo::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CurAtkSpeed_SpeedInfo::speed() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurAtkSpeed.SpeedInfo.speed)
  return _internal_speed();
}
inline void CurAtkSpeed_SpeedInfo::set_speed(::int32_t value) {
  _internal_set_speed(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.CurAtkSpeed.SpeedInfo.speed)
}
inline ::int32_t CurAtkSpeed_SpeedInfo::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void CurAtkSpeed_SpeedInfo::_internal_set_speed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// CurAtkSpeed

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyCurAtkSpeed];
inline bool CurAtkSpeed::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CurAtkSpeed::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 50;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID CurAtkSpeed::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CurAtkSpeed.msgid)
  return _internal_msgid();
}
inline void CurAtkSpeed::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.CurAtkSpeed.msgid)
}
inline ::GSToGC::MsgID CurAtkSpeed::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void CurAtkSpeed::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.CurAtkSpeed.SpeedInfo info = 2;
inline int CurAtkSpeed::_internal_info_size() const {
  return _internal_info().size();
}
inline int CurAtkSpeed::info_size() const {
  return _internal_info_size();
}
inline void CurAtkSpeed::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::GSToGC::CurAtkSpeed_SpeedInfo* CurAtkSpeed::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.CurAtkSpeed.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>* CurAtkSpeed::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.CurAtkSpeed.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::GSToGC::CurAtkSpeed_SpeedInfo& CurAtkSpeed::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.CurAtkSpeed.info)
  return _internal_info().Get(index);
}
inline ::GSToGC::CurAtkSpeed_SpeedInfo* CurAtkSpeed::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::CurAtkSpeed_SpeedInfo* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.CurAtkSpeed.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>& CurAtkSpeed::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.CurAtkSpeed.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>&
CurAtkSpeed::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::CurAtkSpeed_SpeedInfo>*
CurAtkSpeed::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// -------------------------------------------------------------------

// FuryVal

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyFuryValue];
inline bool FuryVal::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FuryVal::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 51;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID FuryVal::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FuryVal.msgid)
  return _internal_msgid();
}
inline void FuryVal::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.FuryVal.msgid)
}
inline ::GSToGC::MsgID FuryVal::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void FuryVal::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool FuryVal::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FuryVal::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t FuryVal::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FuryVal.guid)
  return _internal_guid();
}
inline void FuryVal::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.FuryVal.guid)
}
inline ::uint64_t FuryVal::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void FuryVal::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 fury = 3;
inline bool FuryVal::has_fury() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FuryVal::clear_fury() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fury_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t FuryVal::fury() const {
  // @@protoc_insertion_point(field_get:GSToGC.FuryVal.fury)
  return _internal_fury();
}
inline void FuryVal::set_fury(::int32_t value) {
  _internal_set_fury(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.FuryVal.fury)
}
inline ::int32_t FuryVal::_internal_fury() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fury_;
}
inline void FuryVal::_internal_set_fury(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fury_ = value;
}

// -------------------------------------------------------------------

// FuryState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyFuryState];
inline bool FuryState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FuryState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 52;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID FuryState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FuryState.msgid)
  return _internal_msgid();
}
inline void FuryState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.FuryState.msgid)
}
inline ::GSToGC::MsgID FuryState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void FuryState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool FuryState::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FuryState::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t FuryState::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.FuryState.guid)
  return _internal_guid();
}
inline void FuryState::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.FuryState.guid)
}
inline ::uint64_t FuryState::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void FuryState::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 state = 3;
inline bool FuryState::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FuryState::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t FuryState::state() const {
  // @@protoc_insertion_point(field_get:GSToGC.FuryState.state)
  return _internal_state();
}
inline void FuryState::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.FuryState.state)
}
inline ::int32_t FuryState::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void FuryState::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// NotifyHeroReborn

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroReborn];
inline bool NotifyHeroReborn::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyHeroReborn::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 110;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyHeroReborn::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyHeroReborn.msgid)
  return _internal_msgid();
}
inline void NotifyHeroReborn::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyHeroReborn.msgid)
}
inline ::GSToGC::MsgID NotifyHeroReborn::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyHeroReborn::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// RebornTimes

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyHeroRebornTimes];
inline bool RebornTimes::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RebornTimes::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 53;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID RebornTimes::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornTimes.msgid)
  return _internal_msgid();
}
inline void RebornTimes::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornTimes.msgid)
}
inline ::GSToGC::MsgID RebornTimes::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void RebornTimes::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 masterguid = 2;
inline bool RebornTimes::has_masterguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RebornTimes::clear_masterguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.masterguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t RebornTimes::masterguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornTimes.masterguid)
  return _internal_masterguid();
}
inline void RebornTimes::set_masterguid(::uint64_t value) {
  _internal_set_masterguid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornTimes.masterguid)
}
inline ::uint64_t RebornTimes::_internal_masterguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.masterguid_;
}
inline void RebornTimes::_internal_set_masterguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.masterguid_ = value;
}

// optional int64 sendtimes = 3;
inline bool RebornTimes::has_sendtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RebornTimes::clear_sendtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sendtimes_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t RebornTimes::sendtimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornTimes.sendtimes)
  return _internal_sendtimes();
}
inline void RebornTimes::set_sendtimes(::int64_t value) {
  _internal_set_sendtimes(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornTimes.sendtimes)
}
inline ::int64_t RebornTimes::_internal_sendtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sendtimes_;
}
inline void RebornTimes::_internal_set_sendtimes(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sendtimes_ = value;
}

// optional int64 gold = 4;
inline bool RebornTimes::has_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RebornTimes::clear_gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int64_t RebornTimes::gold() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornTimes.gold)
  return _internal_gold();
}
inline void RebornTimes::set_gold(::int64_t value) {
  _internal_set_gold(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornTimes.gold)
}
inline ::int64_t RebornTimes::_internal_gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gold_;
}
inline void RebornTimes::_internal_set_gold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = value;
}

// optional int32 remain_times = 5;
inline bool RebornTimes::has_remain_times() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RebornTimes::clear_remain_times() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remain_times_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t RebornTimes::remain_times() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornTimes.remain_times)
  return _internal_remain_times();
}
inline void RebornTimes::set_remain_times(::int32_t value) {
  _internal_set_remain_times(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornTimes.remain_times)
}
inline ::int32_t RebornTimes::_internal_remain_times() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remain_times_;
}
inline void RebornTimes::_internal_set_remain_times(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remain_times_ = value;
}

// optional int32 reborn_time = 6;
inline bool RebornTimes::has_reborn_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RebornTimes::clear_reborn_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reborn_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t RebornTimes::reborn_time() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornTimes.reborn_time)
  return _internal_reborn_time();
}
inline void RebornTimes::set_reborn_time(::int32_t value) {
  _internal_set_reborn_time(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornTimes.reborn_time)
}
inline ::int32_t RebornTimes::_internal_reborn_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reborn_time_;
}
inline void RebornTimes::_internal_set_reborn_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reborn_time_ = value;
}

// -------------------------------------------------------------------

// RebornSuccess

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBuyRebornSuccess];
inline bool RebornSuccess::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RebornSuccess::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 54;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID RebornSuccess::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornSuccess.msgid)
  return _internal_msgid();
}
inline void RebornSuccess::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornSuccess.msgid)
}
inline ::GSToGC::MsgID RebornSuccess::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void RebornSuccess::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool RebornSuccess::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RebornSuccess::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t RebornSuccess::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RebornSuccess.guid)
  return _internal_guid();
}
inline void RebornSuccess::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.RebornSuccess.guid)
}
inline ::uint64_t RebornSuccess::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void RebornSuccess::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// -------------------------------------------------------------------

// PersonCPChange

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPersonalCPChange];
inline bool PersonCPChange::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PersonCPChange::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 56;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID PersonCPChange::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PersonCPChange.msgid)
  return _internal_msgid();
}
inline void PersonCPChange::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.PersonCPChange.msgid)
}
inline ::GSToGC::MsgID PersonCPChange::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void PersonCPChange::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool PersonCPChange::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PersonCPChange::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t PersonCPChange::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PersonCPChange.guid)
  return _internal_guid();
}
inline void PersonCPChange::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.PersonCPChange.guid)
}
inline ::uint64_t PersonCPChange::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void PersonCPChange::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 cp = 3;
inline bool PersonCPChange::has_cp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PersonCPChange::clear_cp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t PersonCPChange::cp() const {
  // @@protoc_insertion_point(field_get:GSToGC.PersonCPChange.cp)
  return _internal_cp();
}
inline void PersonCPChange::set_cp(::int32_t value) {
  _internal_set_cp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.PersonCPChange.cp)
}
inline ::int32_t PersonCPChange::_internal_cp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cp_;
}
inline void PersonCPChange::_internal_set_cp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cp_ = value;
}

// -------------------------------------------------------------------

// BroadcastBatteleRes_ResInfo

// optional uint64 objguid = 1;
inline bool BroadcastBatteleRes_ResInfo::has_objguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_objguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BroadcastBatteleRes_ResInfo::objguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.objguid)
  return _internal_objguid();
}
inline void BroadcastBatteleRes_ResInfo::set_objguid(::uint64_t value) {
  _internal_set_objguid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.objguid)
}
inline ::uint64_t BroadcastBatteleRes_ResInfo::_internal_objguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objguid_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_objguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objguid_ = value;
}

// optional int32 heroid = 2;
inline bool BroadcastBatteleRes_ResInfo::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.heroid)
  return _internal_heroid();
}
inline void BroadcastBatteleRes_ResInfo::set_heroid(::int32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.heroid)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// optional string nickname = 3;
inline bool BroadcastBatteleRes_ResInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BroadcastBatteleRes_ResInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BroadcastBatteleRes_ResInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.nickname)
}
inline std::string* BroadcastBatteleRes_ResInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.BroadcastBatteleRes.ResInfo.nickname)
  return _s;
}
inline const std::string& BroadcastBatteleRes_ResInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* BroadcastBatteleRes_ResInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* BroadcastBatteleRes_ResInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.BroadcastBatteleRes.ResInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BroadcastBatteleRes_ResInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.BroadcastBatteleRes.ResInfo.nickname)
}

// optional int32 curlevel = 4;
inline bool BroadcastBatteleRes_ResInfo::has_curlevel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_curlevel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curlevel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::curlevel() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.curlevel)
  return _internal_curlevel();
}
inline void BroadcastBatteleRes_ResInfo::set_curlevel(::int32_t value) {
  _internal_set_curlevel(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.curlevel)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_curlevel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curlevel_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_curlevel(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curlevel_ = value;
}

// optional int32 killtimes = 5;
inline bool BroadcastBatteleRes_ResInfo::has_killtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_killtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killtimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::killtimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.killtimes)
  return _internal_killtimes();
}
inline void BroadcastBatteleRes_ResInfo::set_killtimes(::int32_t value) {
  _internal_set_killtimes(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.killtimes)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_killtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.killtimes_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_killtimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killtimes_ = value;
}

// optional int32 deadtimes = 6;
inline bool BroadcastBatteleRes_ResInfo::has_deadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_deadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::deadtimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.deadtimes)
  return _internal_deadtimes();
}
inline void BroadcastBatteleRes_ResInfo::set_deadtimes(::int32_t value) {
  _internal_set_deadtimes(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.deadtimes)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_deadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadtimes_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_deadtimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = value;
}

// optional int32 asstimes = 7;
inline bool BroadcastBatteleRes_ResInfo::has_asstimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_asstimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.asstimes_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::asstimes() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.asstimes)
  return _internal_asstimes();
}
inline void BroadcastBatteleRes_ResInfo::set_asstimes(::int32_t value) {
  _internal_set_asstimes(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.asstimes)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_asstimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.asstimes_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_asstimes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.asstimes_ = value;
}

// optional int32 totalcp = 8;
inline bool BroadcastBatteleRes_ResInfo::has_totalcp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_totalcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalcp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::totalcp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.totalcp)
  return _internal_totalcp();
}
inline void BroadcastBatteleRes_ResInfo::set_totalcp(::int32_t value) {
  _internal_set_totalcp(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.totalcp)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_totalcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalcp_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_totalcp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalcp_ = value;
}

// optional int32 lasthit = 9;
inline bool BroadcastBatteleRes_ResInfo::has_lasthit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_lasthit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lasthit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::lasthit() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.lasthit)
  return _internal_lasthit();
}
inline void BroadcastBatteleRes_ResInfo::set_lasthit(::int32_t value) {
  _internal_set_lasthit(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.lasthit)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_lasthit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lasthit_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_lasthit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lasthit_ = value;
}

// optional int32 camgpid = 10;
inline bool BroadcastBatteleRes_ResInfo::has_camgpid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void BroadcastBatteleRes_ResInfo::clear_camgpid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camgpid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::int32_t BroadcastBatteleRes_ResInfo::camgpid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ResInfo.camgpid)
  return _internal_camgpid();
}
inline void BroadcastBatteleRes_ResInfo::set_camgpid(::int32_t value) {
  _internal_set_camgpid(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ResInfo.camgpid)
}
inline ::int32_t BroadcastBatteleRes_ResInfo::_internal_camgpid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camgpid_;
}
inline void BroadcastBatteleRes_ResInfo::_internal_set_camgpid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camgpid_ = value;
}

// -------------------------------------------------------------------

// BroadcastBatteleRes

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadCurBattleResult];
inline bool BroadcastBatteleRes::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BroadcastBatteleRes::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 57;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID BroadcastBatteleRes::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.msgid)
  return _internal_msgid();
}
inline void BroadcastBatteleRes::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.msgid)
}
inline ::GSToGC::MsgID BroadcastBatteleRes::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BroadcastBatteleRes::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional bool ifwin = 2;
inline bool BroadcastBatteleRes::has_ifwin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BroadcastBatteleRes::clear_ifwin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifwin_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool BroadcastBatteleRes::ifwin() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.ifwin)
  return _internal_ifwin();
}
inline void BroadcastBatteleRes::set_ifwin(bool value) {
  _internal_set_ifwin(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBatteleRes.ifwin)
}
inline bool BroadcastBatteleRes::_internal_ifwin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifwin_;
}
inline void BroadcastBatteleRes::_internal_set_ifwin(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifwin_ = value;
}

// repeated .GSToGC.BroadcastBatteleRes.ResInfo resinfo = 3;
inline int BroadcastBatteleRes::_internal_resinfo_size() const {
  return _internal_resinfo().size();
}
inline int BroadcastBatteleRes::resinfo_size() const {
  return _internal_resinfo_size();
}
inline void BroadcastBatteleRes::clear_resinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resinfo_.Clear();
}
inline ::GSToGC::BroadcastBatteleRes_ResInfo* BroadcastBatteleRes::mutable_resinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.BroadcastBatteleRes.resinfo)
  return _internal_mutable_resinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>* BroadcastBatteleRes::mutable_resinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.BroadcastBatteleRes.resinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_resinfo();
}
inline const ::GSToGC::BroadcastBatteleRes_ResInfo& BroadcastBatteleRes::resinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBatteleRes.resinfo)
  return _internal_resinfo().Get(index);
}
inline ::GSToGC::BroadcastBatteleRes_ResInfo* BroadcastBatteleRes::add_resinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::BroadcastBatteleRes_ResInfo* _add = _internal_mutable_resinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.BroadcastBatteleRes.resinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>& BroadcastBatteleRes::resinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.BroadcastBatteleRes.resinfo)
  return _internal_resinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>&
BroadcastBatteleRes::_internal_resinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::BroadcastBatteleRes_ResInfo>*
BroadcastBatteleRes::_internal_mutable_resinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.resinfo_;
}

// -------------------------------------------------------------------

// BroadcastBattelePersonalRes

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadBattlePersonalResult];
inline bool BroadcastBattelePersonalRes::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BroadcastBattelePersonalRes::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 233;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::GSToGC::MsgID BroadcastBattelePersonalRes::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattelePersonalRes.msgid)
  return _internal_msgid();
}
inline void BroadcastBattelePersonalRes::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattelePersonalRes.msgid)
}
inline ::GSToGC::MsgID BroadcastBattelePersonalRes::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BroadcastBattelePersonalRes::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 got_gold = 2;
inline bool BroadcastBattelePersonalRes::has_got_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BroadcastBattelePersonalRes::clear_got_gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.got_gold_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t BroadcastBattelePersonalRes::got_gold() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattelePersonalRes.got_gold)
  return _internal_got_gold();
}
inline void BroadcastBattelePersonalRes::set_got_gold(::int64_t value) {
  _internal_set_got_gold(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattelePersonalRes.got_gold)
}
inline ::int64_t BroadcastBattelePersonalRes::_internal_got_gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.got_gold_;
}
inline void BroadcastBattelePersonalRes::_internal_set_got_gold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.got_gold_ = value;
}

// optional int32 old_lv = 3;
inline bool BroadcastBattelePersonalRes::has_old_lv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BroadcastBattelePersonalRes::clear_old_lv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.old_lv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BroadcastBattelePersonalRes::old_lv() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattelePersonalRes.old_lv)
  return _internal_old_lv();
}
inline void BroadcastBattelePersonalRes::set_old_lv(::int32_t value) {
  _internal_set_old_lv(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattelePersonalRes.old_lv)
}
inline ::int32_t BroadcastBattelePersonalRes::_internal_old_lv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.old_lv_;
}
inline void BroadcastBattelePersonalRes::_internal_set_old_lv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.old_lv_ = value;
}

// optional int32 old_exp = 4;
inline bool BroadcastBattelePersonalRes::has_old_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BroadcastBattelePersonalRes::clear_old_exp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.old_exp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BroadcastBattelePersonalRes::old_exp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattelePersonalRes.old_exp)
  return _internal_old_exp();
}
inline void BroadcastBattelePersonalRes::set_old_exp(::int32_t value) {
  _internal_set_old_exp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattelePersonalRes.old_exp)
}
inline ::int32_t BroadcastBattelePersonalRes::_internal_old_exp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.old_exp_;
}
inline void BroadcastBattelePersonalRes::_internal_set_old_exp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.old_exp_ = value;
}

// optional int32 cur_lv = 5;
inline bool BroadcastBattelePersonalRes::has_cur_lv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BroadcastBattelePersonalRes::clear_cur_lv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cur_lv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t BroadcastBattelePersonalRes::cur_lv() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattelePersonalRes.cur_lv)
  return _internal_cur_lv();
}
inline void BroadcastBattelePersonalRes::set_cur_lv(::int32_t value) {
  _internal_set_cur_lv(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattelePersonalRes.cur_lv)
}
inline ::int32_t BroadcastBattelePersonalRes::_internal_cur_lv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cur_lv_;
}
inline void BroadcastBattelePersonalRes::_internal_set_cur_lv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cur_lv_ = value;
}

// optional int32 cur_exp = 6;
inline bool BroadcastBattelePersonalRes::has_cur_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BroadcastBattelePersonalRes::clear_cur_exp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cur_exp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BroadcastBattelePersonalRes::cur_exp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattelePersonalRes.cur_exp)
  return _internal_cur_exp();
}
inline void BroadcastBattelePersonalRes::set_cur_exp(::int32_t value) {
  _internal_set_cur_exp(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattelePersonalRes.cur_exp)
}
inline ::int32_t BroadcastBattelePersonalRes::_internal_cur_exp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.cur_exp_;
}
inline void BroadcastBattelePersonalRes::_internal_set_cur_exp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cur_exp_ = value;
}

// optional int32 got_exp = 7;
inline bool BroadcastBattelePersonalRes::has_got_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BroadcastBattelePersonalRes::clear_got_exp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.got_exp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BroadcastBattelePersonalRes::got_exp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBattelePersonalRes.got_exp)
  return _internal_got_exp();
}
inline void BroadcastBattelePersonalRes::set_got_exp(::int32_t value) {
  _internal_set_got_exp(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBattelePersonalRes.got_exp)
}
inline ::int32_t BroadcastBattelePersonalRes::_internal_got_exp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.got_exp_;
}
inline void BroadcastBattelePersonalRes::_internal_set_got_exp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.got_exp_ = value;
}

// -------------------------------------------------------------------

// BroadcastBuildingDestory

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadBuildingDestroyByWho];
inline bool BroadcastBuildingDestory::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BroadcastBuildingDestory::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 58;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID BroadcastBuildingDestory::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBuildingDestory.msgid)
  return _internal_msgid();
}
inline void BroadcastBuildingDestory::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBuildingDestory.msgid)
}
inline ::GSToGC::MsgID BroadcastBuildingDestory::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BroadcastBuildingDestory::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 buildingguid = 2;
inline bool BroadcastBuildingDestory::has_buildingguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BroadcastBuildingDestory::clear_buildingguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buildingguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t BroadcastBuildingDestory::buildingguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBuildingDestory.buildingguid)
  return _internal_buildingguid();
}
inline void BroadcastBuildingDestory::set_buildingguid(::uint64_t value) {
  _internal_set_buildingguid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBuildingDestory.buildingguid)
}
inline ::uint64_t BroadcastBuildingDestory::_internal_buildingguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buildingguid_;
}
inline void BroadcastBuildingDestory::_internal_set_buildingguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buildingguid_ = value;
}

// optional int32 building_camp = 3;
inline bool BroadcastBuildingDestory::has_building_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BroadcastBuildingDestory::clear_building_camp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.building_camp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BroadcastBuildingDestory::building_camp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBuildingDestory.building_camp)
  return _internal_building_camp();
}
inline void BroadcastBuildingDestory::set_building_camp(::int32_t value) {
  _internal_set_building_camp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBuildingDestory.building_camp)
}
inline ::int32_t BroadcastBuildingDestory::_internal_building_camp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.building_camp_;
}
inline void BroadcastBuildingDestory::_internal_set_building_camp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.building_camp_ = value;
}

// optional uint64 killer_guid = 4;
inline bool BroadcastBuildingDestory::has_killer_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BroadcastBuildingDestory::clear_killer_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t BroadcastBuildingDestory::killer_guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBuildingDestory.killer_guid)
  return _internal_killer_guid();
}
inline void BroadcastBuildingDestory::set_killer_guid(::uint64_t value) {
  _internal_set_killer_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBuildingDestory.killer_guid)
}
inline ::uint64_t BroadcastBuildingDestory::_internal_killer_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.killer_guid_;
}
inline void BroadcastBuildingDestory::_internal_set_killer_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_guid_ = value;
}

// optional int32 killer_camp = 5;
inline bool BroadcastBuildingDestory::has_killer_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BroadcastBuildingDestory::clear_killer_camp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_camp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t BroadcastBuildingDestory::killer_camp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BroadcastBuildingDestory.killer_camp)
  return _internal_killer_camp();
}
inline void BroadcastBuildingDestory::set_killer_camp(::int32_t value) {
  _internal_set_killer_camp(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BroadcastBuildingDestory.killer_camp)
}
inline ::int32_t BroadcastBuildingDestory::_internal_killer_camp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.killer_camp_;
}
inline void BroadcastBuildingDestory::_internal_set_killer_camp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killer_camp_ = value;
}

// -------------------------------------------------------------------

// HeroMoveInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBattleSeatPosInfo];
inline bool HeroMoveInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void HeroMoveInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 9;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID HeroMoveInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroMoveInfo.msgid)
  return _internal_msgid();
}
inline void HeroMoveInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroMoveInfo.msgid)
}
inline ::GSToGC::MsgID HeroMoveInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HeroMoveInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool HeroMoveInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HeroMoveInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t HeroMoveInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HeroMoveInfo.guid)
  return _internal_guid();
}
inline void HeroMoveInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.HeroMoveInfo.guid)
}
inline ::uint64_t HeroMoveInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void HeroMoveInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional .GSToGC.Dir dir = 3;
inline bool HeroMoveInfo::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void HeroMoveInfo::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Dir& HeroMoveInfo::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& HeroMoveInfo::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.HeroMoveInfo.dir)
  return _internal_dir();
}
inline void HeroMoveInfo::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.HeroMoveInfo.dir)
}
inline ::GSToGC::Dir* HeroMoveInfo::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* HeroMoveInfo::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.HeroMoveInfo.dir)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* HeroMoveInfo::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* HeroMoveInfo::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.HeroMoveInfo.dir)
  return _msg;
}
inline void HeroMoveInfo::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.HeroMoveInfo.dir)
}

// optional .GSToGC.Pos pos = 4;
inline bool HeroMoveInfo::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void HeroMoveInfo::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Pos& HeroMoveInfo::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& HeroMoveInfo::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.HeroMoveInfo.pos)
  return _internal_pos();
}
inline void HeroMoveInfo::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.HeroMoveInfo.pos)
}
inline ::GSToGC::Pos* HeroMoveInfo::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* HeroMoveInfo::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.HeroMoveInfo.pos)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* HeroMoveInfo::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* HeroMoveInfo::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.HeroMoveInfo.pos)
  return _msg;
}
inline void HeroMoveInfo::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.HeroMoveInfo.pos)
}

// -------------------------------------------------------------------

// PlayFinishVedio

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_BroadcastPlayFinishVedio];
inline bool PlayFinishVedio::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void PlayFinishVedio::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 61;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID PlayFinishVedio::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PlayFinishVedio.msgid)
  return _internal_msgid();
}
inline void PlayFinishVedio::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.PlayFinishVedio.msgid)
}
inline ::GSToGC::MsgID PlayFinishVedio::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void PlayFinishVedio::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 wincamp = 2;
inline bool PlayFinishVedio::has_wincamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void PlayFinishVedio::clear_wincamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wincamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t PlayFinishVedio::wincamp() const {
  // @@protoc_insertion_point(field_get:GSToGC.PlayFinishVedio.wincamp)
  return _internal_wincamp();
}
inline void PlayFinishVedio::set_wincamp(::int32_t value) {
  _internal_set_wincamp(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.PlayFinishVedio.wincamp)
}
inline ::int32_t PlayFinishVedio::_internal_wincamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wincamp_;
}
inline void PlayFinishVedio::_internal_set_wincamp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wincamp_ = value;
}

// optional int32 losercamp = 3;
inline bool PlayFinishVedio::has_losercamp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void PlayFinishVedio::clear_losercamp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.losercamp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t PlayFinishVedio::losercamp() const {
  // @@protoc_insertion_point(field_get:GSToGC.PlayFinishVedio.losercamp)
  return _internal_losercamp();
}
inline void PlayFinishVedio::set_losercamp(::int32_t value) {
  _internal_set_losercamp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.PlayFinishVedio.losercamp)
}
inline ::int32_t PlayFinishVedio::_internal_losercamp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.losercamp_;
}
inline void PlayFinishVedio::_internal_set_losercamp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.losercamp_ = value;
}

// optional int32 mapid = 4;
inline bool PlayFinishVedio::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void PlayFinishVedio::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t PlayFinishVedio::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PlayFinishVedio.mapid)
  return _internal_mapid();
}
inline void PlayFinishVedio::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.PlayFinishVedio.mapid)
}
inline ::int32_t PlayFinishVedio::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void PlayFinishVedio::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional uint64 guid = 5;
inline bool PlayFinishVedio::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void PlayFinishVedio::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t PlayFinishVedio::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.PlayFinishVedio.guid)
  return _internal_guid();
}
inline void PlayFinishVedio::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.PlayFinishVedio.guid)
}
inline ::uint64_t PlayFinishVedio::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void PlayFinishVedio::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// -------------------------------------------------------------------

// LeaveBattleSuccess

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyLeaveBattleSuccess];
inline bool LeaveBattleSuccess::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LeaveBattleSuccess::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 62;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID LeaveBattleSuccess::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LeaveBattleSuccess.msgid)
  return _internal_msgid();
}
inline void LeaveBattleSuccess::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.LeaveBattleSuccess.msgid)
}
inline ::GSToGC::MsgID LeaveBattleSuccess::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void LeaveBattleSuccess::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// BornSoler

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBornSolder];
inline bool BornSoler::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BornSoler::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 63;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID BornSoler::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BornSoler.msgid)
  return _internal_msgid();
}
inline void BornSoler::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.BornSoler.msgid)
}
inline ::GSToGC::MsgID BornSoler::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BornSoler::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 type = 2;
inline bool BornSoler::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BornSoler::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t BornSoler::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.BornSoler.type)
  return _internal_type();
}
inline void BornSoler::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BornSoler.type)
}
inline ::int32_t BornSoler::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void BornSoler::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional int32 camp = 3;
inline bool BornSoler::has_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BornSoler::clear_camp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BornSoler::camp() const {
  // @@protoc_insertion_point(field_get:GSToGC.BornSoler.camp)
  return _internal_camp();
}
inline void BornSoler::set_camp(::int32_t value) {
  _internal_set_camp(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BornSoler.camp)
}
inline ::int32_t BornSoler::_internal_camp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camp_;
}
inline void BornSoler::_internal_set_camp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = value;
}

// optional .GSToGC.Pos pos = 4;
inline bool BornSoler::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void BornSoler::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& BornSoler::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& BornSoler::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.BornSoler.pos)
  return _internal_pos();
}
inline void BornSoler::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.BornSoler.pos)
}
inline ::GSToGC::Pos* BornSoler::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* BornSoler::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.BornSoler.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* BornSoler::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* BornSoler::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.BornSoler.pos)
  return _msg;
}
inline void BornSoler::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.BornSoler.pos)
}

// optional uint64 guid = 5;
inline bool BornSoler::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BornSoler::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BornSoler::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BornSoler.guid)
  return _internal_guid();
}
inline void BornSoler::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BornSoler.guid)
}
inline ::uint64_t BornSoler::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void BornSoler::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// -------------------------------------------------------------------

// SkillEnd

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillEnd];
inline bool SkillEnd::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void SkillEnd::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 64;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::GSToGC::MsgID SkillEnd::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEnd.msgid)
  return _internal_msgid();
}
inline void SkillEnd::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEnd.msgid)
}
inline ::GSToGC::MsgID SkillEnd::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void SkillEnd::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 guid = 2;
inline bool SkillEnd::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SkillEnd::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t SkillEnd::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEnd.guid)
  return _internal_guid();
}
inline void SkillEnd::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEnd.guid)
}
inline ::int64_t SkillEnd::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void SkillEnd::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool SkillEnd::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SkillEnd::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t SkillEnd::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEnd.skillid)
  return _internal_skillid();
}
inline void SkillEnd::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEnd.skillid)
}
inline ::int32_t SkillEnd::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void SkillEnd::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional int64 targuid = 4;
inline bool SkillEnd::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SkillEnd::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t SkillEnd::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEnd.targuid)
  return _internal_targuid();
}
inline void SkillEnd::set_targuid(::int64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEnd.targuid)
}
inline ::int64_t SkillEnd::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void SkillEnd::_internal_set_targuid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional int32 uniqueid = 5;
inline bool SkillEnd::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SkillEnd::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t SkillEnd::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SkillEnd.uniqueid)
  return _internal_uniqueid();
}
inline void SkillEnd::set_uniqueid(::int32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.SkillEnd.uniqueid)
}
inline ::int32_t SkillEnd::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void SkillEnd::_internal_set_uniqueid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// -------------------------------------------------------------------

// AltarBSIco

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAltarBSIco];
inline bool AltarBSIco::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AltarBSIco::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 65;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID AltarBSIco::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AltarBSIco.msgid)
  return _internal_msgid();
}
inline void AltarBSIco::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.AltarBSIco.msgid)
}
inline ::GSToGC::MsgID AltarBSIco::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void AltarBSIco::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 index = 2;
inline bool AltarBSIco::has_index() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AltarBSIco::clear_index() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AltarBSIco::index() const {
  // @@protoc_insertion_point(field_get:GSToGC.AltarBSIco.index)
  return _internal_index();
}
inline void AltarBSIco::set_index(::int32_t value) {
  _internal_set_index(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.AltarBSIco.index)
}
inline ::int32_t AltarBSIco::_internal_index() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.index_;
}
inline void AltarBSIco::_internal_set_index(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.index_ = value;
}

// optional int32 type = 3;
inline bool AltarBSIco::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AltarBSIco::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AltarBSIco::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.AltarBSIco.type)
  return _internal_type();
}
inline void AltarBSIco::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.AltarBSIco.type)
}
inline ::int32_t AltarBSIco::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void AltarBSIco::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// optional int32 optype = 4;
inline bool AltarBSIco::has_optype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AltarBSIco::clear_optype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AltarBSIco::optype() const {
  // @@protoc_insertion_point(field_get:GSToGC.AltarBSIco.optype)
  return _internal_optype();
}
inline void AltarBSIco::set_optype(::int32_t value) {
  _internal_set_optype(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.AltarBSIco.optype)
}
inline ::int32_t AltarBSIco::_internal_optype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.optype_;
}
inline void AltarBSIco::_internal_set_optype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optype_ = value;
}

// -------------------------------------------------------------------

// GOReleaseSkill

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectReleaseSkill];
inline bool GOReleaseSkill::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void GOReleaseSkill::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 67;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::GSToGC::MsgID GOReleaseSkill::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.msgid)
  return _internal_msgid();
}
inline void GOReleaseSkill::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.GOReleaseSkill.msgid)
}
inline ::GSToGC::MsgID GOReleaseSkill::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GOReleaseSkill::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool GOReleaseSkill::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GOReleaseSkill::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t GOReleaseSkill::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.guid)
  return _internal_guid();
}
inline void GOReleaseSkill::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.GOReleaseSkill.guid)
}
inline ::uint64_t GOReleaseSkill::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void GOReleaseSkill::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool GOReleaseSkill::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void GOReleaseSkill::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t GOReleaseSkill::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.skillid)
  return _internal_skillid();
}
inline void GOReleaseSkill::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.GOReleaseSkill.skillid)
}
inline ::int32_t GOReleaseSkill::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void GOReleaseSkill::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional .GSToGC.SkillState state = 4;
inline bool GOReleaseSkill::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void GOReleaseSkill::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::SkillState GOReleaseSkill::state() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.state)
  return _internal_state();
}
inline void GOReleaseSkill::set_state(::GSToGC::SkillState value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.GOReleaseSkill.state)
}
inline ::GSToGC::SkillState GOReleaseSkill::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::SkillState>(_impl_.state_);
}
inline void GOReleaseSkill::_internal_set_state(::GSToGC::SkillState value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::SkillState_IsValid(value));
  _impl_.state_ = value;
}

// optional .GSToGC.Pos curPos = 5;
inline bool GOReleaseSkill::has_curpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curpos_ != nullptr);
  return value;
}
inline void GOReleaseSkill::clear_curpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.curpos_ != nullptr) _impl_.curpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& GOReleaseSkill::_internal_curpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.curpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& GOReleaseSkill::curpos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.curPos)
  return _internal_curpos();
}
inline void GOReleaseSkill::unsafe_arena_set_allocated_curpos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.curpos_);
  }
  _impl_.curpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.GOReleaseSkill.curPos)
}
inline ::GSToGC::Pos* GOReleaseSkill::release_curpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.curpos_;
  _impl_.curpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* GOReleaseSkill::unsafe_arena_release_curpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GOReleaseSkill.curPos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.curpos_;
  _impl_.curpos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* GOReleaseSkill::_internal_mutable_curpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.curpos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.curpos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.curpos_;
}
inline ::GSToGC::Pos* GOReleaseSkill::mutable_curpos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_curpos();
  // @@protoc_insertion_point(field_mutable:GSToGC.GOReleaseSkill.curPos)
  return _msg;
}
inline void GOReleaseSkill::set_allocated_curpos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.curpos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.curpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GOReleaseSkill.curPos)
}

// optional .GSToGC.Dir curDir = 6;
inline bool GOReleaseSkill::has_curdir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.curdir_ != nullptr);
  return value;
}
inline void GOReleaseSkill::clear_curdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.curdir_ != nullptr) _impl_.curdir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& GOReleaseSkill::_internal_curdir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.curdir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& GOReleaseSkill::curdir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.curDir)
  return _internal_curdir();
}
inline void GOReleaseSkill::unsafe_arena_set_allocated_curdir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.curdir_);
  }
  _impl_.curdir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.GOReleaseSkill.curDir)
}
inline ::GSToGC::Dir* GOReleaseSkill::release_curdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.curdir_;
  _impl_.curdir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* GOReleaseSkill::unsafe_arena_release_curdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GOReleaseSkill.curDir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.curdir_;
  _impl_.curdir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* GOReleaseSkill::_internal_mutable_curdir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.curdir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.curdir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.curdir_;
}
inline ::GSToGC::Dir* GOReleaseSkill::mutable_curdir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_curdir();
  // @@protoc_insertion_point(field_mutable:GSToGC.GOReleaseSkill.curDir)
  return _msg;
}
inline void GOReleaseSkill::set_allocated_curdir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.curdir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.curdir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GOReleaseSkill.curDir)
}

// optional uint64 targuid = 7;
inline bool GOReleaseSkill::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void GOReleaseSkill::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t GOReleaseSkill::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.targuid)
  return _internal_targuid();
}
inline void GOReleaseSkill::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.GOReleaseSkill.targuid)
}
inline ::uint64_t GOReleaseSkill::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void GOReleaseSkill::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional .GSToGC.Pos tarpos = 8;
inline bool GOReleaseSkill::has_tarpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tarpos_ != nullptr);
  return value;
}
inline void GOReleaseSkill::clear_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ != nullptr) _impl_.tarpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::GSToGC::Pos& GOReleaseSkill::_internal_tarpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.tarpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& GOReleaseSkill::tarpos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.GOReleaseSkill.tarpos)
  return _internal_tarpos();
}
inline void GOReleaseSkill::unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tarpos_);
  }
  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.GOReleaseSkill.tarpos)
}
inline ::GSToGC::Pos* GOReleaseSkill::release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::GSToGC::Pos* released = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* GOReleaseSkill::unsafe_arena_release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.GOReleaseSkill.tarpos)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::GSToGC::Pos* temp = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* GOReleaseSkill::_internal_mutable_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.tarpos_;
}
inline ::GSToGC::Pos* GOReleaseSkill::mutable_tarpos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::GSToGC::Pos* _msg = _internal_mutable_tarpos();
  // @@protoc_insertion_point(field_mutable:GSToGC.GOReleaseSkill.tarpos)
  return _msg;
}
inline void GOReleaseSkill::set_allocated_tarpos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.tarpos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.GOReleaseSkill.tarpos)
}

// -------------------------------------------------------------------

// GOSkillCD

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectSkillCD];
inline bool GOSkillCD::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void GOSkillCD::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 68;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID GOSkillCD::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOSkillCD.msgid)
  return _internal_msgid();
}
inline void GOSkillCD::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.GOSkillCD.msgid)
}
inline ::GSToGC::MsgID GOSkillCD::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GOSkillCD::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool GOSkillCD::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GOSkillCD::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t GOSkillCD::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOSkillCD.guid)
  return _internal_guid();
}
inline void GOSkillCD::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GOSkillCD.guid)
}
inline ::uint64_t GOSkillCD::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void GOSkillCD::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool GOSkillCD::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GOSkillCD::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t GOSkillCD::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOSkillCD.skillid)
  return _internal_skillid();
}
inline void GOSkillCD::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GOSkillCD.skillid)
}
inline ::int32_t GOSkillCD::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void GOSkillCD::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional int32 time = 4;
inline bool GOSkillCD::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GOSkillCD::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t GOSkillCD::time() const {
  // @@protoc_insertion_point(field_get:GSToGC.GOSkillCD.time)
  return _internal_time();
}
inline void GOSkillCD::set_time(::int32_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GOSkillCD.time)
}
inline ::int32_t GOSkillCD::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void GOSkillCD::_internal_set_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// EmitSkill

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelEmit];
inline bool EmitSkill::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void EmitSkill::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 69;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::GSToGC::MsgID EmitSkill::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.msgid)
  return _internal_msgid();
}
inline void EmitSkill::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.EmitSkill.msgid)
}
inline ::GSToGC::MsgID EmitSkill::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void EmitSkill::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool EmitSkill::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void EmitSkill::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t EmitSkill::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.guid)
  return _internal_guid();
}
inline void EmitSkill::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.EmitSkill.guid)
}
inline ::uint64_t EmitSkill::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void EmitSkill::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 effectid = 3;
inline bool EmitSkill::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void EmitSkill::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t EmitSkill::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.effectid)
  return _internal_effectid();
}
inline void EmitSkill::set_effectid(::uint32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.EmitSkill.effectid)
}
inline ::uint32_t EmitSkill::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void EmitSkill::_internal_set_effectid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional int32 uniqueid = 4;
inline bool EmitSkill::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void EmitSkill::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t EmitSkill::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.uniqueid)
  return _internal_uniqueid();
}
inline void EmitSkill::set_uniqueid(::int32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.EmitSkill.uniqueid)
}
inline ::int32_t EmitSkill::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void EmitSkill::_internal_set_uniqueid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// optional .GSToGC.Dir dir = 5;
inline bool EmitSkill::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void EmitSkill::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Dir& EmitSkill::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& EmitSkill::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.dir)
  return _internal_dir();
}
inline void EmitSkill::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.EmitSkill.dir)
}
inline ::GSToGC::Dir* EmitSkill::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* EmitSkill::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.EmitSkill.dir)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* EmitSkill::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* EmitSkill::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.EmitSkill.dir)
  return _msg;
}
inline void EmitSkill::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.EmitSkill.dir)
}

// optional uint64 targuid = 6;
inline bool EmitSkill::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void EmitSkill::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t EmitSkill::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.targuid)
  return _internal_targuid();
}
inline void EmitSkill::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.EmitSkill.targuid)
}
inline ::uint64_t EmitSkill::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void EmitSkill::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional .GSToGC.Pos tarpos = 7;
inline bool EmitSkill::has_tarpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tarpos_ != nullptr);
  return value;
}
inline void EmitSkill::clear_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ != nullptr) _impl_.tarpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Pos& EmitSkill::_internal_tarpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.tarpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& EmitSkill::tarpos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.tarpos)
  return _internal_tarpos();
}
inline void EmitSkill::unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tarpos_);
  }
  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.EmitSkill.tarpos)
}
inline ::GSToGC::Pos* EmitSkill::release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* released = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* EmitSkill::unsafe_arena_release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.EmitSkill.tarpos)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* temp = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* EmitSkill::_internal_mutable_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.tarpos_;
}
inline ::GSToGC::Pos* EmitSkill::mutable_tarpos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Pos* _msg = _internal_mutable_tarpos();
  // @@protoc_insertion_point(field_mutable:GSToGC.EmitSkill.tarpos)
  return _msg;
}
inline void EmitSkill::set_allocated_tarpos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.tarpos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.EmitSkill.tarpos)
}

// optional bool ifAbsorbSkill = 8;
inline bool EmitSkill::has_ifabsorbskill() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void EmitSkill::clear_ifabsorbskill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifabsorbskill_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool EmitSkill::ifabsorbskill() const {
  // @@protoc_insertion_point(field_get:GSToGC.EmitSkill.ifAbsorbSkill)
  return _internal_ifabsorbskill();
}
inline void EmitSkill::set_ifabsorbskill(bool value) {
  _internal_set_ifabsorbskill(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.EmitSkill.ifAbsorbSkill)
}
inline bool EmitSkill::_internal_ifabsorbskill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifabsorbskill_;
}
inline void EmitSkill::_internal_set_ifabsorbskill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifabsorbskill_ = value;
}

// -------------------------------------------------------------------

// DestroyEmitEffect

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelEmitDestroy];
inline bool DestroyEmitEffect::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void DestroyEmitEffect::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 70;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID DestroyEmitEffect::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.DestroyEmitEffect.msgid)
  return _internal_msgid();
}
inline void DestroyEmitEffect::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.DestroyEmitEffect.msgid)
}
inline ::GSToGC::MsgID DestroyEmitEffect::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void DestroyEmitEffect::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 uniqueid = 2;
inline bool DestroyEmitEffect::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void DestroyEmitEffect::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t DestroyEmitEffect::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.DestroyEmitEffect.uniqueid)
  return _internal_uniqueid();
}
inline void DestroyEmitEffect::set_uniqueid(::int32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.DestroyEmitEffect.uniqueid)
}
inline ::int32_t DestroyEmitEffect::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void DestroyEmitEffect::_internal_set_uniqueid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// -------------------------------------------------------------------

// HitTar

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelHitTarget];
inline bool HitTar::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void HitTar::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 71;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID HitTar::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HitTar.msgid)
  return _internal_msgid();
}
inline void HitTar::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.HitTar.msgid)
}
inline ::GSToGC::MsgID HitTar::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void HitTar::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool HitTar::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HitTar::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t HitTar::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HitTar.guid)
  return _internal_guid();
}
inline void HitTar::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.HitTar.guid)
}
inline ::uint64_t HitTar::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void HitTar::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 effectid = 3;
inline bool HitTar::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HitTar::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t HitTar::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HitTar.effectid)
  return _internal_effectid();
}
inline void HitTar::set_effectid(::uint32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.HitTar.effectid)
}
inline ::uint32_t HitTar::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void HitTar::_internal_set_effectid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional uint64 targuid = 4;
inline bool HitTar::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HitTar::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t HitTar::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.HitTar.targuid)
  return _internal_targuid();
}
inline void HitTar::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.HitTar.targuid)
}
inline ::uint64_t HitTar::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void HitTar::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// -------------------------------------------------------------------

// RangeEffect

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelRange];
inline bool RangeEffect::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RangeEffect::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 72;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID RangeEffect::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffect.msgid)
  return _internal_msgid();
}
inline void RangeEffect::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.RangeEffect.msgid)
}
inline ::GSToGC::MsgID RangeEffect::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void RangeEffect::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool RangeEffect::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RangeEffect::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t RangeEffect::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffect.guid)
  return _internal_guid();
}
inline void RangeEffect::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RangeEffect.guid)
}
inline ::uint64_t RangeEffect::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void RangeEffect::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 effectid = 3;
inline bool RangeEffect::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RangeEffect::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RangeEffect::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffect.effectid)
  return _internal_effectid();
}
inline void RangeEffect::set_effectid(::uint32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.RangeEffect.effectid)
}
inline ::uint32_t RangeEffect::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void RangeEffect::_internal_set_effectid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional uint32 uniqueid = 4;
inline bool RangeEffect::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RangeEffect::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t RangeEffect::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffect.uniqueid)
  return _internal_uniqueid();
}
inline void RangeEffect::set_uniqueid(::uint32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.RangeEffect.uniqueid)
}
inline ::uint32_t RangeEffect::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void RangeEffect::_internal_set_uniqueid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// optional .GSToGC.Dir dir = 5;
inline bool RangeEffect::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void RangeEffect::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Dir& RangeEffect::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& RangeEffect::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffect.dir)
  return _internal_dir();
}
inline void RangeEffect::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.RangeEffect.dir)
}
inline ::GSToGC::Dir* RangeEffect::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* RangeEffect::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.RangeEffect.dir)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* RangeEffect::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* RangeEffect::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.RangeEffect.dir)
  return _msg;
}
inline void RangeEffect::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.RangeEffect.dir)
}

// optional .GSToGC.Pos pos = 6;
inline bool RangeEffect::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void RangeEffect::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Pos& RangeEffect::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& RangeEffect::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffect.pos)
  return _internal_pos();
}
inline void RangeEffect::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.RangeEffect.pos)
}
inline ::GSToGC::Pos* RangeEffect::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* RangeEffect::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.RangeEffect.pos)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* RangeEffect::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* RangeEffect::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.RangeEffect.pos)
  return _msg;
}
inline void RangeEffect::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.RangeEffect.pos)
}

// -------------------------------------------------------------------

// RangeEffectEnd

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelRangeEnd];
inline bool RangeEffectEnd::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RangeEffectEnd::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 73;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID RangeEffectEnd::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffectEnd.msgid)
  return _internal_msgid();
}
inline void RangeEffectEnd::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RangeEffectEnd.msgid)
}
inline ::GSToGC::MsgID RangeEffectEnd::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void RangeEffectEnd::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool RangeEffectEnd::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RangeEffectEnd::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t RangeEffectEnd::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffectEnd.guid)
  return _internal_guid();
}
inline void RangeEffectEnd::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.RangeEffectEnd.guid)
}
inline ::uint64_t RangeEffectEnd::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void RangeEffectEnd::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 uniqueid = 3;
inline bool RangeEffectEnd::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RangeEffectEnd::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t RangeEffectEnd::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RangeEffectEnd.uniqueid)
  return _internal_uniqueid();
}
inline void RangeEffectEnd::set_uniqueid(::uint32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RangeEffectEnd.uniqueid)
}
inline ::uint32_t RangeEffectEnd::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void RangeEffectEnd::_internal_set_uniqueid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// -------------------------------------------------------------------

// SummonEffect

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelSummonEffect];
inline bool SummonEffect::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void SummonEffect::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 75;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID SummonEffect::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SummonEffect.msgid)
  return _internal_msgid();
}
inline void SummonEffect::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.SummonEffect.msgid)
}
inline ::GSToGC::MsgID SummonEffect::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void SummonEffect::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool SummonEffect::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SummonEffect::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SummonEffect::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SummonEffect.guid)
  return _internal_guid();
}
inline void SummonEffect::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.SummonEffect.guid)
}
inline ::uint64_t SummonEffect::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void SummonEffect::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 effectid = 3;
inline bool SummonEffect::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void SummonEffect::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t SummonEffect::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SummonEffect.effectid)
  return _internal_effectid();
}
inline void SummonEffect::set_effectid(::uint32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.SummonEffect.effectid)
}
inline ::uint32_t SummonEffect::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void SummonEffect::_internal_set_effectid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional uint64 npcguid = 4;
inline bool SummonEffect::has_npcguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SummonEffect::clear_npcguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npcguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t SummonEffect::npcguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.SummonEffect.npcguid)
  return _internal_npcguid();
}
inline void SummonEffect::set_npcguid(::uint64_t value) {
  _internal_set_npcguid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.SummonEffect.npcguid)
}
inline ::uint64_t SummonEffect::_internal_npcguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.npcguid_;
}
inline void SummonEffect::_internal_set_npcguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.npcguid_ = value;
}

// -------------------------------------------------------------------

// BuffEffect

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelBufEffect];
inline bool BuffEffect::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void BuffEffect::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 76;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::GSToGC::MsgID BuffEffect::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BuffEffect.msgid)
  return _internal_msgid();
}
inline void BuffEffect::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.BuffEffect.msgid)
}
inline ::GSToGC::MsgID BuffEffect::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void BuffEffect::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool BuffEffect::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BuffEffect::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t BuffEffect::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BuffEffect.guid)
  return _internal_guid();
}
inline void BuffEffect::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.BuffEffect.guid)
}
inline ::uint64_t BuffEffect::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void BuffEffect::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 effectid = 3;
inline bool BuffEffect::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BuffEffect::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t BuffEffect::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BuffEffect.effectid)
  return _internal_effectid();
}
inline void BuffEffect::set_effectid(::uint32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.BuffEffect.effectid)
}
inline ::uint32_t BuffEffect::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void BuffEffect::_internal_set_effectid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional uint32 uniqueid = 4;
inline bool BuffEffect::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BuffEffect::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t BuffEffect::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BuffEffect.uniqueid)
  return _internal_uniqueid();
}
inline void BuffEffect::set_uniqueid(::uint32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.BuffEffect.uniqueid)
}
inline ::uint32_t BuffEffect::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void BuffEffect::_internal_set_uniqueid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// optional uint64 targuid = 5;
inline bool BuffEffect::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BuffEffect::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t BuffEffect::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.BuffEffect.targuid)
  return _internal_targuid();
}
inline void BuffEffect::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.BuffEffect.targuid)
}
inline ::uint64_t BuffEffect::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void BuffEffect::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional int32 time = 6;
inline bool BuffEffect::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void BuffEffect::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t BuffEffect::time() const {
  // @@protoc_insertion_point(field_get:GSToGC.BuffEffect.time)
  return _internal_time();
}
inline void BuffEffect::set_time(::int32_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.BuffEffect.time)
}
inline ::int32_t BuffEffect::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void BuffEffect::_internal_set_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = value;
}

// optional int32 state = 7;
inline bool BuffEffect::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void BuffEffect::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t BuffEffect::state() const {
  // @@protoc_insertion_point(field_get:GSToGC.BuffEffect.state)
  return _internal_state();
}
inline void BuffEffect::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.BuffEffect.state)
}
inline ::int32_t BuffEffect::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void BuffEffect::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// NotifySummonLifeTime

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySummonLifeTime];
inline bool NotifySummonLifeTime::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifySummonLifeTime::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 77;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID NotifySummonLifeTime::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySummonLifeTime.msgid)
  return _internal_msgid();
}
inline void NotifySummonLifeTime::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySummonLifeTime.msgid)
}
inline ::GSToGC::MsgID NotifySummonLifeTime::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySummonLifeTime::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySummonLifeTime::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySummonLifeTime::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t NotifySummonLifeTime::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySummonLifeTime.guid)
  return _internal_guid();
}
inline void NotifySummonLifeTime::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySummonLifeTime.guid)
}
inline ::uint64_t NotifySummonLifeTime::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySummonLifeTime::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 lifetime = 3;
inline bool NotifySummonLifeTime::has_lifetime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySummonLifeTime::clear_lifetime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lifetime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifySummonLifeTime::lifetime() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySummonLifeTime.lifetime)
  return _internal_lifetime();
}
inline void NotifySummonLifeTime::set_lifetime(::int32_t value) {
  _internal_set_lifetime(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySummonLifeTime.lifetime)
}
inline ::int32_t NotifySummonLifeTime::_internal_lifetime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lifetime_;
}
inline void NotifySummonLifeTime::_internal_set_lifetime(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lifetime_ = value;
}

// optional int32 resttime = 4;
inline bool NotifySummonLifeTime::has_resttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifySummonLifeTime::clear_resttime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resttime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NotifySummonLifeTime::resttime() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySummonLifeTime.resttime)
  return _internal_resttime();
}
inline void NotifySummonLifeTime::set_resttime(::int32_t value) {
  _internal_set_resttime(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySummonLifeTime.resttime)
}
inline ::int32_t NotifySummonLifeTime::_internal_resttime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.resttime_;
}
inline void NotifySummonLifeTime::_internal_set_resttime(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.resttime_ = value;
}

// optional .GSToGC.Pos pos = 5;
inline bool NotifySummonLifeTime::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void NotifySummonLifeTime::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& NotifySummonLifeTime::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySummonLifeTime::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySummonLifeTime.pos)
  return _internal_pos();
}
inline void NotifySummonLifeTime::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySummonLifeTime.pos)
}
inline ::GSToGC::Pos* NotifySummonLifeTime::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySummonLifeTime::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySummonLifeTime.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySummonLifeTime::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* NotifySummonLifeTime::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySummonLifeTime.pos)
  return _msg;
}
inline void NotifySummonLifeTime::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySummonLifeTime.pos)
}

// optional .GSToGC.Dir dir = 6;
inline bool NotifySummonLifeTime::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void NotifySummonLifeTime::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& NotifySummonLifeTime::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& NotifySummonLifeTime::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySummonLifeTime.dir)
  return _internal_dir();
}
inline void NotifySummonLifeTime::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySummonLifeTime.dir)
}
inline ::GSToGC::Dir* NotifySummonLifeTime::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* NotifySummonLifeTime::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySummonLifeTime.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* NotifySummonLifeTime::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* NotifySummonLifeTime::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySummonLifeTime.dir)
  return _msg;
}
inline void NotifySummonLifeTime::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySummonLifeTime.dir)
}

// -------------------------------------------------------------------

// NotifySkillModelStartForceMove

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartForceMove];
inline bool NotifySkillModelStartForceMove::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMove::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 78;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID NotifySkillModelStartForceMove::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMove.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelStartForceMove::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMove.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelStartForceMove::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelStartForceMove::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillModelStartForceMove::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMove::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t NotifySkillModelStartForceMove::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMove.guid)
  return _internal_guid();
}
inline void NotifySkillModelStartForceMove::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMove.guid)
}
inline ::uint64_t NotifySkillModelStartForceMove::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillModelStartForceMove::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 effectid = 3;
inline bool NotifySkillModelStartForceMove::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMove::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifySkillModelStartForceMove::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMove.effectid)
  return _internal_effectid();
}
inline void NotifySkillModelStartForceMove::set_effectid(::int32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMove.effectid)
}
inline ::int32_t NotifySkillModelStartForceMove::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void NotifySkillModelStartForceMove::_internal_set_effectid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional .GSToGC.Dir dir = 4;
inline bool NotifySkillModelStartForceMove::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void NotifySkillModelStartForceMove::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Dir& NotifySkillModelStartForceMove::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& NotifySkillModelStartForceMove::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMove.dir)
  return _internal_dir();
}
inline void NotifySkillModelStartForceMove::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelStartForceMove.dir)
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMove::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMove::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelStartForceMove.dir)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMove::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMove::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelStartForceMove.dir)
  return _msg;
}
inline void NotifySkillModelStartForceMove::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelStartForceMove.dir)
}

// optional .GSToGC.Pos pod = 5;
inline bool NotifySkillModelStartForceMove::has_pod() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pod_ != nullptr);
  return value;
}
inline void NotifySkillModelStartForceMove::clear_pod() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pod_ != nullptr) _impl_.pod_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMove::_internal_pod() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pod_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMove::pod() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMove.pod)
  return _internal_pod();
}
inline void NotifySkillModelStartForceMove::unsafe_arena_set_allocated_pod(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pod_);
  }
  _impl_.pod_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelStartForceMove.pod)
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMove::release_pod() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* released = _impl_.pod_;
  _impl_.pod_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMove::unsafe_arena_release_pod() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelStartForceMove.pod)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Pos* temp = _impl_.pod_;
  _impl_.pod_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMove::_internal_mutable_pod() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pod_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pod_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pod_;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMove::mutable_pod() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Pos* _msg = _internal_mutable_pod();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelStartForceMove.pod)
  return _msg;
}
inline void NotifySkillModelStartForceMove::set_allocated_pod(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pod_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.pod_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelStartForceMove.pod)
}

// optional int32 speed = 6;
inline bool NotifySkillModelStartForceMove::has_speed() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMove::clear_speed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NotifySkillModelStartForceMove::speed() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMove.speed)
  return _internal_speed();
}
inline void NotifySkillModelStartForceMove::set_speed(::int32_t value) {
  _internal_set_speed(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMove.speed)
}
inline ::int32_t NotifySkillModelStartForceMove::_internal_speed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.speed_;
}
inline void NotifySkillModelStartForceMove::_internal_set_speed(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.speed_ = value;
}

// -------------------------------------------------------------------

// NotifySkillModelStartForceMoveStop

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartForceMoveStop];
inline bool NotifySkillModelStartForceMoveStop::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMoveStop::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 79;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifySkillModelStartForceMoveStop::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveStop.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelStartForceMoveStop::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMoveStop.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelStartForceMoveStop::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelStartForceMoveStop::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillModelStartForceMoveStop::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMoveStop::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t NotifySkillModelStartForceMoveStop::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveStop.guid)
  return _internal_guid();
}
inline void NotifySkillModelStartForceMoveStop::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMoveStop.guid)
}
inline ::uint64_t NotifySkillModelStartForceMoveStop::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillModelStartForceMoveStop::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 effectid = 3;
inline bool NotifySkillModelStartForceMoveStop::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMoveStop::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifySkillModelStartForceMoveStop::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveStop.effectid)
  return _internal_effectid();
}
inline void NotifySkillModelStartForceMoveStop::set_effectid(::int32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMoveStop.effectid)
}
inline ::int32_t NotifySkillModelStartForceMoveStop::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void NotifySkillModelStartForceMoveStop::_internal_set_effectid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional .GSToGC.Pos pos = 4;
inline bool NotifySkillModelStartForceMoveStop::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void NotifySkillModelStartForceMoveStop::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMoveStop::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMoveStop::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveStop.pos)
  return _internal_pos();
}
inline void NotifySkillModelStartForceMoveStop::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelStartForceMoveStop.pos)
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveStop::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveStop::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelStartForceMoveStop.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveStop::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveStop::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelStartForceMoveStop.pos)
  return _msg;
}
inline void NotifySkillModelStartForceMoveStop::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelStartForceMoveStop.pos)
}

// -------------------------------------------------------------------

// NotifySkillModelStartForceMoveTeleport

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartForceMoveTeleport];
inline bool NotifySkillModelStartForceMoveTeleport::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMoveTeleport::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 80;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID NotifySkillModelStartForceMoveTeleport::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveTeleport.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelStartForceMoveTeleport::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMoveTeleport.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelStartForceMoveTeleport::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelStartForceMoveTeleport::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillModelStartForceMoveTeleport::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMoveTeleport::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t NotifySkillModelStartForceMoveTeleport::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveTeleport.guid)
  return _internal_guid();
}
inline void NotifySkillModelStartForceMoveTeleport::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMoveTeleport.guid)
}
inline ::uint64_t NotifySkillModelStartForceMoveTeleport::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillModelStartForceMoveTeleport::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 effectid = 3;
inline bool NotifySkillModelStartForceMoveTeleport::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifySkillModelStartForceMoveTeleport::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t NotifySkillModelStartForceMoveTeleport::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveTeleport.effectid)
  return _internal_effectid();
}
inline void NotifySkillModelStartForceMoveTeleport::set_effectid(::int32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartForceMoveTeleport.effectid)
}
inline ::int32_t NotifySkillModelStartForceMoveTeleport::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void NotifySkillModelStartForceMoveTeleport::_internal_set_effectid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional .GSToGC.Pos beginpos = 4;
inline bool NotifySkillModelStartForceMoveTeleport::has_beginpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.beginpos_ != nullptr);
  return value;
}
inline void NotifySkillModelStartForceMoveTeleport::clear_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.beginpos_ != nullptr) _impl_.beginpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMoveTeleport::_internal_beginpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.beginpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMoveTeleport::beginpos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveTeleport.beginpos)
  return _internal_beginpos();
}
inline void NotifySkillModelStartForceMoveTeleport::unsafe_arena_set_allocated_beginpos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.beginpos_);
  }
  _impl_.beginpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelStartForceMoveTeleport.beginpos)
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::release_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.beginpos_;
  _impl_.beginpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::unsafe_arena_release_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelStartForceMoveTeleport.beginpos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.beginpos_;
  _impl_.beginpos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::_internal_mutable_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.beginpos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.beginpos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.beginpos_;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::mutable_beginpos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_beginpos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelStartForceMoveTeleport.beginpos)
  return _msg;
}
inline void NotifySkillModelStartForceMoveTeleport::set_allocated_beginpos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.beginpos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.beginpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelStartForceMoveTeleport.beginpos)
}

// optional .GSToGC.Dir begindir = 5;
inline bool NotifySkillModelStartForceMoveTeleport::has_begindir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.begindir_ != nullptr);
  return value;
}
inline void NotifySkillModelStartForceMoveTeleport::clear_begindir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.begindir_ != nullptr) _impl_.begindir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& NotifySkillModelStartForceMoveTeleport::_internal_begindir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.begindir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& NotifySkillModelStartForceMoveTeleport::begindir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveTeleport.begindir)
  return _internal_begindir();
}
inline void NotifySkillModelStartForceMoveTeleport::unsafe_arena_set_allocated_begindir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.begindir_);
  }
  _impl_.begindir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelStartForceMoveTeleport.begindir)
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMoveTeleport::release_begindir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.begindir_;
  _impl_.begindir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMoveTeleport::unsafe_arena_release_begindir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelStartForceMoveTeleport.begindir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.begindir_;
  _impl_.begindir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMoveTeleport::_internal_mutable_begindir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.begindir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.begindir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.begindir_;
}
inline ::GSToGC::Dir* NotifySkillModelStartForceMoveTeleport::mutable_begindir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_begindir();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelStartForceMoveTeleport.begindir)
  return _msg;
}
inline void NotifySkillModelStartForceMoveTeleport::set_allocated_begindir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.begindir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.begindir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelStartForceMoveTeleport.begindir)
}

// optional .GSToGC.Pos tarpos = 6;
inline bool NotifySkillModelStartForceMoveTeleport::has_tarpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tarpos_ != nullptr);
  return value;
}
inline void NotifySkillModelStartForceMoveTeleport::clear_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ != nullptr) _impl_.tarpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMoveTeleport::_internal_tarpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.tarpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySkillModelStartForceMoveTeleport::tarpos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartForceMoveTeleport.tarpos)
  return _internal_tarpos();
}
inline void NotifySkillModelStartForceMoveTeleport::unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tarpos_);
  }
  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelStartForceMoveTeleport.tarpos)
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::GSToGC::Pos* released = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::unsafe_arena_release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelStartForceMoveTeleport.tarpos)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::GSToGC::Pos* temp = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::_internal_mutable_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.tarpos_;
}
inline ::GSToGC::Pos* NotifySkillModelStartForceMoveTeleport::mutable_tarpos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::GSToGC::Pos* _msg = _internal_mutable_tarpos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelStartForceMoveTeleport.tarpos)
  return _msg;
}
inline void NotifySkillModelStartForceMoveTeleport::set_allocated_tarpos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.tarpos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelStartForceMoveTeleport.tarpos)
}

// -------------------------------------------------------------------

// NotifySkillModelPurification

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelPurification];
inline bool NotifySkillModelPurification::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillModelPurification::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 220;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifySkillModelPurification::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelPurification.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelPurification::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelPurification.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelPurification::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelPurification::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillModelPurification::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifySkillModelPurification::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifySkillModelPurification::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelPurification.guid)
  return _internal_guid();
}
inline void NotifySkillModelPurification::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelPurification.guid)
}
inline ::uint64_t NotifySkillModelPurification::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillModelPurification::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint64 targetguid = 3;
inline bool NotifySkillModelPurification::has_targetguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySkillModelPurification::clear_targetguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t NotifySkillModelPurification::targetguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelPurification.targetguid)
  return _internal_targetguid();
}
inline void NotifySkillModelPurification::set_targetguid(::uint64_t value) {
  _internal_set_targetguid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelPurification.targetguid)
}
inline ::uint64_t NotifySkillModelPurification::_internal_targetguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetguid_;
}
inline void NotifySkillModelPurification::_internal_set_targetguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetguid_ = value;
}

// optional int32 effectid = 4;
inline bool NotifySkillModelPurification::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySkillModelPurification::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifySkillModelPurification::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelPurification.effectid)
  return _internal_effectid();
}
inline void NotifySkillModelPurification::set_effectid(::int32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelPurification.effectid)
}
inline ::int32_t NotifySkillModelPurification::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void NotifySkillModelPurification::_internal_set_effectid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// -------------------------------------------------------------------

// NotifySkillModelStartLink

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStartLink];
inline bool NotifySkillModelStartLink::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifySkillModelStartLink::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 550;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::GSToGC::MsgID NotifySkillModelStartLink::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartLink.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelStartLink::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartLink.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelStartLink::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelStartLink::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillModelStartLink::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySkillModelStartLink::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t NotifySkillModelStartLink::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartLink.guid)
  return _internal_guid();
}
inline void NotifySkillModelStartLink::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartLink.guid)
}
inline ::uint64_t NotifySkillModelStartLink::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillModelStartLink::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional .GSToGC.Pos beginpos = 3;
inline bool NotifySkillModelStartLink::has_beginpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.beginpos_ != nullptr);
  return value;
}
inline void NotifySkillModelStartLink::clear_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.beginpos_ != nullptr) _impl_.beginpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& NotifySkillModelStartLink::_internal_beginpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.beginpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySkillModelStartLink::beginpos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartLink.beginpos)
  return _internal_beginpos();
}
inline void NotifySkillModelStartLink::unsafe_arena_set_allocated_beginpos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.beginpos_);
  }
  _impl_.beginpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelStartLink.beginpos)
}
inline ::GSToGC::Pos* NotifySkillModelStartLink::release_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.beginpos_;
  _impl_.beginpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySkillModelStartLink::unsafe_arena_release_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelStartLink.beginpos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.beginpos_;
  _impl_.beginpos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySkillModelStartLink::_internal_mutable_beginpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.beginpos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.beginpos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.beginpos_;
}
inline ::GSToGC::Pos* NotifySkillModelStartLink::mutable_beginpos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_beginpos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelStartLink.beginpos)
  return _msg;
}
inline void NotifySkillModelStartLink::set_allocated_beginpos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.beginpos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.beginpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelStartLink.beginpos)
}

// optional uint64 targetguid = 4;
inline bool NotifySkillModelStartLink::has_targetguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySkillModelStartLink::clear_targetguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t NotifySkillModelStartLink::targetguid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartLink.targetguid)
  return _internal_targetguid();
}
inline void NotifySkillModelStartLink::set_targetguid(::uint64_t value) {
  _internal_set_targetguid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartLink.targetguid)
}
inline ::uint64_t NotifySkillModelStartLink::_internal_targetguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targetguid_;
}
inline void NotifySkillModelStartLink::_internal_set_targetguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targetguid_ = value;
}

// optional int32 effectid = 5;
inline bool NotifySkillModelStartLink::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillModelStartLink::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t NotifySkillModelStartLink::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartLink.effectid)
  return _internal_effectid();
}
inline void NotifySkillModelStartLink::set_effectid(::int32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartLink.effectid)
}
inline ::int32_t NotifySkillModelStartLink::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void NotifySkillModelStartLink::_internal_set_effectid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional uint32 uniqueid = 6;
inline bool NotifySkillModelStartLink::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifySkillModelStartLink::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t NotifySkillModelStartLink::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStartLink.uniqueid)
  return _internal_uniqueid();
}
inline void NotifySkillModelStartLink::set_uniqueid(::uint32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStartLink.uniqueid)
}
inline ::uint32_t NotifySkillModelStartLink::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void NotifySkillModelStartLink::_internal_set_uniqueid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// -------------------------------------------------------------------

// NotifySkillModelStopLink

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelStopLink];
inline bool NotifySkillModelStopLink::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySkillModelStopLink::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 551;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifySkillModelStopLink::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStopLink.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelStopLink::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStopLink.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelStopLink::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelStopLink::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 uniqueid = 2;
inline bool NotifySkillModelStopLink::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifySkillModelStopLink::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifySkillModelStopLink::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelStopLink.uniqueid)
  return _internal_uniqueid();
}
inline void NotifySkillModelStopLink::set_uniqueid(::uint32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelStopLink.uniqueid)
}
inline ::uint32_t NotifySkillModelStopLink::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void NotifySkillModelStopLink::_internal_set_uniqueid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// -------------------------------------------------------------------

// NotifyPassitiveSkillRelease

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPassitiveSkillRelease];
inline bool NotifyPassitiveSkillRelease::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyPassitiveSkillRelease::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 81;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyPassitiveSkillRelease::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillRelease.msgid)
  return _internal_msgid();
}
inline void NotifyPassitiveSkillRelease::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillRelease.msgid)
}
inline ::GSToGC::MsgID NotifyPassitiveSkillRelease::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyPassitiveSkillRelease::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyPassitiveSkillRelease::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyPassitiveSkillRelease::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyPassitiveSkillRelease::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillRelease.guid)
  return _internal_guid();
}
inline void NotifyPassitiveSkillRelease::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillRelease.guid)
}
inline ::uint64_t NotifyPassitiveSkillRelease::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyPassitiveSkillRelease::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool NotifyPassitiveSkillRelease::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyPassitiveSkillRelease::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyPassitiveSkillRelease::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillRelease.skillid)
  return _internal_skillid();
}
inline void NotifyPassitiveSkillRelease::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillRelease.skillid)
}
inline ::int32_t NotifyPassitiveSkillRelease::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void NotifyPassitiveSkillRelease::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional int32 timeLeft = 4;
inline bool NotifyPassitiveSkillRelease::has_timeleft() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyPassitiveSkillRelease::clear_timeleft() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeleft_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyPassitiveSkillRelease::timeleft() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillRelease.timeLeft)
  return _internal_timeleft();
}
inline void NotifyPassitiveSkillRelease::set_timeleft(::int32_t value) {
  _internal_set_timeleft(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillRelease.timeLeft)
}
inline ::int32_t NotifyPassitiveSkillRelease::_internal_timeleft() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timeleft_;
}
inline void NotifyPassitiveSkillRelease::_internal_set_timeleft(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeleft_ = value;
}

// -------------------------------------------------------------------

// NotifyPassitiveSkillLoad

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPassitiveSkillLoad];
inline bool NotifyPassitiveSkillLoad::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyPassitiveSkillLoad::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 82;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyPassitiveSkillLoad::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillLoad.msgid)
  return _internal_msgid();
}
inline void NotifyPassitiveSkillLoad::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillLoad.msgid)
}
inline ::GSToGC::MsgID NotifyPassitiveSkillLoad::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyPassitiveSkillLoad::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyPassitiveSkillLoad::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyPassitiveSkillLoad::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyPassitiveSkillLoad::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillLoad.guid)
  return _internal_guid();
}
inline void NotifyPassitiveSkillLoad::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillLoad.guid)
}
inline ::uint64_t NotifyPassitiveSkillLoad::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyPassitiveSkillLoad::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool NotifyPassitiveSkillLoad::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyPassitiveSkillLoad::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyPassitiveSkillLoad::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillLoad.skillid)
  return _internal_skillid();
}
inline void NotifyPassitiveSkillLoad::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillLoad.skillid)
}
inline ::int32_t NotifyPassitiveSkillLoad::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void NotifyPassitiveSkillLoad::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional int32 uniqueid = 4;
inline bool NotifyPassitiveSkillLoad::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyPassitiveSkillLoad::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyPassitiveSkillLoad::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillLoad.uniqueid)
  return _internal_uniqueid();
}
inline void NotifyPassitiveSkillLoad::set_uniqueid(::int32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillLoad.uniqueid)
}
inline ::int32_t NotifyPassitiveSkillLoad::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void NotifyPassitiveSkillLoad::_internal_set_uniqueid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// -------------------------------------------------------------------

// NotifyPassitiveSkillUnLoad

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyPassitiveSkillUnload];
inline bool NotifyPassitiveSkillUnLoad::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyPassitiveSkillUnLoad::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 83;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyPassitiveSkillUnLoad::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillUnLoad.msgid)
  return _internal_msgid();
}
inline void NotifyPassitiveSkillUnLoad::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillUnLoad.msgid)
}
inline ::GSToGC::MsgID NotifyPassitiveSkillUnLoad::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyPassitiveSkillUnLoad::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyPassitiveSkillUnLoad::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyPassitiveSkillUnLoad::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyPassitiveSkillUnLoad::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillUnLoad.guid)
  return _internal_guid();
}
inline void NotifyPassitiveSkillUnLoad::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillUnLoad.guid)
}
inline ::uint64_t NotifyPassitiveSkillUnLoad::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyPassitiveSkillUnLoad::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 skillid = 3;
inline bool NotifyPassitiveSkillUnLoad::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyPassitiveSkillUnLoad::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyPassitiveSkillUnLoad::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillUnLoad.skillid)
  return _internal_skillid();
}
inline void NotifyPassitiveSkillUnLoad::set_skillid(::int32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillUnLoad.skillid)
}
inline ::int32_t NotifyPassitiveSkillUnLoad::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void NotifyPassitiveSkillUnLoad::_internal_set_skillid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// optional int32 uniqueid = 4;
inline bool NotifyPassitiveSkillUnLoad::has_uniqueid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyPassitiveSkillUnLoad::clear_uniqueid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyPassitiveSkillUnLoad::uniqueid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyPassitiveSkillUnLoad.uniqueid)
  return _internal_uniqueid();
}
inline void NotifyPassitiveSkillUnLoad::set_uniqueid(::int32_t value) {
  _internal_set_uniqueid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyPassitiveSkillUnLoad.uniqueid)
}
inline ::int32_t NotifyPassitiveSkillUnLoad::_internal_uniqueid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.uniqueid_;
}
inline void NotifyPassitiveSkillUnLoad::_internal_set_uniqueid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.uniqueid_ = value;
}

// -------------------------------------------------------------------

// NotifySkillModelEmitTurn

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillModelEmitTurn];
inline bool NotifySkillModelEmitTurn::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void NotifySkillModelEmitTurn::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 84;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::GSToGC::MsgID NotifySkillModelEmitTurn::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.msgid)
  return _internal_msgid();
}
inline void NotifySkillModelEmitTurn::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelEmitTurn.msgid)
}
inline ::GSToGC::MsgID NotifySkillModelEmitTurn::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillModelEmitTurn::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillModelEmitTurn::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillModelEmitTurn::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint64_t NotifySkillModelEmitTurn::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.guid)
  return _internal_guid();
}
inline void NotifySkillModelEmitTurn::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelEmitTurn.guid)
}
inline ::uint64_t NotifySkillModelEmitTurn::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillModelEmitTurn::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 effectid = 3;
inline bool NotifySkillModelEmitTurn::has_effectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifySkillModelEmitTurn::clear_effectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t NotifySkillModelEmitTurn::effectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.effectid)
  return _internal_effectid();
}
inline void NotifySkillModelEmitTurn::set_effectid(::uint32_t value) {
  _internal_set_effectid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelEmitTurn.effectid)
}
inline ::uint32_t NotifySkillModelEmitTurn::_internal_effectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.effectid_;
}
inline void NotifySkillModelEmitTurn::_internal_set_effectid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.effectid_ = value;
}

// optional int32 progectid = 4;
inline bool NotifySkillModelEmitTurn::has_progectid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void NotifySkillModelEmitTurn::clear_progectid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.progectid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t NotifySkillModelEmitTurn::progectid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.progectid)
  return _internal_progectid();
}
inline void NotifySkillModelEmitTurn::set_progectid(::int32_t value) {
  _internal_set_progectid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelEmitTurn.progectid)
}
inline ::int32_t NotifySkillModelEmitTurn::_internal_progectid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.progectid_;
}
inline void NotifySkillModelEmitTurn::_internal_set_progectid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.progectid_ = value;
}

// optional .GSToGC.Pos pos = 5;
inline bool NotifySkillModelEmitTurn::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void NotifySkillModelEmitTurn::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& NotifySkillModelEmitTurn::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySkillModelEmitTurn::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.pos)
  return _internal_pos();
}
inline void NotifySkillModelEmitTurn::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelEmitTurn.pos)
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelEmitTurn.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelEmitTurn.pos)
  return _msg;
}
inline void NotifySkillModelEmitTurn::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelEmitTurn.pos)
}

// optional .GSToGC.Dir dir = 6;
inline bool NotifySkillModelEmitTurn::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void NotifySkillModelEmitTurn::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& NotifySkillModelEmitTurn::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& NotifySkillModelEmitTurn::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.dir)
  return _internal_dir();
}
inline void NotifySkillModelEmitTurn::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelEmitTurn.dir)
}
inline ::GSToGC::Dir* NotifySkillModelEmitTurn::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* NotifySkillModelEmitTurn::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelEmitTurn.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* NotifySkillModelEmitTurn::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* NotifySkillModelEmitTurn::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelEmitTurn.dir)
  return _msg;
}
inline void NotifySkillModelEmitTurn::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelEmitTurn.dir)
}

// optional uint64 targuid = 7;
inline bool NotifySkillModelEmitTurn::has_targuid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void NotifySkillModelEmitTurn::clear_targuid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t NotifySkillModelEmitTurn::targuid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.targuid)
  return _internal_targuid();
}
inline void NotifySkillModelEmitTurn::set_targuid(::uint64_t value) {
  _internal_set_targuid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillModelEmitTurn.targuid)
}
inline ::uint64_t NotifySkillModelEmitTurn::_internal_targuid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.targuid_;
}
inline void NotifySkillModelEmitTurn::_internal_set_targuid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.targuid_ = value;
}

// optional .GSToGC.Pos tarpos = 8;
inline bool NotifySkillModelEmitTurn::has_tarpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tarpos_ != nullptr);
  return value;
}
inline void NotifySkillModelEmitTurn::clear_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ != nullptr) _impl_.tarpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::GSToGC::Pos& NotifySkillModelEmitTurn::_internal_tarpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.tarpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifySkillModelEmitTurn::tarpos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillModelEmitTurn.tarpos)
  return _internal_tarpos();
}
inline void NotifySkillModelEmitTurn::unsafe_arena_set_allocated_tarpos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tarpos_);
  }
  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifySkillModelEmitTurn.tarpos)
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::GSToGC::Pos* released = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::unsafe_arena_release_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifySkillModelEmitTurn.tarpos)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::GSToGC::Pos* temp = _impl_.tarpos_;
  _impl_.tarpos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::_internal_mutable_tarpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.tarpos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.tarpos_;
}
inline ::GSToGC::Pos* NotifySkillModelEmitTurn::mutable_tarpos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::GSToGC::Pos* _msg = _internal_mutable_tarpos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifySkillModelEmitTurn.tarpos)
  return _msg;
}
inline void NotifySkillModelEmitTurn::set_allocated_tarpos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.tarpos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.tarpos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifySkillModelEmitTurn.tarpos)
}

// -------------------------------------------------------------------

// NotifyBornObj

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToSSFromCS_NotifyBornObj];
inline bool NotifyBornObj::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyBornObj::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 116;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyBornObj::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBornObj.msgid)
  return _internal_msgid();
}
inline void NotifyBornObj::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBornObj.msgid)
}
inline ::GSToGC::MsgID NotifyBornObj::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyBornObj::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 type = 2;
inline bool NotifyBornObj::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyBornObj::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t NotifyBornObj::type() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBornObj.type)
  return _internal_type();
}
inline void NotifyBornObj::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBornObj.type)
}
inline ::int32_t NotifyBornObj::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void NotifyBornObj::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// NotifyReconnectInfo_ReconnectInfo

// optional int32 pos = 1;
inline bool NotifyReconnectInfo_ReconnectInfo::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyReconnectInfo_ReconnectInfo::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t NotifyReconnectInfo_ReconnectInfo::pos() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.ReconnectInfo.pos)
  return _internal_pos();
}
inline void NotifyReconnectInfo_ReconnectInfo::set_pos(::int32_t value) {
  _internal_set_pos(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.ReconnectInfo.pos)
}
inline ::int32_t NotifyReconnectInfo_ReconnectInfo::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pos_;
}
inline void NotifyReconnectInfo_ReconnectInfo::_internal_set_pos(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pos_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyReconnectInfo_ReconnectInfo::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyReconnectInfo_ReconnectInfo::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t NotifyReconnectInfo_ReconnectInfo::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.ReconnectInfo.guid)
  return _internal_guid();
}
inline void NotifyReconnectInfo_ReconnectInfo::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.ReconnectInfo.guid)
}
inline ::uint64_t NotifyReconnectInfo_ReconnectInfo::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyReconnectInfo_ReconnectInfo::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional string nickname = 3;
inline bool NotifyReconnectInfo_ReconnectInfo::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyReconnectInfo_ReconnectInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NotifyReconnectInfo_ReconnectInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.ReconnectInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NotifyReconnectInfo_ReconnectInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.ReconnectInfo.nickname)
}
inline std::string* NotifyReconnectInfo_ReconnectInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyReconnectInfo.ReconnectInfo.nickname)
  return _s;
}
inline const std::string& NotifyReconnectInfo_ReconnectInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void NotifyReconnectInfo_ReconnectInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* NotifyReconnectInfo_ReconnectInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* NotifyReconnectInfo_ReconnectInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyReconnectInfo.ReconnectInfo.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void NotifyReconnectInfo_ReconnectInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyReconnectInfo.ReconnectInfo.nickname)
}

// optional uint32 heroid = 4;
inline bool NotifyReconnectInfo_ReconnectInfo::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyReconnectInfo_ReconnectInfo::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t NotifyReconnectInfo_ReconnectInfo::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.ReconnectInfo.heroid)
  return _internal_heroid();
}
inline void NotifyReconnectInfo_ReconnectInfo::set_heroid(::uint32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.ReconnectInfo.heroid)
}
inline ::uint32_t NotifyReconnectInfo_ReconnectInfo::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void NotifyReconnectInfo_ReconnectInfo::_internal_set_heroid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// optional bool ifselected = 5;
inline bool NotifyReconnectInfo_ReconnectInfo::has_ifselected() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NotifyReconnectInfo_ReconnectInfo::clear_ifselected() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifselected_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool NotifyReconnectInfo_ReconnectInfo::ifselected() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.ReconnectInfo.ifselected)
  return _internal_ifselected();
}
inline void NotifyReconnectInfo_ReconnectInfo::set_ifselected(bool value) {
  _internal_set_ifselected(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.ReconnectInfo.ifselected)
}
inline bool NotifyReconnectInfo_ReconnectInfo::_internal_ifselected() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifselected_;
}
inline void NotifyReconnectInfo_ReconnectInfo::_internal_set_ifselected(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifselected_ = value;
}

// -------------------------------------------------------------------

// NotifyReconnectInfo

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromCS_NotifyReconnectInfo];
inline bool NotifyReconnectInfo::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyReconnectInfo::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 115;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyReconnectInfo::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.msgid)
  return _internal_msgid();
}
inline void NotifyReconnectInfo::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.msgid)
}
inline ::GSToGC::MsgID NotifyReconnectInfo::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyReconnectInfo::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int32 battlestate = 2;
inline bool NotifyReconnectInfo::has_battlestate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyReconnectInfo::clear_battlestate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battlestate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t NotifyReconnectInfo::battlestate() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.battlestate)
  return _internal_battlestate();
}
inline void NotifyReconnectInfo::set_battlestate(::int32_t value) {
  _internal_set_battlestate(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.battlestate)
}
inline ::int32_t NotifyReconnectInfo::_internal_battlestate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battlestate_;
}
inline void NotifyReconnectInfo::_internal_set_battlestate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battlestate_ = value;
}

// optional int32 remain_times = 3;
inline bool NotifyReconnectInfo::has_remain_times() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyReconnectInfo::clear_remain_times() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remain_times_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyReconnectInfo::remain_times() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.remain_times)
  return _internal_remain_times();
}
inline void NotifyReconnectInfo::set_remain_times(::int32_t value) {
  _internal_set_remain_times(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.remain_times)
}
inline ::int32_t NotifyReconnectInfo::_internal_remain_times() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.remain_times_;
}
inline void NotifyReconnectInfo::_internal_set_remain_times(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.remain_times_ = value;
}

// optional bool ifob = 4;
inline bool NotifyReconnectInfo::has_ifob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyReconnectInfo::clear_ifob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifob_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool NotifyReconnectInfo::ifob() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.ifob)
  return _internal_ifob();
}
inline void NotifyReconnectInfo::set_ifob(bool value) {
  _internal_set_ifob(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyReconnectInfo.ifob)
}
inline bool NotifyReconnectInfo::_internal_ifob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifob_;
}
inline void NotifyReconnectInfo::_internal_set_ifob(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifob_ = value;
}

// repeated .GSToGC.NotifyReconnectInfo.ReconnectInfo reconnectinfo = 5;
inline int NotifyReconnectInfo::_internal_reconnectinfo_size() const {
  return _internal_reconnectinfo().size();
}
inline int NotifyReconnectInfo::reconnectinfo_size() const {
  return _internal_reconnectinfo_size();
}
inline void NotifyReconnectInfo::clear_reconnectinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reconnectinfo_.Clear();
}
inline ::GSToGC::NotifyReconnectInfo_ReconnectInfo* NotifyReconnectInfo::mutable_reconnectinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyReconnectInfo.reconnectinfo)
  return _internal_mutable_reconnectinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>* NotifyReconnectInfo::mutable_reconnectinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.NotifyReconnectInfo.reconnectinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_reconnectinfo();
}
inline const ::GSToGC::NotifyReconnectInfo_ReconnectInfo& NotifyReconnectInfo::reconnectinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyReconnectInfo.reconnectinfo)
  return _internal_reconnectinfo().Get(index);
}
inline ::GSToGC::NotifyReconnectInfo_ReconnectInfo* NotifyReconnectInfo::add_reconnectinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::NotifyReconnectInfo_ReconnectInfo* _add = _internal_mutable_reconnectinfo()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.NotifyReconnectInfo.reconnectinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>& NotifyReconnectInfo::reconnectinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.NotifyReconnectInfo.reconnectinfo)
  return _internal_reconnectinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>&
NotifyReconnectInfo::_internal_reconnectinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reconnectinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::NotifyReconnectInfo_ReconnectInfo>*
NotifyReconnectInfo::_internal_mutable_reconnectinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.reconnectinfo_;
}

// -------------------------------------------------------------------

// NotifyOBReturnBattleRoom

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOBReturnBattleRoom];
inline bool NotifyOBReturnBattleRoom::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyOBReturnBattleRoom::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 90;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID NotifyOBReturnBattleRoom::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOBReturnBattleRoom.msgid)
  return _internal_msgid();
}
inline void NotifyOBReturnBattleRoom::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOBReturnBattleRoom.msgid)
}
inline ::GSToGC::MsgID NotifyOBReturnBattleRoom::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyOBReturnBattleRoom::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// NotifyOBAppear

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyOBAppear];
inline bool NotifyOBAppear::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyOBAppear::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 95;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyOBAppear::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOBAppear.msgid)
  return _internal_msgid();
}
inline void NotifyOBAppear::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOBAppear.msgid)
}
inline ::GSToGC::MsgID NotifyOBAppear::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyOBAppear::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 obid = 2;
inline bool NotifyOBAppear::has_obid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyOBAppear::clear_obid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyOBAppear::obid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOBAppear.obid)
  return _internal_obid();
}
inline void NotifyOBAppear::set_obid(::uint64_t value) {
  _internal_set_obid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOBAppear.obid)
}
inline ::uint64_t NotifyOBAppear::_internal_obid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.obid_;
}
inline void NotifyOBAppear::_internal_set_obid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.obid_ = value;
}

// optional int32 camp = 3;
inline bool NotifyOBAppear::has_camp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyOBAppear::clear_camp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyOBAppear::camp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyOBAppear.camp)
  return _internal_camp();
}
inline void NotifyOBAppear::set_camp(::int32_t value) {
  _internal_set_camp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyOBAppear.camp)
}
inline ::int32_t NotifyOBAppear::_internal_camp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.camp_;
}
inline void NotifyOBAppear::_internal_set_camp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.camp_ = value;
}

// -------------------------------------------------------------------

// NotifyKillNPC

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyKillNPC];
inline bool NotifyKillNPC::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyKillNPC::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 96;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyKillNPC::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyKillNPC.msgid)
  return _internal_msgid();
}
inline void NotifyKillNPC::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyKillNPC.msgid)
}
inline ::GSToGC::MsgID NotifyKillNPC::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyKillNPC::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyKillNPC::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyKillNPC::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyKillNPC::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyKillNPC.guid)
  return _internal_guid();
}
inline void NotifyKillNPC::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyKillNPC.guid)
}
inline ::uint64_t NotifyKillNPC::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyKillNPC::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 killnum = 3;
inline bool NotifyKillNPC::has_killnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyKillNPC::clear_killnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killnum_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyKillNPC::killnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyKillNPC.killnum)
  return _internal_killnum();
}
inline void NotifyKillNPC::set_killnum(::uint32_t value) {
  _internal_set_killnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyKillNPC.killnum)
}
inline ::uint32_t NotifyKillNPC::_internal_killnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.killnum_;
}
inline void NotifyKillNPC::_internal_set_killnum(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.killnum_ = value;
}

// -------------------------------------------------------------------

// NotifyAltarBSIco

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyAltarBSOk];
inline bool NotifyAltarBSIco::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyAltarBSIco::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 97;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyAltarBSIco::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAltarBSIco.msgid)
  return _internal_msgid();
}
inline void NotifyAltarBSIco::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAltarBSIco.msgid)
}
inline ::GSToGC::MsgID NotifyAltarBSIco::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyAltarBSIco::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 altarid = 2;
inline bool NotifyAltarBSIco::has_altarid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyAltarBSIco::clear_altarid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.altarid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint32_t NotifyAltarBSIco::altarid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAltarBSIco.altarid)
  return _internal_altarid();
}
inline void NotifyAltarBSIco::set_altarid(::uint32_t value) {
  _internal_set_altarid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAltarBSIco.altarid)
}
inline ::uint32_t NotifyAltarBSIco::_internal_altarid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.altarid_;
}
inline void NotifyAltarBSIco::_internal_set_altarid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.altarid_ = value;
}

// optional uint32 objtype = 3;
inline bool NotifyAltarBSIco::has_objtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyAltarBSIco::clear_objtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objtype_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifyAltarBSIco::objtype() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAltarBSIco.objtype)
  return _internal_objtype();
}
inline void NotifyAltarBSIco::set_objtype(::uint32_t value) {
  _internal_set_objtype(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAltarBSIco.objtype)
}
inline ::uint32_t NotifyAltarBSIco::_internal_objtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objtype_;
}
inline void NotifyAltarBSIco::_internal_set_objtype(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objtype_ = value;
}

// optional uint32 optype = 4;
inline bool NotifyAltarBSIco::has_optype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyAltarBSIco::clear_optype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optype_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t NotifyAltarBSIco::optype() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyAltarBSIco.optype)
  return _internal_optype();
}
inline void NotifyAltarBSIco::set_optype(::uint32_t value) {
  _internal_set_optype(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyAltarBSIco.optype)
}
inline ::uint32_t NotifyAltarBSIco::_internal_optype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.optype_;
}
inline void NotifyAltarBSIco::_internal_set_optype(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optype_ = value;
}

// -------------------------------------------------------------------

// NotifySkillUpLv

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifySkillUpLv];
inline bool NotifySkillUpLv::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifySkillUpLv::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 98;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifySkillUpLv::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillUpLv.msgid)
  return _internal_msgid();
}
inline void NotifySkillUpLv::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillUpLv.msgid)
}
inline ::GSToGC::MsgID NotifySkillUpLv::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifySkillUpLv::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifySkillUpLv::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifySkillUpLv::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifySkillUpLv::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillUpLv.guid)
  return _internal_guid();
}
inline void NotifySkillUpLv::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillUpLv.guid)
}
inline ::uint64_t NotifySkillUpLv::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifySkillUpLv::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 skillpos = 3;
inline bool NotifySkillUpLv::has_skillpos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifySkillUpLv::clear_skillpos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillpos_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t NotifySkillUpLv::skillpos() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillUpLv.skillpos)
  return _internal_skillpos();
}
inline void NotifySkillUpLv::set_skillpos(::uint32_t value) {
  _internal_set_skillpos(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillUpLv.skillpos)
}
inline ::uint32_t NotifySkillUpLv::_internal_skillpos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillpos_;
}
inline void NotifySkillUpLv::_internal_set_skillpos(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillpos_ = value;
}

// optional uint32 skillid = 4;
inline bool NotifySkillUpLv::has_skillid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifySkillUpLv::clear_skillid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t NotifySkillUpLv::skillid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifySkillUpLv.skillid)
  return _internal_skillid();
}
inline void NotifySkillUpLv::set_skillid(::uint32_t value) {
  _internal_set_skillid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifySkillUpLv.skillid)
}
inline ::uint32_t NotifySkillUpLv::_internal_skillid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skillid_;
}
inline void NotifySkillUpLv::_internal_set_skillid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skillid_ = value;
}

// -------------------------------------------------------------------

// NotifyBlastHurt

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyBlastHurt];
inline bool NotifyBlastHurt::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyBlastHurt::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 107;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID NotifyBlastHurt::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBlastHurt.msgid)
  return _internal_msgid();
}
inline void NotifyBlastHurt::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBlastHurt.msgid)
}
inline ::GSToGC::MsgID NotifyBlastHurt::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyBlastHurt::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyBlastHurt::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyBlastHurt::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyBlastHurt::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBlastHurt.guid)
  return _internal_guid();
}
inline void NotifyBlastHurt::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBlastHurt.guid)
}
inline ::uint64_t NotifyBlastHurt::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyBlastHurt::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 blasthp = 3;
inline bool NotifyBlastHurt::has_blasthp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyBlastHurt::clear_blasthp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blasthp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t NotifyBlastHurt::blasthp() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyBlastHurt.blasthp)
  return _internal_blasthp();
}
inline void NotifyBlastHurt::set_blasthp(::int32_t value) {
  _internal_set_blasthp(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyBlastHurt.blasthp)
}
inline ::int32_t NotifyBlastHurt::_internal_blasthp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blasthp_;
}
inline void NotifyBlastHurt::_internal_set_blasthp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blasthp_ = value;
}

// -------------------------------------------------------------------

// NotifyGameObjectReliveState

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGameObjectReliveState];
inline bool NotifyGameObjectReliveState::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NotifyGameObjectReliveState::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 111;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::GSToGC::MsgID NotifyGameObjectReliveState::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGameObjectReliveState.msgid)
  return _internal_msgid();
}
inline void NotifyGameObjectReliveState::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGameObjectReliveState.msgid)
}
inline ::GSToGC::MsgID NotifyGameObjectReliveState::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyGameObjectReliveState::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool NotifyGameObjectReliveState::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NotifyGameObjectReliveState::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t NotifyGameObjectReliveState::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGameObjectReliveState.guid)
  return _internal_guid();
}
inline void NotifyGameObjectReliveState::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyGameObjectReliveState.guid)
}
inline ::uint64_t NotifyGameObjectReliveState::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void NotifyGameObjectReliveState::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional .GSToGC.Pos pos = 3;
inline bool NotifyGameObjectReliveState::has_pos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.pos_ != nullptr);
  return value;
}
inline void NotifyGameObjectReliveState::clear_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::GSToGC::Pos& NotifyGameObjectReliveState::_internal_pos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Pos* p = _impl_.pos_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Pos&>(::GSToGC::_Pos_default_instance_);
}
inline const ::GSToGC::Pos& NotifyGameObjectReliveState::pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGameObjectReliveState.pos)
  return _internal_pos();
}
inline void NotifyGameObjectReliveState::unsafe_arena_set_allocated_pos(::GSToGC::Pos* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.pos_);
  }
  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifyGameObjectReliveState.pos)
}
inline ::GSToGC::Pos* NotifyGameObjectReliveState::release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* released = _impl_.pos_;
  _impl_.pos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Pos* NotifyGameObjectReliveState::unsafe_arena_release_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyGameObjectReliveState.pos)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::GSToGC::Pos* temp = _impl_.pos_;
  _impl_.pos_ = nullptr;
  return temp;
}
inline ::GSToGC::Pos* NotifyGameObjectReliveState::_internal_mutable_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.pos_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Pos>(GetArena());
    _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(p);
  }
  return _impl_.pos_;
}
inline ::GSToGC::Pos* NotifyGameObjectReliveState::mutable_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::GSToGC::Pos* _msg = _internal_mutable_pos();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyGameObjectReliveState.pos)
  return _msg;
}
inline void NotifyGameObjectReliveState::set_allocated_pos(::GSToGC::Pos* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.pos_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.pos_ = reinterpret_cast<::GSToGC::Pos*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyGameObjectReliveState.pos)
}

// optional .GSToGC.Dir dir = 4;
inline bool NotifyGameObjectReliveState::has_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.dir_ != nullptr);
  return value;
}
inline void NotifyGameObjectReliveState::clear_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::GSToGC::Dir& NotifyGameObjectReliveState::_internal_dir() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::GSToGC::Dir* p = _impl_.dir_;
  return p != nullptr ? *p : reinterpret_cast<const ::GSToGC::Dir&>(::GSToGC::_Dir_default_instance_);
}
inline const ::GSToGC::Dir& NotifyGameObjectReliveState::dir() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyGameObjectReliveState.dir)
  return _internal_dir();
}
inline void NotifyGameObjectReliveState::unsafe_arena_set_allocated_dir(::GSToGC::Dir* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.dir_);
  }
  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GSToGC.NotifyGameObjectReliveState.dir)
}
inline ::GSToGC::Dir* NotifyGameObjectReliveState::release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* released = _impl_.dir_;
  _impl_.dir_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::GSToGC::Dir* NotifyGameObjectReliveState::unsafe_arena_release_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.NotifyGameObjectReliveState.dir)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::GSToGC::Dir* temp = _impl_.dir_;
  _impl_.dir_ = nullptr;
  return temp;
}
inline ::GSToGC::Dir* NotifyGameObjectReliveState::_internal_mutable_dir() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.dir_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::GSToGC::Dir>(GetArena());
    _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(p);
  }
  return _impl_.dir_;
}
inline ::GSToGC::Dir* NotifyGameObjectReliveState::mutable_dir() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::GSToGC::Dir* _msg = _internal_mutable_dir();
  // @@protoc_insertion_point(field_mutable:GSToGC.NotifyGameObjectReliveState.dir)
  return _msg;
}
inline void NotifyGameObjectReliveState::set_allocated_dir(::GSToGC::Dir* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.dir_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.dir_ = reinterpret_cast<::GSToGC::Dir*>(value);
  // @@protoc_insertion_point(field_set_allocated:GSToGC.NotifyGameObjectReliveState.dir)
}

// -------------------------------------------------------------------

// NotifyCurGold

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGs_NotifyCurGold];
inline bool NotifyCurGold::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyCurGold::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 122;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyCurGold::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCurGold.msgid)
  return _internal_msgid();
}
inline void NotifyCurGold::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCurGold.msgid)
}
inline ::GSToGC::MsgID NotifyCurGold::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyCurGold::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 gold = 2;
inline bool NotifyCurGold::has_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyCurGold::clear_gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyCurGold::gold() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCurGold.gold)
  return _internal_gold();
}
inline void NotifyCurGold::set_gold(::uint64_t value) {
  _internal_set_gold(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCurGold.gold)
}
inline ::uint64_t NotifyCurGold::_internal_gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gold_;
}
inline void NotifyCurGold::_internal_set_gold(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = value;
}

// -------------------------------------------------------------------

// NotifyCurDiamond

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGs_NotifyCurDiamond];
inline bool NotifyCurDiamond::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotifyCurDiamond::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 123;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID NotifyCurDiamond::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCurDiamond.msgid)
  return _internal_msgid();
}
inline void NotifyCurDiamond::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCurDiamond.msgid)
}
inline ::GSToGC::MsgID NotifyCurDiamond::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void NotifyCurDiamond::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 Diamond = 2;
inline bool NotifyCurDiamond::has_diamond() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotifyCurDiamond::clear_diamond() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diamond_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t NotifyCurDiamond::diamond() const {
  // @@protoc_insertion_point(field_get:GSToGC.NotifyCurDiamond.Diamond)
  return _internal_diamond();
}
inline void NotifyCurDiamond::set_diamond(::uint64_t value) {
  _internal_set_diamond(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.NotifyCurDiamond.Diamond)
}
inline ::uint64_t NotifyCurDiamond::_internal_diamond() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.diamond_;
}
inline void NotifyCurDiamond::_internal_set_diamond(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diamond_ = value;
}

// -------------------------------------------------------------------

// GetloginRewardSuccess

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginRewardSuccess];
inline bool GetloginRewardSuccess::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetloginRewardSuccess::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 124;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID GetloginRewardSuccess::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginRewardSuccess.msgid)
  return _internal_msgid();
}
inline void GetloginRewardSuccess::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginRewardSuccess.msgid)
}
inline ::GSToGC::MsgID GetloginRewardSuccess::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GetloginRewardSuccess::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// -------------------------------------------------------------------

// GetloginReward_Skin

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginReward_Skin];
inline bool GetloginReward_Skin::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetloginReward_Skin::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 125;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID GetloginReward_Skin::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginReward_Skin.msgid)
  return _internal_msgid();
}
inline void GetloginReward_Skin::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginReward_Skin.msgid)
}
inline ::GSToGC::MsgID GetloginReward_Skin::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GetloginReward_Skin::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 skinid = 2;
inline bool GetloginReward_Skin::has_skinid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetloginReward_Skin::clear_skinid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skinid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t GetloginReward_Skin::skinid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginReward_Skin.skinid)
  return _internal_skinid();
}
inline void GetloginReward_Skin::set_skinid(::int64_t value) {
  _internal_set_skinid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginReward_Skin.skinid)
}
inline ::int64_t GetloginReward_Skin::_internal_skinid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.skinid_;
}
inline void GetloginReward_Skin::_internal_set_skinid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.skinid_ = value;
}

// -------------------------------------------------------------------

// GetloginReward_Rune

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginReward_Rune];
inline bool GetloginReward_Rune::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetloginReward_Rune::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 126;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::GSToGC::MsgID GetloginReward_Rune::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginReward_Rune.msgid)
  return _internal_msgid();
}
inline void GetloginReward_Rune::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginReward_Rune.msgid)
}
inline ::GSToGC::MsgID GetloginReward_Rune::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GetloginReward_Rune::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional int64 runeid = 2;
inline bool GetloginReward_Rune::has_runeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetloginReward_Rune::clear_runeid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t GetloginReward_Rune::runeid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginReward_Rune.runeid)
  return _internal_runeid();
}
inline void GetloginReward_Rune::set_runeid(::int64_t value) {
  _internal_set_runeid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginReward_Rune.runeid)
}
inline ::int64_t GetloginReward_Rune::_internal_runeid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runeid_;
}
inline void GetloginReward_Rune::_internal_set_runeid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeid_ = value;
}

// -------------------------------------------------------------------

// GetloginReward_Hero

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_NotifyGetloginReward_Hero];
inline bool GetloginReward_Hero::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void GetloginReward_Hero::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 127;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID GetloginReward_Hero::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginReward_Hero.msgid)
  return _internal_msgid();
}
inline void GetloginReward_Hero::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginReward_Hero.msgid)
}
inline ::GSToGC::MsgID GetloginReward_Hero::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void GetloginReward_Hero::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint32 heroid = 2;
inline bool GetloginReward_Hero::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void GetloginReward_Hero::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t GetloginReward_Hero::heroid() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginReward_Hero.heroid)
  return _internal_heroid();
}
inline void GetloginReward_Hero::set_heroid(::uint32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginReward_Hero.heroid)
}
inline ::uint32_t GetloginReward_Hero::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void GetloginReward_Hero::_internal_set_heroid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// optional int64 expired_time = 3;
inline bool GetloginReward_Hero::has_expired_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GetloginReward_Hero::clear_expired_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expired_time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t GetloginReward_Hero::expired_time() const {
  // @@protoc_insertion_point(field_get:GSToGC.GetloginReward_Hero.expired_time)
  return _internal_expired_time();
}
inline void GetloginReward_Hero::set_expired_time(::int64_t value) {
  _internal_set_expired_time(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.GetloginReward_Hero.expired_time)
}
inline ::int64_t GetloginReward_Hero::_internal_expired_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expired_time_;
}
inline void GetloginReward_Hero::_internal_set_expired_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expired_time_ = value;
}

// -------------------------------------------------------------------

// CanInviteFriends_Friends

// optional int32 HeaderId = 1;
inline bool CanInviteFriends_Friends::has_headerid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CanInviteFriends_Friends::clear_headerid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headerid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CanInviteFriends_Friends::headerid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CanInviteFriends.Friends.HeaderId)
  return _internal_headerid();
}
inline void CanInviteFriends_Friends::set_headerid(::int32_t value) {
  _internal_set_headerid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.CanInviteFriends.Friends.HeaderId)
}
inline ::int32_t CanInviteFriends_Friends::_internal_headerid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.headerid_;
}
inline void CanInviteFriends_Friends::_internal_set_headerid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.headerid_ = value;
}

// optional string nickname = 2;
inline bool CanInviteFriends_Friends::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CanInviteFriends_Friends::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CanInviteFriends_Friends::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.CanInviteFriends.Friends.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CanInviteFriends_Friends::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.CanInviteFriends.Friends.nickname)
}
inline std::string* CanInviteFriends_Friends::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:GSToGC.CanInviteFriends.Friends.nickname)
  return _s;
}
inline const std::string& CanInviteFriends_Friends::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void CanInviteFriends_Friends::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* CanInviteFriends_Friends::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* CanInviteFriends_Friends::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.CanInviteFriends.Friends.nickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CanInviteFriends_Friends::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.CanInviteFriends.Friends.nickname)
}

// optional uint64 guididx = 3;
inline bool CanInviteFriends_Friends::has_guididx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CanInviteFriends_Friends::clear_guididx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t CanInviteFriends_Friends::guididx() const {
  // @@protoc_insertion_point(field_get:GSToGC.CanInviteFriends.Friends.guididx)
  return _internal_guididx();
}
inline void CanInviteFriends_Friends::set_guididx(::uint64_t value) {
  _internal_set_guididx(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.CanInviteFriends.Friends.guididx)
}
inline ::uint64_t CanInviteFriends_Friends::_internal_guididx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guididx_;
}
inline void CanInviteFriends_Friends::_internal_set_guididx(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guididx_ = value;
}

// -------------------------------------------------------------------

// CanInviteFriends

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyCanInviteFriends];
inline bool CanInviteFriends::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CanInviteFriends::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 141;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID CanInviteFriends::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.CanInviteFriends.msgid)
  return _internal_msgid();
}
inline void CanInviteFriends::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.CanInviteFriends.msgid)
}
inline ::GSToGC::MsgID CanInviteFriends::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void CanInviteFriends::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.CanInviteFriends.Friends friends = 2;
inline int CanInviteFriends::_internal_friends_size() const {
  return _internal_friends().size();
}
inline int CanInviteFriends::friends_size() const {
  return _internal_friends_size();
}
inline void CanInviteFriends::clear_friends() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.friends_.Clear();
}
inline ::GSToGC::CanInviteFriends_Friends* CanInviteFriends::mutable_friends(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.CanInviteFriends.friends)
  return _internal_mutable_friends()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>* CanInviteFriends::mutable_friends()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.CanInviteFriends.friends)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_friends();
}
inline const ::GSToGC::CanInviteFriends_Friends& CanInviteFriends::friends(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.CanInviteFriends.friends)
  return _internal_friends().Get(index);
}
inline ::GSToGC::CanInviteFriends_Friends* CanInviteFriends::add_friends() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::CanInviteFriends_Friends* _add = _internal_mutable_friends()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.CanInviteFriends.friends)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>& CanInviteFriends::friends() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.CanInviteFriends.friends)
  return _internal_friends();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>&
CanInviteFriends::_internal_friends() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.friends_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::CanInviteFriends_Friends>*
CanInviteFriends::_internal_mutable_friends() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.friends_;
}

// -------------------------------------------------------------------

// LastHitNum

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromBS_NotifyCurLastHitNum];
inline bool LastHitNum::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void LastHitNum::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 142;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::GSToGC::MsgID LastHitNum::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LastHitNum.msgid)
  return _internal_msgid();
}
inline void LastHitNum::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.LastHitNum.msgid)
}
inline ::GSToGC::MsgID LastHitNum::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void LastHitNum::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional uint64 guid = 2;
inline bool LastHitNum::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void LastHitNum::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t LastHitNum::guid() const {
  // @@protoc_insertion_point(field_get:GSToGC.LastHitNum.guid)
  return _internal_guid();
}
inline void LastHitNum::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.LastHitNum.guid)
}
inline ::uint64_t LastHitNum::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void LastHitNum::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 lhnum = 3;
inline bool LastHitNum::has_lhnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void LastHitNum::clear_lhnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lhnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t LastHitNum::lhnum() const {
  // @@protoc_insertion_point(field_get:GSToGC.LastHitNum.lhnum)
  return _internal_lhnum();
}
inline void LastHitNum::set_lhnum(::int32_t value) {
  _internal_set_lhnum(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.LastHitNum.lhnum)
}
inline ::int32_t LastHitNum::_internal_lhnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lhnum_;
}
inline void LastHitNum::_internal_set_lhnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lhnum_ = value;
}

// -------------------------------------------------------------------

// RoomInfo

// optional int32 roomId = 1;
inline bool RoomInfo::has_roomid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RoomInfo::clear_roomid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roomid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t RoomInfo::roomid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomInfo.roomId)
  return _internal_roomid();
}
inline void RoomInfo::set_roomid(::int32_t value) {
  _internal_set_roomid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomInfo.roomId)
}
inline ::int32_t RoomInfo::_internal_roomid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roomid_;
}
inline void RoomInfo::_internal_set_roomid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roomid_ = value;
}

// optional int32 ifPwd = 2;
inline bool RoomInfo::has_ifpwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RoomInfo::clear_ifpwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifpwd_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t RoomInfo::ifpwd() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomInfo.ifPwd)
  return _internal_ifpwd();
}
inline void RoomInfo::set_ifpwd(::int32_t value) {
  _internal_set_ifpwd(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomInfo.ifPwd)
}
inline ::int32_t RoomInfo::_internal_ifpwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifpwd_;
}
inline void RoomInfo::_internal_set_ifpwd(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifpwd_ = value;
}

// optional int32 mapId = 3;
inline bool RoomInfo::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RoomInfo::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t RoomInfo::mapid() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomInfo.mapId)
  return _internal_mapid();
}
inline void RoomInfo::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomInfo.mapId)
}
inline ::int32_t RoomInfo::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void RoomInfo::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// optional string master = 4;
inline bool RoomInfo::has_master() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RoomInfo::clear_master() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.master_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RoomInfo::master() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.RoomInfo.master)
  return _internal_master();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RoomInfo::set_master(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.master_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:GSToGC.RoomInfo.master)
}
inline std::string* RoomInfo::mutable_master() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_master();
  // @@protoc_insertion_point(field_mutable:GSToGC.RoomInfo.master)
  return _s;
}
inline const std::string& RoomInfo::_internal_master() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.master_.Get();
}
inline void RoomInfo::_internal_set_master(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.master_.Set(value, GetArena());
}
inline std::string* RoomInfo::_internal_mutable_master() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.master_.Mutable( GetArena());
}
inline std::string* RoomInfo::release_master() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:GSToGC.RoomInfo.master)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.master_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.master_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RoomInfo::set_allocated_master(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.master_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.master_.IsDefault()) {
          _impl_.master_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GSToGC.RoomInfo.master)
}

// optional int32 curUserCount = 5;
inline bool RoomInfo::has_curusercount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RoomInfo::clear_curusercount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curusercount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t RoomInfo::curusercount() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomInfo.curUserCount)
  return _internal_curusercount();
}
inline void RoomInfo::set_curusercount(::int32_t value) {
  _internal_set_curusercount(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomInfo.curUserCount)
}
inline ::int32_t RoomInfo::_internal_curusercount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curusercount_;
}
inline void RoomInfo::_internal_set_curusercount(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curusercount_ = value;
}

// optional int32 maxUserCount = 6;
inline bool RoomInfo::has_maxusercount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void RoomInfo::clear_maxusercount() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxusercount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t RoomInfo::maxusercount() const {
  // @@protoc_insertion_point(field_get:GSToGC.RoomInfo.maxUserCount)
  return _internal_maxusercount();
}
inline void RoomInfo::set_maxusercount(::int32_t value) {
  _internal_set_maxusercount(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:GSToGC.RoomInfo.maxUserCount)
}
inline ::int32_t RoomInfo::_internal_maxusercount() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxusercount_;
}
inline void RoomInfo::_internal_set_maxusercount(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxusercount_ = value;
}

// -------------------------------------------------------------------

// AskRoomListRet

// optional .GSToGC.MsgID msgid = 1 [default = eMsgToGCFromGS_AskRoomListRet];
inline bool AskRoomListRet::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRoomListRet::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 143;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::GSToGC::MsgID AskRoomListRet::msgid() const {
  // @@protoc_insertion_point(field_get:GSToGC.AskRoomListRet.msgid)
  return _internal_msgid();
}
inline void AskRoomListRet::set_msgid(::GSToGC::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:GSToGC.AskRoomListRet.msgid)
}
inline ::GSToGC::MsgID AskRoomListRet::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::GSToGC::MsgID>(_impl_.msgid_);
}
inline void AskRoomListRet::_internal_set_msgid(::GSToGC::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::GSToGC::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .GSToGC.RoomInfo roomlist = 2;
inline int AskRoomListRet::_internal_roomlist_size() const {
  return _internal_roomlist().size();
}
inline int AskRoomListRet::roomlist_size() const {
  return _internal_roomlist_size();
}
inline void AskRoomListRet::clear_roomlist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.roomlist_.Clear();
}
inline ::GSToGC::RoomInfo* AskRoomListRet::mutable_roomlist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:GSToGC.AskRoomListRet.roomlist)
  return _internal_mutable_roomlist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>* AskRoomListRet::mutable_roomlist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:GSToGC.AskRoomListRet.roomlist)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_roomlist();
}
inline const ::GSToGC::RoomInfo& AskRoomListRet::roomlist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:GSToGC.AskRoomListRet.roomlist)
  return _internal_roomlist().Get(index);
}
inline ::GSToGC::RoomInfo* AskRoomListRet::add_roomlist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::GSToGC::RoomInfo* _add = _internal_mutable_roomlist()->Add();
  // @@protoc_insertion_point(field_add:GSToGC.AskRoomListRet.roomlist)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>& AskRoomListRet::roomlist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:GSToGC.AskRoomListRet.roomlist)
  return _internal_roomlist();
}
inline const ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>&
AskRoomListRet::_internal_roomlist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.roomlist_;
}
inline ::google::protobuf::RepeatedPtrField<::GSToGC::RoomInfo>*
AskRoomListRet::_internal_mutable_roomlist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.roomlist_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace GSToGC


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::GSToGC::GuideAward_dtype> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::GuideAward_dtype>() {
  return ::GSToGC::GuideAward_dtype_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::GoodsCfgInfo_CfgType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::GoodsCfgInfo_CfgType>() {
  return ::GSToGC::GoodsCfgInfo_CfgType_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::NotifyAFPData_EnumFpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::NotifyAFPData_EnumFpType>() {
  return ::GSToGC::NotifyAFPData_EnumFpType_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::MsgID> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::MsgID>() {
  return ::GSToGC::MsgID_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::MailType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::MailType>() {
  return ::GSToGC::MailType_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::EMailCurtState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::EMailCurtState>() {
  return ::GSToGC::EMailCurtState_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::BattleState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::BattleState>() {
  return ::GSToGC::BattleState_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::ObjType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::ObjType>() {
  return ::GSToGC::ObjType_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::HPMPChangeReason> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::HPMPChangeReason>() {
  return ::GSToGC::HPMPChangeReason_descriptor();
}
template <>
struct is_proto_enum<::GSToGC::SkillState> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::GSToGC::SkillState>() {
  return ::GSToGC::SkillState_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_GSToGC_2eproto_2epb_2eh
