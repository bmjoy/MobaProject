// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DBToCs.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_DBToCs_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_DBToCs_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_DBToCs_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_DBToCs_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_DBToCs_2eproto;
namespace DBToCS {
class BuyGoods;
struct BuyGoodsDefaultTypeInternal;
extern BuyGoodsDefaultTypeInternal _BuyGoods_default_instance_;
class CDKeyEvents;
struct CDKeyEventsDefaultTypeInternal;
extern CDKeyEventsDefaultTypeInternal _CDKeyEvents_default_instance_;
class CDKeyEvents_event_info;
struct CDKeyEvents_event_infoDefaultTypeInternal;
extern CDKeyEvents_event_infoDefaultTypeInternal _CDKeyEvents_event_info_default_instance_;
class ChangeNickname;
struct ChangeNicknameDefaultTypeInternal;
extern ChangeNicknameDefaultTypeInternal _ChangeNickname_default_instance_;
class CheckNameRsp;
struct CheckNameRspDefaultTypeInternal;
extern CheckNameRspDefaultTypeInternal _CheckNameRsp_default_instance_;
class HeroCfg;
struct HeroCfgDefaultTypeInternal;
extern HeroCfgDefaultTypeInternal _HeroCfg_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class MailCallBack;
struct MailCallBackDefaultTypeInternal;
extern MailCallBackDefaultTypeInternal _MailCallBack_default_instance_;
class MailInfo;
struct MailInfoDefaultTypeInternal;
extern MailInfoDefaultTypeInternal _MailInfo_default_instance_;
class QueryAllAccount;
struct QueryAllAccountDefaultTypeInternal;
extern QueryAllAccountDefaultTypeInternal _QueryAllAccount_default_instance_;
class QueryAllAccount_Account;
struct QueryAllAccount_AccountDefaultTypeInternal;
extern QueryAllAccount_AccountDefaultTypeInternal _QueryAllAccount_Account_default_instance_;
class QueryAllUser;
struct QueryAllUserDefaultTypeInternal;
extern QueryAllUserDefaultTypeInternal _QueryAllUser_default_instance_;
class QueryNotice;
struct QueryNoticeDefaultTypeInternal;
extern QueryNoticeDefaultTypeInternal _QueryNotice_default_instance_;
class QueryNotice_Notice;
struct QueryNotice_NoticeDefaultTypeInternal;
extern QueryNotice_NoticeDefaultTypeInternal _QueryNotice_Notice_default_instance_;
class QueryUser;
struct QueryUserDefaultTypeInternal;
extern QueryUserDefaultTypeInternal _QueryUser_default_instance_;
class RSinfo;
struct RSinfoDefaultTypeInternal;
extern RSinfoDefaultTypeInternal _RSinfo_default_instance_;
class RuneInfo;
struct RuneInfoDefaultTypeInternal;
extern RuneInfoDefaultTypeInternal _RuneInfo_default_instance_;
}  // namespace DBToCS
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace DBToCS {
enum MsgID : int {
  eCheckNickNameLogicCallBack = 1,
  eQueryUser_DBCallBack = 2,
  eBuyGoodsCallBack = 3,
  eChangeNickname_CallBack = 4,
  eQueryNotice_CallBack = 5,
  eMail_CallBack = 6,
  eQueryAllAccount_CallBack = 7,
  eQueryCDKeyEvents_CallBack = 8,
  eQueryAllUser_CallBack = 9,
};

bool MsgID_IsValid(int value);
extern const uint32_t MsgID_internal_data_[];
constexpr MsgID MsgID_MIN = static_cast<MsgID>(1);
constexpr MsgID MsgID_MAX = static_cast<MsgID>(9);
constexpr int MsgID_ARRAYSIZE = 9 + 1;
const ::google::protobuf::EnumDescriptor*
MsgID_descriptor();
template <typename T>
const std::string& MsgID_Name(T value) {
  static_assert(std::is_same<T, MsgID>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgID_Name().");
  return MsgID_Name(static_cast<MsgID>(value));
}
template <>
inline const std::string& MsgID_Name(MsgID value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MsgID_descriptor,
                                                 1, 9>(
      static_cast<int>(value));
}
inline bool MsgID_Parse(absl::string_view name, MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgID>(
      MsgID_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class RuneInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.RuneInfo) */ {
 public:
  inline RuneInfo() : RuneInfo(nullptr) {}
  ~RuneInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RuneInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RuneInfo(const RuneInfo& from) : RuneInfo(nullptr, from) {}
  inline RuneInfo(RuneInfo&& from) noexcept
      : RuneInfo(nullptr, std::move(from)) {}
  inline RuneInfo& operator=(const RuneInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuneInfo& operator=(RuneInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuneInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuneInfo* internal_default_instance() {
    return reinterpret_cast<const RuneInfo*>(
        &_RuneInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(RuneInfo& a, RuneInfo& b) { a.Swap(&b); }
  inline void Swap(RuneInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuneInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuneInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RuneInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RuneInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RuneInfo& from) { RuneInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RuneInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.RuneInfo"; }

 protected:
  explicit RuneInfo(::google::protobuf::Arena* arena);
  RuneInfo(::google::protobuf::Arena* arena, const RuneInfo& from);
  RuneInfo(::google::protobuf::Arena* arena, RuneInfo&& from) noexcept
      : RuneInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBagStrFieldNumber = 1,
    kSlotStrFieldNumber = 2,
  };
  // optional string bagStr = 1;
  bool has_bagstr() const;
  void clear_bagstr() ;
  const std::string& bagstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_bagstr(Arg_&& arg, Args_... args);
  std::string* mutable_bagstr();
  PROTOBUF_NODISCARD std::string* release_bagstr();
  void set_allocated_bagstr(std::string* value);

  private:
  const std::string& _internal_bagstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bagstr(
      const std::string& value);
  std::string* _internal_mutable_bagstr();

  public:
  // optional string slotStr = 2;
  bool has_slotstr() const;
  void clear_slotstr() ;
  const std::string& slotstr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_slotstr(Arg_&& arg, Args_... args);
  std::string* mutable_slotstr();
  PROTOBUF_NODISCARD std::string* release_slotstr();
  void set_allocated_slotstr(std::string* value);

  private:
  const std::string& _internal_slotstr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_slotstr(
      const std::string& value);
  std::string* _internal_mutable_slotstr();

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.RuneInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      37, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr bagstr_;
    ::google::protobuf::internal::ArenaStringPtr slotstr_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class RSinfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.RSinfo) */ {
 public:
  inline RSinfo() : RSinfo(nullptr) {}
  ~RSinfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RSinfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline RSinfo(const RSinfo& from) : RSinfo(nullptr, from) {}
  inline RSinfo(RSinfo&& from) noexcept
      : RSinfo(nullptr, std::move(from)) {}
  inline RSinfo& operator=(const RSinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RSinfo& operator=(RSinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RSinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RSinfo* internal_default_instance() {
    return reinterpret_cast<const RSinfo*>(
        &_RSinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(RSinfo& a, RSinfo& b) { a.Swap(&b); }
  inline void Swap(RSinfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RSinfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RSinfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RSinfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RSinfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RSinfo& from) { RSinfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RSinfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.RSinfo"; }

 protected:
  explicit RSinfo(::google::protobuf::Arena* arena);
  RSinfo(::google::protobuf::Arena* arena, const RSinfo& from);
  RSinfo(::google::protobuf::Arena* arena, RSinfo&& from) noexcept
      : RSinfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRelatedNameFieldNumber = 3,
    kRelatedIdFieldNumber = 1,
    kRelatedHeaderFieldNumber = 2,
    kRelationFieldNumber = 4,
    kRelatedVipFieldNumber = 5,
  };
  // optional string related_name = 3;
  bool has_related_name() const;
  void clear_related_name() ;
  const std::string& related_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_related_name(Arg_&& arg, Args_... args);
  std::string* mutable_related_name();
  PROTOBUF_NODISCARD std::string* release_related_name();
  void set_allocated_related_name(std::string* value);

  private:
  const std::string& _internal_related_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_related_name(
      const std::string& value);
  std::string* _internal_mutable_related_name();

  public:
  // optional uint64 related_id = 1;
  bool has_related_id() const;
  void clear_related_id() ;
  ::uint64_t related_id() const;
  void set_related_id(::uint64_t value);

  private:
  ::uint64_t _internal_related_id() const;
  void _internal_set_related_id(::uint64_t value);

  public:
  // optional uint32 related_header = 2;
  bool has_related_header() const;
  void clear_related_header() ;
  ::uint32_t related_header() const;
  void set_related_header(::uint32_t value);

  private:
  ::uint32_t _internal_related_header() const;
  void _internal_set_related_header(::uint32_t value);

  public:
  // optional uint32 relation = 4;
  bool has_relation() const;
  void clear_relation() ;
  ::uint32_t relation() const;
  void set_relation(::uint32_t value);

  private:
  ::uint32_t _internal_relation() const;
  void _internal_set_relation(::uint32_t value);

  public:
  // optional uint32 related_vip = 5;
  bool has_related_vip() const;
  void clear_related_vip() ;
  ::uint32_t related_vip() const;
  void set_related_vip(::uint32_t value);

  private:
  ::uint32_t _internal_related_vip() const;
  void _internal_set_related_vip(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.RSinfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr related_name_;
    ::uint64_t related_id_;
    ::uint32_t related_header_;
    ::uint32_t relation_;
    ::uint32_t related_vip_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class QueryNotice_Notice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.QueryNotice.Notice) */ {
 public:
  inline QueryNotice_Notice() : QueryNotice_Notice(nullptr) {}
  ~QueryNotice_Notice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryNotice_Notice(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryNotice_Notice(const QueryNotice_Notice& from) : QueryNotice_Notice(nullptr, from) {}
  inline QueryNotice_Notice(QueryNotice_Notice&& from) noexcept
      : QueryNotice_Notice(nullptr, std::move(from)) {}
  inline QueryNotice_Notice& operator=(const QueryNotice_Notice& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryNotice_Notice& operator=(QueryNotice_Notice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryNotice_Notice& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryNotice_Notice* internal_default_instance() {
    return reinterpret_cast<const QueryNotice_Notice*>(
        &_QueryNotice_Notice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(QueryNotice_Notice& a, QueryNotice_Notice& b) { a.Swap(&b); }
  inline void Swap(QueryNotice_Notice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryNotice_Notice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryNotice_Notice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryNotice_Notice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryNotice_Notice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryNotice_Notice& from) { QueryNotice_Notice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryNotice_Notice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.QueryNotice.Notice"; }

 protected:
  explicit QueryNotice_Notice(::google::protobuf::Arena* arena);
  QueryNotice_Notice(::google::protobuf::Arena* arena, const QueryNotice_Notice& from);
  QueryNotice_Notice(::google::protobuf::Arena* arena, QueryNotice_Notice&& from) noexcept
      : QueryNotice_Notice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTitleFieldNumber = 2,
    kNoticeFieldNumber = 6,
    kIdFieldNumber = 1,
    kEflagFieldNumber = 3,
    kEstateFieldNumber = 4,
    kPriorityFieldNumber = 5,
    kStarTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
    kPlatformFieldNumber = 9,
  };
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string notice = 6;
  bool has_notice() const;
  void clear_notice() ;
  const std::string& notice() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_notice(Arg_&& arg, Args_... args);
  std::string* mutable_notice();
  PROTOBUF_NODISCARD std::string* release_notice();
  void set_allocated_notice(std::string* value);

  private:
  const std::string& _internal_notice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notice(
      const std::string& value);
  std::string* _internal_mutable_notice();

  public:
  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // optional int32 eflag = 3;
  bool has_eflag() const;
  void clear_eflag() ;
  ::int32_t eflag() const;
  void set_eflag(::int32_t value);

  private:
  ::int32_t _internal_eflag() const;
  void _internal_set_eflag(::int32_t value);

  public:
  // optional int32 estate = 4;
  bool has_estate() const;
  void clear_estate() ;
  ::int32_t estate() const;
  void set_estate(::int32_t value);

  private:
  ::int32_t _internal_estate() const;
  void _internal_set_estate(::int32_t value);

  public:
  // optional int32 priority = 5;
  bool has_priority() const;
  void clear_priority() ;
  ::int32_t priority() const;
  void set_priority(::int32_t value);

  private:
  ::int32_t _internal_priority() const;
  void _internal_set_priority(::int32_t value);

  public:
  // optional uint64 star_time = 7;
  bool has_star_time() const;
  void clear_star_time() ;
  ::uint64_t star_time() const;
  void set_star_time(::uint64_t value);

  private:
  ::uint64_t _internal_star_time() const;
  void _internal_set_star_time(::uint64_t value);

  public:
  // optional uint64 end_time = 8;
  bool has_end_time() const;
  void clear_end_time() ;
  ::uint64_t end_time() const;
  void set_end_time(::uint64_t value);

  private:
  ::uint64_t _internal_end_time() const;
  void _internal_set_end_time(::uint64_t value);

  public:
  // optional uint32 platform = 9;
  bool has_platform() const;
  void clear_platform() ;
  ::uint32_t platform() const;
  void set_platform(::uint32_t value);

  private:
  ::uint32_t _internal_platform() const;
  void _internal_set_platform(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.QueryNotice.Notice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      53, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr notice_;
    ::uint32_t id_;
    ::int32_t eflag_;
    ::int32_t estate_;
    ::int32_t priority_;
    ::uint64_t star_time_;
    ::uint64_t end_time_;
    ::uint32_t platform_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class QueryAllAccount_Account final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.QueryAllAccount.Account) */ {
 public:
  inline QueryAllAccount_Account() : QueryAllAccount_Account(nullptr) {}
  ~QueryAllAccount_Account() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAllAccount_Account(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryAllAccount_Account(const QueryAllAccount_Account& from) : QueryAllAccount_Account(nullptr, from) {}
  inline QueryAllAccount_Account(QueryAllAccount_Account&& from) noexcept
      : QueryAllAccount_Account(nullptr, std::move(from)) {}
  inline QueryAllAccount_Account& operator=(const QueryAllAccount_Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAllAccount_Account& operator=(QueryAllAccount_Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAllAccount_Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAllAccount_Account* internal_default_instance() {
    return reinterpret_cast<const QueryAllAccount_Account*>(
        &_QueryAllAccount_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(QueryAllAccount_Account& a, QueryAllAccount_Account& b) { a.Swap(&b); }
  inline void Swap(QueryAllAccount_Account* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAllAccount_Account* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAllAccount_Account* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryAllAccount_Account>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryAllAccount_Account& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryAllAccount_Account& from) { QueryAllAccount_Account::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryAllAccount_Account* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.QueryAllAccount.Account"; }

 protected:
  explicit QueryAllAccount_Account(::google::protobuf::Arena* arena);
  QueryAllAccount_Account(::google::protobuf::Arena* arena, const QueryAllAccount_Account& from);
  QueryAllAccount_Account(::google::protobuf::Arena* arena, QueryAllAccount_Account&& from) noexcept
      : QueryAllAccount_Account(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserNameFieldNumber = 1,
    kNicknameFieldNumber = 4,
    kCsidFieldNumber = 2,
    kSdkidFieldNumber = 3,
    kGuidFieldNumber = 5,
  };
  // optional string user_name = 1;
  bool has_user_name() const;
  void clear_user_name() ;
  const std::string& user_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user_name(Arg_&& arg, Args_... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* value);

  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(
      const std::string& value);
  std::string* _internal_mutable_user_name();

  public:
  // optional string nickname = 4;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional int32 csid = 2;
  bool has_csid() const;
  void clear_csid() ;
  ::int32_t csid() const;
  void set_csid(::int32_t value);

  private:
  ::int32_t _internal_csid() const;
  void _internal_set_csid(::int32_t value);

  public:
  // optional int32 sdkid = 3;
  bool has_sdkid() const;
  void clear_sdkid() ;
  ::int32_t sdkid() const;
  void set_sdkid(::int32_t value);

  private:
  ::int32_t _internal_sdkid() const;
  void _internal_set_sdkid(::int32_t value);

  public:
  // optional int64 guid = 5;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.QueryAllAccount.Account)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      56, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr user_name_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::int32_t csid_;
    ::int32_t sdkid_;
    ::int64_t guid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class MailInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.MailInfo) */ {
 public:
  inline MailInfo() : MailInfo(nullptr) {}
  ~MailInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MailInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline MailInfo(const MailInfo& from) : MailInfo(nullptr, from) {}
  inline MailInfo(MailInfo&& from) noexcept
      : MailInfo(nullptr, std::move(from)) {}
  inline MailInfo& operator=(const MailInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailInfo& operator=(MailInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailInfo* internal_default_instance() {
    return reinterpret_cast<const MailInfo*>(
        &_MailInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(MailInfo& a, MailInfo& b) { a.Swap(&b); }
  inline void Swap(MailInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MailInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MailInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MailInfo& from) { MailInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MailInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.MailInfo"; }

 protected:
  explicit MailInfo(::google::protobuf::Arena* arena);
  MailInfo(::google::protobuf::Arena* arena, const MailInfo& from);
  MailInfo(::google::protobuf::Arena* arena, MailInfo&& from) noexcept
      : MailInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMailidFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // optional int32 mailid = 1;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional int32 state = 2;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.MailInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mailid_;
    ::int32_t state_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class MailCallBack final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.MailCallBack) */ {
 public:
  inline MailCallBack() : MailCallBack(nullptr) {}
  ~MailCallBack() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MailCallBack(
      ::google::protobuf::internal::ConstantInitialized);

  inline MailCallBack(const MailCallBack& from) : MailCallBack(nullptr, from) {}
  inline MailCallBack(MailCallBack&& from) noexcept
      : MailCallBack(nullptr, std::move(from)) {}
  inline MailCallBack& operator=(const MailCallBack& from) {
    CopyFrom(from);
    return *this;
  }
  inline MailCallBack& operator=(MailCallBack&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MailCallBack& default_instance() {
    return *internal_default_instance();
  }
  static inline const MailCallBack* internal_default_instance() {
    return reinterpret_cast<const MailCallBack*>(
        &_MailCallBack_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(MailCallBack& a, MailCallBack& b) { a.Swap(&b); }
  inline void Swap(MailCallBack* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MailCallBack* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MailCallBack* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<MailCallBack>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MailCallBack& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MailCallBack& from) { MailCallBack::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MailCallBack* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.MailCallBack"; }

 protected:
  explicit MailCallBack(::google::protobuf::Arena* arena);
  MailCallBack(::google::protobuf::Arena* arena, const MailCallBack& from);
  MailCallBack(::google::protobuf::Arena* arena, MailCallBack&& from) noexcept
      : MailCallBack(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTitleFieldNumber = 5,
    kContentFieldNumber = 6,
    kGiftFieldNumber = 7,
    kSenderFieldNumber = 8,
    kCreatetimeFieldNumber = 9,
    kMailidFieldNumber = 2,
    kMailtypeFieldNumber = 3,
    kObjidFieldNumber = 10,
    kChannelFieldNumber = 4,
    kMgsidFieldNumber = 1,
  };
  // optional string title = 5;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string content = 6;
  bool has_content() const;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // optional string gift = 7;
  bool has_gift() const;
  void clear_gift() ;
  const std::string& gift() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_gift(Arg_&& arg, Args_... args);
  std::string* mutable_gift();
  PROTOBUF_NODISCARD std::string* release_gift();
  void set_allocated_gift(std::string* value);

  private:
  const std::string& _internal_gift() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gift(
      const std::string& value);
  std::string* _internal_mutable_gift();

  public:
  // optional string sender = 8;
  bool has_sender() const;
  void clear_sender() ;
  const std::string& sender() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sender(Arg_&& arg, Args_... args);
  std::string* mutable_sender();
  PROTOBUF_NODISCARD std::string* release_sender();
  void set_allocated_sender(std::string* value);

  private:
  const std::string& _internal_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(
      const std::string& value);
  std::string* _internal_mutable_sender();

  public:
  // optional string createtime = 9;
  bool has_createtime() const;
  void clear_createtime() ;
  const std::string& createtime() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_createtime(Arg_&& arg, Args_... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* value);

  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(
      const std::string& value);
  std::string* _internal_mutable_createtime();

  public:
  // optional int32 mailid = 2;
  bool has_mailid() const;
  void clear_mailid() ;
  ::int32_t mailid() const;
  void set_mailid(::int32_t value);

  private:
  ::int32_t _internal_mailid() const;
  void _internal_set_mailid(::int32_t value);

  public:
  // optional int32 mailtype = 3;
  bool has_mailtype() const;
  void clear_mailtype() ;
  ::int32_t mailtype() const;
  void set_mailtype(::int32_t value);

  private:
  ::int32_t _internal_mailtype() const;
  void _internal_set_mailtype(::int32_t value);

  public:
  // optional int64 objid = 10;
  bool has_objid() const;
  void clear_objid() ;
  ::int64_t objid() const;
  void set_objid(::int64_t value);

  private:
  ::int64_t _internal_objid() const;
  void _internal_set_objid(::int64_t value);

  public:
  // optional int32 channel = 4;
  bool has_channel() const;
  void clear_channel() ;
  ::int32_t channel() const;
  void set_channel(::int32_t value);

  private:
  ::int32_t _internal_channel() const;
  void _internal_set_channel(::int32_t value);

  public:
  // optional .DBToCS.MsgID mgsid = 1 [default = eMail_CallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::DBToCS::MsgID mgsid() const;
  void set_mgsid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.MailCallBack)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 1,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr gift_;
    ::google::protobuf::internal::ArenaStringPtr sender_;
    ::google::protobuf::internal::ArenaStringPtr createtime_;
    ::int32_t mailid_;
    ::int32_t mailtype_;
    ::int64_t objid_;
    ::int32_t channel_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ItemInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline ItemInfo(const ItemInfo& from) : ItemInfo(nullptr, from) {}
  inline ItemInfo(ItemInfo&& from) noexcept
      : ItemInfo(nullptr, std::move(from)) {}
  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
        &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ItemInfo& a, ItemInfo& b) { a.Swap(&b); }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ItemInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ItemInfo& from) { ItemInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ItemInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.ItemInfo"; }

 protected:
  explicit ItemInfo(::google::protobuf::Arena* arena);
  ItemInfo(::google::protobuf::Arena* arena, const ItemInfo& from);
  ItemInfo(::google::protobuf::Arena* arena, ItemInfo&& from) noexcept
      : ItemInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kItemIdFieldNumber = 1,
    kItemNumFieldNumber = 2,
    kBuyTimeFieldNumber = 3,
    kEndTimeFieldNumber = 4,
  };
  // optional int32 item_id = 1;
  bool has_item_id() const;
  void clear_item_id() ;
  ::int32_t item_id() const;
  void set_item_id(::int32_t value);

  private:
  ::int32_t _internal_item_id() const;
  void _internal_set_item_id(::int32_t value);

  public:
  // optional uint32 item_num = 2;
  bool has_item_num() const;
  void clear_item_num() ;
  ::uint32_t item_num() const;
  void set_item_num(::uint32_t value);

  private:
  ::uint32_t _internal_item_num() const;
  void _internal_set_item_num(::uint32_t value);

  public:
  // optional int32 buy_time = 3;
  bool has_buy_time() const;
  void clear_buy_time() ;
  ::int32_t buy_time() const;
  void set_buy_time(::int32_t value);

  private:
  ::int32_t _internal_buy_time() const;
  void _internal_set_buy_time(::int32_t value);

  public:
  // optional int32 end_time = 4;
  bool has_end_time() const;
  void clear_end_time() ;
  ::int32_t end_time() const;
  void set_end_time(::int32_t value);

  private:
  ::int32_t _internal_end_time() const;
  void _internal_set_end_time(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.ItemInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t item_id_;
    ::uint32_t item_num_;
    ::int32_t buy_time_;
    ::int32_t end_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class HeroCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.HeroCfg) */ {
 public:
  inline HeroCfg() : HeroCfg(nullptr) {}
  ~HeroCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeroCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeroCfg(const HeroCfg& from) : HeroCfg(nullptr, from) {}
  inline HeroCfg(HeroCfg&& from) noexcept
      : HeroCfg(nullptr, std::move(from)) {}
  inline HeroCfg& operator=(const HeroCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeroCfg& operator=(HeroCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeroCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeroCfg* internal_default_instance() {
    return reinterpret_cast<const HeroCfg*>(
        &_HeroCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(HeroCfg& a, HeroCfg& b) { a.Swap(&b); }
  inline void Swap(HeroCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeroCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeroCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<HeroCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeroCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeroCfg& from) { HeroCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeroCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.HeroCfg"; }

 protected:
  explicit HeroCfg(::google::protobuf::Arena* arena);
  HeroCfg(::google::protobuf::Arena* arena, const HeroCfg& from);
  HeroCfg(::google::protobuf::Arena* arena, HeroCfg&& from) noexcept
      : HeroCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBuytimeFieldNumber = 2,
    kExpiredtimeFieldNumber = 3,
    kCommodityidFieldNumber = 1,
  };
  // optional int64 buytime = 2;
  bool has_buytime() const;
  void clear_buytime() ;
  ::int64_t buytime() const;
  void set_buytime(::int64_t value);

  private:
  ::int64_t _internal_buytime() const;
  void _internal_set_buytime(::int64_t value);

  public:
  // optional int64 expiredtime = 3;
  bool has_expiredtime() const;
  void clear_expiredtime() ;
  ::int64_t expiredtime() const;
  void set_expiredtime(::int64_t value);

  private:
  ::int64_t _internal_expiredtime() const;
  void _internal_set_expiredtime(::int64_t value);

  public:
  // optional uint32 commodityid = 1;
  bool has_commodityid() const;
  void clear_commodityid() ;
  ::uint32_t commodityid() const;
  void set_commodityid(::uint32_t value);

  private:
  ::uint32_t _internal_commodityid() const;
  void _internal_set_commodityid(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.HeroCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t buytime_;
    ::int64_t expiredtime_;
    ::uint32_t commodityid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class CheckNameRsp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.CheckNameRsp) */ {
 public:
  inline CheckNameRsp() : CheckNameRsp(nullptr) {}
  ~CheckNameRsp() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CheckNameRsp(
      ::google::protobuf::internal::ConstantInitialized);

  inline CheckNameRsp(const CheckNameRsp& from) : CheckNameRsp(nullptr, from) {}
  inline CheckNameRsp(CheckNameRsp&& from) noexcept
      : CheckNameRsp(nullptr, std::move(from)) {}
  inline CheckNameRsp& operator=(const CheckNameRsp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckNameRsp& operator=(CheckNameRsp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckNameRsp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckNameRsp* internal_default_instance() {
    return reinterpret_cast<const CheckNameRsp*>(
        &_CheckNameRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(CheckNameRsp& a, CheckNameRsp& b) { a.Swap(&b); }
  inline void Swap(CheckNameRsp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckNameRsp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckNameRsp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CheckNameRsp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CheckNameRsp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CheckNameRsp& from) { CheckNameRsp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CheckNameRsp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.CheckNameRsp"; }

 protected:
  explicit CheckNameRsp(::google::protobuf::Arena* arena);
  CheckNameRsp(::google::protobuf::Arena* arena, const CheckNameRsp& from);
  CheckNameRsp(::google::protobuf::Arena* arena, CheckNameRsp&& from) noexcept
      : CheckNameRsp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCompleteInfoFieldNumber = 2,
    kGsidFieldNumber = 3,
    kGcnetidFieldNumber = 4,
    kGsnetidFieldNumber = 5,
    kCheckresFieldNumber = 6,
    kMgsidFieldNumber = 1,
  };
  // optional string completeInfo = 2;
  bool has_completeinfo() const;
  void clear_completeinfo() ;
  const std::string& completeinfo() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_completeinfo(Arg_&& arg, Args_... args);
  std::string* mutable_completeinfo();
  PROTOBUF_NODISCARD std::string* release_completeinfo();
  void set_allocated_completeinfo(std::string* value);

  private:
  const std::string& _internal_completeinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_completeinfo(
      const std::string& value);
  std::string* _internal_mutable_completeinfo();

  public:
  // optional int32 gsid = 3;
  bool has_gsid() const;
  void clear_gsid() ;
  ::int32_t gsid() const;
  void set_gsid(::int32_t value);

  private:
  ::int32_t _internal_gsid() const;
  void _internal_set_gsid(::int32_t value);

  public:
  // optional int32 gcnetid = 4;
  bool has_gcnetid() const;
  void clear_gcnetid() ;
  ::int32_t gcnetid() const;
  void set_gcnetid(::int32_t value);

  private:
  ::int32_t _internal_gcnetid() const;
  void _internal_set_gcnetid(::int32_t value);

  public:
  // optional int32 gsnetid = 5;
  bool has_gsnetid() const;
  void clear_gsnetid() ;
  ::int32_t gsnetid() const;
  void set_gsnetid(::int32_t value);

  private:
  ::int32_t _internal_gsnetid() const;
  void _internal_set_gsnetid(::int32_t value);

  public:
  // optional int32 checkres = 6;
  bool has_checkres() const;
  void clear_checkres() ;
  ::int32_t checkres() const;
  void set_checkres(::int32_t value);

  private:
  ::int32_t _internal_checkres() const;
  void _internal_set_checkres(::int32_t value);

  public:
  // optional .DBToCS.MsgID mgsid = 1 [default = eCheckNickNameLogicCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::DBToCS::MsgID mgsid() const;
  void set_mgsid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.CheckNameRsp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr completeinfo_;
    ::int32_t gsid_;
    ::int32_t gcnetid_;
    ::int32_t gsnetid_;
    ::int32_t checkres_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class ChangeNickname final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.ChangeNickname) */ {
 public:
  inline ChangeNickname() : ChangeNickname(nullptr) {}
  ~ChangeNickname() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChangeNickname(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChangeNickname(const ChangeNickname& from) : ChangeNickname(nullptr, from) {}
  inline ChangeNickname(ChangeNickname&& from) noexcept
      : ChangeNickname(nullptr, std::move(from)) {}
  inline ChangeNickname& operator=(const ChangeNickname& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeNickname& operator=(ChangeNickname&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeNickname& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeNickname* internal_default_instance() {
    return reinterpret_cast<const ChangeNickname*>(
        &_ChangeNickname_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(ChangeNickname& a, ChangeNickname& b) { a.Swap(&b); }
  inline void Swap(ChangeNickname* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeNickname* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeNickname* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChangeNickname>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangeNickname& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChangeNickname& from) { ChangeNickname::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangeNickname* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.ChangeNickname"; }

 protected:
  explicit ChangeNickname(::google::protobuf::Arena* arena);
  ChangeNickname(::google::protobuf::Arena* arena, const ChangeNickname& from);
  ChangeNickname(::google::protobuf::Arena* arena, ChangeNickname&& from) noexcept
      : ChangeNickname(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNewnicknameFieldNumber = 4,
    kOldnicknameFieldNumber = 5,
    kGuidFieldNumber = 2,
    kReflagFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // optional string newnickname = 4;
  bool has_newnickname() const;
  void clear_newnickname() ;
  const std::string& newnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_newnickname(Arg_&& arg, Args_... args);
  std::string* mutable_newnickname();
  PROTOBUF_NODISCARD std::string* release_newnickname();
  void set_allocated_newnickname(std::string* value);

  private:
  const std::string& _internal_newnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newnickname(
      const std::string& value);
  std::string* _internal_mutable_newnickname();

  public:
  // optional string oldnickname = 5;
  bool has_oldnickname() const;
  void clear_oldnickname() ;
  const std::string& oldnickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_oldnickname(Arg_&& arg, Args_... args);
  std::string* mutable_oldnickname();
  PROTOBUF_NODISCARD std::string* release_oldnickname();
  void set_allocated_oldnickname(std::string* value);

  private:
  const std::string& _internal_oldnickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_oldnickname(
      const std::string& value);
  std::string* _internal_mutable_oldnickname();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional bool reflag = 3;
  bool has_reflag() const;
  void clear_reflag() ;
  bool reflag() const;
  void set_reflag(bool value);

  private:
  bool _internal_reflag() const;
  void _internal_set_reflag(bool value);

  public:
  // optional .DBToCS.MsgID mgsid = 1 [default = eChangeNickname_CallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::DBToCS::MsgID mgsid() const;
  void set_mgsid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.ChangeNickname)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      52, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr newnickname_;
    ::google::protobuf::internal::ArenaStringPtr oldnickname_;
    ::uint64_t guid_;
    bool reflag_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class CDKeyEvents_event_info final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.CDKeyEvents.event_info) */ {
 public:
  inline CDKeyEvents_event_info() : CDKeyEvents_event_info(nullptr) {}
  ~CDKeyEvents_event_info() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CDKeyEvents_event_info(
      ::google::protobuf::internal::ConstantInitialized);

  inline CDKeyEvents_event_info(const CDKeyEvents_event_info& from) : CDKeyEvents_event_info(nullptr, from) {}
  inline CDKeyEvents_event_info(CDKeyEvents_event_info&& from) noexcept
      : CDKeyEvents_event_info(nullptr, std::move(from)) {}
  inline CDKeyEvents_event_info& operator=(const CDKeyEvents_event_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDKeyEvents_event_info& operator=(CDKeyEvents_event_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDKeyEvents_event_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDKeyEvents_event_info* internal_default_instance() {
    return reinterpret_cast<const CDKeyEvents_event_info*>(
        &_CDKeyEvents_event_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(CDKeyEvents_event_info& a, CDKeyEvents_event_info& b) { a.Swap(&b); }
  inline void Swap(CDKeyEvents_event_info* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDKeyEvents_event_info* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDKeyEvents_event_info* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CDKeyEvents_event_info>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CDKeyEvents_event_info& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CDKeyEvents_event_info& from) { CDKeyEvents_event_info::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CDKeyEvents_event_info* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.CDKeyEvents.event_info"; }

 protected:
  explicit CDKeyEvents_event_info(::google::protobuf::Arena* arena);
  CDKeyEvents_event_info(::google::protobuf::Arena* arena, const CDKeyEvents_event_info& from);
  CDKeyEvents_event_info(::google::protobuf::Arena* arena, CDKeyEvents_event_info&& from) noexcept
      : CDKeyEvents_event_info(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTitleFieldNumber = 2,
    kContentFieldNumber = 5,
    kItemInfoFieldNumber = 7,
    kIdFieldNumber = 1,
    kPlatformFieldNumber = 3,
    kEndTimeFieldNumber = 4,
    kGiftTypeFieldNumber = 6,
    kCodeNumFieldNumber = 8,
    kCodeLenFieldNumber = 9,
  };
  // optional string title = 2;
  bool has_title() const;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // optional string content = 5;
  bool has_content() const;
  void clear_content() ;
  const std::string& content() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_content(Arg_&& arg, Args_... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* value);

  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(
      const std::string& value);
  std::string* _internal_mutable_content();

  public:
  // optional string item_info = 7;
  bool has_item_info() const;
  void clear_item_info() ;
  const std::string& item_info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_item_info(Arg_&& arg, Args_... args);
  std::string* mutable_item_info();
  PROTOBUF_NODISCARD std::string* release_item_info();
  void set_allocated_item_info(std::string* value);

  private:
  const std::string& _internal_item_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_item_info(
      const std::string& value);
  std::string* _internal_mutable_item_info();

  public:
  // optional int32 id = 1;
  bool has_id() const;
  void clear_id() ;
  ::int32_t id() const;
  void set_id(::int32_t value);

  private:
  ::int32_t _internal_id() const;
  void _internal_set_id(::int32_t value);

  public:
  // optional int32 platform = 3;
  bool has_platform() const;
  void clear_platform() ;
  ::int32_t platform() const;
  void set_platform(::int32_t value);

  private:
  ::int32_t _internal_platform() const;
  void _internal_set_platform(::int32_t value);

  public:
  // optional uint64 end_time = 4;
  bool has_end_time() const;
  void clear_end_time() ;
  ::uint64_t end_time() const;
  void set_end_time(::uint64_t value);

  private:
  ::uint64_t _internal_end_time() const;
  void _internal_set_end_time(::uint64_t value);

  public:
  // optional int32 gift_type = 6;
  bool has_gift_type() const;
  void clear_gift_type() ;
  ::int32_t gift_type() const;
  void set_gift_type(::int32_t value);

  private:
  ::int32_t _internal_gift_type() const;
  void _internal_set_gift_type(::int32_t value);

  public:
  // optional int32 code_num = 8;
  bool has_code_num() const;
  void clear_code_num() ;
  ::int32_t code_num() const;
  void set_code_num(::int32_t value);

  private:
  ::int32_t _internal_code_num() const;
  void _internal_set_code_num(::int32_t value);

  public:
  // optional int32 code_len = 9;
  bool has_code_len() const;
  void clear_code_len() ;
  ::int32_t code_len() const;
  void set_code_len(::int32_t value);

  private:
  ::int32_t _internal_code_len() const;
  void _internal_set_code_len(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.CDKeyEvents.event_info)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      67, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr content_;
    ::google::protobuf::internal::ArenaStringPtr item_info_;
    ::int32_t id_;
    ::int32_t platform_;
    ::uint64_t end_time_;
    ::int32_t gift_type_;
    ::int32_t code_num_;
    ::int32_t code_len_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class BuyGoods final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.BuyGoods) */ {
 public:
  inline BuyGoods() : BuyGoods(nullptr) {}
  ~BuyGoods() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BuyGoods(
      ::google::protobuf::internal::ConstantInitialized);

  inline BuyGoods(const BuyGoods& from) : BuyGoods(nullptr, from) {}
  inline BuyGoods(BuyGoods&& from) noexcept
      : BuyGoods(nullptr, std::move(from)) {}
  inline BuyGoods& operator=(const BuyGoods& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuyGoods& operator=(BuyGoods&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuyGoods& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuyGoods* internal_default_instance() {
    return reinterpret_cast<const BuyGoods*>(
        &_BuyGoods_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(BuyGoods& a, BuyGoods& b) { a.Swap(&b); }
  inline void Swap(BuyGoods* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuyGoods* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuyGoods* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BuyGoods>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BuyGoods& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BuyGoods& from) { BuyGoods::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BuyGoods* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.BuyGoods"; }

 protected:
  explicit BuyGoods(::google::protobuf::Arena* arena);
  BuyGoods(::google::protobuf::Arena* arena, const BuyGoods& from);
  BuyGoods(::google::protobuf::Arena* arena, BuyGoods&& from) noexcept
      : BuyGoods(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBuygoodsmagFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional string buygoodsmag = 2;
  bool has_buygoodsmag() const;
  void clear_buygoodsmag() ;
  const std::string& buygoodsmag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_buygoodsmag(Arg_&& arg, Args_... args);
  std::string* mutable_buygoodsmag();
  PROTOBUF_NODISCARD std::string* release_buygoodsmag();
  void set_allocated_buygoodsmag(std::string* value);

  private:
  const std::string& _internal_buygoodsmag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_buygoodsmag(
      const std::string& value);
  std::string* _internal_mutable_buygoodsmag();

  public:
  // optional .DBToCS.MsgID mgsid = 1 [default = eBuyGoodsCallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::DBToCS::MsgID mgsid() const;
  void set_mgsid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.BuyGoods)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr buygoodsmag_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class QueryUser final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.QueryUser) */ {
 public:
  inline QueryUser() : QueryUser(nullptr) {}
  ~QueryUser() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryUser(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryUser(const QueryUser& from) : QueryUser(nullptr, from) {}
  inline QueryUser(QueryUser&& from) noexcept
      : QueryUser(nullptr, std::move(from)) {}
  inline QueryUser& operator=(const QueryUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryUser& operator=(QueryUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryUser* internal_default_instance() {
    return reinterpret_cast<const QueryUser*>(
        &_QueryUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(QueryUser& a, QueryUser& b) { a.Swap(&b); }
  inline void Swap(QueryUser* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryUser* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryUser* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryUser>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryUser& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryUser& from) { QueryUser::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryUser* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.QueryUser"; }

 protected:
  explicit QueryUser(::google::protobuf::Arena* arena);
  QueryUser(::google::protobuf::Arena* arena, const QueryUser& from);
  QueryUser(::google::protobuf::Arena* arena, QueryUser&& from) noexcept
      : QueryUser(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHerocfgFieldNumber = 7,
    kRuneinfoFieldNumber = 8,
    kRsinfoFieldNumber = 9,
    kItemInfoFieldNumber = 10,
    kMailInfoFieldNumber = 11,
    kDbFieldNumber = 2,
    kLoginFieldNumber = 3,
    kNicknameFieldNumber = 6,
    kGuidestrFieldNumber = 12,
    kTaskDataFieldNumber = 13,
    kGsidFieldNumber = 4,
    kGcnetidFieldNumber = 5,
    kMsgidFieldNumber = 1,
  };
  // repeated .DBToCS.HeroCfg herocfg = 7;
  int herocfg_size() const;
  private:
  int _internal_herocfg_size() const;

  public:
  void clear_herocfg() ;
  ::DBToCS::HeroCfg* mutable_herocfg(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>* mutable_herocfg();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>& _internal_herocfg() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>* _internal_mutable_herocfg();
  public:
  const ::DBToCS::HeroCfg& herocfg(int index) const;
  ::DBToCS::HeroCfg* add_herocfg();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>& herocfg() const;
  // repeated .DBToCS.RuneInfo runeinfo = 8;
  int runeinfo_size() const;
  private:
  int _internal_runeinfo_size() const;

  public:
  void clear_runeinfo() ;
  ::DBToCS::RuneInfo* mutable_runeinfo(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>* mutable_runeinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>& _internal_runeinfo() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>* _internal_mutable_runeinfo();
  public:
  const ::DBToCS::RuneInfo& runeinfo(int index) const;
  ::DBToCS::RuneInfo* add_runeinfo();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>& runeinfo() const;
  // repeated .DBToCS.RSinfo rsinfo = 9;
  int rsinfo_size() const;
  private:
  int _internal_rsinfo_size() const;

  public:
  void clear_rsinfo() ;
  ::DBToCS::RSinfo* mutable_rsinfo(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>* mutable_rsinfo();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>& _internal_rsinfo() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>* _internal_mutable_rsinfo();
  public:
  const ::DBToCS::RSinfo& rsinfo(int index) const;
  ::DBToCS::RSinfo* add_rsinfo();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>& rsinfo() const;
  // repeated .DBToCS.ItemInfo item_info = 10;
  int item_info_size() const;
  private:
  int _internal_item_info_size() const;

  public:
  void clear_item_info() ;
  ::DBToCS::ItemInfo* mutable_item_info(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>* mutable_item_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>& _internal_item_info() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>* _internal_mutable_item_info();
  public:
  const ::DBToCS::ItemInfo& item_info(int index) const;
  ::DBToCS::ItemInfo* add_item_info();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>& item_info() const;
  // repeated .DBToCS.MailInfo mail_info = 11;
  int mail_info_size() const;
  private:
  int _internal_mail_info_size() const;

  public:
  void clear_mail_info() ;
  ::DBToCS::MailInfo* mutable_mail_info(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>* mutable_mail_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>& _internal_mail_info() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>* _internal_mutable_mail_info();
  public:
  const ::DBToCS::MailInfo& mail_info(int index) const;
  ::DBToCS::MailInfo* add_mail_info();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>& mail_info() const;
  // optional string db = 2;
  bool has_db() const;
  void clear_db() ;
  const std::string& db() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_db(Arg_&& arg, Args_... args);
  std::string* mutable_db();
  PROTOBUF_NODISCARD std::string* release_db();
  void set_allocated_db(std::string* value);

  private:
  const std::string& _internal_db() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_db(
      const std::string& value);
  std::string* _internal_mutable_db();

  public:
  // optional string login = 3;
  bool has_login() const;
  void clear_login() ;
  const std::string& login() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_login(Arg_&& arg, Args_... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* value);

  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(
      const std::string& value);
  std::string* _internal_mutable_login();

  public:
  // optional string nickname = 6;
  bool has_nickname() const;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // optional string guidestr = 12;
  bool has_guidestr() const;
  void clear_guidestr() ;
  const std::string& guidestr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_guidestr(Arg_&& arg, Args_... args);
  std::string* mutable_guidestr();
  PROTOBUF_NODISCARD std::string* release_guidestr();
  void set_allocated_guidestr(std::string* value);

  private:
  const std::string& _internal_guidestr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guidestr(
      const std::string& value);
  std::string* _internal_mutable_guidestr();

  public:
  // optional string taskData = 13;
  bool has_taskdata() const;
  void clear_taskdata() ;
  const std::string& taskdata() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taskdata(Arg_&& arg, Args_... args);
  std::string* mutable_taskdata();
  PROTOBUF_NODISCARD std::string* release_taskdata();
  void set_allocated_taskdata(std::string* value);

  private:
  const std::string& _internal_taskdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taskdata(
      const std::string& value);
  std::string* _internal_mutable_taskdata();

  public:
  // optional int32 gsid = 4;
  bool has_gsid() const;
  void clear_gsid() ;
  ::int32_t gsid() const;
  void set_gsid(::int32_t value);

  private:
  ::int32_t _internal_gsid() const;
  void _internal_set_gsid(::int32_t value);

  public:
  // optional int32 gcnetid = 5;
  bool has_gcnetid() const;
  void clear_gcnetid() ;
  ::int32_t gcnetid() const;
  void set_gcnetid(::int32_t value);

  private:
  ::int32_t _internal_gcnetid() const;
  void _internal_set_gcnetid(::int32_t value);

  public:
  // optional .DBToCS.MsgID msgid = 1 [default = eQueryUser_DBCallBack];
  bool has_msgid() const;
  void clear_msgid() ;
  ::DBToCS::MsgID msgid() const;
  void set_msgid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.QueryUser)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 6,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::HeroCfg > herocfg_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::RuneInfo > runeinfo_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::RSinfo > rsinfo_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::ItemInfo > item_info_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::MailInfo > mail_info_;
    ::google::protobuf::internal::ArenaStringPtr db_;
    ::google::protobuf::internal::ArenaStringPtr login_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr guidestr_;
    ::google::protobuf::internal::ArenaStringPtr taskdata_;
    ::int32_t gsid_;
    ::int32_t gcnetid_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class QueryNotice final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.QueryNotice) */ {
 public:
  inline QueryNotice() : QueryNotice(nullptr) {}
  ~QueryNotice() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryNotice(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryNotice(const QueryNotice& from) : QueryNotice(nullptr, from) {}
  inline QueryNotice(QueryNotice&& from) noexcept
      : QueryNotice(nullptr, std::move(from)) {}
  inline QueryNotice& operator=(const QueryNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryNotice& operator=(QueryNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryNotice* internal_default_instance() {
    return reinterpret_cast<const QueryNotice*>(
        &_QueryNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(QueryNotice& a, QueryNotice& b) { a.Swap(&b); }
  inline void Swap(QueryNotice* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryNotice* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryNotice* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryNotice>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryNotice& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryNotice& from) { QueryNotice::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryNotice* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.QueryNotice"; }

 protected:
  explicit QueryNotice(::google::protobuf::Arena* arena);
  QueryNotice(::google::protobuf::Arena* arena, const QueryNotice& from);
  QueryNotice(::google::protobuf::Arena* arena, QueryNotice&& from) noexcept
      : QueryNotice(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Notice = QueryNotice_Notice;

  // accessors -------------------------------------------------------
  enum : int {
    kNoticeInfoFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // repeated .DBToCS.QueryNotice.Notice notice_info = 2;
  int notice_info_size() const;
  private:
  int _internal_notice_info_size() const;

  public:
  void clear_notice_info() ;
  ::DBToCS::QueryNotice_Notice* mutable_notice_info(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>* mutable_notice_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>& _internal_notice_info() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>* _internal_mutable_notice_info();
  public:
  const ::DBToCS::QueryNotice_Notice& notice_info(int index) const;
  ::DBToCS::QueryNotice_Notice* add_notice_info();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>& notice_info() const;
  // optional .DBToCS.MsgID mgsid = 1 [default = eQueryNotice_CallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::DBToCS::MsgID mgsid() const;
  void set_mgsid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.QueryNotice)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::QueryNotice_Notice > notice_info_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class QueryAllAccount final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.QueryAllAccount) */ {
 public:
  inline QueryAllAccount() : QueryAllAccount(nullptr) {}
  ~QueryAllAccount() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAllAccount(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryAllAccount(const QueryAllAccount& from) : QueryAllAccount(nullptr, from) {}
  inline QueryAllAccount(QueryAllAccount&& from) noexcept
      : QueryAllAccount(nullptr, std::move(from)) {}
  inline QueryAllAccount& operator=(const QueryAllAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAllAccount& operator=(QueryAllAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAllAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAllAccount* internal_default_instance() {
    return reinterpret_cast<const QueryAllAccount*>(
        &_QueryAllAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(QueryAllAccount& a, QueryAllAccount& b) { a.Swap(&b); }
  inline void Swap(QueryAllAccount* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAllAccount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAllAccount* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryAllAccount>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryAllAccount& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryAllAccount& from) { QueryAllAccount::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryAllAccount* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.QueryAllAccount"; }

 protected:
  explicit QueryAllAccount(::google::protobuf::Arena* arena);
  QueryAllAccount(::google::protobuf::Arena* arena, const QueryAllAccount& from);
  QueryAllAccount(::google::protobuf::Arena* arena, QueryAllAccount&& from) noexcept
      : QueryAllAccount(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Account = QueryAllAccount_Account;

  // accessors -------------------------------------------------------
  enum : int {
    kAccountFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // repeated .DBToCS.QueryAllAccount.Account account = 2;
  int account_size() const;
  private:
  int _internal_account_size() const;

  public:
  void clear_account() ;
  ::DBToCS::QueryAllAccount_Account* mutable_account(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>* mutable_account();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>& _internal_account() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>* _internal_mutable_account();
  public:
  const ::DBToCS::QueryAllAccount_Account& account(int index) const;
  ::DBToCS::QueryAllAccount_Account* add_account();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>& account() const;
  // optional .DBToCS.MsgID mgsid = 1 [default = eQueryAllAccount_CallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::DBToCS::MsgID mgsid() const;
  void set_mgsid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.QueryAllAccount)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::QueryAllAccount_Account > account_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class CDKeyEvents final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.CDKeyEvents) */ {
 public:
  inline CDKeyEvents() : CDKeyEvents(nullptr) {}
  ~CDKeyEvents() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CDKeyEvents(
      ::google::protobuf::internal::ConstantInitialized);

  inline CDKeyEvents(const CDKeyEvents& from) : CDKeyEvents(nullptr, from) {}
  inline CDKeyEvents(CDKeyEvents&& from) noexcept
      : CDKeyEvents(nullptr, std::move(from)) {}
  inline CDKeyEvents& operator=(const CDKeyEvents& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDKeyEvents& operator=(CDKeyEvents&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDKeyEvents& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDKeyEvents* internal_default_instance() {
    return reinterpret_cast<const CDKeyEvents*>(
        &_CDKeyEvents_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CDKeyEvents& a, CDKeyEvents& b) { a.Swap(&b); }
  inline void Swap(CDKeyEvents* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDKeyEvents* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDKeyEvents* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CDKeyEvents>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CDKeyEvents& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CDKeyEvents& from) { CDKeyEvents::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CDKeyEvents* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.CDKeyEvents"; }

 protected:
  explicit CDKeyEvents(::google::protobuf::Arena* arena);
  CDKeyEvents(::google::protobuf::Arena* arena, const CDKeyEvents& from);
  CDKeyEvents(::google::protobuf::Arena* arena, CDKeyEvents&& from) noexcept
      : CDKeyEvents(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using event_info = CDKeyEvents_event_info;

  // accessors -------------------------------------------------------
  enum : int {
    kInfoFieldNumber = 2,
    kNsidFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // repeated .DBToCS.CDKeyEvents.event_info info = 2;
  int info_size() const;
  private:
  int _internal_info_size() const;

  public:
  void clear_info() ;
  ::DBToCS::CDKeyEvents_event_info* mutable_info(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>* mutable_info();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>& _internal_info() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>* _internal_mutable_info();
  public:
  const ::DBToCS::CDKeyEvents_event_info& info(int index) const;
  ::DBToCS::CDKeyEvents_event_info* add_info();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>& info() const;
  // optional int32 nsid = 3;
  bool has_nsid() const;
  void clear_nsid() ;
  ::int32_t nsid() const;
  void set_nsid(::int32_t value);

  private:
  ::int32_t _internal_nsid() const;
  void _internal_set_nsid(::int32_t value);

  public:
  // optional .DBToCS.MsgID mgsid = 1 [default = eQueryCDKeyEvents_CallBack];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::DBToCS::MsgID mgsid() const;
  void set_mgsid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.CDKeyEvents)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::CDKeyEvents_event_info > info_;
    ::int32_t nsid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};
// -------------------------------------------------------------------

class QueryAllUser final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:DBToCS.QueryAllUser) */ {
 public:
  inline QueryAllUser() : QueryAllUser(nullptr) {}
  ~QueryAllUser() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR QueryAllUser(
      ::google::protobuf::internal::ConstantInitialized);

  inline QueryAllUser(const QueryAllUser& from) : QueryAllUser(nullptr, from) {}
  inline QueryAllUser(QueryAllUser&& from) noexcept
      : QueryAllUser(nullptr, std::move(from)) {}
  inline QueryAllUser& operator=(const QueryAllUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryAllUser& operator=(QueryAllUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryAllUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryAllUser* internal_default_instance() {
    return reinterpret_cast<const QueryAllUser*>(
        &_QueryAllUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(QueryAllUser& a, QueryAllUser& b) { a.Swap(&b); }
  inline void Swap(QueryAllUser* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryAllUser* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryAllUser* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<QueryAllUser>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const QueryAllUser& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const QueryAllUser& from) { QueryAllUser::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(QueryAllUser* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "DBToCS.QueryAllUser"; }

 protected:
  explicit QueryAllUser(::google::protobuf::Arena* arena);
  QueryAllUser(::google::protobuf::Arena* arena, const QueryAllUser& from);
  QueryAllUser(::google::protobuf::Arena* arena, QueryAllUser&& from) noexcept
      : QueryAllUser(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSQueryUserFieldNumber = 2,
    kMsgidFieldNumber = 1,
  };
  // repeated .DBToCS.QueryUser sQueryUser = 2;
  int squeryuser_size() const;
  private:
  int _internal_squeryuser_size() const;

  public:
  void clear_squeryuser() ;
  ::DBToCS::QueryUser* mutable_squeryuser(int index);
  ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>* mutable_squeryuser();

  private:
  const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>& _internal_squeryuser() const;
  ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>* _internal_mutable_squeryuser();
  public:
  const ::DBToCS::QueryUser& squeryuser(int index) const;
  ::DBToCS::QueryUser* add_squeryuser();
  const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>& squeryuser() const;
  // optional .DBToCS.MsgID msgid = 1 [default = eQueryAllUser_CallBack];
  bool has_msgid() const;
  void clear_msgid() ;
  ::DBToCS::MsgID msgid() const;
  void set_msgid(::DBToCS::MsgID value);

  private:
  ::DBToCS::MsgID _internal_msgid() const;
  void _internal_set_msgid(::DBToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:DBToCS.QueryAllUser)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::DBToCS::QueryUser > squeryuser_;
    int msgid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_DBToCs_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// CDKeyEvents_event_info

// optional int32 id = 1;
inline bool CDKeyEvents_event_info::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t CDKeyEvents_event_info::id() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.id)
  return _internal_id();
}
inline void CDKeyEvents_event_info::set_id(::int32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.id)
}
inline ::int32_t CDKeyEvents_event_info::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void CDKeyEvents_event_info::_internal_set_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// optional string title = 2;
inline bool CDKeyEvents_event_info::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CDKeyEvents_event_info::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CDKeyEvents_event_info::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.title)
}
inline std::string* CDKeyEvents_event_info::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:DBToCS.CDKeyEvents.event_info.title)
  return _s;
}
inline const std::string& CDKeyEvents_event_info::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void CDKeyEvents_event_info::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* CDKeyEvents_event_info::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* CDKeyEvents_event_info::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.CDKeyEvents.event_info.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CDKeyEvents_event_info::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.CDKeyEvents.event_info.title)
}

// optional int32 platform = 3;
inline bool CDKeyEvents_event_info::has_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t CDKeyEvents_event_info::platform() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.platform)
  return _internal_platform();
}
inline void CDKeyEvents_event_info::set_platform(::int32_t value) {
  _internal_set_platform(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.platform)
}
inline ::int32_t CDKeyEvents_event_info::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_;
}
inline void CDKeyEvents_event_info::_internal_set_platform(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = value;
}

// optional uint64 end_time = 4;
inline bool CDKeyEvents_event_info::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint64_t CDKeyEvents_event_info::end_time() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.end_time)
  return _internal_end_time();
}
inline void CDKeyEvents_event_info::set_end_time(::uint64_t value) {
  _internal_set_end_time(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.end_time)
}
inline ::uint64_t CDKeyEvents_event_info::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void CDKeyEvents_event_info::_internal_set_end_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = value;
}

// optional string content = 5;
inline bool CDKeyEvents_event_info::has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CDKeyEvents_event_info::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CDKeyEvents_event_info::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.content)
}
inline std::string* CDKeyEvents_event_info::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:DBToCS.CDKeyEvents.event_info.content)
  return _s;
}
inline const std::string& CDKeyEvents_event_info::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void CDKeyEvents_event_info::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* CDKeyEvents_event_info::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* CDKeyEvents_event_info::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.CDKeyEvents.event_info.content)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.content_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CDKeyEvents_event_info::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.CDKeyEvents.event_info.content)
}

// optional int32 gift_type = 6;
inline bool CDKeyEvents_event_info::has_gift_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_gift_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gift_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t CDKeyEvents_event_info::gift_type() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.gift_type)
  return _internal_gift_type();
}
inline void CDKeyEvents_event_info::set_gift_type(::int32_t value) {
  _internal_set_gift_type(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.gift_type)
}
inline ::int32_t CDKeyEvents_event_info::_internal_gift_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gift_type_;
}
inline void CDKeyEvents_event_info::_internal_set_gift_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gift_type_ = value;
}

// optional string item_info = 7;
inline bool CDKeyEvents_event_info::has_item_info() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_item_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_info_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CDKeyEvents_event_info::item_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.item_info)
  return _internal_item_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CDKeyEvents_event_info::set_item_info(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.item_info_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.item_info)
}
inline std::string* CDKeyEvents_event_info::mutable_item_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_item_info();
  // @@protoc_insertion_point(field_mutable:DBToCS.CDKeyEvents.event_info.item_info)
  return _s;
}
inline const std::string& CDKeyEvents_event_info::_internal_item_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_info_.Get();
}
inline void CDKeyEvents_event_info::_internal_set_item_info(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.item_info_.Set(value, GetArena());
}
inline std::string* CDKeyEvents_event_info::_internal_mutable_item_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.item_info_.Mutable( GetArena());
}
inline std::string* CDKeyEvents_event_info::release_item_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.CDKeyEvents.event_info.item_info)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.item_info_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.item_info_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CDKeyEvents_event_info::set_allocated_item_info(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.item_info_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.item_info_.IsDefault()) {
          _impl_.item_info_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.CDKeyEvents.event_info.item_info)
}

// optional int32 code_num = 8;
inline bool CDKeyEvents_event_info::has_code_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_code_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t CDKeyEvents_event_info::code_num() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.code_num)
  return _internal_code_num();
}
inline void CDKeyEvents_event_info::set_code_num(::int32_t value) {
  _internal_set_code_num(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.code_num)
}
inline ::int32_t CDKeyEvents_event_info::_internal_code_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_num_;
}
inline void CDKeyEvents_event_info::_internal_set_code_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_num_ = value;
}

// optional int32 code_len = 9;
inline bool CDKeyEvents_event_info::has_code_len() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void CDKeyEvents_event_info::clear_code_len() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_len_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t CDKeyEvents_event_info::code_len() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.event_info.code_len)
  return _internal_code_len();
}
inline void CDKeyEvents_event_info::set_code_len(::int32_t value) {
  _internal_set_code_len(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.event_info.code_len)
}
inline ::int32_t CDKeyEvents_event_info::_internal_code_len() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.code_len_;
}
inline void CDKeyEvents_event_info::_internal_set_code_len(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.code_len_ = value;
}

// -------------------------------------------------------------------

// CDKeyEvents

// optional .DBToCS.MsgID mgsid = 1 [default = eQueryCDKeyEvents_CallBack];
inline bool CDKeyEvents::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CDKeyEvents::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::DBToCS::MsgID CDKeyEvents::mgsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.mgsid)
  return _internal_mgsid();
}
inline void CDKeyEvents::set_mgsid(::DBToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.mgsid)
}
inline ::DBToCS::MsgID CDKeyEvents::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.mgsid_);
}
inline void CDKeyEvents::_internal_set_mgsid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// repeated .DBToCS.CDKeyEvents.event_info info = 2;
inline int CDKeyEvents::_internal_info_size() const {
  return _internal_info().size();
}
inline int CDKeyEvents::info_size() const {
  return _internal_info_size();
}
inline void CDKeyEvents::clear_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.info_.Clear();
}
inline ::DBToCS::CDKeyEvents_event_info* CDKeyEvents::mutable_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.CDKeyEvents.info)
  return _internal_mutable_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>* CDKeyEvents::mutable_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.CDKeyEvents.info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_info();
}
inline const ::DBToCS::CDKeyEvents_event_info& CDKeyEvents::info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.info)
  return _internal_info().Get(index);
}
inline ::DBToCS::CDKeyEvents_event_info* CDKeyEvents::add_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::CDKeyEvents_event_info* _add = _internal_mutable_info()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.CDKeyEvents.info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>& CDKeyEvents::info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.CDKeyEvents.info)
  return _internal_info();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>&
CDKeyEvents::_internal_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.info_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::CDKeyEvents_event_info>*
CDKeyEvents::_internal_mutable_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.info_;
}

// optional int32 nsid = 3;
inline bool CDKeyEvents::has_nsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CDKeyEvents::clear_nsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t CDKeyEvents::nsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.CDKeyEvents.nsid)
  return _internal_nsid();
}
inline void CDKeyEvents::set_nsid(::int32_t value) {
  _internal_set_nsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:DBToCS.CDKeyEvents.nsid)
}
inline ::int32_t CDKeyEvents::_internal_nsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nsid_;
}
inline void CDKeyEvents::_internal_set_nsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nsid_ = value;
}

// -------------------------------------------------------------------

// QueryAllAccount_Account

// optional string user_name = 1;
inline bool QueryAllAccount_Account::has_user_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryAllAccount_Account::clear_user_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryAllAccount_Account::user_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllAccount.Account.user_name)
  return _internal_user_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAllAccount_Account::set_user_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryAllAccount.Account.user_name)
}
inline std::string* QueryAllAccount_Account::mutable_user_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryAllAccount.Account.user_name)
  return _s;
}
inline const std::string& QueryAllAccount_Account::_internal_user_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_name_.Get();
}
inline void QueryAllAccount_Account::_internal_set_user_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.user_name_.Set(value, GetArena());
}
inline std::string* QueryAllAccount_Account::_internal_mutable_user_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.user_name_.Mutable( GetArena());
}
inline std::string* QueryAllAccount_Account::release_user_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryAllAccount.Account.user_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.user_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.user_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryAllAccount_Account::set_allocated_user_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.user_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_name_.IsDefault()) {
          _impl_.user_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryAllAccount.Account.user_name)
}

// optional int32 csid = 2;
inline bool QueryAllAccount_Account::has_csid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryAllAccount_Account::clear_csid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t QueryAllAccount_Account::csid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllAccount.Account.csid)
  return _internal_csid();
}
inline void QueryAllAccount_Account::set_csid(::int32_t value) {
  _internal_set_csid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryAllAccount.Account.csid)
}
inline ::int32_t QueryAllAccount_Account::_internal_csid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.csid_;
}
inline void QueryAllAccount_Account::_internal_set_csid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.csid_ = value;
}

// optional int32 sdkid = 3;
inline bool QueryAllAccount_Account::has_sdkid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryAllAccount_Account::clear_sdkid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t QueryAllAccount_Account::sdkid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllAccount.Account.sdkid)
  return _internal_sdkid();
}
inline void QueryAllAccount_Account::set_sdkid(::int32_t value) {
  _internal_set_sdkid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryAllAccount.Account.sdkid)
}
inline ::int32_t QueryAllAccount_Account::_internal_sdkid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sdkid_;
}
inline void QueryAllAccount_Account::_internal_set_sdkid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sdkid_ = value;
}

// optional string nickname = 4;
inline bool QueryAllAccount_Account::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryAllAccount_Account::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryAllAccount_Account::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllAccount.Account.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryAllAccount_Account::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryAllAccount.Account.nickname)
}
inline std::string* QueryAllAccount_Account::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryAllAccount.Account.nickname)
  return _s;
}
inline const std::string& QueryAllAccount_Account::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void QueryAllAccount_Account::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* QueryAllAccount_Account::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* QueryAllAccount_Account::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryAllAccount.Account.nickname)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryAllAccount_Account::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryAllAccount.Account.nickname)
}

// optional int64 guid = 5;
inline bool QueryAllAccount_Account::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QueryAllAccount_Account::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int64_t QueryAllAccount_Account::guid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllAccount.Account.guid)
  return _internal_guid();
}
inline void QueryAllAccount_Account::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryAllAccount.Account.guid)
}
inline ::int64_t QueryAllAccount_Account::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void QueryAllAccount_Account::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// -------------------------------------------------------------------

// QueryAllAccount

// optional .DBToCS.MsgID mgsid = 1 [default = eQueryAllAccount_CallBack];
inline bool QueryAllAccount::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryAllAccount::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 7;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::DBToCS::MsgID QueryAllAccount::mgsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllAccount.mgsid)
  return _internal_mgsid();
}
inline void QueryAllAccount::set_mgsid(::DBToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryAllAccount.mgsid)
}
inline ::DBToCS::MsgID QueryAllAccount::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.mgsid_);
}
inline void QueryAllAccount::_internal_set_mgsid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// repeated .DBToCS.QueryAllAccount.Account account = 2;
inline int QueryAllAccount::_internal_account_size() const {
  return _internal_account().size();
}
inline int QueryAllAccount::account_size() const {
  return _internal_account_size();
}
inline void QueryAllAccount::clear_account() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_.Clear();
}
inline ::DBToCS::QueryAllAccount_Account* QueryAllAccount::mutable_account(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryAllAccount.account)
  return _internal_mutable_account()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>* QueryAllAccount::mutable_account()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryAllAccount.account)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_account();
}
inline const ::DBToCS::QueryAllAccount_Account& QueryAllAccount::account(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllAccount.account)
  return _internal_account().Get(index);
}
inline ::DBToCS::QueryAllAccount_Account* QueryAllAccount::add_account() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::QueryAllAccount_Account* _add = _internal_mutable_account()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryAllAccount.account)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>& QueryAllAccount::account() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryAllAccount.account)
  return _internal_account();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>&
QueryAllAccount::_internal_account() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.account_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::QueryAllAccount_Account>*
QueryAllAccount::_internal_mutable_account() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.account_;
}

// -------------------------------------------------------------------

// MailCallBack

// optional .DBToCS.MsgID mgsid = 1 [default = eMail_CallBack];
inline bool MailCallBack::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void MailCallBack::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 6;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::DBToCS::MsgID MailCallBack::mgsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.mgsid)
  return _internal_mgsid();
}
inline void MailCallBack::set_mgsid(::DBToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.mgsid)
}
inline ::DBToCS::MsgID MailCallBack::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.mgsid_);
}
inline void MailCallBack::_internal_set_mgsid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int32 mailid = 2;
inline bool MailCallBack::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void MailCallBack::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t MailCallBack::mailid() const {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.mailid)
  return _internal_mailid();
}
inline void MailCallBack::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.mailid)
}
inline ::int32_t MailCallBack::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void MailCallBack::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional int32 mailtype = 3;
inline bool MailCallBack::has_mailtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void MailCallBack::clear_mailtype() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t MailCallBack::mailtype() const {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.mailtype)
  return _internal_mailtype();
}
inline void MailCallBack::set_mailtype(::int32_t value) {
  _internal_set_mailtype(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.mailtype)
}
inline ::int32_t MailCallBack::_internal_mailtype() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailtype_;
}
inline void MailCallBack::_internal_set_mailtype(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailtype_ = value;
}

// optional int32 channel = 4;
inline bool MailCallBack::has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void MailCallBack::clear_channel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t MailCallBack::channel() const {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.channel)
  return _internal_channel();
}
inline void MailCallBack::set_channel(::int32_t value) {
  _internal_set_channel(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.channel)
}
inline ::int32_t MailCallBack::_internal_channel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.channel_;
}
inline void MailCallBack::_internal_set_channel(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.channel_ = value;
}

// optional string title = 5;
inline bool MailCallBack::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MailCallBack::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MailCallBack::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailCallBack::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.title)
}
inline std::string* MailCallBack::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:DBToCS.MailCallBack.title)
  return _s;
}
inline const std::string& MailCallBack::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void MailCallBack::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* MailCallBack::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* MailCallBack::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.MailCallBack.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailCallBack::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.MailCallBack.title)
}

// optional string content = 6;
inline bool MailCallBack::has_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MailCallBack::clear_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MailCallBack::content() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.content)
  return _internal_content();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailCallBack::set_content(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.content)
}
inline std::string* MailCallBack::mutable_content() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:DBToCS.MailCallBack.content)
  return _s;
}
inline const std::string& MailCallBack::_internal_content() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.content_.Get();
}
inline void MailCallBack::_internal_set_content(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.content_.Set(value, GetArena());
}
inline std::string* MailCallBack::_internal_mutable_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.content_.Mutable( GetArena());
}
inline std::string* MailCallBack::release_content() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.MailCallBack.content)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.content_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.content_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailCallBack::set_allocated_content(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.content_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.content_.IsDefault()) {
          _impl_.content_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.MailCallBack.content)
}

// optional string gift = 7;
inline bool MailCallBack::has_gift() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void MailCallBack::clear_gift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gift_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MailCallBack::gift() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.gift)
  return _internal_gift();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailCallBack::set_gift(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gift_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.gift)
}
inline std::string* MailCallBack::mutable_gift() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_gift();
  // @@protoc_insertion_point(field_mutable:DBToCS.MailCallBack.gift)
  return _s;
}
inline const std::string& MailCallBack::_internal_gift() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gift_.Get();
}
inline void MailCallBack::_internal_set_gift(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.gift_.Set(value, GetArena());
}
inline std::string* MailCallBack::_internal_mutable_gift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.gift_.Mutable( GetArena());
}
inline std::string* MailCallBack::release_gift() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.MailCallBack.gift)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.gift_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.gift_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailCallBack::set_allocated_gift(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.gift_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.gift_.IsDefault()) {
          _impl_.gift_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.MailCallBack.gift)
}

// optional string sender = 8;
inline bool MailCallBack::has_sender() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void MailCallBack::clear_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sender_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MailCallBack::sender() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.sender)
  return _internal_sender();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailCallBack::set_sender(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sender_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.sender)
}
inline std::string* MailCallBack::mutable_sender() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:DBToCS.MailCallBack.sender)
  return _s;
}
inline const std::string& MailCallBack::_internal_sender() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sender_.Get();
}
inline void MailCallBack::_internal_set_sender(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.sender_.Set(value, GetArena());
}
inline std::string* MailCallBack::_internal_mutable_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.sender_.Mutable( GetArena());
}
inline std::string* MailCallBack::release_sender() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.MailCallBack.sender)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.sender_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sender_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailCallBack::set_allocated_sender(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.sender_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sender_.IsDefault()) {
          _impl_.sender_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.MailCallBack.sender)
}

// optional string createtime = 9;
inline bool MailCallBack::has_createtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void MailCallBack::clear_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.createtime_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MailCallBack::createtime() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.createtime)
  return _internal_createtime();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MailCallBack::set_createtime(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.createtime_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.createtime)
}
inline std::string* MailCallBack::mutable_createtime() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:DBToCS.MailCallBack.createtime)
  return _s;
}
inline const std::string& MailCallBack::_internal_createtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.createtime_.Get();
}
inline void MailCallBack::_internal_set_createtime(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.createtime_.Set(value, GetArena());
}
inline std::string* MailCallBack::_internal_mutable_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.createtime_.Mutable( GetArena());
}
inline std::string* MailCallBack::release_createtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.MailCallBack.createtime)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.createtime_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.createtime_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void MailCallBack::set_allocated_createtime(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.createtime_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.createtime_.IsDefault()) {
          _impl_.createtime_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.MailCallBack.createtime)
}

// optional int64 objid = 10;
inline bool MailCallBack::has_objid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void MailCallBack::clear_objid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int64_t MailCallBack::objid() const {
  // @@protoc_insertion_point(field_get:DBToCS.MailCallBack.objid)
  return _internal_objid();
}
inline void MailCallBack::set_objid(::int64_t value) {
  _internal_set_objid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:DBToCS.MailCallBack.objid)
}
inline ::int64_t MailCallBack::_internal_objid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.objid_;
}
inline void MailCallBack::_internal_set_objid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.objid_ = value;
}

// -------------------------------------------------------------------

// QueryNotice_Notice

// optional uint32 id = 1;
inline bool QueryNotice_Notice::has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t QueryNotice_Notice::id() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.id)
  return _internal_id();
}
inline void QueryNotice_Notice::set_id(::uint32_t value) {
  _internal_set_id(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.id)
}
inline ::uint32_t QueryNotice_Notice::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void QueryNotice_Notice::_internal_set_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = value;
}

// optional string title = 2;
inline bool QueryNotice_Notice::has_title() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.title_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryNotice_Notice::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryNotice_Notice::set_title(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.title)
}
inline std::string* QueryNotice_Notice::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryNotice.Notice.title)
  return _s;
}
inline const std::string& QueryNotice_Notice::_internal_title() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.title_.Get();
}
inline void QueryNotice_Notice::_internal_set_title(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.title_.Set(value, GetArena());
}
inline std::string* QueryNotice_Notice::_internal_mutable_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* QueryNotice_Notice::release_title() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryNotice.Notice.title)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.title_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.title_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryNotice_Notice::set_allocated_title(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryNotice.Notice.title)
}

// optional int32 eflag = 3;
inline bool QueryNotice_Notice::has_eflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_eflag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.eflag_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t QueryNotice_Notice::eflag() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.eflag)
  return _internal_eflag();
}
inline void QueryNotice_Notice::set_eflag(::int32_t value) {
  _internal_set_eflag(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.eflag)
}
inline ::int32_t QueryNotice_Notice::_internal_eflag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.eflag_;
}
inline void QueryNotice_Notice::_internal_set_eflag(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.eflag_ = value;
}

// optional int32 estate = 4;
inline bool QueryNotice_Notice::has_estate() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_estate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.estate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t QueryNotice_Notice::estate() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.estate)
  return _internal_estate();
}
inline void QueryNotice_Notice::set_estate(::int32_t value) {
  _internal_set_estate(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.estate)
}
inline ::int32_t QueryNotice_Notice::_internal_estate() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.estate_;
}
inline void QueryNotice_Notice::_internal_set_estate(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.estate_ = value;
}

// optional int32 priority = 5;
inline bool QueryNotice_Notice::has_priority() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_priority() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t QueryNotice_Notice::priority() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.priority)
  return _internal_priority();
}
inline void QueryNotice_Notice::set_priority(::int32_t value) {
  _internal_set_priority(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.priority)
}
inline ::int32_t QueryNotice_Notice::_internal_priority() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.priority_;
}
inline void QueryNotice_Notice::_internal_set_priority(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.priority_ = value;
}

// optional string notice = 6;
inline bool QueryNotice_Notice::has_notice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryNotice_Notice::notice() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.notice)
  return _internal_notice();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryNotice_Notice::set_notice(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.notice_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.notice)
}
inline std::string* QueryNotice_Notice::mutable_notice() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_notice();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryNotice.Notice.notice)
  return _s;
}
inline const std::string& QueryNotice_Notice::_internal_notice() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notice_.Get();
}
inline void QueryNotice_Notice::_internal_set_notice(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.notice_.Set(value, GetArena());
}
inline std::string* QueryNotice_Notice::_internal_mutable_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.notice_.Mutable( GetArena());
}
inline std::string* QueryNotice_Notice::release_notice() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryNotice.Notice.notice)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.notice_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.notice_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryNotice_Notice::set_allocated_notice(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.notice_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.notice_.IsDefault()) {
          _impl_.notice_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryNotice.Notice.notice)
}

// optional uint64 star_time = 7;
inline bool QueryNotice_Notice::has_star_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_star_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.star_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint64_t QueryNotice_Notice::star_time() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.star_time)
  return _internal_star_time();
}
inline void QueryNotice_Notice::set_star_time(::uint64_t value) {
  _internal_set_star_time(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.star_time)
}
inline ::uint64_t QueryNotice_Notice::_internal_star_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.star_time_;
}
inline void QueryNotice_Notice::_internal_set_star_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.star_time_ = value;
}

// optional uint64 end_time = 8;
inline bool QueryNotice_Notice::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t QueryNotice_Notice::end_time() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.end_time)
  return _internal_end_time();
}
inline void QueryNotice_Notice::set_end_time(::uint64_t value) {
  _internal_set_end_time(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.end_time)
}
inline ::uint64_t QueryNotice_Notice::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void QueryNotice_Notice::_internal_set_end_time(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = value;
}

// optional uint32 platform = 9;
inline bool QueryNotice_Notice::has_platform() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void QueryNotice_Notice::clear_platform() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t QueryNotice_Notice::platform() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.Notice.platform)
  return _internal_platform();
}
inline void QueryNotice_Notice::set_platform(::uint32_t value) {
  _internal_set_platform(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.Notice.platform)
}
inline ::uint32_t QueryNotice_Notice::_internal_platform() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.platform_;
}
inline void QueryNotice_Notice::_internal_set_platform(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.platform_ = value;
}

// -------------------------------------------------------------------

// QueryNotice

// optional .DBToCS.MsgID mgsid = 1 [default = eQueryNotice_CallBack];
inline bool QueryNotice::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryNotice::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 5;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::DBToCS::MsgID QueryNotice::mgsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.mgsid)
  return _internal_mgsid();
}
inline void QueryNotice::set_mgsid(::DBToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryNotice.mgsid)
}
inline ::DBToCS::MsgID QueryNotice::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.mgsid_);
}
inline void QueryNotice::_internal_set_mgsid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// repeated .DBToCS.QueryNotice.Notice notice_info = 2;
inline int QueryNotice::_internal_notice_info_size() const {
  return _internal_notice_info().size();
}
inline int QueryNotice::notice_info_size() const {
  return _internal_notice_info_size();
}
inline void QueryNotice::clear_notice_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.notice_info_.Clear();
}
inline ::DBToCS::QueryNotice_Notice* QueryNotice::mutable_notice_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryNotice.notice_info)
  return _internal_mutable_notice_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>* QueryNotice::mutable_notice_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryNotice.notice_info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_notice_info();
}
inline const ::DBToCS::QueryNotice_Notice& QueryNotice::notice_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryNotice.notice_info)
  return _internal_notice_info().Get(index);
}
inline ::DBToCS::QueryNotice_Notice* QueryNotice::add_notice_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::QueryNotice_Notice* _add = _internal_mutable_notice_info()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryNotice.notice_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>& QueryNotice::notice_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryNotice.notice_info)
  return _internal_notice_info();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>&
QueryNotice::_internal_notice_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.notice_info_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::QueryNotice_Notice>*
QueryNotice::_internal_mutable_notice_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.notice_info_;
}

// -------------------------------------------------------------------

// ChangeNickname

// optional .DBToCS.MsgID mgsid = 1 [default = eChangeNickname_CallBack];
inline bool ChangeNickname::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void ChangeNickname::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 4;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::DBToCS::MsgID ChangeNickname::mgsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.ChangeNickname.mgsid)
  return _internal_mgsid();
}
inline void ChangeNickname::set_mgsid(::DBToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:DBToCS.ChangeNickname.mgsid)
}
inline ::DBToCS::MsgID ChangeNickname::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.mgsid_);
}
inline void ChangeNickname::_internal_set_mgsid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 guid = 2;
inline bool ChangeNickname::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ChangeNickname::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint64_t ChangeNickname::guid() const {
  // @@protoc_insertion_point(field_get:DBToCS.ChangeNickname.guid)
  return _internal_guid();
}
inline void ChangeNickname::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:DBToCS.ChangeNickname.guid)
}
inline ::uint64_t ChangeNickname::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void ChangeNickname::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional bool reflag = 3;
inline bool ChangeNickname::has_reflag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ChangeNickname::clear_reflag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reflag_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ChangeNickname::reflag() const {
  // @@protoc_insertion_point(field_get:DBToCS.ChangeNickname.reflag)
  return _internal_reflag();
}
inline void ChangeNickname::set_reflag(bool value) {
  _internal_set_reflag(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:DBToCS.ChangeNickname.reflag)
}
inline bool ChangeNickname::_internal_reflag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reflag_;
}
inline void ChangeNickname::_internal_set_reflag(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reflag_ = value;
}

// optional string newnickname = 4;
inline bool ChangeNickname::has_newnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ChangeNickname::clear_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.newnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChangeNickname::newnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.ChangeNickname.newnickname)
  return _internal_newnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangeNickname::set_newnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.ChangeNickname.newnickname)
}
inline std::string* ChangeNickname::mutable_newnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_newnickname();
  // @@protoc_insertion_point(field_mutable:DBToCS.ChangeNickname.newnickname)
  return _s;
}
inline const std::string& ChangeNickname::_internal_newnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.newnickname_.Get();
}
inline void ChangeNickname::_internal_set_newnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.newnickname_.Set(value, GetArena());
}
inline std::string* ChangeNickname::_internal_mutable_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.newnickname_.Mutable( GetArena());
}
inline std::string* ChangeNickname::release_newnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.ChangeNickname.newnickname)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.newnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.newnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChangeNickname::set_allocated_newnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.newnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.newnickname_.IsDefault()) {
          _impl_.newnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.ChangeNickname.newnickname)
}

// optional string oldnickname = 5;
inline bool ChangeNickname::has_oldnickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ChangeNickname::clear_oldnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.oldnickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ChangeNickname::oldnickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.ChangeNickname.oldnickname)
  return _internal_oldnickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangeNickname::set_oldnickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.oldnickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.ChangeNickname.oldnickname)
}
inline std::string* ChangeNickname::mutable_oldnickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_oldnickname();
  // @@protoc_insertion_point(field_mutable:DBToCS.ChangeNickname.oldnickname)
  return _s;
}
inline const std::string& ChangeNickname::_internal_oldnickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.oldnickname_.Get();
}
inline void ChangeNickname::_internal_set_oldnickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.oldnickname_.Set(value, GetArena());
}
inline std::string* ChangeNickname::_internal_mutable_oldnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.oldnickname_.Mutable( GetArena());
}
inline std::string* ChangeNickname::release_oldnickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.ChangeNickname.oldnickname)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.oldnickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.oldnickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ChangeNickname::set_allocated_oldnickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.oldnickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.oldnickname_.IsDefault()) {
          _impl_.oldnickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.ChangeNickname.oldnickname)
}

// -------------------------------------------------------------------

// BuyGoods

// optional .DBToCS.MsgID mgsid = 1 [default = eBuyGoodsCallBack];
inline bool BuyGoods::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BuyGoods::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 3;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::DBToCS::MsgID BuyGoods::mgsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.BuyGoods.mgsid)
  return _internal_mgsid();
}
inline void BuyGoods::set_mgsid(::DBToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:DBToCS.BuyGoods.mgsid)
}
inline ::DBToCS::MsgID BuyGoods::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.mgsid_);
}
inline void BuyGoods::_internal_set_mgsid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional string buygoodsmag = 2;
inline bool BuyGoods::has_buygoodsmag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BuyGoods::clear_buygoodsmag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buygoodsmag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BuyGoods::buygoodsmag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.BuyGoods.buygoodsmag)
  return _internal_buygoodsmag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BuyGoods::set_buygoodsmag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buygoodsmag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.BuyGoods.buygoodsmag)
}
inline std::string* BuyGoods::mutable_buygoodsmag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_buygoodsmag();
  // @@protoc_insertion_point(field_mutable:DBToCS.BuyGoods.buygoodsmag)
  return _s;
}
inline const std::string& BuyGoods::_internal_buygoodsmag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buygoodsmag_.Get();
}
inline void BuyGoods::_internal_set_buygoodsmag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.buygoodsmag_.Set(value, GetArena());
}
inline std::string* BuyGoods::_internal_mutable_buygoodsmag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.buygoodsmag_.Mutable( GetArena());
}
inline std::string* BuyGoods::release_buygoodsmag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.BuyGoods.buygoodsmag)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.buygoodsmag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.buygoodsmag_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BuyGoods::set_allocated_buygoodsmag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.buygoodsmag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.buygoodsmag_.IsDefault()) {
          _impl_.buygoodsmag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.BuyGoods.buygoodsmag)
}

// -------------------------------------------------------------------

// CheckNameRsp

// optional .DBToCS.MsgID mgsid = 1 [default = eCheckNickNameLogicCallBack];
inline bool CheckNameRsp::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void CheckNameRsp::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 1;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::DBToCS::MsgID CheckNameRsp::mgsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.CheckNameRsp.mgsid)
  return _internal_mgsid();
}
inline void CheckNameRsp::set_mgsid(::DBToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:DBToCS.CheckNameRsp.mgsid)
}
inline ::DBToCS::MsgID CheckNameRsp::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.mgsid_);
}
inline void CheckNameRsp::_internal_set_mgsid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional string completeInfo = 2;
inline bool CheckNameRsp::has_completeinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CheckNameRsp::clear_completeinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.completeinfo_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CheckNameRsp::completeinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.CheckNameRsp.completeInfo)
  return _internal_completeinfo();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CheckNameRsp::set_completeinfo(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.completeinfo_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.CheckNameRsp.completeInfo)
}
inline std::string* CheckNameRsp::mutable_completeinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_completeinfo();
  // @@protoc_insertion_point(field_mutable:DBToCS.CheckNameRsp.completeInfo)
  return _s;
}
inline const std::string& CheckNameRsp::_internal_completeinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.completeinfo_.Get();
}
inline void CheckNameRsp::_internal_set_completeinfo(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.completeinfo_.Set(value, GetArena());
}
inline std::string* CheckNameRsp::_internal_mutable_completeinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.completeinfo_.Mutable( GetArena());
}
inline std::string* CheckNameRsp::release_completeinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.CheckNameRsp.completeInfo)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.completeinfo_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.completeinfo_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void CheckNameRsp::set_allocated_completeinfo(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.completeinfo_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.completeinfo_.IsDefault()) {
          _impl_.completeinfo_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.CheckNameRsp.completeInfo)
}

// optional int32 gsid = 3;
inline bool CheckNameRsp::has_gsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CheckNameRsp::clear_gsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t CheckNameRsp::gsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.CheckNameRsp.gsid)
  return _internal_gsid();
}
inline void CheckNameRsp::set_gsid(::int32_t value) {
  _internal_set_gsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:DBToCS.CheckNameRsp.gsid)
}
inline ::int32_t CheckNameRsp::_internal_gsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsid_;
}
inline void CheckNameRsp::_internal_set_gsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = value;
}

// optional int32 gcnetid = 4;
inline bool CheckNameRsp::has_gcnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CheckNameRsp::clear_gcnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t CheckNameRsp::gcnetid() const {
  // @@protoc_insertion_point(field_get:DBToCS.CheckNameRsp.gcnetid)
  return _internal_gcnetid();
}
inline void CheckNameRsp::set_gcnetid(::int32_t value) {
  _internal_set_gcnetid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:DBToCS.CheckNameRsp.gcnetid)
}
inline ::int32_t CheckNameRsp::_internal_gcnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gcnetid_;
}
inline void CheckNameRsp::_internal_set_gcnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = value;
}

// optional int32 gsnetid = 5;
inline bool CheckNameRsp::has_gsnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void CheckNameRsp::clear_gsnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t CheckNameRsp::gsnetid() const {
  // @@protoc_insertion_point(field_get:DBToCS.CheckNameRsp.gsnetid)
  return _internal_gsnetid();
}
inline void CheckNameRsp::set_gsnetid(::int32_t value) {
  _internal_set_gsnetid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:DBToCS.CheckNameRsp.gsnetid)
}
inline ::int32_t CheckNameRsp::_internal_gsnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsnetid_;
}
inline void CheckNameRsp::_internal_set_gsnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsnetid_ = value;
}

// optional int32 checkres = 6;
inline bool CheckNameRsp::has_checkres() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void CheckNameRsp::clear_checkres() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.checkres_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t CheckNameRsp::checkres() const {
  // @@protoc_insertion_point(field_get:DBToCS.CheckNameRsp.checkres)
  return _internal_checkres();
}
inline void CheckNameRsp::set_checkres(::int32_t value) {
  _internal_set_checkres(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:DBToCS.CheckNameRsp.checkres)
}
inline ::int32_t CheckNameRsp::_internal_checkres() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.checkres_;
}
inline void CheckNameRsp::_internal_set_checkres(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.checkres_ = value;
}

// -------------------------------------------------------------------

// HeroCfg

// optional uint32 commodityid = 1;
inline bool HeroCfg::has_commodityid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void HeroCfg::clear_commodityid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commodityid_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t HeroCfg::commodityid() const {
  // @@protoc_insertion_point(field_get:DBToCS.HeroCfg.commodityid)
  return _internal_commodityid();
}
inline void HeroCfg::set_commodityid(::uint32_t value) {
  _internal_set_commodityid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:DBToCS.HeroCfg.commodityid)
}
inline ::uint32_t HeroCfg::_internal_commodityid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.commodityid_;
}
inline void HeroCfg::_internal_set_commodityid(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.commodityid_ = value;
}

// optional int64 buytime = 2;
inline bool HeroCfg::has_buytime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void HeroCfg::clear_buytime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buytime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t HeroCfg::buytime() const {
  // @@protoc_insertion_point(field_get:DBToCS.HeroCfg.buytime)
  return _internal_buytime();
}
inline void HeroCfg::set_buytime(::int64_t value) {
  _internal_set_buytime(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:DBToCS.HeroCfg.buytime)
}
inline ::int64_t HeroCfg::_internal_buytime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buytime_;
}
inline void HeroCfg::_internal_set_buytime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buytime_ = value;
}

// optional int64 expiredtime = 3;
inline bool HeroCfg::has_expiredtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void HeroCfg::clear_expiredtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expiredtime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t HeroCfg::expiredtime() const {
  // @@protoc_insertion_point(field_get:DBToCS.HeroCfg.expiredtime)
  return _internal_expiredtime();
}
inline void HeroCfg::set_expiredtime(::int64_t value) {
  _internal_set_expiredtime(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:DBToCS.HeroCfg.expiredtime)
}
inline ::int64_t HeroCfg::_internal_expiredtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.expiredtime_;
}
inline void HeroCfg::_internal_set_expiredtime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.expiredtime_ = value;
}

// -------------------------------------------------------------------

// RuneInfo

// optional string bagStr = 1;
inline bool RuneInfo::has_bagstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RuneInfo::clear_bagstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bagstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RuneInfo::bagstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.RuneInfo.bagStr)
  return _internal_bagstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RuneInfo::set_bagstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bagstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.RuneInfo.bagStr)
}
inline std::string* RuneInfo::mutable_bagstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_bagstr();
  // @@protoc_insertion_point(field_mutable:DBToCS.RuneInfo.bagStr)
  return _s;
}
inline const std::string& RuneInfo::_internal_bagstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bagstr_.Get();
}
inline void RuneInfo::_internal_set_bagstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.bagstr_.Set(value, GetArena());
}
inline std::string* RuneInfo::_internal_mutable_bagstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.bagstr_.Mutable( GetArena());
}
inline std::string* RuneInfo::release_bagstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.RuneInfo.bagStr)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.bagstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.bagstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RuneInfo::set_allocated_bagstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.bagstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.bagstr_.IsDefault()) {
          _impl_.bagstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.RuneInfo.bagStr)
}

// optional string slotStr = 2;
inline bool RuneInfo::has_slotstr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RuneInfo::clear_slotstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.slotstr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RuneInfo::slotstr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.RuneInfo.slotStr)
  return _internal_slotstr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RuneInfo::set_slotstr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.slotstr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.RuneInfo.slotStr)
}
inline std::string* RuneInfo::mutable_slotstr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_slotstr();
  // @@protoc_insertion_point(field_mutable:DBToCS.RuneInfo.slotStr)
  return _s;
}
inline const std::string& RuneInfo::_internal_slotstr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.slotstr_.Get();
}
inline void RuneInfo::_internal_set_slotstr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.slotstr_.Set(value, GetArena());
}
inline std::string* RuneInfo::_internal_mutable_slotstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.slotstr_.Mutable( GetArena());
}
inline std::string* RuneInfo::release_slotstr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.RuneInfo.slotStr)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.slotstr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.slotstr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RuneInfo::set_allocated_slotstr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.slotstr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.slotstr_.IsDefault()) {
          _impl_.slotstr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.RuneInfo.slotStr)
}

// -------------------------------------------------------------------

// RSinfo

// optional uint64 related_id = 1;
inline bool RSinfo::has_related_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RSinfo::clear_related_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_id_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t RSinfo::related_id() const {
  // @@protoc_insertion_point(field_get:DBToCS.RSinfo.related_id)
  return _internal_related_id();
}
inline void RSinfo::set_related_id(::uint64_t value) {
  _internal_set_related_id(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:DBToCS.RSinfo.related_id)
}
inline ::uint64_t RSinfo::_internal_related_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.related_id_;
}
inline void RSinfo::_internal_set_related_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_id_ = value;
}

// optional uint32 related_header = 2;
inline bool RSinfo::has_related_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void RSinfo::clear_related_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_header_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t RSinfo::related_header() const {
  // @@protoc_insertion_point(field_get:DBToCS.RSinfo.related_header)
  return _internal_related_header();
}
inline void RSinfo::set_related_header(::uint32_t value) {
  _internal_set_related_header(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:DBToCS.RSinfo.related_header)
}
inline ::uint32_t RSinfo::_internal_related_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.related_header_;
}
inline void RSinfo::_internal_set_related_header(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_header_ = value;
}

// optional string related_name = 3;
inline bool RSinfo::has_related_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RSinfo::clear_related_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RSinfo::related_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.RSinfo.related_name)
  return _internal_related_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RSinfo::set_related_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.related_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.RSinfo.related_name)
}
inline std::string* RSinfo::mutable_related_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_related_name();
  // @@protoc_insertion_point(field_mutable:DBToCS.RSinfo.related_name)
  return _s;
}
inline const std::string& RSinfo::_internal_related_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.related_name_.Get();
}
inline void RSinfo::_internal_set_related_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.related_name_.Set(value, GetArena());
}
inline std::string* RSinfo::_internal_mutable_related_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.related_name_.Mutable( GetArena());
}
inline std::string* RSinfo::release_related_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.RSinfo.related_name)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.related_name_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.related_name_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void RSinfo::set_allocated_related_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.related_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.related_name_.IsDefault()) {
          _impl_.related_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.RSinfo.related_name)
}

// optional uint32 relation = 4;
inline bool RSinfo::has_relation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void RSinfo::clear_relation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relation_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t RSinfo::relation() const {
  // @@protoc_insertion_point(field_get:DBToCS.RSinfo.relation)
  return _internal_relation();
}
inline void RSinfo::set_relation(::uint32_t value) {
  _internal_set_relation(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:DBToCS.RSinfo.relation)
}
inline ::uint32_t RSinfo::_internal_relation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.relation_;
}
inline void RSinfo::_internal_set_relation(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.relation_ = value;
}

// optional uint32 related_vip = 5;
inline bool RSinfo::has_related_vip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void RSinfo::clear_related_vip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_vip_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t RSinfo::related_vip() const {
  // @@protoc_insertion_point(field_get:DBToCS.RSinfo.related_vip)
  return _internal_related_vip();
}
inline void RSinfo::set_related_vip(::uint32_t value) {
  _internal_set_related_vip(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:DBToCS.RSinfo.related_vip)
}
inline ::uint32_t RSinfo::_internal_related_vip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.related_vip_;
}
inline void RSinfo::_internal_set_related_vip(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.related_vip_ = value;
}

// -------------------------------------------------------------------

// ItemInfo

// optional int32 item_id = 1;
inline bool ItemInfo::has_item_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ItemInfo::clear_item_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t ItemInfo::item_id() const {
  // @@protoc_insertion_point(field_get:DBToCS.ItemInfo.item_id)
  return _internal_item_id();
}
inline void ItemInfo::set_item_id(::int32_t value) {
  _internal_set_item_id(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:DBToCS.ItemInfo.item_id)
}
inline ::int32_t ItemInfo::_internal_item_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_id_;
}
inline void ItemInfo::_internal_set_item_id(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_id_ = value;
}

// optional uint32 item_num = 2;
inline bool ItemInfo::has_item_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ItemInfo::clear_item_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t ItemInfo::item_num() const {
  // @@protoc_insertion_point(field_get:DBToCS.ItemInfo.item_num)
  return _internal_item_num();
}
inline void ItemInfo::set_item_num(::uint32_t value) {
  _internal_set_item_num(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:DBToCS.ItemInfo.item_num)
}
inline ::uint32_t ItemInfo::_internal_item_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_num_;
}
inline void ItemInfo::_internal_set_item_num(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_num_ = value;
}

// optional int32 buy_time = 3;
inline bool ItemInfo::has_buy_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ItemInfo::clear_buy_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buy_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ItemInfo::buy_time() const {
  // @@protoc_insertion_point(field_get:DBToCS.ItemInfo.buy_time)
  return _internal_buy_time();
}
inline void ItemInfo::set_buy_time(::int32_t value) {
  _internal_set_buy_time(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:DBToCS.ItemInfo.buy_time)
}
inline ::int32_t ItemInfo::_internal_buy_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.buy_time_;
}
inline void ItemInfo::_internal_set_buy_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.buy_time_ = value;
}

// optional int32 end_time = 4;
inline bool ItemInfo::has_end_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ItemInfo::clear_end_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t ItemInfo::end_time() const {
  // @@protoc_insertion_point(field_get:DBToCS.ItemInfo.end_time)
  return _internal_end_time();
}
inline void ItemInfo::set_end_time(::int32_t value) {
  _internal_set_end_time(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:DBToCS.ItemInfo.end_time)
}
inline ::int32_t ItemInfo::_internal_end_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.end_time_;
}
inline void ItemInfo::_internal_set_end_time(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.end_time_ = value;
}

// -------------------------------------------------------------------

// MailInfo

// optional int32 mailid = 1;
inline bool MailInfo::has_mailid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void MailInfo::clear_mailid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t MailInfo::mailid() const {
  // @@protoc_insertion_point(field_get:DBToCS.MailInfo.mailid)
  return _internal_mailid();
}
inline void MailInfo::set_mailid(::int32_t value) {
  _internal_set_mailid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:DBToCS.MailInfo.mailid)
}
inline ::int32_t MailInfo::_internal_mailid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mailid_;
}
inline void MailInfo::_internal_set_mailid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mailid_ = value;
}

// optional int32 state = 2;
inline bool MailInfo::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void MailInfo::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t MailInfo::state() const {
  // @@protoc_insertion_point(field_get:DBToCS.MailInfo.state)
  return _internal_state();
}
inline void MailInfo::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:DBToCS.MailInfo.state)
}
inline ::int32_t MailInfo::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void MailInfo::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// -------------------------------------------------------------------

// QueryUser

// optional .DBToCS.MsgID msgid = 1 [default = eQueryUser_DBCallBack];
inline bool QueryUser::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void QueryUser::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 2;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::DBToCS::MsgID QueryUser::msgid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.msgid)
  return _internal_msgid();
}
inline void QueryUser::set_msgid(::DBToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.msgid)
}
inline ::DBToCS::MsgID QueryUser::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.msgid_);
}
inline void QueryUser::_internal_set_msgid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// optional string db = 2;
inline bool QueryUser::has_db() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryUser::clear_db() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.db_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QueryUser::db() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.db)
  return _internal_db();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUser::set_db(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.db_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.db)
}
inline std::string* QueryUser::mutable_db() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_db();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.db)
  return _s;
}
inline const std::string& QueryUser::_internal_db() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.db_.Get();
}
inline void QueryUser::_internal_set_db(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.db_.Set(value, GetArena());
}
inline std::string* QueryUser::_internal_mutable_db() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.db_.Mutable( GetArena());
}
inline std::string* QueryUser::release_db() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryUser.db)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.db_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.db_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUser::set_allocated_db(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.db_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.db_.IsDefault()) {
          _impl_.db_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryUser.db)
}

// optional string login = 3;
inline bool QueryUser::has_login() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void QueryUser::clear_login() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.login_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& QueryUser::login() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.login)
  return _internal_login();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUser::set_login(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.login_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.login)
}
inline std::string* QueryUser::mutable_login() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.login)
  return _s;
}
inline const std::string& QueryUser::_internal_login() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.login_.Get();
}
inline void QueryUser::_internal_set_login(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.login_.Set(value, GetArena());
}
inline std::string* QueryUser::_internal_mutable_login() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.login_.Mutable( GetArena());
}
inline std::string* QueryUser::release_login() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryUser.login)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.login_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.login_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUser::set_allocated_login(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.login_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.login_.IsDefault()) {
          _impl_.login_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryUser.login)
}

// optional int32 gsid = 4;
inline bool QueryUser::has_gsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void QueryUser::clear_gsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int32_t QueryUser::gsid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.gsid)
  return _internal_gsid();
}
inline void QueryUser::set_gsid(::int32_t value) {
  _internal_set_gsid(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.gsid)
}
inline ::int32_t QueryUser::_internal_gsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsid_;
}
inline void QueryUser::_internal_set_gsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = value;
}

// optional int32 gcnetid = 5;
inline bool QueryUser::has_gcnetid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void QueryUser::clear_gcnetid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t QueryUser::gcnetid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.gcnetid)
  return _internal_gcnetid();
}
inline void QueryUser::set_gcnetid(::int32_t value) {
  _internal_set_gcnetid(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.gcnetid)
}
inline ::int32_t QueryUser::_internal_gcnetid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gcnetid_;
}
inline void QueryUser::_internal_set_gcnetid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnetid_ = value;
}

// optional string nickname = 6;
inline bool QueryUser::has_nickname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void QueryUser::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& QueryUser::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUser::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.nickname)
}
inline std::string* QueryUser::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.nickname)
  return _s;
}
inline const std::string& QueryUser::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void QueryUser::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* QueryUser::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* QueryUser::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryUser.nickname)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.nickname_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.nickname_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUser::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryUser.nickname)
}

// repeated .DBToCS.HeroCfg herocfg = 7;
inline int QueryUser::_internal_herocfg_size() const {
  return _internal_herocfg().size();
}
inline int QueryUser::herocfg_size() const {
  return _internal_herocfg_size();
}
inline void QueryUser::clear_herocfg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herocfg_.Clear();
}
inline ::DBToCS::HeroCfg* QueryUser::mutable_herocfg(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.herocfg)
  return _internal_mutable_herocfg()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>* QueryUser::mutable_herocfg()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryUser.herocfg)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_herocfg();
}
inline const ::DBToCS::HeroCfg& QueryUser::herocfg(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.herocfg)
  return _internal_herocfg().Get(index);
}
inline ::DBToCS::HeroCfg* QueryUser::add_herocfg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::HeroCfg* _add = _internal_mutable_herocfg()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryUser.herocfg)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>& QueryUser::herocfg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryUser.herocfg)
  return _internal_herocfg();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>&
QueryUser::_internal_herocfg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herocfg_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::HeroCfg>*
QueryUser::_internal_mutable_herocfg() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.herocfg_;
}

// repeated .DBToCS.RuneInfo runeinfo = 8;
inline int QueryUser::_internal_runeinfo_size() const {
  return _internal_runeinfo().size();
}
inline int QueryUser::runeinfo_size() const {
  return _internal_runeinfo_size();
}
inline void QueryUser::clear_runeinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runeinfo_.Clear();
}
inline ::DBToCS::RuneInfo* QueryUser::mutable_runeinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.runeinfo)
  return _internal_mutable_runeinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>* QueryUser::mutable_runeinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryUser.runeinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_runeinfo();
}
inline const ::DBToCS::RuneInfo& QueryUser::runeinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.runeinfo)
  return _internal_runeinfo().Get(index);
}
inline ::DBToCS::RuneInfo* QueryUser::add_runeinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::RuneInfo* _add = _internal_mutable_runeinfo()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryUser.runeinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>& QueryUser::runeinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryUser.runeinfo)
  return _internal_runeinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>&
QueryUser::_internal_runeinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runeinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::RuneInfo>*
QueryUser::_internal_mutable_runeinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.runeinfo_;
}

// repeated .DBToCS.RSinfo rsinfo = 9;
inline int QueryUser::_internal_rsinfo_size() const {
  return _internal_rsinfo().size();
}
inline int QueryUser::rsinfo_size() const {
  return _internal_rsinfo_size();
}
inline void QueryUser::clear_rsinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rsinfo_.Clear();
}
inline ::DBToCS::RSinfo* QueryUser::mutable_rsinfo(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.rsinfo)
  return _internal_mutable_rsinfo()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>* QueryUser::mutable_rsinfo()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryUser.rsinfo)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_rsinfo();
}
inline const ::DBToCS::RSinfo& QueryUser::rsinfo(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.rsinfo)
  return _internal_rsinfo().Get(index);
}
inline ::DBToCS::RSinfo* QueryUser::add_rsinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::RSinfo* _add = _internal_mutable_rsinfo()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryUser.rsinfo)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>& QueryUser::rsinfo() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryUser.rsinfo)
  return _internal_rsinfo();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>&
QueryUser::_internal_rsinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rsinfo_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::RSinfo>*
QueryUser::_internal_mutable_rsinfo() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.rsinfo_;
}

// repeated .DBToCS.ItemInfo item_info = 10;
inline int QueryUser::_internal_item_info_size() const {
  return _internal_item_info().size();
}
inline int QueryUser::item_info_size() const {
  return _internal_item_info_size();
}
inline void QueryUser::clear_item_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.item_info_.Clear();
}
inline ::DBToCS::ItemInfo* QueryUser::mutable_item_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.item_info)
  return _internal_mutable_item_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>* QueryUser::mutable_item_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryUser.item_info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_item_info();
}
inline const ::DBToCS::ItemInfo& QueryUser::item_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.item_info)
  return _internal_item_info().Get(index);
}
inline ::DBToCS::ItemInfo* QueryUser::add_item_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::ItemInfo* _add = _internal_mutable_item_info()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryUser.item_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>& QueryUser::item_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryUser.item_info)
  return _internal_item_info();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>&
QueryUser::_internal_item_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.item_info_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::ItemInfo>*
QueryUser::_internal_mutable_item_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.item_info_;
}

// repeated .DBToCS.MailInfo mail_info = 11;
inline int QueryUser::_internal_mail_info_size() const {
  return _internal_mail_info().size();
}
inline int QueryUser::mail_info_size() const {
  return _internal_mail_info_size();
}
inline void QueryUser::clear_mail_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mail_info_.Clear();
}
inline ::DBToCS::MailInfo* QueryUser::mutable_mail_info(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.mail_info)
  return _internal_mutable_mail_info()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>* QueryUser::mutable_mail_info()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryUser.mail_info)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_mail_info();
}
inline const ::DBToCS::MailInfo& QueryUser::mail_info(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.mail_info)
  return _internal_mail_info().Get(index);
}
inline ::DBToCS::MailInfo* QueryUser::add_mail_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::MailInfo* _add = _internal_mutable_mail_info()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryUser.mail_info)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>& QueryUser::mail_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryUser.mail_info)
  return _internal_mail_info();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>&
QueryUser::_internal_mail_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mail_info_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::MailInfo>*
QueryUser::_internal_mutable_mail_info() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.mail_info_;
}

// optional string guidestr = 12;
inline bool QueryUser::has_guidestr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void QueryUser::clear_guidestr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guidestr_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& QueryUser::guidestr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.guidestr)
  return _internal_guidestr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUser::set_guidestr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.guidestr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.guidestr)
}
inline std::string* QueryUser::mutable_guidestr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_guidestr();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.guidestr)
  return _s;
}
inline const std::string& QueryUser::_internal_guidestr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guidestr_.Get();
}
inline void QueryUser::_internal_set_guidestr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.guidestr_.Set(value, GetArena());
}
inline std::string* QueryUser::_internal_mutable_guidestr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.guidestr_.Mutable( GetArena());
}
inline std::string* QueryUser::release_guidestr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryUser.guidestr)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.guidestr_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.guidestr_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUser::set_allocated_guidestr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.guidestr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.guidestr_.IsDefault()) {
          _impl_.guidestr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryUser.guidestr)
}

// optional string taskData = 13;
inline bool QueryUser::has_taskdata() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void QueryUser::clear_taskdata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskdata_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& QueryUser::taskdata() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryUser.taskData)
  return _internal_taskdata();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void QueryUser::set_taskdata(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.taskdata_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:DBToCS.QueryUser.taskData)
}
inline std::string* QueryUser::mutable_taskdata() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_taskdata();
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryUser.taskData)
  return _s;
}
inline const std::string& QueryUser::_internal_taskdata() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskdata_.Get();
}
inline void QueryUser::_internal_set_taskdata(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.taskdata_.Set(value, GetArena());
}
inline std::string* QueryUser::_internal_mutable_taskdata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.taskdata_.Mutable( GetArena());
}
inline std::string* QueryUser::release_taskdata() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:DBToCS.QueryUser.taskData)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.taskdata_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.taskdata_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void QueryUser::set_allocated_taskdata(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.taskdata_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taskdata_.IsDefault()) {
          _impl_.taskdata_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DBToCS.QueryUser.taskData)
}

// -------------------------------------------------------------------

// QueryAllUser

// optional .DBToCS.MsgID msgid = 1 [default = eQueryAllUser_CallBack];
inline bool QueryAllUser::has_msgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void QueryAllUser::clear_msgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.msgid_ = 9;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::DBToCS::MsgID QueryAllUser::msgid() const {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllUser.msgid)
  return _internal_msgid();
}
inline void QueryAllUser::set_msgid(::DBToCS::MsgID value) {
  _internal_set_msgid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:DBToCS.QueryAllUser.msgid)
}
inline ::DBToCS::MsgID QueryAllUser::_internal_msgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::DBToCS::MsgID>(_impl_.msgid_);
}
inline void QueryAllUser::_internal_set_msgid(::DBToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::DBToCS::MsgID_IsValid(value));
  _impl_.msgid_ = value;
}

// repeated .DBToCS.QueryUser sQueryUser = 2;
inline int QueryAllUser::_internal_squeryuser_size() const {
  return _internal_squeryuser().size();
}
inline int QueryAllUser::squeryuser_size() const {
  return _internal_squeryuser_size();
}
inline void QueryAllUser::clear_squeryuser() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.squeryuser_.Clear();
}
inline ::DBToCS::QueryUser* QueryAllUser::mutable_squeryuser(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:DBToCS.QueryAllUser.sQueryUser)
  return _internal_mutable_squeryuser()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>* QueryAllUser::mutable_squeryuser()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:DBToCS.QueryAllUser.sQueryUser)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_squeryuser();
}
inline const ::DBToCS::QueryUser& QueryAllUser::squeryuser(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:DBToCS.QueryAllUser.sQueryUser)
  return _internal_squeryuser().Get(index);
}
inline ::DBToCS::QueryUser* QueryAllUser::add_squeryuser() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::DBToCS::QueryUser* _add = _internal_mutable_squeryuser()->Add();
  // @@protoc_insertion_point(field_add:DBToCS.QueryAllUser.sQueryUser)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>& QueryAllUser::squeryuser() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:DBToCS.QueryAllUser.sQueryUser)
  return _internal_squeryuser();
}
inline const ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>&
QueryAllUser::_internal_squeryuser() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.squeryuser_;
}
inline ::google::protobuf::RepeatedPtrField<::DBToCS::QueryUser>*
QueryAllUser::_internal_mutable_squeryuser() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.squeryuser_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace DBToCS


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::DBToCS::MsgID> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::DBToCS::MsgID>() {
  return ::DBToCS::MsgID_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_DBToCs_2eproto_2epb_2eh
