// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SSToCS.proto
// Protobuf C++ Version: 4.26.0-dev

#ifndef GOOGLE_PROTOBUF_INCLUDED_SSToCS_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_SSToCS_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 4026000
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_SSToCS_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_SSToCS_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_SSToCS_2eproto;
namespace SSToCS {
class AddGold;
struct AddGoldDefaultTypeInternal;
extern AddGoldDefaultTypeInternal _AddGold_default_instance_;
class AskAllCfgList;
struct AskAllCfgListDefaultTypeInternal;
extern AskAllCfgListDefaultTypeInternal _AskAllCfgList_default_instance_;
class AskChangeFirstWinTime;
struct AskChangeFirstWinTimeDefaultTypeInternal;
extern AskChangeFirstWinTimeDefaultTypeInternal _AskChangeFirstWinTime_default_instance_;
class AskGoodsfgList;
struct AskGoodsfgListDefaultTypeInternal;
extern AskGoodsfgListDefaultTypeInternal _AskGoodsfgList_default_instance_;
class AskHeroCfgList;
struct AskHeroCfgListDefaultTypeInternal;
extern AskHeroCfgListDefaultTypeInternal _AskHeroCfgList_default_instance_;
class AskMapCfgList;
struct AskMapCfgListDefaultTypeInternal;
extern AskMapCfgListDefaultTypeInternal _AskMapCfgList_default_instance_;
class AskNewSkillCfg;
struct AskNewSkillCfgDefaultTypeInternal;
extern AskNewSkillCfgDefaultTypeInternal _AskNewSkillCfg_default_instance_;
class AskPassitiveEffectBloodSeekCfg;
struct AskPassitiveEffectBloodSeekCfgDefaultTypeInternal;
extern AskPassitiveEffectBloodSeekCfgDefaultTypeInternal _AskPassitiveEffectBloodSeekCfg_default_instance_;
class AskPassitiveEffectReboundCfg;
struct AskPassitiveEffectReboundCfgDefaultTypeInternal;
extern AskPassitiveEffectReboundCfgDefaultTypeInternal _AskPassitiveEffectReboundCfg_default_instance_;
class AskPassitiveEffectReliveCfg;
struct AskPassitiveEffectReliveCfgDefaultTypeInternal;
extern AskPassitiveEffectReliveCfgDefaultTypeInternal _AskPassitiveEffectReliveCfg_default_instance_;
class AskPassitiveSkillCfg;
struct AskPassitiveSkillCfgDefaultTypeInternal;
extern AskPassitiveSkillCfgDefaultTypeInternal _AskPassitiveSkillCfg_default_instance_;
class AskPing;
struct AskPingDefaultTypeInternal;
extern AskPingDefaultTypeInternal _AskPing_default_instance_;
class AskPublicLuaStr;
struct AskPublicLuaStrDefaultTypeInternal;
extern AskPublicLuaStrDefaultTypeInternal _AskPublicLuaStr_default_instance_;
class AskRegiste;
struct AskRegisteDefaultTypeInternal;
extern AskRegisteDefaultTypeInternal _AskRegiste_default_instance_;
class AskShopfgList;
struct AskShopfgListDefaultTypeInternal;
extern AskShopfgListDefaultTypeInternal _AskShopfgList_default_instance_;
class AskSkillEffectAccountCfg;
struct AskSkillEffectAccountCfgDefaultTypeInternal;
extern AskSkillEffectAccountCfgDefaultTypeInternal _AskSkillEffectAccountCfg_default_instance_;
class AskSkillEffectBufCfg;
struct AskSkillEffectBufCfgDefaultTypeInternal;
extern AskSkillEffectBufCfgDefaultTypeInternal _AskSkillEffectBufCfg_default_instance_;
class AskSkillEffectLeadingCfg;
struct AskSkillEffectLeadingCfgDefaultTypeInternal;
extern AskSkillEffectLeadingCfgDefaultTypeInternal _AskSkillEffectLeadingCfg_default_instance_;
class AskSkillEffectMoveCfg;
struct AskSkillEffectMoveCfgDefaultTypeInternal;
extern AskSkillEffectMoveCfgDefaultTypeInternal _AskSkillEffectMoveCfg_default_instance_;
class AskSkillEffectRangeCfg;
struct AskSkillEffectRangeCfgDefaultTypeInternal;
extern AskSkillEffectRangeCfgDefaultTypeInternal _AskSkillEffectRangeCfg_default_instance_;
class AskSkillEffectSummonCfg;
struct AskSkillEffectSummonCfgDefaultTypeInternal;
extern AskSkillEffectSummonCfgDefaultTypeInternal _AskSkillEffectSummonCfg_default_instance_;
class AskSkillEffectSwitchCfg;
struct AskSkillEffectSwitchCfgDefaultTypeInternal;
extern AskSkillEffectSwitchCfgDefaultTypeInternal _AskSkillEffectSwitchCfg_default_instance_;
class AskUpdateData;
struct AskUpdateDataDefaultTypeInternal;
extern AskUpdateDataDefaultTypeInternal _AskUpdateData_default_instance_;
class AskUpdateGuideStep;
struct AskUpdateGuideStepDefaultTypeInternal;
extern AskUpdateGuideStepDefaultTypeInternal _AskUpdateGuideStep_default_instance_;
class AskUserGoHall;
struct AskUserGoHallDefaultTypeInternal;
extern AskUserGoHallDefaultTypeInternal _AskUserGoHall_default_instance_;
class BattleLog;
struct BattleLogDefaultTypeInternal;
extern BattleLogDefaultTypeInternal _BattleLog_default_instance_;
class CreateBattleResponse;
struct CreateBattleResponseDefaultTypeInternal;
extern CreateBattleResponseDefaultTypeInternal _CreateBattleResponse_default_instance_;
class FinishBattle;
struct FinishBattleDefaultTypeInternal;
extern FinishBattleDefaultTypeInternal _FinishBattle_default_instance_;
class FinishBattle_BattleUserData;
struct FinishBattle_BattleUserDataDefaultTypeInternal;
extern FinishBattle_BattleUserDataDefaultTypeInternal _FinishBattle_BattleUserData_default_instance_;
class GameLogSwitch;
struct GameLogSwitchDefaultTypeInternal;
extern GameLogSwitchDefaultTypeInternal _GameLogSwitch_default_instance_;
class ReportBattleFinished;
struct ReportBattleFinishedDefaultTypeInternal;
extern ReportBattleFinishedDefaultTypeInternal _ReportBattleFinished_default_instance_;
class ReportBattleShowResult;
struct ReportBattleShowResultDefaultTypeInternal;
extern ReportBattleShowResultDefaultTypeInternal _ReportBattleShowResult_default_instance_;
class ReportGotSomeMsg;
struct ReportGotSomeMsgDefaultTypeInternal;
extern ReportGotSomeMsgDefaultTypeInternal _ReportGotSomeMsg_default_instance_;
class ReportUserOffline;
struct ReportUserOfflineDefaultTypeInternal;
extern ReportUserOfflineDefaultTypeInternal _ReportUserOffline_default_instance_;
class SyncAllBattleInfo;
struct SyncAllBattleInfoDefaultTypeInternal;
extern SyncAllBattleInfoDefaultTypeInternal _SyncAllBattleInfo_default_instance_;
class UpGuideBattleStep;
struct UpGuideBattleStepDefaultTypeInternal;
extern UpGuideBattleStepDefaultTypeInternal _UpGuideBattleStep_default_instance_;
class UserNetInfo;
struct UserNetInfoDefaultTypeInternal;
extern UserNetInfoDefaultTypeInternal _UserNetInfo_default_instance_;
class userData;
struct userDataDefaultTypeInternal;
extern userDataDefaultTypeInternal _userData_default_instance_;
}  // namespace SSToCS
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace SSToCS {
enum MsgID : int {
  eMsgToCSFromSS_Begin = 8192,
  eMsgToCSFromSS_AskPing = 8193,
  eMsgToCSFromSS_AskRegiste = 8194,
  eMsgToCSFromSS_ReportBattleFinished = 8195,
  eMsgToCSFromSS_ReportUserOffline = 8196,
  eMsgToCSFromSS_AskBuffCfgList = 8197,
  eMsgToCSFromSS_AskSkillCfgList = 8198,
  eMsgToCSFromSS_AskAllCfgList = 8199,
  eMsgToCSFromSS_AskHeroCfgList = 8200,
  eMsgToCSFromSS_AskShopfgList = 8201,
  eMsgToCSFromSS_AskGoodsfgList = 8202,
  eMsgToCSFromSS_AskPublicLuaStr = 8203,
  eMsgToCSFromSS_AskMapCfgList = 8204,
  eMsgToCSFromSS_AskMapCfgData = 8205,
  eMsgToCSFromSS_AskUpdateData = 8206,
  eMsgToCSFromSS_AskAddGold = 8207,
  eMsgToCSFromSS_AskChangeFirstWinTime = 8210,
  eMsgToCSFromSS_AskNewSkillCfg = 8211,
  eMsgToCSFromSS_AskSkillModelType = 8212,
  eMsgToCSFromSS_AskSkillEffectAccountCfg = 8213,
  eMsgToCSFromSS_AskSkillEffectEmitCfg = 8214,
  eMsgToCSFromSS_AskSkillEffectRangeCfg = 8215,
  eMsgToCSFromSS_AskSkillEffectLeadingCfg = 8216,
  eMsgToCSFromSS_AskSkillEffectBufCfg = 8217,
  eMsgToCSFromSS_AskSkillEffectSummonCfg = 8218,
  eMsgToCSFromSS_AskSkillEffectMoveCfg = 8219,
  eMsgToCSFromSS_AskSkillEffectSwitchCfg = 8220,
  eMsgToCSFromSS_AskPassitiveSkillCfg = 8221,
  eMsgToCSFromSS_AskPassitiveEffectBloodSeekCfg = 8222,
  eMsgToCSFromSS_AskPassitiveEffectReboundCfg = 8223,
  eMsgToCSFromSS_AskPassitiveEffectReliveCfg = 8224,
  eMsgToCSFromSS_AskUpdateGuideStep = 8225,
  eMsgToCSFromSS_AskUserGoHall = 8226,
  eMsgToCSFromSS_ReportBattleShowResult = 8227,
  eMsgToCSFromSS_ReportGotSomeMsg = 8228,
  eMsgToCSFromSS_AllBattleInfo = 8229,
  eMsgToCSFromSS_BattleLog = 8230,
  eMsgToCSFromSS_UpdateGuideBattleStep = 8231,
  eMsgToCSFromSS_AskSSGameLogSwitch = 8232,
  eMsgToCSFromSS_CreateBattleResponse = 8300,
  eMsgToCSFromSS_FinishBattle = 8310,
  eMsgToCSFromSS_End = 8500,
};

bool MsgID_IsValid(int value);
extern const uint32_t MsgID_internal_data_[];
constexpr MsgID MsgID_MIN = static_cast<MsgID>(8192);
constexpr MsgID MsgID_MAX = static_cast<MsgID>(8500);
constexpr int MsgID_ARRAYSIZE = 8500 + 1;
const ::google::protobuf::EnumDescriptor*
MsgID_descriptor();
template <typename T>
const std::string& MsgID_Name(T value) {
  static_assert(std::is_same<T, MsgID>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MsgID_Name().");
  return ::google::protobuf::internal::NameOfEnum(MsgID_descriptor(), value);
}
inline bool MsgID_Parse(absl::string_view name, MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgID>(
      MsgID_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class userData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.userData) */ {
 public:
  inline userData() : userData(nullptr) {}
  ~userData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR userData(
      ::google::protobuf::internal::ConstantInitialized);

  inline userData(const userData& from) : userData(nullptr, from) {}
  inline userData(userData&& from) noexcept
      : userData(nullptr, std::move(from)) {}
  inline userData& operator=(const userData& from) {
    CopyFrom(from);
    return *this;
  }
  inline userData& operator=(userData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const userData& default_instance() {
    return *internal_default_instance();
  }
  static inline const userData* internal_default_instance() {
    return reinterpret_cast<const userData*>(
        &_userData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(userData& a, userData& b) { a.Swap(&b); }
  inline void Swap(userData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(userData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  userData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<userData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const userData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const userData& from) { userData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(userData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.userData"; }

 protected:
  explicit userData(::google::protobuf::Arena* arena);
  userData(::google::protobuf::Arena* arena, const userData& from);
  userData(::google::protobuf::Arena* arena, userData&& from) noexcept
      : userData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 1,
    kDeadtimesFieldNumber = 2,
    kHerokillsFieldNumber = 3,
    kGameinnFieldNumber = 4,
    kWininnFieldNumber = 5,
    kGoldFieldNumber = 7,
    kExpFieldNumber = 6,
    kDestorybuildingFieldNumber = 8,
    kHeroidFieldNumber = 9,
  };
  // optional uint64 guid = 1;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint32 deadtimes = 2;
  bool has_deadtimes() const;
  void clear_deadtimes() ;
  ::uint32_t deadtimes() const;
  void set_deadtimes(::uint32_t value);

  private:
  ::uint32_t _internal_deadtimes() const;
  void _internal_set_deadtimes(::uint32_t value);

  public:
  // optional uint32 herokills = 3;
  bool has_herokills() const;
  void clear_herokills() ;
  ::uint32_t herokills() const;
  void set_herokills(::uint32_t value);

  private:
  ::uint32_t _internal_herokills() const;
  void _internal_set_herokills(::uint32_t value);

  public:
  // optional uint32 gameinn = 4;
  bool has_gameinn() const;
  void clear_gameinn() ;
  ::uint32_t gameinn() const;
  void set_gameinn(::uint32_t value);

  private:
  ::uint32_t _internal_gameinn() const;
  void _internal_set_gameinn(::uint32_t value);

  public:
  // optional uint32 wininn = 5;
  bool has_wininn() const;
  void clear_wininn() ;
  ::uint32_t wininn() const;
  void set_wininn(::uint32_t value);

  private:
  ::uint32_t _internal_wininn() const;
  void _internal_set_wininn(::uint32_t value);

  public:
  // optional int64 gold = 7;
  bool has_gold() const;
  void clear_gold() ;
  ::int64_t gold() const;
  void set_gold(::int64_t value);

  private:
  ::int64_t _internal_gold() const;
  void _internal_set_gold(::int64_t value);

  public:
  // optional uint32 exp = 6;
  bool has_exp() const;
  void clear_exp() ;
  ::uint32_t exp() const;
  void set_exp(::uint32_t value);

  private:
  ::uint32_t _internal_exp() const;
  void _internal_set_exp(::uint32_t value);

  public:
  // optional int32 destorybuilding = 8;
  bool has_destorybuilding() const;
  void clear_destorybuilding() ;
  ::int32_t destorybuilding() const;
  void set_destorybuilding(::int32_t value);

  private:
  ::int32_t _internal_destorybuilding() const;
  void _internal_set_destorybuilding(::int32_t value);

  public:
  // optional int32 heroid = 9;
  bool has_heroid() const;
  void clear_heroid() ;
  ::int32_t heroid() const;
  void set_heroid(::int32_t value);

  private:
  ::int32_t _internal_heroid() const;
  void _internal_set_heroid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.userData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint32_t deadtimes_;
    ::uint32_t herokills_;
    ::uint32_t gameinn_;
    ::uint32_t wininn_;
    ::int64_t gold_;
    ::uint32_t exp_;
    ::int32_t destorybuilding_;
    ::int32_t heroid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class UserNetInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.UserNetInfo) */ {
 public:
  inline UserNetInfo() : UserNetInfo(nullptr) {}
  ~UserNetInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UserNetInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline UserNetInfo(const UserNetInfo& from) : UserNetInfo(nullptr, from) {}
  inline UserNetInfo(UserNetInfo&& from) noexcept
      : UserNetInfo(nullptr, std::move(from)) {}
  inline UserNetInfo& operator=(const UserNetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserNetInfo& operator=(UserNetInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserNetInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserNetInfo* internal_default_instance() {
    return reinterpret_cast<const UserNetInfo*>(
        &_UserNetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(UserNetInfo& a, UserNetInfo& b) { a.Swap(&b); }
  inline void Swap(UserNetInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserNetInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserNetInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UserNetInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UserNetInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UserNetInfo& from) { UserNetInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UserNetInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.UserNetInfo"; }

 protected:
  explicit UserNetInfo(::google::protobuf::Arena* arena);
  UserNetInfo(::google::protobuf::Arena* arena, const UserNetInfo& from);
  UserNetInfo(::google::protobuf::Arena* arena, UserNetInfo&& from) noexcept
      : UserNetInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGsidFieldNumber = 1,
    kGcnsidFieldNumber = 2,
  };
  // optional int32 gsid = 1;
  bool has_gsid() const;
  void clear_gsid() ;
  ::int32_t gsid() const;
  void set_gsid(::int32_t value);

  private:
  ::int32_t _internal_gsid() const;
  void _internal_set_gsid(::int32_t value);

  public:
  // optional int32 gcnsid = 2;
  bool has_gcnsid() const;
  void clear_gcnsid() ;
  ::int32_t gcnsid() const;
  void set_gcnsid(::int32_t value);

  private:
  ::int32_t _internal_gcnsid() const;
  void _internal_set_gcnsid(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.UserNetInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t gsid_;
    ::int32_t gcnsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class UpGuideBattleStep final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.UpGuideBattleStep) */ {
 public:
  inline UpGuideBattleStep() : UpGuideBattleStep(nullptr) {}
  ~UpGuideBattleStep() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpGuideBattleStep(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpGuideBattleStep(const UpGuideBattleStep& from) : UpGuideBattleStep(nullptr, from) {}
  inline UpGuideBattleStep(UpGuideBattleStep&& from) noexcept
      : UpGuideBattleStep(nullptr, std::move(from)) {}
  inline UpGuideBattleStep& operator=(const UpGuideBattleStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpGuideBattleStep& operator=(UpGuideBattleStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpGuideBattleStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpGuideBattleStep* internal_default_instance() {
    return reinterpret_cast<const UpGuideBattleStep*>(
        &_UpGuideBattleStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(UpGuideBattleStep& a, UpGuideBattleStep& b) { a.Swap(&b); }
  inline void Swap(UpGuideBattleStep* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpGuideBattleStep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpGuideBattleStep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<UpGuideBattleStep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpGuideBattleStep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpGuideBattleStep& from) { UpGuideBattleStep::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpGuideBattleStep* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.UpGuideBattleStep"; }

 protected:
  explicit UpGuideBattleStep(::google::protobuf::Arena* arena);
  UpGuideBattleStep(::google::protobuf::Arena* arena, const UpGuideBattleStep& from);
  UpGuideBattleStep(::google::protobuf::Arena* arena, UpGuideBattleStep&& from) noexcept
      : UpGuideBattleStep(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kTaskidFieldNumber = 3,
    kNumFieldNumber = 4,
    kMgsidFieldNumber = 1,
  };
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional int32 taskid = 3;
  bool has_taskid() const;
  void clear_taskid() ;
  ::int32_t taskid() const;
  void set_taskid(::int32_t value);

  private:
  ::int32_t _internal_taskid() const;
  void _internal_set_taskid(::int32_t value);

  public:
  // optional int32 num = 4;
  bool has_num() const;
  void clear_num() ;
  ::int32_t num() const;
  void set_num(::int32_t value);

  private:
  ::int32_t _internal_num() const;
  void _internal_set_num(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_UpdateGuideBattleStep];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.UpGuideBattleStep)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t guid_;
    ::int32_t taskid_;
    ::int32_t num_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class SyncAllBattleInfo final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.SyncAllBattleInfo) */ {
 public:
  inline SyncAllBattleInfo() : SyncAllBattleInfo(nullptr) {}
  ~SyncAllBattleInfo() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SyncAllBattleInfo(
      ::google::protobuf::internal::ConstantInitialized);

  inline SyncAllBattleInfo(const SyncAllBattleInfo& from) : SyncAllBattleInfo(nullptr, from) {}
  inline SyncAllBattleInfo(SyncAllBattleInfo&& from) noexcept
      : SyncAllBattleInfo(nullptr, std::move(from)) {}
  inline SyncAllBattleInfo& operator=(const SyncAllBattleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncAllBattleInfo& operator=(SyncAllBattleInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SyncAllBattleInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncAllBattleInfo* internal_default_instance() {
    return reinterpret_cast<const SyncAllBattleInfo*>(
        &_SyncAllBattleInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 34;
  friend void swap(SyncAllBattleInfo& a, SyncAllBattleInfo& b) { a.Swap(&b); }
  inline void Swap(SyncAllBattleInfo* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncAllBattleInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncAllBattleInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SyncAllBattleInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SyncAllBattleInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SyncAllBattleInfo& from) { SyncAllBattleInfo::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SyncAllBattleInfo* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.SyncAllBattleInfo"; }

 protected:
  explicit SyncAllBattleInfo(::google::protobuf::Arena* arena);
  SyncAllBattleInfo(::google::protobuf::Arena* arena, const SyncAllBattleInfo& from);
  SyncAllBattleInfo(::google::protobuf::Arena* arena, SyncAllBattleInfo&& from) noexcept
      : SyncAllBattleInfo(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPlaybattleFieldNumber = 2,
    kMaxbattleidFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // repeated uint64 playbattle = 2;
  int playbattle_size() const;
  private:
  int _internal_playbattle_size() const;

  public:
  void clear_playbattle() ;
  ::uint64_t playbattle(int index) const;
  void set_playbattle(int index, ::uint64_t value);
  void add_playbattle(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& playbattle() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_playbattle();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_playbattle() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_playbattle();

  public:
  // optional uint64 maxbattleid = 3;
  bool has_maxbattleid() const;
  void clear_maxbattleid() ;
  ::uint64_t maxbattleid() const;
  void set_maxbattleid(::uint64_t value);

  private:
  ::uint64_t _internal_maxbattleid() const;
  void _internal_set_maxbattleid(::uint64_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AllBattleInfo];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.SyncAllBattleInfo)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::uint64_t> playbattle_;
    ::uint64_t maxbattleid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class ReportGotSomeMsg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.ReportGotSomeMsg) */ {
 public:
  inline ReportGotSomeMsg() : ReportGotSomeMsg(nullptr) {}
  ~ReportGotSomeMsg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportGotSomeMsg(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportGotSomeMsg(const ReportGotSomeMsg& from) : ReportGotSomeMsg(nullptr, from) {}
  inline ReportGotSomeMsg(ReportGotSomeMsg&& from) noexcept
      : ReportGotSomeMsg(nullptr, std::move(from)) {}
  inline ReportGotSomeMsg& operator=(const ReportGotSomeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportGotSomeMsg& operator=(ReportGotSomeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportGotSomeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportGotSomeMsg* internal_default_instance() {
    return reinterpret_cast<const ReportGotSomeMsg*>(
        &_ReportGotSomeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(ReportGotSomeMsg& a, ReportGotSomeMsg& b) { a.Swap(&b); }
  inline void Swap(ReportGotSomeMsg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportGotSomeMsg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportGotSomeMsg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReportGotSomeMsg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportGotSomeMsg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportGotSomeMsg& from) { ReportGotSomeMsg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportGotSomeMsg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.ReportGotSomeMsg"; }

 protected:
  explicit ReportGotSomeMsg(::google::protobuf::Arena* arena);
  ReportGotSomeMsg(::google::protobuf::Arena* arena, const ReportGotSomeMsg& from);
  ReportGotSomeMsg(::google::protobuf::Arena* arena, ReportGotSomeMsg&& from) noexcept
      : ReportGotSomeMsg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOthervalFieldNumber = 3,
    kGotmsgidFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional uint64 otherval = 3;
  bool has_otherval() const;
  void clear_otherval() ;
  ::uint64_t otherval() const;
  void set_otherval(::uint64_t value);

  private:
  ::uint64_t _internal_otherval() const;
  void _internal_set_otherval(::uint64_t value);

  public:
  // optional int32 gotmsgid = 2;
  bool has_gotmsgid() const;
  void clear_gotmsgid() ;
  ::int32_t gotmsgid() const;
  void set_gotmsgid(::int32_t value);

  private:
  ::int32_t _internal_gotmsgid() const;
  void _internal_set_gotmsgid(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportGotSomeMsg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.ReportGotSomeMsg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t otherval_;
    ::int32_t gotmsgid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class ReportBattleShowResult final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.ReportBattleShowResult) */ {
 public:
  inline ReportBattleShowResult() : ReportBattleShowResult(nullptr) {}
  ~ReportBattleShowResult() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportBattleShowResult(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportBattleShowResult(const ReportBattleShowResult& from) : ReportBattleShowResult(nullptr, from) {}
  inline ReportBattleShowResult(ReportBattleShowResult&& from) noexcept
      : ReportBattleShowResult(nullptr, std::move(from)) {}
  inline ReportBattleShowResult& operator=(const ReportBattleShowResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBattleShowResult& operator=(ReportBattleShowResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBattleShowResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBattleShowResult* internal_default_instance() {
    return reinterpret_cast<const ReportBattleShowResult*>(
        &_ReportBattleShowResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ReportBattleShowResult& a, ReportBattleShowResult& b) { a.Swap(&b); }
  inline void Swap(ReportBattleShowResult* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBattleShowResult* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBattleShowResult* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReportBattleShowResult>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportBattleShowResult& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportBattleShowResult& from) { ReportBattleShowResult::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportBattleShowResult* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.ReportBattleShowResult"; }

 protected:
  explicit ReportBattleShowResult(::google::protobuf::Arena* arena);
  ReportBattleShowResult(::google::protobuf::Arena* arena, const ReportBattleShowResult& from);
  ReportBattleShowResult(::google::protobuf::Arena* arena, ReportBattleShowResult&& from) noexcept
      : ReportBattleShowResult(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBattleidFieldNumber = 2,
    kResultFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // optional uint64 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::uint64_t battleid() const;
  void set_battleid(::uint64_t value);

  private:
  ::uint64_t _internal_battleid() const;
  void _internal_set_battleid(::uint64_t value);

  public:
  // optional int32 result = 3;
  bool has_result() const;
  void clear_result() ;
  ::int32_t result() const;
  void set_result(::int32_t value);

  private:
  ::int32_t _internal_result() const;
  void _internal_set_result(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportBattleShowResult];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.ReportBattleShowResult)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t battleid_;
    ::int32_t result_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class ReportBattleFinished final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.ReportBattleFinished) */ {
 public:
  inline ReportBattleFinished() : ReportBattleFinished(nullptr) {}
  ~ReportBattleFinished() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportBattleFinished(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportBattleFinished(const ReportBattleFinished& from) : ReportBattleFinished(nullptr, from) {}
  inline ReportBattleFinished(ReportBattleFinished&& from) noexcept
      : ReportBattleFinished(nullptr, std::move(from)) {}
  inline ReportBattleFinished& operator=(const ReportBattleFinished& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportBattleFinished& operator=(ReportBattleFinished&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportBattleFinished& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportBattleFinished* internal_default_instance() {
    return reinterpret_cast<const ReportBattleFinished*>(
        &_ReportBattleFinished_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ReportBattleFinished& a, ReportBattleFinished& b) { a.Swap(&b); }
  inline void Swap(ReportBattleFinished* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportBattleFinished* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportBattleFinished* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReportBattleFinished>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportBattleFinished& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportBattleFinished& from) { ReportBattleFinished::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportBattleFinished* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.ReportBattleFinished"; }

 protected:
  explicit ReportBattleFinished(::google::protobuf::Arena* arena);
  ReportBattleFinished(::google::protobuf::Arena* arena, const ReportBattleFinished& from);
  ReportBattleFinished(::google::protobuf::Arena* arena, ReportBattleFinished&& from) noexcept
      : ReportBattleFinished(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBattleidFieldNumber = 2,
    kCampidFieldNumber = 3,
    kResFieldNumber = 4,
    kMgsidFieldNumber = 1,
  };
  // optional int64 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::int64_t battleid() const;
  void set_battleid(::int64_t value);

  private:
  ::int64_t _internal_battleid() const;
  void _internal_set_battleid(::int64_t value);

  public:
  // optional int32 campid = 3;
  bool has_campid() const;
  void clear_campid() ;
  ::int32_t campid() const;
  void set_campid(::int32_t value);

  private:
  ::int32_t _internal_campid() const;
  void _internal_set_campid(::int32_t value);

  public:
  // optional int32 res = 4;
  bool has_res() const;
  void clear_res() ;
  ::int32_t res() const;
  void set_res(::int32_t value);

  private:
  ::int32_t _internal_res() const;
  void _internal_set_res(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportBattleFinished];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.ReportBattleFinished)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t battleid_;
    ::int32_t campid_;
    ::int32_t res_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class GameLogSwitch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.GameLogSwitch) */ {
 public:
  inline GameLogSwitch() : GameLogSwitch(nullptr) {}
  ~GameLogSwitch() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GameLogSwitch(
      ::google::protobuf::internal::ConstantInitialized);

  inline GameLogSwitch(const GameLogSwitch& from) : GameLogSwitch(nullptr, from) {}
  inline GameLogSwitch(GameLogSwitch&& from) noexcept
      : GameLogSwitch(nullptr, std::move(from)) {}
  inline GameLogSwitch& operator=(const GameLogSwitch& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameLogSwitch& operator=(GameLogSwitch&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameLogSwitch& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameLogSwitch* internal_default_instance() {
    return reinterpret_cast<const GameLogSwitch*>(
        &_GameLogSwitch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(GameLogSwitch& a, GameLogSwitch& b) { a.Swap(&b); }
  inline void Swap(GameLogSwitch* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameLogSwitch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameLogSwitch* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GameLogSwitch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameLogSwitch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GameLogSwitch& from) { GameLogSwitch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameLogSwitch* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.GameLogSwitch"; }

 protected:
  explicit GameLogSwitch(::google::protobuf::Arena* arena);
  GameLogSwitch(::google::protobuf::Arena* arena, const GameLogSwitch& from);
  GameLogSwitch(::google::protobuf::Arena* arena, GameLogSwitch&& from) noexcept
      : GameLogSwitch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSSGameLogSwitch];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.GameLogSwitch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class FinishBattle_BattleUserData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.FinishBattle.BattleUserData) */ {
 public:
  inline FinishBattle_BattleUserData() : FinishBattle_BattleUserData(nullptr) {}
  ~FinishBattle_BattleUserData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FinishBattle_BattleUserData(
      ::google::protobuf::internal::ConstantInitialized);

  inline FinishBattle_BattleUserData(const FinishBattle_BattleUserData& from) : FinishBattle_BattleUserData(nullptr, from) {}
  inline FinishBattle_BattleUserData(FinishBattle_BattleUserData&& from) noexcept
      : FinishBattle_BattleUserData(nullptr, std::move(from)) {}
  inline FinishBattle_BattleUserData& operator=(const FinishBattle_BattleUserData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishBattle_BattleUserData& operator=(FinishBattle_BattleUserData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinishBattle_BattleUserData& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishBattle_BattleUserData* internal_default_instance() {
    return reinterpret_cast<const FinishBattle_BattleUserData*>(
        &_FinishBattle_BattleUserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 36;
  friend void swap(FinishBattle_BattleUserData& a, FinishBattle_BattleUserData& b) { a.Swap(&b); }
  inline void Swap(FinishBattle_BattleUserData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishBattle_BattleUserData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishBattle_BattleUserData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FinishBattle_BattleUserData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FinishBattle_BattleUserData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FinishBattle_BattleUserData& from) { FinishBattle_BattleUserData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FinishBattle_BattleUserData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.FinishBattle.BattleUserData"; }

 protected:
  explicit FinishBattle_BattleUserData(::google::protobuf::Arena* arena);
  FinishBattle_BattleUserData(::google::protobuf::Arena* arena, const FinishBattle_BattleUserData& from);
  FinishBattle_BattleUserData(::google::protobuf::Arena* arena, FinishBattle_BattleUserData&& from) noexcept
      : FinishBattle_BattleUserData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 1,
    kHeroguidFieldNumber = 2,
    kTimeinsecondFieldNumber = 3,
    kHeroidFieldNumber = 5,
    kRunepageFieldNumber = 6,
    kDeadtimesFieldNumber = 7,
    kHerokillsFieldNumber = 8,
    kDestorybuildingFieldNumber = 9,
    kDiamondusedFieldNumber = 10,
    kIfEndFieldNumber = 4,
    kIfAiRobotFieldNumber = 16,
    kLasthitnumFieldNumber = 12,
    kGoldusedFieldNumber = 11,
    kAsskillnumFieldNumber = 13,
    kHerolvFieldNumber = 14,
    kTotalcpFieldNumber = 15,
  };
  // optional uint64 guid = 1;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional uint64 heroguid = 2;
  bool has_heroguid() const;
  void clear_heroguid() ;
  ::uint64_t heroguid() const;
  void set_heroguid(::uint64_t value);

  private:
  ::uint64_t _internal_heroguid() const;
  void _internal_set_heroguid(::uint64_t value);

  public:
  // optional uint32 timeinsecond = 3;
  bool has_timeinsecond() const;
  void clear_timeinsecond() ;
  ::uint32_t timeinsecond() const;
  void set_timeinsecond(::uint32_t value);

  private:
  ::uint32_t _internal_timeinsecond() const;
  void _internal_set_timeinsecond(::uint32_t value);

  public:
  // optional int32 heroid = 5;
  bool has_heroid() const;
  void clear_heroid() ;
  ::int32_t heroid() const;
  void set_heroid(::int32_t value);

  private:
  ::int32_t _internal_heroid() const;
  void _internal_set_heroid(::int32_t value);

  public:
  // optional int32 runepage = 6;
  bool has_runepage() const;
  void clear_runepage() ;
  ::int32_t runepage() const;
  void set_runepage(::int32_t value);

  private:
  ::int32_t _internal_runepage() const;
  void _internal_set_runepage(::int32_t value);

  public:
  // optional uint32 deadtimes = 7;
  bool has_deadtimes() const;
  void clear_deadtimes() ;
  ::uint32_t deadtimes() const;
  void set_deadtimes(::uint32_t value);

  private:
  ::uint32_t _internal_deadtimes() const;
  void _internal_set_deadtimes(::uint32_t value);

  public:
  // optional uint32 herokills = 8;
  bool has_herokills() const;
  void clear_herokills() ;
  ::uint32_t herokills() const;
  void set_herokills(::uint32_t value);

  private:
  ::uint32_t _internal_herokills() const;
  void _internal_set_herokills(::uint32_t value);

  public:
  // optional int32 destorybuilding = 9;
  bool has_destorybuilding() const;
  void clear_destorybuilding() ;
  ::int32_t destorybuilding() const;
  void set_destorybuilding(::int32_t value);

  private:
  ::int32_t _internal_destorybuilding() const;
  void _internal_set_destorybuilding(::int32_t value);

  public:
  // optional int64 diamondused = 10;
  bool has_diamondused() const;
  void clear_diamondused() ;
  ::int64_t diamondused() const;
  void set_diamondused(::int64_t value);

  private:
  ::int64_t _internal_diamondused() const;
  void _internal_set_diamondused(::int64_t value);

  public:
  // optional bool ifEnd = 4;
  bool has_ifend() const;
  void clear_ifend() ;
  bool ifend() const;
  void set_ifend(bool value);

  private:
  bool _internal_ifend() const;
  void _internal_set_ifend(bool value);

  public:
  // optional bool ifAiRobot = 16;
  bool has_ifairobot() const;
  void clear_ifairobot() ;
  bool ifairobot() const;
  void set_ifairobot(bool value);

  private:
  bool _internal_ifairobot() const;
  void _internal_set_ifairobot(bool value);

  public:
  // optional int32 lasthitnum = 12;
  bool has_lasthitnum() const;
  void clear_lasthitnum() ;
  ::int32_t lasthitnum() const;
  void set_lasthitnum(::int32_t value);

  private:
  ::int32_t _internal_lasthitnum() const;
  void _internal_set_lasthitnum(::int32_t value);

  public:
  // optional int64 goldused = 11;
  bool has_goldused() const;
  void clear_goldused() ;
  ::int64_t goldused() const;
  void set_goldused(::int64_t value);

  private:
  ::int64_t _internal_goldused() const;
  void _internal_set_goldused(::int64_t value);

  public:
  // optional int32 asskillnum = 13;
  bool has_asskillnum() const;
  void clear_asskillnum() ;
  ::int32_t asskillnum() const;
  void set_asskillnum(::int32_t value);

  private:
  ::int32_t _internal_asskillnum() const;
  void _internal_set_asskillnum(::int32_t value);

  public:
  // optional int32 herolv = 14;
  bool has_herolv() const;
  void clear_herolv() ;
  ::int32_t herolv() const;
  void set_herolv(::int32_t value);

  private:
  ::int32_t _internal_herolv() const;
  void _internal_set_herolv(::int32_t value);

  public:
  // optional int32 totalcp = 15;
  bool has_totalcp() const;
  void clear_totalcp() ;
  ::int32_t totalcp() const;
  void set_totalcp(::int32_t value);

  private:
  ::int32_t _internal_totalcp() const;
  void _internal_set_totalcp(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.FinishBattle.BattleUserData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 16, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::uint64_t heroguid_;
    ::uint32_t timeinsecond_;
    ::int32_t heroid_;
    ::int32_t runepage_;
    ::uint32_t deadtimes_;
    ::uint32_t herokills_;
    ::int32_t destorybuilding_;
    ::int64_t diamondused_;
    bool ifend_;
    bool ifairobot_;
    ::int32_t lasthitnum_;
    ::int64_t goldused_;
    ::int32_t asskillnum_;
    ::int32_t herolv_;
    ::int32_t totalcp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class CreateBattleResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.CreateBattleResponse) */ {
 public:
  inline CreateBattleResponse() : CreateBattleResponse(nullptr) {}
  ~CreateBattleResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateBattleResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateBattleResponse(const CreateBattleResponse& from) : CreateBattleResponse(nullptr, from) {}
  inline CreateBattleResponse(CreateBattleResponse&& from) noexcept
      : CreateBattleResponse(nullptr, std::move(from)) {}
  inline CreateBattleResponse& operator=(const CreateBattleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateBattleResponse& operator=(CreateBattleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateBattleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateBattleResponse* internal_default_instance() {
    return reinterpret_cast<const CreateBattleResponse*>(
        &_CreateBattleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 35;
  friend void swap(CreateBattleResponse& a, CreateBattleResponse& b) { a.Swap(&b); }
  inline void Swap(CreateBattleResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateBattleResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateBattleResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<CreateBattleResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateBattleResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateBattleResponse& from) { CreateBattleResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateBattleResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.CreateBattleResponse"; }

 protected:
  explicit CreateBattleResponse(::google::protobuf::Arena* arena);
  CreateBattleResponse(::google::protobuf::Arena* arena, const CreateBattleResponse& from);
  CreateBattleResponse(::google::protobuf::Arena* arena, CreateBattleResponse&& from) noexcept
      : CreateBattleResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBattleidFieldNumber = 2,
    kRstFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // optional int64 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::int64_t battleid() const;
  void set_battleid(::int64_t value);

  private:
  ::int64_t _internal_battleid() const;
  void _internal_set_battleid(::int64_t value);

  public:
  // optional bool rst = 3;
  bool has_rst() const;
  void clear_rst() ;
  bool rst() const;
  void set_rst(bool value);

  private:
  bool _internal_rst() const;
  void _internal_set_rst(bool value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_CreateBattleResponse];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.CreateBattleResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t battleid_;
    bool rst_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class BattleLog final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.BattleLog) */ {
 public:
  inline BattleLog() : BattleLog(nullptr) {}
  ~BattleLog() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BattleLog(
      ::google::protobuf::internal::ConstantInitialized);

  inline BattleLog(const BattleLog& from) : BattleLog(nullptr, from) {}
  inline BattleLog(BattleLog&& from) noexcept
      : BattleLog(nullptr, std::move(from)) {}
  inline BattleLog& operator=(const BattleLog& from) {
    CopyFrom(from);
    return *this;
  }
  inline BattleLog& operator=(BattleLog&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BattleLog& default_instance() {
    return *internal_default_instance();
  }
  static inline const BattleLog* internal_default_instance() {
    return reinterpret_cast<const BattleLog*>(
        &_BattleLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(BattleLog& a, BattleLog& b) { a.Swap(&b); }
  inline void Swap(BattleLog* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BattleLog* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BattleLog* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<BattleLog>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BattleLog& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BattleLog& from) { BattleLog::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BattleLog* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.BattleLog"; }

 protected:
  explicit BattleLog(::google::protobuf::Arena* arena);
  BattleLog(::google::protobuf::Arena* arena, const BattleLog& from);
  BattleLog(::google::protobuf::Arena* arena, BattleLog&& from) noexcept
      : BattleLog(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLogStrFieldNumber = 4,
    kGuidFieldNumber = 2,
    kLogTypeFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // optional string log_str = 4;
  bool has_log_str() const;
  void clear_log_str() ;
  const std::string& log_str() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_log_str(Arg_&& arg, Args_... args);
  std::string* mutable_log_str();
  PROTOBUF_NODISCARD std::string* release_log_str();
  void set_allocated_log_str(std::string* value);

  private:
  const std::string& _internal_log_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_str(
      const std::string& value);
  std::string* _internal_mutable_log_str();

  public:
  // optional int64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::int64_t guid() const;
  void set_guid(::int64_t value);

  private:
  ::int64_t _internal_guid() const;
  void _internal_set_guid(::int64_t value);

  public:
  // optional int32 log_type = 3;
  bool has_log_type() const;
  void clear_log_type() ;
  ::int32_t log_type() const;
  void set_log_type(::int32_t value);

  private:
  ::int32_t _internal_log_type() const;
  void _internal_set_log_type(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_BattleLog];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.BattleLog)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr log_str_;
    ::int64_t guid_;
    ::int32_t log_type_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskUserGoHall final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskUserGoHall) */ {
 public:
  inline AskUserGoHall() : AskUserGoHall(nullptr) {}
  ~AskUserGoHall() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskUserGoHall(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskUserGoHall(const AskUserGoHall& from) : AskUserGoHall(nullptr, from) {}
  inline AskUserGoHall(AskUserGoHall&& from) noexcept
      : AskUserGoHall(nullptr, std::move(from)) {}
  inline AskUserGoHall& operator=(const AskUserGoHall& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskUserGoHall& operator=(AskUserGoHall&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskUserGoHall& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskUserGoHall* internal_default_instance() {
    return reinterpret_cast<const AskUserGoHall*>(
        &_AskUserGoHall_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 33;
  friend void swap(AskUserGoHall& a, AskUserGoHall& b) { a.Swap(&b); }
  inline void Swap(AskUserGoHall* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskUserGoHall* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskUserGoHall* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskUserGoHall>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskUserGoHall& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskUserGoHall& from) { AskUserGoHall::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskUserGoHall* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskUserGoHall"; }

 protected:
  explicit AskUserGoHall(::google::protobuf::Arena* arena);
  AskUserGoHall(::google::protobuf::Arena* arena, const AskUserGoHall& from);
  AskUserGoHall(::google::protobuf::Arena* arena, AskUserGoHall&& from) noexcept
      : AskUserGoHall(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kTypeFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 type = 3;
  bool has_type() const;
  void clear_type() ;
  ::int32_t type() const;
  void set_type(::int32_t value);

  private:
  ::int32_t _internal_type() const;
  void _internal_set_type(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskUserGoHall];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskUserGoHall)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t type_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskUpdateGuideStep final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskUpdateGuideStep) */ {
 public:
  inline AskUpdateGuideStep() : AskUpdateGuideStep(nullptr) {}
  ~AskUpdateGuideStep() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskUpdateGuideStep(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskUpdateGuideStep(const AskUpdateGuideStep& from) : AskUpdateGuideStep(nullptr, from) {}
  inline AskUpdateGuideStep(AskUpdateGuideStep&& from) noexcept
      : AskUpdateGuideStep(nullptr, std::move(from)) {}
  inline AskUpdateGuideStep& operator=(const AskUpdateGuideStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskUpdateGuideStep& operator=(AskUpdateGuideStep&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskUpdateGuideStep& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskUpdateGuideStep* internal_default_instance() {
    return reinterpret_cast<const AskUpdateGuideStep*>(
        &_AskUpdateGuideStep_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 32;
  friend void swap(AskUpdateGuideStep& a, AskUpdateGuideStep& b) { a.Swap(&b); }
  inline void Swap(AskUpdateGuideStep* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskUpdateGuideStep* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskUpdateGuideStep* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskUpdateGuideStep>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskUpdateGuideStep& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskUpdateGuideStep& from) { AskUpdateGuideStep::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskUpdateGuideStep* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskUpdateGuideStep"; }

 protected:
  explicit AskUpdateGuideStep(::google::protobuf::Arena* arena);
  AskUpdateGuideStep(::google::protobuf::Arena* arena, const AskUpdateGuideStep& from);
  AskUpdateGuideStep(::google::protobuf::Arena* arena, AskUpdateGuideStep&& from) noexcept
      : AskUpdateGuideStep(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kStateFieldNumber = 3,
    kStepidFieldNumber = 4,
    kMgsidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int32 state = 3;
  bool has_state() const;
  void clear_state() ;
  ::int32_t state() const;
  void set_state(::int32_t value);

  private:
  ::int32_t _internal_state() const;
  void _internal_set_state(::int32_t value);

  public:
  // optional int32 stepid = 4;
  bool has_stepid() const;
  void clear_stepid() ;
  ::int32_t stepid() const;
  void set_stepid(::int32_t value);

  private:
  ::int32_t _internal_stepid() const;
  void _internal_set_stepid(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskUpdateGuideStep];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskUpdateGuideStep)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int32_t state_;
    ::int32_t stepid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSkillEffectSwitchCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskSkillEffectSwitchCfg) */ {
 public:
  inline AskSkillEffectSwitchCfg() : AskSkillEffectSwitchCfg(nullptr) {}
  ~AskSkillEffectSwitchCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSkillEffectSwitchCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSkillEffectSwitchCfg(const AskSkillEffectSwitchCfg& from) : AskSkillEffectSwitchCfg(nullptr, from) {}
  inline AskSkillEffectSwitchCfg(AskSkillEffectSwitchCfg&& from) noexcept
      : AskSkillEffectSwitchCfg(nullptr, std::move(from)) {}
  inline AskSkillEffectSwitchCfg& operator=(const AskSkillEffectSwitchCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSkillEffectSwitchCfg& operator=(AskSkillEffectSwitchCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSkillEffectSwitchCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSkillEffectSwitchCfg* internal_default_instance() {
    return reinterpret_cast<const AskSkillEffectSwitchCfg*>(
        &_AskSkillEffectSwitchCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(AskSkillEffectSwitchCfg& a, AskSkillEffectSwitchCfg& b) { a.Swap(&b); }
  inline void Swap(AskSkillEffectSwitchCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSkillEffectSwitchCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSkillEffectSwitchCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSkillEffectSwitchCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSkillEffectSwitchCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSkillEffectSwitchCfg& from) { AskSkillEffectSwitchCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSkillEffectSwitchCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskSkillEffectSwitchCfg"; }

 protected:
  explicit AskSkillEffectSwitchCfg(::google::protobuf::Arena* arena);
  AskSkillEffectSwitchCfg(::google::protobuf::Arena* arena, const AskSkillEffectSwitchCfg& from);
  AskSkillEffectSwitchCfg(::google::protobuf::Arena* arena, AskSkillEffectSwitchCfg&& from) noexcept
      : AskSkillEffectSwitchCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectSwitchCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskSkillEffectSwitchCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSkillEffectSummonCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskSkillEffectSummonCfg) */ {
 public:
  inline AskSkillEffectSummonCfg() : AskSkillEffectSummonCfg(nullptr) {}
  ~AskSkillEffectSummonCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSkillEffectSummonCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSkillEffectSummonCfg(const AskSkillEffectSummonCfg& from) : AskSkillEffectSummonCfg(nullptr, from) {}
  inline AskSkillEffectSummonCfg(AskSkillEffectSummonCfg&& from) noexcept
      : AskSkillEffectSummonCfg(nullptr, std::move(from)) {}
  inline AskSkillEffectSummonCfg& operator=(const AskSkillEffectSummonCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSkillEffectSummonCfg& operator=(AskSkillEffectSummonCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSkillEffectSummonCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSkillEffectSummonCfg* internal_default_instance() {
    return reinterpret_cast<const AskSkillEffectSummonCfg*>(
        &_AskSkillEffectSummonCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(AskSkillEffectSummonCfg& a, AskSkillEffectSummonCfg& b) { a.Swap(&b); }
  inline void Swap(AskSkillEffectSummonCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSkillEffectSummonCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSkillEffectSummonCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSkillEffectSummonCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSkillEffectSummonCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSkillEffectSummonCfg& from) { AskSkillEffectSummonCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSkillEffectSummonCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskSkillEffectSummonCfg"; }

 protected:
  explicit AskSkillEffectSummonCfg(::google::protobuf::Arena* arena);
  AskSkillEffectSummonCfg(::google::protobuf::Arena* arena, const AskSkillEffectSummonCfg& from);
  AskSkillEffectSummonCfg(::google::protobuf::Arena* arena, AskSkillEffectSummonCfg&& from) noexcept
      : AskSkillEffectSummonCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectSummonCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskSkillEffectSummonCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSkillEffectRangeCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskSkillEffectRangeCfg) */ {
 public:
  inline AskSkillEffectRangeCfg() : AskSkillEffectRangeCfg(nullptr) {}
  ~AskSkillEffectRangeCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSkillEffectRangeCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSkillEffectRangeCfg(const AskSkillEffectRangeCfg& from) : AskSkillEffectRangeCfg(nullptr, from) {}
  inline AskSkillEffectRangeCfg(AskSkillEffectRangeCfg&& from) noexcept
      : AskSkillEffectRangeCfg(nullptr, std::move(from)) {}
  inline AskSkillEffectRangeCfg& operator=(const AskSkillEffectRangeCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSkillEffectRangeCfg& operator=(AskSkillEffectRangeCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSkillEffectRangeCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSkillEffectRangeCfg* internal_default_instance() {
    return reinterpret_cast<const AskSkillEffectRangeCfg*>(
        &_AskSkillEffectRangeCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(AskSkillEffectRangeCfg& a, AskSkillEffectRangeCfg& b) { a.Swap(&b); }
  inline void Swap(AskSkillEffectRangeCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSkillEffectRangeCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSkillEffectRangeCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSkillEffectRangeCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSkillEffectRangeCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSkillEffectRangeCfg& from) { AskSkillEffectRangeCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSkillEffectRangeCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskSkillEffectRangeCfg"; }

 protected:
  explicit AskSkillEffectRangeCfg(::google::protobuf::Arena* arena);
  AskSkillEffectRangeCfg(::google::protobuf::Arena* arena, const AskSkillEffectRangeCfg& from);
  AskSkillEffectRangeCfg(::google::protobuf::Arena* arena, AskSkillEffectRangeCfg&& from) noexcept
      : AskSkillEffectRangeCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectRangeCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskSkillEffectRangeCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSkillEffectMoveCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskSkillEffectMoveCfg) */ {
 public:
  inline AskSkillEffectMoveCfg() : AskSkillEffectMoveCfg(nullptr) {}
  ~AskSkillEffectMoveCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSkillEffectMoveCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSkillEffectMoveCfg(const AskSkillEffectMoveCfg& from) : AskSkillEffectMoveCfg(nullptr, from) {}
  inline AskSkillEffectMoveCfg(AskSkillEffectMoveCfg&& from) noexcept
      : AskSkillEffectMoveCfg(nullptr, std::move(from)) {}
  inline AskSkillEffectMoveCfg& operator=(const AskSkillEffectMoveCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSkillEffectMoveCfg& operator=(AskSkillEffectMoveCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSkillEffectMoveCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSkillEffectMoveCfg* internal_default_instance() {
    return reinterpret_cast<const AskSkillEffectMoveCfg*>(
        &_AskSkillEffectMoveCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(AskSkillEffectMoveCfg& a, AskSkillEffectMoveCfg& b) { a.Swap(&b); }
  inline void Swap(AskSkillEffectMoveCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSkillEffectMoveCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSkillEffectMoveCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSkillEffectMoveCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSkillEffectMoveCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSkillEffectMoveCfg& from) { AskSkillEffectMoveCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSkillEffectMoveCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskSkillEffectMoveCfg"; }

 protected:
  explicit AskSkillEffectMoveCfg(::google::protobuf::Arena* arena);
  AskSkillEffectMoveCfg(::google::protobuf::Arena* arena, const AskSkillEffectMoveCfg& from);
  AskSkillEffectMoveCfg(::google::protobuf::Arena* arena, AskSkillEffectMoveCfg&& from) noexcept
      : AskSkillEffectMoveCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectMoveCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskSkillEffectMoveCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSkillEffectLeadingCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskSkillEffectLeadingCfg) */ {
 public:
  inline AskSkillEffectLeadingCfg() : AskSkillEffectLeadingCfg(nullptr) {}
  ~AskSkillEffectLeadingCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSkillEffectLeadingCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSkillEffectLeadingCfg(const AskSkillEffectLeadingCfg& from) : AskSkillEffectLeadingCfg(nullptr, from) {}
  inline AskSkillEffectLeadingCfg(AskSkillEffectLeadingCfg&& from) noexcept
      : AskSkillEffectLeadingCfg(nullptr, std::move(from)) {}
  inline AskSkillEffectLeadingCfg& operator=(const AskSkillEffectLeadingCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSkillEffectLeadingCfg& operator=(AskSkillEffectLeadingCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSkillEffectLeadingCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSkillEffectLeadingCfg* internal_default_instance() {
    return reinterpret_cast<const AskSkillEffectLeadingCfg*>(
        &_AskSkillEffectLeadingCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(AskSkillEffectLeadingCfg& a, AskSkillEffectLeadingCfg& b) { a.Swap(&b); }
  inline void Swap(AskSkillEffectLeadingCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSkillEffectLeadingCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSkillEffectLeadingCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSkillEffectLeadingCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSkillEffectLeadingCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSkillEffectLeadingCfg& from) { AskSkillEffectLeadingCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSkillEffectLeadingCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskSkillEffectLeadingCfg"; }

 protected:
  explicit AskSkillEffectLeadingCfg(::google::protobuf::Arena* arena);
  AskSkillEffectLeadingCfg(::google::protobuf::Arena* arena, const AskSkillEffectLeadingCfg& from);
  AskSkillEffectLeadingCfg(::google::protobuf::Arena* arena, AskSkillEffectLeadingCfg&& from) noexcept
      : AskSkillEffectLeadingCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectLeadingCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskSkillEffectLeadingCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSkillEffectBufCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskSkillEffectBufCfg) */ {
 public:
  inline AskSkillEffectBufCfg() : AskSkillEffectBufCfg(nullptr) {}
  ~AskSkillEffectBufCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSkillEffectBufCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSkillEffectBufCfg(const AskSkillEffectBufCfg& from) : AskSkillEffectBufCfg(nullptr, from) {}
  inline AskSkillEffectBufCfg(AskSkillEffectBufCfg&& from) noexcept
      : AskSkillEffectBufCfg(nullptr, std::move(from)) {}
  inline AskSkillEffectBufCfg& operator=(const AskSkillEffectBufCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSkillEffectBufCfg& operator=(AskSkillEffectBufCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSkillEffectBufCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSkillEffectBufCfg* internal_default_instance() {
    return reinterpret_cast<const AskSkillEffectBufCfg*>(
        &_AskSkillEffectBufCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(AskSkillEffectBufCfg& a, AskSkillEffectBufCfg& b) { a.Swap(&b); }
  inline void Swap(AskSkillEffectBufCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSkillEffectBufCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSkillEffectBufCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSkillEffectBufCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSkillEffectBufCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSkillEffectBufCfg& from) { AskSkillEffectBufCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSkillEffectBufCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskSkillEffectBufCfg"; }

 protected:
  explicit AskSkillEffectBufCfg(::google::protobuf::Arena* arena);
  AskSkillEffectBufCfg(::google::protobuf::Arena* arena, const AskSkillEffectBufCfg& from);
  AskSkillEffectBufCfg(::google::protobuf::Arena* arena, AskSkillEffectBufCfg&& from) noexcept
      : AskSkillEffectBufCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectBufCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskSkillEffectBufCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskSkillEffectAccountCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskSkillEffectAccountCfg) */ {
 public:
  inline AskSkillEffectAccountCfg() : AskSkillEffectAccountCfg(nullptr) {}
  ~AskSkillEffectAccountCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskSkillEffectAccountCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskSkillEffectAccountCfg(const AskSkillEffectAccountCfg& from) : AskSkillEffectAccountCfg(nullptr, from) {}
  inline AskSkillEffectAccountCfg(AskSkillEffectAccountCfg&& from) noexcept
      : AskSkillEffectAccountCfg(nullptr, std::move(from)) {}
  inline AskSkillEffectAccountCfg& operator=(const AskSkillEffectAccountCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskSkillEffectAccountCfg& operator=(AskSkillEffectAccountCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskSkillEffectAccountCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskSkillEffectAccountCfg* internal_default_instance() {
    return reinterpret_cast<const AskSkillEffectAccountCfg*>(
        &_AskSkillEffectAccountCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(AskSkillEffectAccountCfg& a, AskSkillEffectAccountCfg& b) { a.Swap(&b); }
  inline void Swap(AskSkillEffectAccountCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskSkillEffectAccountCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskSkillEffectAccountCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskSkillEffectAccountCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskSkillEffectAccountCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskSkillEffectAccountCfg& from) { AskSkillEffectAccountCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskSkillEffectAccountCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskSkillEffectAccountCfg"; }

 protected:
  explicit AskSkillEffectAccountCfg(::google::protobuf::Arena* arena);
  AskSkillEffectAccountCfg(::google::protobuf::Arena* arena, const AskSkillEffectAccountCfg& from);
  AskSkillEffectAccountCfg(::google::protobuf::Arena* arena, AskSkillEffectAccountCfg&& from) noexcept
      : AskSkillEffectAccountCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectAccountCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskSkillEffectAccountCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskShopfgList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskShopfgList) */ {
 public:
  inline AskShopfgList() : AskShopfgList(nullptr) {}
  ~AskShopfgList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskShopfgList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskShopfgList(const AskShopfgList& from) : AskShopfgList(nullptr, from) {}
  inline AskShopfgList(AskShopfgList&& from) noexcept
      : AskShopfgList(nullptr, std::move(from)) {}
  inline AskShopfgList& operator=(const AskShopfgList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskShopfgList& operator=(AskShopfgList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskShopfgList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskShopfgList* internal_default_instance() {
    return reinterpret_cast<const AskShopfgList*>(
        &_AskShopfgList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(AskShopfgList& a, AskShopfgList& b) { a.Swap(&b); }
  inline void Swap(AskShopfgList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskShopfgList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskShopfgList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskShopfgList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskShopfgList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskShopfgList& from) { AskShopfgList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskShopfgList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskShopfgList"; }

 protected:
  explicit AskShopfgList(::google::protobuf::Arena* arena);
  AskShopfgList(::google::protobuf::Arena* arena, const AskShopfgList& from);
  AskShopfgList(::google::protobuf::Arena* arena, AskShopfgList&& from) noexcept
      : AskShopfgList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskShopfgList];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskShopfgList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskRegiste final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskRegiste) */ {
 public:
  inline AskRegiste() : AskRegiste(nullptr) {}
  ~AskRegiste() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskRegiste(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskRegiste(const AskRegiste& from) : AskRegiste(nullptr, from) {}
  inline AskRegiste(AskRegiste&& from) noexcept
      : AskRegiste(nullptr, std::move(from)) {}
  inline AskRegiste& operator=(const AskRegiste& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskRegiste& operator=(AskRegiste&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskRegiste& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskRegiste* internal_default_instance() {
    return reinterpret_cast<const AskRegiste*>(
        &_AskRegiste_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(AskRegiste& a, AskRegiste& b) { a.Swap(&b); }
  inline void Swap(AskRegiste* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskRegiste* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskRegiste* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskRegiste>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskRegiste& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskRegiste& from) { AskRegiste::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskRegiste* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskRegiste"; }

 protected:
  explicit AskRegiste(::google::protobuf::Arena* arena);
  AskRegiste(::google::protobuf::Arena* arena, const AskRegiste& from);
  AskRegiste(::google::protobuf::Arena* arena, AskRegiste&& from) noexcept
      : AskRegiste(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIpFieldNumber = 3,
    kUserpwdFieldNumber = 5,
    kSsidFieldNumber = 2,
    kPortFieldNumber = 4,
    kMgsidFieldNumber = 1,
  };
  // optional string ip = 3;
  bool has_ip() const;
  void clear_ip() ;
  const std::string& ip() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ip(Arg_&& arg, Args_... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* value);

  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(
      const std::string& value);
  std::string* _internal_mutable_ip();

  public:
  // optional string userpwd = 5;
  bool has_userpwd() const;
  void clear_userpwd() ;
  const std::string& userpwd() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_userpwd(Arg_&& arg, Args_... args);
  std::string* mutable_userpwd();
  PROTOBUF_NODISCARD std::string* release_userpwd();
  void set_allocated_userpwd(std::string* value);

  private:
  const std::string& _internal_userpwd() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userpwd(
      const std::string& value);
  std::string* _internal_mutable_userpwd();

  public:
  // optional int32 ssid = 2;
  bool has_ssid() const;
  void clear_ssid() ;
  ::int32_t ssid() const;
  void set_ssid(::int32_t value);

  private:
  ::int32_t _internal_ssid() const;
  void _internal_set_ssid(::int32_t value);

  public:
  // optional int32 port = 4;
  bool has_port() const;
  void clear_port() ;
  ::int32_t port() const;
  void set_port(::int32_t value);

  private:
  ::int32_t _internal_port() const;
  void _internal_set_port(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskRegiste];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskRegiste)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 1,
      35, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ip_;
    ::google::protobuf::internal::ArenaStringPtr userpwd_;
    ::int32_t ssid_;
    ::int32_t port_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskPublicLuaStr final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskPublicLuaStr) */ {
 public:
  inline AskPublicLuaStr() : AskPublicLuaStr(nullptr) {}
  ~AskPublicLuaStr() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskPublicLuaStr(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskPublicLuaStr(const AskPublicLuaStr& from) : AskPublicLuaStr(nullptr, from) {}
  inline AskPublicLuaStr(AskPublicLuaStr&& from) noexcept
      : AskPublicLuaStr(nullptr, std::move(from)) {}
  inline AskPublicLuaStr& operator=(const AskPublicLuaStr& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskPublicLuaStr& operator=(AskPublicLuaStr&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskPublicLuaStr& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskPublicLuaStr* internal_default_instance() {
    return reinterpret_cast<const AskPublicLuaStr*>(
        &_AskPublicLuaStr_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(AskPublicLuaStr& a, AskPublicLuaStr& b) { a.Swap(&b); }
  inline void Swap(AskPublicLuaStr* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskPublicLuaStr* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskPublicLuaStr* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskPublicLuaStr>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskPublicLuaStr& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskPublicLuaStr& from) { AskPublicLuaStr::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskPublicLuaStr* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskPublicLuaStr"; }

 protected:
  explicit AskPublicLuaStr(::google::protobuf::Arena* arena);
  AskPublicLuaStr(::google::protobuf::Arena* arena, const AskPublicLuaStr& from);
  AskPublicLuaStr(::google::protobuf::Arena* arena, AskPublicLuaStr&& from) noexcept
      : AskPublicLuaStr(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPublicLuaStr];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskPublicLuaStr)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskPing final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskPing) */ {
 public:
  inline AskPing() : AskPing(nullptr) {}
  ~AskPing() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskPing(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskPing(const AskPing& from) : AskPing(nullptr, from) {}
  inline AskPing(AskPing&& from) noexcept
      : AskPing(nullptr, std::move(from)) {}
  inline AskPing& operator=(const AskPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskPing& operator=(AskPing&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskPing& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskPing* internal_default_instance() {
    return reinterpret_cast<const AskPing*>(
        &_AskPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(AskPing& a, AskPing& b) { a.Swap(&b); }
  inline void Swap(AskPing* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskPing* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskPing* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskPing>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskPing& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskPing& from) { AskPing::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskPing* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskPing"; }

 protected:
  explicit AskPing(::google::protobuf::Arena* arena);
  AskPing(::google::protobuf::Arena* arena, const AskPing& from);
  AskPing(::google::protobuf::Arena* arena, AskPing&& from) noexcept
      : AskPing(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTimeFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional int64 time = 2;
  bool has_time() const;
  void clear_time() ;
  ::int64_t time() const;
  void set_time(::int64_t value);

  private:
  ::int64_t _internal_time() const;
  void _internal_set_time(::int64_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPing];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskPing)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t time_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskPassitiveSkillCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskPassitiveSkillCfg) */ {
 public:
  inline AskPassitiveSkillCfg() : AskPassitiveSkillCfg(nullptr) {}
  ~AskPassitiveSkillCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskPassitiveSkillCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskPassitiveSkillCfg(const AskPassitiveSkillCfg& from) : AskPassitiveSkillCfg(nullptr, from) {}
  inline AskPassitiveSkillCfg(AskPassitiveSkillCfg&& from) noexcept
      : AskPassitiveSkillCfg(nullptr, std::move(from)) {}
  inline AskPassitiveSkillCfg& operator=(const AskPassitiveSkillCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskPassitiveSkillCfg& operator=(AskPassitiveSkillCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskPassitiveSkillCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskPassitiveSkillCfg* internal_default_instance() {
    return reinterpret_cast<const AskPassitiveSkillCfg*>(
        &_AskPassitiveSkillCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(AskPassitiveSkillCfg& a, AskPassitiveSkillCfg& b) { a.Swap(&b); }
  inline void Swap(AskPassitiveSkillCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskPassitiveSkillCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskPassitiveSkillCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskPassitiveSkillCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskPassitiveSkillCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskPassitiveSkillCfg& from) { AskPassitiveSkillCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskPassitiveSkillCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskPassitiveSkillCfg"; }

 protected:
  explicit AskPassitiveSkillCfg(::google::protobuf::Arena* arena);
  AskPassitiveSkillCfg(::google::protobuf::Arena* arena, const AskPassitiveSkillCfg& from);
  AskPassitiveSkillCfg(::google::protobuf::Arena* arena, AskPassitiveSkillCfg&& from) noexcept
      : AskPassitiveSkillCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveSkillCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskPassitiveSkillCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskPassitiveEffectReliveCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskPassitiveEffectReliveCfg) */ {
 public:
  inline AskPassitiveEffectReliveCfg() : AskPassitiveEffectReliveCfg(nullptr) {}
  ~AskPassitiveEffectReliveCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskPassitiveEffectReliveCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskPassitiveEffectReliveCfg(const AskPassitiveEffectReliveCfg& from) : AskPassitiveEffectReliveCfg(nullptr, from) {}
  inline AskPassitiveEffectReliveCfg(AskPassitiveEffectReliveCfg&& from) noexcept
      : AskPassitiveEffectReliveCfg(nullptr, std::move(from)) {}
  inline AskPassitiveEffectReliveCfg& operator=(const AskPassitiveEffectReliveCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskPassitiveEffectReliveCfg& operator=(AskPassitiveEffectReliveCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskPassitiveEffectReliveCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskPassitiveEffectReliveCfg* internal_default_instance() {
    return reinterpret_cast<const AskPassitiveEffectReliveCfg*>(
        &_AskPassitiveEffectReliveCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(AskPassitiveEffectReliveCfg& a, AskPassitiveEffectReliveCfg& b) { a.Swap(&b); }
  inline void Swap(AskPassitiveEffectReliveCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskPassitiveEffectReliveCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskPassitiveEffectReliveCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskPassitiveEffectReliveCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskPassitiveEffectReliveCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskPassitiveEffectReliveCfg& from) { AskPassitiveEffectReliveCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskPassitiveEffectReliveCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskPassitiveEffectReliveCfg"; }

 protected:
  explicit AskPassitiveEffectReliveCfg(::google::protobuf::Arena* arena);
  AskPassitiveEffectReliveCfg(::google::protobuf::Arena* arena, const AskPassitiveEffectReliveCfg& from);
  AskPassitiveEffectReliveCfg(::google::protobuf::Arena* arena, AskPassitiveEffectReliveCfg&& from) noexcept
      : AskPassitiveEffectReliveCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveEffectReliveCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskPassitiveEffectReliveCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskPassitiveEffectReboundCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskPassitiveEffectReboundCfg) */ {
 public:
  inline AskPassitiveEffectReboundCfg() : AskPassitiveEffectReboundCfg(nullptr) {}
  ~AskPassitiveEffectReboundCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskPassitiveEffectReboundCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskPassitiveEffectReboundCfg(const AskPassitiveEffectReboundCfg& from) : AskPassitiveEffectReboundCfg(nullptr, from) {}
  inline AskPassitiveEffectReboundCfg(AskPassitiveEffectReboundCfg&& from) noexcept
      : AskPassitiveEffectReboundCfg(nullptr, std::move(from)) {}
  inline AskPassitiveEffectReboundCfg& operator=(const AskPassitiveEffectReboundCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskPassitiveEffectReboundCfg& operator=(AskPassitiveEffectReboundCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskPassitiveEffectReboundCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskPassitiveEffectReboundCfg* internal_default_instance() {
    return reinterpret_cast<const AskPassitiveEffectReboundCfg*>(
        &_AskPassitiveEffectReboundCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(AskPassitiveEffectReboundCfg& a, AskPassitiveEffectReboundCfg& b) { a.Swap(&b); }
  inline void Swap(AskPassitiveEffectReboundCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskPassitiveEffectReboundCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskPassitiveEffectReboundCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskPassitiveEffectReboundCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskPassitiveEffectReboundCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskPassitiveEffectReboundCfg& from) { AskPassitiveEffectReboundCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskPassitiveEffectReboundCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskPassitiveEffectReboundCfg"; }

 protected:
  explicit AskPassitiveEffectReboundCfg(::google::protobuf::Arena* arena);
  AskPassitiveEffectReboundCfg(::google::protobuf::Arena* arena, const AskPassitiveEffectReboundCfg& from);
  AskPassitiveEffectReboundCfg(::google::protobuf::Arena* arena, AskPassitiveEffectReboundCfg&& from) noexcept
      : AskPassitiveEffectReboundCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveEffectReboundCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskPassitiveEffectReboundCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskPassitiveEffectBloodSeekCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskPassitiveEffectBloodSeekCfg) */ {
 public:
  inline AskPassitiveEffectBloodSeekCfg() : AskPassitiveEffectBloodSeekCfg(nullptr) {}
  ~AskPassitiveEffectBloodSeekCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskPassitiveEffectBloodSeekCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskPassitiveEffectBloodSeekCfg(const AskPassitiveEffectBloodSeekCfg& from) : AskPassitiveEffectBloodSeekCfg(nullptr, from) {}
  inline AskPassitiveEffectBloodSeekCfg(AskPassitiveEffectBloodSeekCfg&& from) noexcept
      : AskPassitiveEffectBloodSeekCfg(nullptr, std::move(from)) {}
  inline AskPassitiveEffectBloodSeekCfg& operator=(const AskPassitiveEffectBloodSeekCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskPassitiveEffectBloodSeekCfg& operator=(AskPassitiveEffectBloodSeekCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskPassitiveEffectBloodSeekCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskPassitiveEffectBloodSeekCfg* internal_default_instance() {
    return reinterpret_cast<const AskPassitiveEffectBloodSeekCfg*>(
        &_AskPassitiveEffectBloodSeekCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(AskPassitiveEffectBloodSeekCfg& a, AskPassitiveEffectBloodSeekCfg& b) { a.Swap(&b); }
  inline void Swap(AskPassitiveEffectBloodSeekCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskPassitiveEffectBloodSeekCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskPassitiveEffectBloodSeekCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskPassitiveEffectBloodSeekCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskPassitiveEffectBloodSeekCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskPassitiveEffectBloodSeekCfg& from) { AskPassitiveEffectBloodSeekCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskPassitiveEffectBloodSeekCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskPassitiveEffectBloodSeekCfg"; }

 protected:
  explicit AskPassitiveEffectBloodSeekCfg(::google::protobuf::Arena* arena);
  AskPassitiveEffectBloodSeekCfg(::google::protobuf::Arena* arena, const AskPassitiveEffectBloodSeekCfg& from);
  AskPassitiveEffectBloodSeekCfg(::google::protobuf::Arena* arena, AskPassitiveEffectBloodSeekCfg&& from) noexcept
      : AskPassitiveEffectBloodSeekCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveEffectBloodSeekCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskPassitiveEffectBloodSeekCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskNewSkillCfg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskNewSkillCfg) */ {
 public:
  inline AskNewSkillCfg() : AskNewSkillCfg(nullptr) {}
  ~AskNewSkillCfg() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskNewSkillCfg(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskNewSkillCfg(const AskNewSkillCfg& from) : AskNewSkillCfg(nullptr, from) {}
  inline AskNewSkillCfg(AskNewSkillCfg&& from) noexcept
      : AskNewSkillCfg(nullptr, std::move(from)) {}
  inline AskNewSkillCfg& operator=(const AskNewSkillCfg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskNewSkillCfg& operator=(AskNewSkillCfg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskNewSkillCfg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskNewSkillCfg* internal_default_instance() {
    return reinterpret_cast<const AskNewSkillCfg*>(
        &_AskNewSkillCfg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(AskNewSkillCfg& a, AskNewSkillCfg& b) { a.Swap(&b); }
  inline void Swap(AskNewSkillCfg* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskNewSkillCfg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskNewSkillCfg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskNewSkillCfg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskNewSkillCfg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskNewSkillCfg& from) { AskNewSkillCfg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskNewSkillCfg* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskNewSkillCfg"; }

 protected:
  explicit AskNewSkillCfg(::google::protobuf::Arena* arena);
  AskNewSkillCfg(::google::protobuf::Arena* arena, const AskNewSkillCfg& from);
  AskNewSkillCfg(::google::protobuf::Arena* arena, AskNewSkillCfg&& from) noexcept
      : AskNewSkillCfg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskNewSkillCfg];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskNewSkillCfg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskMapCfgList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskMapCfgList) */ {
 public:
  inline AskMapCfgList() : AskMapCfgList(nullptr) {}
  ~AskMapCfgList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskMapCfgList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskMapCfgList(const AskMapCfgList& from) : AskMapCfgList(nullptr, from) {}
  inline AskMapCfgList(AskMapCfgList&& from) noexcept
      : AskMapCfgList(nullptr, std::move(from)) {}
  inline AskMapCfgList& operator=(const AskMapCfgList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskMapCfgList& operator=(AskMapCfgList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskMapCfgList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskMapCfgList* internal_default_instance() {
    return reinterpret_cast<const AskMapCfgList*>(
        &_AskMapCfgList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(AskMapCfgList& a, AskMapCfgList& b) { a.Swap(&b); }
  inline void Swap(AskMapCfgList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskMapCfgList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskMapCfgList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskMapCfgList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskMapCfgList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskMapCfgList& from) { AskMapCfgList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskMapCfgList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskMapCfgList"; }

 protected:
  explicit AskMapCfgList(::google::protobuf::Arena* arena);
  AskMapCfgList(::google::protobuf::Arena* arena, const AskMapCfgList& from);
  AskMapCfgList(::google::protobuf::Arena* arena, AskMapCfgList&& from) noexcept
      : AskMapCfgList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMapidFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional int32 mapid = 2;
  bool has_mapid() const;
  void clear_mapid() ;
  ::int32_t mapid() const;
  void set_mapid(::int32_t value);

  private:
  ::int32_t _internal_mapid() const;
  void _internal_set_mapid(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskMapCfgList];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskMapCfgList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t mapid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskHeroCfgList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskHeroCfgList) */ {
 public:
  inline AskHeroCfgList() : AskHeroCfgList(nullptr) {}
  ~AskHeroCfgList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskHeroCfgList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskHeroCfgList(const AskHeroCfgList& from) : AskHeroCfgList(nullptr, from) {}
  inline AskHeroCfgList(AskHeroCfgList&& from) noexcept
      : AskHeroCfgList(nullptr, std::move(from)) {}
  inline AskHeroCfgList& operator=(const AskHeroCfgList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskHeroCfgList& operator=(AskHeroCfgList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskHeroCfgList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskHeroCfgList* internal_default_instance() {
    return reinterpret_cast<const AskHeroCfgList*>(
        &_AskHeroCfgList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(AskHeroCfgList& a, AskHeroCfgList& b) { a.Swap(&b); }
  inline void Swap(AskHeroCfgList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskHeroCfgList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskHeroCfgList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskHeroCfgList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskHeroCfgList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskHeroCfgList& from) { AskHeroCfgList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskHeroCfgList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskHeroCfgList"; }

 protected:
  explicit AskHeroCfgList(::google::protobuf::Arena* arena);
  AskHeroCfgList(::google::protobuf::Arena* arena, const AskHeroCfgList& from);
  AskHeroCfgList(::google::protobuf::Arena* arena, AskHeroCfgList&& from) noexcept
      : AskHeroCfgList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskHeroCfgList];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskHeroCfgList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskGoodsfgList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskGoodsfgList) */ {
 public:
  inline AskGoodsfgList() : AskGoodsfgList(nullptr) {}
  ~AskGoodsfgList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskGoodsfgList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskGoodsfgList(const AskGoodsfgList& from) : AskGoodsfgList(nullptr, from) {}
  inline AskGoodsfgList(AskGoodsfgList&& from) noexcept
      : AskGoodsfgList(nullptr, std::move(from)) {}
  inline AskGoodsfgList& operator=(const AskGoodsfgList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskGoodsfgList& operator=(AskGoodsfgList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskGoodsfgList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskGoodsfgList* internal_default_instance() {
    return reinterpret_cast<const AskGoodsfgList*>(
        &_AskGoodsfgList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(AskGoodsfgList& a, AskGoodsfgList& b) { a.Swap(&b); }
  inline void Swap(AskGoodsfgList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskGoodsfgList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskGoodsfgList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskGoodsfgList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskGoodsfgList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskGoodsfgList& from) { AskGoodsfgList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskGoodsfgList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskGoodsfgList"; }

 protected:
  explicit AskGoodsfgList(::google::protobuf::Arena* arena);
  AskGoodsfgList(::google::protobuf::Arena* arena, const AskGoodsfgList& from);
  AskGoodsfgList(::google::protobuf::Arena* arena, AskGoodsfgList&& from) noexcept
      : AskGoodsfgList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskGoodsfgList];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskGoodsfgList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskChangeFirstWinTime final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskChangeFirstWinTime) */ {
 public:
  inline AskChangeFirstWinTime() : AskChangeFirstWinTime(nullptr) {}
  ~AskChangeFirstWinTime() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskChangeFirstWinTime(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskChangeFirstWinTime(const AskChangeFirstWinTime& from) : AskChangeFirstWinTime(nullptr, from) {}
  inline AskChangeFirstWinTime(AskChangeFirstWinTime&& from) noexcept
      : AskChangeFirstWinTime(nullptr, std::move(from)) {}
  inline AskChangeFirstWinTime& operator=(const AskChangeFirstWinTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskChangeFirstWinTime& operator=(AskChangeFirstWinTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskChangeFirstWinTime& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskChangeFirstWinTime* internal_default_instance() {
    return reinterpret_cast<const AskChangeFirstWinTime*>(
        &_AskChangeFirstWinTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(AskChangeFirstWinTime& a, AskChangeFirstWinTime& b) { a.Swap(&b); }
  inline void Swap(AskChangeFirstWinTime* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskChangeFirstWinTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskChangeFirstWinTime* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskChangeFirstWinTime>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskChangeFirstWinTime& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskChangeFirstWinTime& from) { AskChangeFirstWinTime::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskChangeFirstWinTime* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskChangeFirstWinTime"; }

 protected:
  explicit AskChangeFirstWinTime(::google::protobuf::Arena* arena);
  AskChangeFirstWinTime(::google::protobuf::Arena* arena, const AskChangeFirstWinTime& from);
  AskChangeFirstWinTime(::google::protobuf::Arena* arena, AskChangeFirstWinTime&& from) noexcept
      : AskChangeFirstWinTime(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kCurtimeFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int64 curtime = 3;
  bool has_curtime() const;
  void clear_curtime() ;
  ::int64_t curtime() const;
  void set_curtime(::int64_t value);

  private:
  ::int64_t _internal_curtime() const;
  void _internal_set_curtime(::int64_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskChangeFirstWinTime];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskChangeFirstWinTime)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int64_t curtime_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskAllCfgList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskAllCfgList) */ {
 public:
  inline AskAllCfgList() : AskAllCfgList(nullptr) {}
  ~AskAllCfgList() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskAllCfgList(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskAllCfgList(const AskAllCfgList& from) : AskAllCfgList(nullptr, from) {}
  inline AskAllCfgList(AskAllCfgList&& from) noexcept
      : AskAllCfgList(nullptr, std::move(from)) {}
  inline AskAllCfgList& operator=(const AskAllCfgList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskAllCfgList& operator=(AskAllCfgList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskAllCfgList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskAllCfgList* internal_default_instance() {
    return reinterpret_cast<const AskAllCfgList*>(
        &_AskAllCfgList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(AskAllCfgList& a, AskAllCfgList& b) { a.Swap(&b); }
  inline void Swap(AskAllCfgList* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskAllCfgList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskAllCfgList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskAllCfgList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskAllCfgList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskAllCfgList& from) { AskAllCfgList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskAllCfgList* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskAllCfgList"; }

 protected:
  explicit AskAllCfgList(::google::protobuf::Arena* arena);
  AskAllCfgList(::google::protobuf::Arena* arena, const AskAllCfgList& from);
  AskAllCfgList(::google::protobuf::Arena* arena, AskAllCfgList&& from) noexcept
      : AskAllCfgList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskAllCfgList];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskAllCfgList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AddGold final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AddGold) */ {
 public:
  inline AddGold() : AddGold(nullptr) {}
  ~AddGold() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AddGold(
      ::google::protobuf::internal::ConstantInitialized);

  inline AddGold(const AddGold& from) : AddGold(nullptr, from) {}
  inline AddGold(AddGold&& from) noexcept
      : AddGold(nullptr, std::move(from)) {}
  inline AddGold& operator=(const AddGold& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddGold& operator=(AddGold&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddGold& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddGold* internal_default_instance() {
    return reinterpret_cast<const AddGold*>(
        &_AddGold_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(AddGold& a, AddGold& b) { a.Swap(&b); }
  inline void Swap(AddGold* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddGold* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddGold* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AddGold>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AddGold& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AddGold& from) { AddGold::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AddGold* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AddGold"; }

 protected:
  explicit AddGold(::google::protobuf::Arena* arena);
  AddGold(::google::protobuf::Arena* arena, const AddGold& from);
  AddGold(::google::protobuf::Arena* arena, AddGold&& from) noexcept
      : AddGold(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kGuidFieldNumber = 2,
    kGoldFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional int64 gold = 3;
  bool has_gold() const;
  void clear_gold() ;
  ::int64_t gold() const;
  void set_gold(::int64_t value);

  private:
  ::int64_t _internal_gold() const;
  void _internal_set_gold(::int64_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskAddGold];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AddGold)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t guid_;
    ::int64_t gold_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class ReportUserOffline final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.ReportUserOffline) */ {
 public:
  inline ReportUserOffline() : ReportUserOffline(nullptr) {}
  ~ReportUserOffline() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReportUserOffline(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReportUserOffline(const ReportUserOffline& from) : ReportUserOffline(nullptr, from) {}
  inline ReportUserOffline(ReportUserOffline&& from) noexcept
      : ReportUserOffline(nullptr, std::move(from)) {}
  inline ReportUserOffline& operator=(const ReportUserOffline& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportUserOffline& operator=(ReportUserOffline&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportUserOffline& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportUserOffline* internal_default_instance() {
    return reinterpret_cast<const ReportUserOffline*>(
        &_ReportUserOffline_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(ReportUserOffline& a, ReportUserOffline& b) { a.Swap(&b); }
  inline void Swap(ReportUserOffline* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportUserOffline* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportUserOffline* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReportUserOffline>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReportUserOffline& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReportUserOffline& from) { ReportUserOffline::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReportUserOffline* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.ReportUserOffline"; }

 protected:
  explicit ReportUserOffline(::google::protobuf::Arena* arena);
  ReportUserOffline(::google::protobuf::Arena* arena, const ReportUserOffline& from);
  ReportUserOffline(::google::protobuf::Arena* arena, ReportUserOffline&& from) noexcept
      : ReportUserOffline(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUsernetinfoFieldNumber = 3,
    kGuidFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // optional .SSToCS.UserNetInfo usernetinfo = 3;
  bool has_usernetinfo() const;
  void clear_usernetinfo() ;
  const ::SSToCS::UserNetInfo& usernetinfo() const;
  PROTOBUF_NODISCARD ::SSToCS::UserNetInfo* release_usernetinfo();
  ::SSToCS::UserNetInfo* mutable_usernetinfo();
  void set_allocated_usernetinfo(::SSToCS::UserNetInfo* value);
  void unsafe_arena_set_allocated_usernetinfo(::SSToCS::UserNetInfo* value);
  ::SSToCS::UserNetInfo* unsafe_arena_release_usernetinfo();

  private:
  const ::SSToCS::UserNetInfo& _internal_usernetinfo() const;
  ::SSToCS::UserNetInfo* _internal_mutable_usernetinfo();

  public:
  // optional uint64 guid = 2;
  bool has_guid() const;
  void clear_guid() ;
  ::uint64_t guid() const;
  void set_guid(::uint64_t value);

  private:
  ::uint64_t _internal_guid() const;
  void _internal_set_guid(::uint64_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportUserOffline];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.ReportUserOffline)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::SSToCS::UserNetInfo* usernetinfo_;
    ::uint64_t guid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class FinishBattle final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.FinishBattle) */ {
 public:
  inline FinishBattle() : FinishBattle(nullptr) {}
  ~FinishBattle() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR FinishBattle(
      ::google::protobuf::internal::ConstantInitialized);

  inline FinishBattle(const FinishBattle& from) : FinishBattle(nullptr, from) {}
  inline FinishBattle(FinishBattle&& from) noexcept
      : FinishBattle(nullptr, std::move(from)) {}
  inline FinishBattle& operator=(const FinishBattle& from) {
    CopyFrom(from);
    return *this;
  }
  inline FinishBattle& operator=(FinishBattle&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FinishBattle& default_instance() {
    return *internal_default_instance();
  }
  static inline const FinishBattle* internal_default_instance() {
    return reinterpret_cast<const FinishBattle*>(
        &_FinishBattle_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 37;
  friend void swap(FinishBattle& a, FinishBattle& b) { a.Swap(&b); }
  inline void Swap(FinishBattle* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FinishBattle* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FinishBattle* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<FinishBattle>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FinishBattle& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const FinishBattle& from) { FinishBattle::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FinishBattle* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.FinishBattle"; }

 protected:
  explicit FinishBattle(::google::protobuf::Arena* arena);
  FinishBattle(::google::protobuf::Arena* arena, const FinishBattle& from);
  FinishBattle(::google::protobuf::Arena* arena, FinishBattle&& from) noexcept
      : FinishBattle(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using BattleUserData = FinishBattle_BattleUserData;

  // accessors -------------------------------------------------------
  enum : int {
    kBattelUserDataListFieldNumber = 4,
    kBattleidFieldNumber = 2,
    kWinGrpIDFieldNumber = 3,
    kMgsidFieldNumber = 1,
  };
  // repeated .SSToCS.FinishBattle.BattleUserData battelUserDataList = 4;
  int batteluserdatalist_size() const;
  private:
  int _internal_batteluserdatalist_size() const;

  public:
  void clear_batteluserdatalist() ;
  ::SSToCS::FinishBattle_BattleUserData* mutable_batteluserdatalist(int index);
  ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>* mutable_batteluserdatalist();

  private:
  const ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>& _internal_batteluserdatalist() const;
  ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>* _internal_mutable_batteluserdatalist();
  public:
  const ::SSToCS::FinishBattle_BattleUserData& batteluserdatalist(int index) const;
  ::SSToCS::FinishBattle_BattleUserData* add_batteluserdatalist();
  const ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>& batteluserdatalist() const;
  // optional int64 battleid = 2;
  bool has_battleid() const;
  void clear_battleid() ;
  ::int64_t battleid() const;
  void set_battleid(::int64_t value);

  private:
  ::int64_t _internal_battleid() const;
  void _internal_set_battleid(::int64_t value);

  public:
  // optional int32 winGrpID = 3;
  bool has_wingrpid() const;
  void clear_wingrpid() ;
  ::int32_t wingrpid() const;
  void set_wingrpid(::int32_t value);

  private:
  ::int32_t _internal_wingrpid() const;
  void _internal_set_wingrpid(::int32_t value);

  public:
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_FinishBattle];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.FinishBattle)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SSToCS::FinishBattle_BattleUserData > batteluserdatalist_;
    ::int64_t battleid_;
    ::int32_t wingrpid_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};
// -------------------------------------------------------------------

class AskUpdateData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:SSToCS.AskUpdateData) */ {
 public:
  inline AskUpdateData() : AskUpdateData(nullptr) {}
  ~AskUpdateData() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AskUpdateData(
      ::google::protobuf::internal::ConstantInitialized);

  inline AskUpdateData(const AskUpdateData& from) : AskUpdateData(nullptr, from) {}
  inline AskUpdateData(AskUpdateData&& from) noexcept
      : AskUpdateData(nullptr, std::move(from)) {}
  inline AskUpdateData& operator=(const AskUpdateData& from) {
    CopyFrom(from);
    return *this;
  }
  inline AskUpdateData& operator=(AskUpdateData&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AskUpdateData& default_instance() {
    return *internal_default_instance();
  }
  static inline const AskUpdateData* internal_default_instance() {
    return reinterpret_cast<const AskUpdateData*>(
        &_AskUpdateData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(AskUpdateData& a, AskUpdateData& b) { a.Swap(&b); }
  inline void Swap(AskUpdateData* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AskUpdateData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AskUpdateData* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AskUpdateData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AskUpdateData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AskUpdateData& from) { AskUpdateData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AskUpdateData* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "SSToCS.AskUpdateData"; }

 protected:
  explicit AskUpdateData(::google::protobuf::Arena* arena);
  AskUpdateData(::google::protobuf::Arena* arena, const AskUpdateData& from);
  AskUpdateData(::google::protobuf::Arena* arena, AskUpdateData&& from) noexcept
      : AskUpdateData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUserDataFieldNumber = 2,
    kMgsidFieldNumber = 1,
  };
  // repeated .SSToCS.userData user_data = 2;
  int user_data_size() const;
  private:
  int _internal_user_data_size() const;

  public:
  void clear_user_data() ;
  ::SSToCS::userData* mutable_user_data(int index);
  ::google::protobuf::RepeatedPtrField<::SSToCS::userData>* mutable_user_data();

  private:
  const ::google::protobuf::RepeatedPtrField<::SSToCS::userData>& _internal_user_data() const;
  ::google::protobuf::RepeatedPtrField<::SSToCS::userData>* _internal_mutable_user_data();
  public:
  const ::SSToCS::userData& user_data(int index) const;
  ::SSToCS::userData* add_user_data();
  const ::google::protobuf::RepeatedPtrField<::SSToCS::userData>& user_data() const;
  // optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskUpdateData];
  bool has_mgsid() const;
  void clear_mgsid() ;
  ::SSToCS::MsgID mgsid() const;
  void set_mgsid(::SSToCS::MsgID value);

  private:
  ::SSToCS::MsgID _internal_mgsid() const;
  void _internal_set_mgsid(::SSToCS::MsgID value);

  public:
  // @@protoc_insertion_point(class_scope:SSToCS.AskUpdateData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::SSToCS::userData > user_data_;
    int mgsid_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_SSToCS_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GameLogSwitch

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSSGameLogSwitch];
inline bool GameLogSwitch::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void GameLogSwitch::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8232;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID GameLogSwitch::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.GameLogSwitch.mgsid)
  return _internal_mgsid();
}
inline void GameLogSwitch::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.GameLogSwitch.mgsid)
}
inline ::SSToCS::MsgID GameLogSwitch::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void GameLogSwitch::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// UpGuideBattleStep

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_UpdateGuideBattleStep];
inline bool UpGuideBattleStep::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UpGuideBattleStep::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8231;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SSToCS::MsgID UpGuideBattleStep::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.UpGuideBattleStep.mgsid)
  return _internal_mgsid();
}
inline void UpGuideBattleStep::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:SSToCS.UpGuideBattleStep.mgsid)
}
inline ::SSToCS::MsgID UpGuideBattleStep::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void UpGuideBattleStep::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 guid = 2;
inline bool UpGuideBattleStep::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UpGuideBattleStep::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t UpGuideBattleStep::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.UpGuideBattleStep.guid)
  return _internal_guid();
}
inline void UpGuideBattleStep::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.UpGuideBattleStep.guid)
}
inline ::int64_t UpGuideBattleStep::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void UpGuideBattleStep::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 taskid = 3;
inline bool UpGuideBattleStep::has_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UpGuideBattleStep::clear_taskid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t UpGuideBattleStep::taskid() const {
  // @@protoc_insertion_point(field_get:SSToCS.UpGuideBattleStep.taskid)
  return _internal_taskid();
}
inline void UpGuideBattleStep::set_taskid(::int32_t value) {
  _internal_set_taskid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.UpGuideBattleStep.taskid)
}
inline ::int32_t UpGuideBattleStep::_internal_taskid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.taskid_;
}
inline void UpGuideBattleStep::_internal_set_taskid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.taskid_ = value;
}

// optional int32 num = 4;
inline bool UpGuideBattleStep::has_num() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UpGuideBattleStep::clear_num() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t UpGuideBattleStep::num() const {
  // @@protoc_insertion_point(field_get:SSToCS.UpGuideBattleStep.num)
  return _internal_num();
}
inline void UpGuideBattleStep::set_num(::int32_t value) {
  _internal_set_num(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.UpGuideBattleStep.num)
}
inline ::int32_t UpGuideBattleStep::_internal_num() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_;
}
inline void UpGuideBattleStep::_internal_set_num(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_ = value;
}

// -------------------------------------------------------------------

// BattleLog

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_BattleLog];
inline bool BattleLog::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void BattleLog::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8230;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SSToCS::MsgID BattleLog::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.BattleLog.mgsid)
  return _internal_mgsid();
}
inline void BattleLog::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:SSToCS.BattleLog.mgsid)
}
inline ::SSToCS::MsgID BattleLog::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void BattleLog::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 guid = 2;
inline bool BattleLog::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void BattleLog::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t BattleLog::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.BattleLog.guid)
  return _internal_guid();
}
inline void BattleLog::set_guid(::int64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.BattleLog.guid)
}
inline ::int64_t BattleLog::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void BattleLog::_internal_set_guid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 log_type = 3;
inline bool BattleLog::has_log_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void BattleLog::clear_log_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t BattleLog::log_type() const {
  // @@protoc_insertion_point(field_get:SSToCS.BattleLog.log_type)
  return _internal_log_type();
}
inline void BattleLog::set_log_type(::int32_t value) {
  _internal_set_log_type(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.BattleLog.log_type)
}
inline ::int32_t BattleLog::_internal_log_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_type_;
}
inline void BattleLog::_internal_set_log_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_type_ = value;
}

// optional string log_str = 4;
inline bool BattleLog::has_log_str() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void BattleLog::clear_log_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.log_str_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BattleLog::log_str() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SSToCS.BattleLog.log_str)
  return _internal_log_str();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void BattleLog::set_log_str(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.log_str_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SSToCS.BattleLog.log_str)
}
inline std::string* BattleLog::mutable_log_str() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_log_str();
  // @@protoc_insertion_point(field_mutable:SSToCS.BattleLog.log_str)
  return _s;
}
inline const std::string& BattleLog::_internal_log_str() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.log_str_.Get();
}
inline void BattleLog::_internal_set_log_str(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.log_str_.Set(value, GetArena());
}
inline std::string* BattleLog::_internal_mutable_log_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.log_str_.Mutable( GetArena());
}
inline std::string* BattleLog::release_log_str() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SSToCS.BattleLog.log_str)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.log_str_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.log_str_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void BattleLog::set_allocated_log_str(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.log_str_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.log_str_.IsDefault()) {
          _impl_.log_str_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SSToCS.BattleLog.log_str)
}

// -------------------------------------------------------------------

// AskPing

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPing];
inline bool AskPing::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskPing::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8193;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SSToCS::MsgID AskPing::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskPing.mgsid)
  return _internal_mgsid();
}
inline void AskPing::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.AskPing.mgsid)
}
inline ::SSToCS::MsgID AskPing::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskPing::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 time = 2;
inline bool AskPing::has_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskPing::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t AskPing::time() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskPing.time)
  return _internal_time();
}
inline void AskPing::set_time(::int64_t value) {
  _internal_set_time(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskPing.time)
}
inline ::int64_t AskPing::_internal_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.time_;
}
inline void AskPing::_internal_set_time(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// ReportGotSomeMsg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportGotSomeMsg];
inline bool ReportGotSomeMsg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReportGotSomeMsg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8228;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID ReportGotSomeMsg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportGotSomeMsg.mgsid)
  return _internal_mgsid();
}
inline void ReportGotSomeMsg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportGotSomeMsg.mgsid)
}
inline ::SSToCS::MsgID ReportGotSomeMsg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void ReportGotSomeMsg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int32 gotmsgid = 2;
inline bool ReportGotSomeMsg::has_gotmsgid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReportGotSomeMsg::clear_gotmsgid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gotmsgid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ReportGotSomeMsg::gotmsgid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportGotSomeMsg.gotmsgid)
  return _internal_gotmsgid();
}
inline void ReportGotSomeMsg::set_gotmsgid(::int32_t value) {
  _internal_set_gotmsgid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportGotSomeMsg.gotmsgid)
}
inline ::int32_t ReportGotSomeMsg::_internal_gotmsgid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gotmsgid_;
}
inline void ReportGotSomeMsg::_internal_set_gotmsgid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gotmsgid_ = value;
}

// optional uint64 otherval = 3;
inline bool ReportGotSomeMsg::has_otherval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReportGotSomeMsg::clear_otherval() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.otherval_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t ReportGotSomeMsg::otherval() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportGotSomeMsg.otherval)
  return _internal_otherval();
}
inline void ReportGotSomeMsg::set_otherval(::uint64_t value) {
  _internal_set_otherval(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportGotSomeMsg.otherval)
}
inline ::uint64_t ReportGotSomeMsg::_internal_otherval() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.otherval_;
}
inline void ReportGotSomeMsg::_internal_set_otherval(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.otherval_ = value;
}

// -------------------------------------------------------------------

// ReportBattleShowResult

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportBattleShowResult];
inline bool ReportBattleShowResult::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReportBattleShowResult::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8227;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID ReportBattleShowResult::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportBattleShowResult.mgsid)
  return _internal_mgsid();
}
inline void ReportBattleShowResult::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportBattleShowResult.mgsid)
}
inline ::SSToCS::MsgID ReportBattleShowResult::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void ReportBattleShowResult::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 battleid = 2;
inline bool ReportBattleShowResult::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReportBattleShowResult::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t ReportBattleShowResult::battleid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportBattleShowResult.battleid)
  return _internal_battleid();
}
inline void ReportBattleShowResult::set_battleid(::uint64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportBattleShowResult.battleid)
}
inline ::uint64_t ReportBattleShowResult::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void ReportBattleShowResult::_internal_set_battleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional int32 result = 3;
inline bool ReportBattleShowResult::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReportBattleShowResult::clear_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ReportBattleShowResult::result() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportBattleShowResult.result)
  return _internal_result();
}
inline void ReportBattleShowResult::set_result(::int32_t value) {
  _internal_set_result(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportBattleShowResult.result)
}
inline ::int32_t ReportBattleShowResult::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_;
}
inline void ReportBattleShowResult::_internal_set_result(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_ = value;
}

// -------------------------------------------------------------------

// AskChangeFirstWinTime

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskChangeFirstWinTime];
inline bool AskChangeFirstWinTime::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskChangeFirstWinTime::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8210;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID AskChangeFirstWinTime::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskChangeFirstWinTime.mgsid)
  return _internal_mgsid();
}
inline void AskChangeFirstWinTime::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.AskChangeFirstWinTime.mgsid)
}
inline ::SSToCS::MsgID AskChangeFirstWinTime::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskChangeFirstWinTime::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 guid = 2;
inline bool AskChangeFirstWinTime::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskChangeFirstWinTime::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AskChangeFirstWinTime::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskChangeFirstWinTime.guid)
  return _internal_guid();
}
inline void AskChangeFirstWinTime::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskChangeFirstWinTime.guid)
}
inline ::uint64_t AskChangeFirstWinTime::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void AskChangeFirstWinTime::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int64 curtime = 3;
inline bool AskChangeFirstWinTime::has_curtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskChangeFirstWinTime::clear_curtime() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curtime_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t AskChangeFirstWinTime::curtime() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskChangeFirstWinTime.curtime)
  return _internal_curtime();
}
inline void AskChangeFirstWinTime::set_curtime(::int64_t value) {
  _internal_set_curtime(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.AskChangeFirstWinTime.curtime)
}
inline ::int64_t AskChangeFirstWinTime::_internal_curtime() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.curtime_;
}
inline void AskChangeFirstWinTime::_internal_set_curtime(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.curtime_ = value;
}

// -------------------------------------------------------------------

// AddGold

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskAddGold];
inline bool AddGold::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AddGold::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8207;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID AddGold::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AddGold.mgsid)
  return _internal_mgsid();
}
inline void AddGold::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.AddGold.mgsid)
}
inline ::SSToCS::MsgID AddGold::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AddGold::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 guid = 2;
inline bool AddGold::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AddGold::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AddGold::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AddGold.guid)
  return _internal_guid();
}
inline void AddGold::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AddGold.guid)
}
inline ::uint64_t AddGold::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void AddGold::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int64 gold = 3;
inline bool AddGold::has_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AddGold::clear_gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t AddGold::gold() const {
  // @@protoc_insertion_point(field_get:SSToCS.AddGold.gold)
  return _internal_gold();
}
inline void AddGold::set_gold(::int64_t value) {
  _internal_set_gold(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.AddGold.gold)
}
inline ::int64_t AddGold::_internal_gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gold_;
}
inline void AddGold::_internal_set_gold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = value;
}

// -------------------------------------------------------------------

// AskRegiste

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskRegiste];
inline bool AskRegiste::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void AskRegiste::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8194;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::SSToCS::MsgID AskRegiste::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskRegiste.mgsid)
  return _internal_mgsid();
}
inline void AskRegiste::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:SSToCS.AskRegiste.mgsid)
}
inline ::SSToCS::MsgID AskRegiste::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskRegiste::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int32 ssid = 2;
inline bool AskRegiste::has_ssid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskRegiste::clear_ssid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AskRegiste::ssid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskRegiste.ssid)
  return _internal_ssid();
}
inline void AskRegiste::set_ssid(::int32_t value) {
  _internal_set_ssid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.AskRegiste.ssid)
}
inline ::int32_t AskRegiste::_internal_ssid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ssid_;
}
inline void AskRegiste::_internal_set_ssid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ssid_ = value;
}

// optional string ip = 3;
inline bool AskRegiste::has_ip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskRegiste::clear_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ip_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AskRegiste::ip() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SSToCS.AskRegiste.ip)
  return _internal_ip();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskRegiste::set_ip(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SSToCS.AskRegiste.ip)
}
inline std::string* AskRegiste::mutable_ip() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:SSToCS.AskRegiste.ip)
  return _s;
}
inline const std::string& AskRegiste::_internal_ip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ip_.Get();
}
inline void AskRegiste::_internal_set_ip(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.ip_.Set(value, GetArena());
}
inline std::string* AskRegiste::_internal_mutable_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.ip_.Mutable( GetArena());
}
inline std::string* AskRegiste::release_ip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SSToCS.AskRegiste.ip)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.ip_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.ip_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskRegiste::set_allocated_ip(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.ip_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ip_.IsDefault()) {
          _impl_.ip_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SSToCS.AskRegiste.ip)
}

// optional int32 port = 4;
inline bool AskRegiste::has_port() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AskRegiste::clear_port() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t AskRegiste::port() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskRegiste.port)
  return _internal_port();
}
inline void AskRegiste::set_port(::int32_t value) {
  _internal_set_port(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:SSToCS.AskRegiste.port)
}
inline ::int32_t AskRegiste::_internal_port() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.port_;
}
inline void AskRegiste::_internal_set_port(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.port_ = value;
}

// optional string userpwd = 5;
inline bool AskRegiste::has_userpwd() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskRegiste::clear_userpwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.userpwd_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AskRegiste::userpwd() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SSToCS.AskRegiste.userpwd)
  return _internal_userpwd();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AskRegiste::set_userpwd(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.userpwd_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:SSToCS.AskRegiste.userpwd)
}
inline std::string* AskRegiste::mutable_userpwd() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_userpwd();
  // @@protoc_insertion_point(field_mutable:SSToCS.AskRegiste.userpwd)
  return _s;
}
inline const std::string& AskRegiste::_internal_userpwd() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.userpwd_.Get();
}
inline void AskRegiste::_internal_set_userpwd(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.userpwd_.Set(value, GetArena());
}
inline std::string* AskRegiste::_internal_mutable_userpwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.userpwd_.Mutable( GetArena());
}
inline std::string* AskRegiste::release_userpwd() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SSToCS.AskRegiste.userpwd)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.userpwd_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.userpwd_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void AskRegiste::set_allocated_userpwd(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.userpwd_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.userpwd_.IsDefault()) {
          _impl_.userpwd_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SSToCS.AskRegiste.userpwd)
}

// -------------------------------------------------------------------

// ReportBattleFinished

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportBattleFinished];
inline bool ReportBattleFinished::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void ReportBattleFinished::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8195;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SSToCS::MsgID ReportBattleFinished::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportBattleFinished.mgsid)
  return _internal_mgsid();
}
inline void ReportBattleFinished::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportBattleFinished.mgsid)
}
inline ::SSToCS::MsgID ReportBattleFinished::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void ReportBattleFinished::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 battleid = 2;
inline bool ReportBattleFinished::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ReportBattleFinished::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t ReportBattleFinished::battleid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportBattleFinished.battleid)
  return _internal_battleid();
}
inline void ReportBattleFinished::set_battleid(::int64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportBattleFinished.battleid)
}
inline ::int64_t ReportBattleFinished::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void ReportBattleFinished::_internal_set_battleid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional int32 campid = 3;
inline bool ReportBattleFinished::has_campid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReportBattleFinished::clear_campid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.campid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t ReportBattleFinished::campid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportBattleFinished.campid)
  return _internal_campid();
}
inline void ReportBattleFinished::set_campid(::int32_t value) {
  _internal_set_campid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportBattleFinished.campid)
}
inline ::int32_t ReportBattleFinished::_internal_campid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.campid_;
}
inline void ReportBattleFinished::_internal_set_campid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.campid_ = value;
}

// optional int32 res = 4;
inline bool ReportBattleFinished::has_res() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReportBattleFinished::clear_res() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.res_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ReportBattleFinished::res() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportBattleFinished.res)
  return _internal_res();
}
inline void ReportBattleFinished::set_res(::int32_t value) {
  _internal_set_res(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportBattleFinished.res)
}
inline ::int32_t ReportBattleFinished::_internal_res() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.res_;
}
inline void ReportBattleFinished::_internal_set_res(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.res_ = value;
}

// -------------------------------------------------------------------

// userData

// optional uint64 guid = 1;
inline bool userData::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void userData::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t userData::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.guid)
  return _internal_guid();
}
inline void userData::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.guid)
}
inline ::uint64_t userData::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void userData::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint32 deadtimes = 2;
inline bool userData::has_deadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void userData::clear_deadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint32_t userData::deadtimes() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.deadtimes)
  return _internal_deadtimes();
}
inline void userData::set_deadtimes(::uint32_t value) {
  _internal_set_deadtimes(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.deadtimes)
}
inline ::uint32_t userData::_internal_deadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadtimes_;
}
inline void userData::_internal_set_deadtimes(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = value;
}

// optional uint32 herokills = 3;
inline bool userData::has_herokills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void userData::clear_herokills() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herokills_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t userData::herokills() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.herokills)
  return _internal_herokills();
}
inline void userData::set_herokills(::uint32_t value) {
  _internal_set_herokills(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.herokills)
}
inline ::uint32_t userData::_internal_herokills() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herokills_;
}
inline void userData::_internal_set_herokills(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herokills_ = value;
}

// optional uint32 gameinn = 4;
inline bool userData::has_gameinn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void userData::clear_gameinn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gameinn_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t userData::gameinn() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.gameinn)
  return _internal_gameinn();
}
inline void userData::set_gameinn(::uint32_t value) {
  _internal_set_gameinn(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.gameinn)
}
inline ::uint32_t userData::_internal_gameinn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gameinn_;
}
inline void userData::_internal_set_gameinn(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gameinn_ = value;
}

// optional uint32 wininn = 5;
inline bool userData::has_wininn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void userData::clear_wininn() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wininn_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::uint32_t userData::wininn() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.wininn)
  return _internal_wininn();
}
inline void userData::set_wininn(::uint32_t value) {
  _internal_set_wininn(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.wininn)
}
inline ::uint32_t userData::_internal_wininn() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wininn_;
}
inline void userData::_internal_set_wininn(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wininn_ = value;
}

// optional uint32 exp = 6;
inline bool userData::has_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void userData::clear_exp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t userData::exp() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.exp)
  return _internal_exp();
}
inline void userData::set_exp(::uint32_t value) {
  _internal_set_exp(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.exp)
}
inline ::uint32_t userData::_internal_exp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exp_;
}
inline void userData::_internal_set_exp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exp_ = value;
}

// optional int64 gold = 7;
inline bool userData::has_gold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void userData::clear_gold() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::int64_t userData::gold() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.gold)
  return _internal_gold();
}
inline void userData::set_gold(::int64_t value) {
  _internal_set_gold(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.gold)
}
inline ::int64_t userData::_internal_gold() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gold_;
}
inline void userData::_internal_set_gold(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gold_ = value;
}

// optional int32 destorybuilding = 8;
inline bool userData::has_destorybuilding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void userData::clear_destorybuilding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destorybuilding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t userData::destorybuilding() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.destorybuilding)
  return _internal_destorybuilding();
}
inline void userData::set_destorybuilding(::int32_t value) {
  _internal_set_destorybuilding(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.destorybuilding)
}
inline ::int32_t userData::_internal_destorybuilding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destorybuilding_;
}
inline void userData::_internal_set_destorybuilding(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destorybuilding_ = value;
}

// optional int32 heroid = 9;
inline bool userData::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void userData::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int32_t userData::heroid() const {
  // @@protoc_insertion_point(field_get:SSToCS.userData.heroid)
  return _internal_heroid();
}
inline void userData::set_heroid(::int32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:SSToCS.userData.heroid)
}
inline ::int32_t userData::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void userData::_internal_set_heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// -------------------------------------------------------------------

// AskUpdateData

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskUpdateData];
inline bool AskUpdateData::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskUpdateData::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8206;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskUpdateData::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUpdateData.mgsid)
  return _internal_mgsid();
}
inline void AskUpdateData::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUpdateData.mgsid)
}
inline ::SSToCS::MsgID AskUpdateData::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskUpdateData::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// repeated .SSToCS.userData user_data = 2;
inline int AskUpdateData::_internal_user_data_size() const {
  return _internal_user_data().size();
}
inline int AskUpdateData::user_data_size() const {
  return _internal_user_data_size();
}
inline void AskUpdateData::clear_user_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.user_data_.Clear();
}
inline ::SSToCS::userData* AskUpdateData::mutable_user_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SSToCS.AskUpdateData.user_data)
  return _internal_mutable_user_data()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SSToCS::userData>* AskUpdateData::mutable_user_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SSToCS.AskUpdateData.user_data)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_user_data();
}
inline const ::SSToCS::userData& AskUpdateData::user_data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SSToCS.AskUpdateData.user_data)
  return _internal_user_data().Get(index);
}
inline ::SSToCS::userData* AskUpdateData::add_user_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SSToCS::userData* _add = _internal_mutable_user_data()->Add();
  // @@protoc_insertion_point(field_add:SSToCS.AskUpdateData.user_data)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SSToCS::userData>& AskUpdateData::user_data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SSToCS.AskUpdateData.user_data)
  return _internal_user_data();
}
inline const ::google::protobuf::RepeatedPtrField<::SSToCS::userData>&
AskUpdateData::_internal_user_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.user_data_;
}
inline ::google::protobuf::RepeatedPtrField<::SSToCS::userData>*
AskUpdateData::_internal_mutable_user_data() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.user_data_;
}

// -------------------------------------------------------------------

// UserNetInfo

// optional int32 gsid = 1;
inline bool UserNetInfo::has_gsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UserNetInfo::clear_gsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UserNetInfo::gsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.UserNetInfo.gsid)
  return _internal_gsid();
}
inline void UserNetInfo::set_gsid(::int32_t value) {
  _internal_set_gsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.UserNetInfo.gsid)
}
inline ::int32_t UserNetInfo::_internal_gsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gsid_;
}
inline void UserNetInfo::_internal_set_gsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gsid_ = value;
}

// optional int32 gcnsid = 2;
inline bool UserNetInfo::has_gcnsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UserNetInfo::clear_gcnsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnsid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t UserNetInfo::gcnsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.UserNetInfo.gcnsid)
  return _internal_gcnsid();
}
inline void UserNetInfo::set_gcnsid(::int32_t value) {
  _internal_set_gcnsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.UserNetInfo.gcnsid)
}
inline ::int32_t UserNetInfo::_internal_gcnsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.gcnsid_;
}
inline void UserNetInfo::_internal_set_gcnsid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.gcnsid_ = value;
}

// -------------------------------------------------------------------

// ReportUserOffline

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_ReportUserOffline];
inline bool ReportUserOffline::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ReportUserOffline::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8196;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID ReportUserOffline::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportUserOffline.mgsid)
  return _internal_mgsid();
}
inline void ReportUserOffline::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportUserOffline.mgsid)
}
inline ::SSToCS::MsgID ReportUserOffline::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void ReportUserOffline::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 guid = 2;
inline bool ReportUserOffline::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void ReportUserOffline::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t ReportUserOffline::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.ReportUserOffline.guid)
  return _internal_guid();
}
inline void ReportUserOffline::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.ReportUserOffline.guid)
}
inline ::uint64_t ReportUserOffline::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void ReportUserOffline::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional .SSToCS.UserNetInfo usernetinfo = 3;
inline bool ReportUserOffline::has_usernetinfo() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.usernetinfo_ != nullptr);
  return value;
}
inline void ReportUserOffline::clear_usernetinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.usernetinfo_ != nullptr) _impl_.usernetinfo_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::SSToCS::UserNetInfo& ReportUserOffline::_internal_usernetinfo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::SSToCS::UserNetInfo* p = _impl_.usernetinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::SSToCS::UserNetInfo&>(::SSToCS::_UserNetInfo_default_instance_);
}
inline const ::SSToCS::UserNetInfo& ReportUserOffline::usernetinfo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SSToCS.ReportUserOffline.usernetinfo)
  return _internal_usernetinfo();
}
inline void ReportUserOffline::unsafe_arena_set_allocated_usernetinfo(::SSToCS::UserNetInfo* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.usernetinfo_);
  }
  _impl_.usernetinfo_ = reinterpret_cast<::SSToCS::UserNetInfo*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SSToCS.ReportUserOffline.usernetinfo)
}
inline ::SSToCS::UserNetInfo* ReportUserOffline::release_usernetinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SSToCS::UserNetInfo* released = _impl_.usernetinfo_;
  _impl_.usernetinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::SSToCS::UserNetInfo* ReportUserOffline::unsafe_arena_release_usernetinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:SSToCS.ReportUserOffline.usernetinfo)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::SSToCS::UserNetInfo* temp = _impl_.usernetinfo_;
  _impl_.usernetinfo_ = nullptr;
  return temp;
}
inline ::SSToCS::UserNetInfo* ReportUserOffline::_internal_mutable_usernetinfo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.usernetinfo_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::SSToCS::UserNetInfo>(GetArena());
    _impl_.usernetinfo_ = reinterpret_cast<::SSToCS::UserNetInfo*>(p);
  }
  return _impl_.usernetinfo_;
}
inline ::SSToCS::UserNetInfo* ReportUserOffline::mutable_usernetinfo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::SSToCS::UserNetInfo* _msg = _internal_mutable_usernetinfo();
  // @@protoc_insertion_point(field_mutable:SSToCS.ReportUserOffline.usernetinfo)
  return _msg;
}
inline void ReportUserOffline::set_allocated_usernetinfo(::SSToCS::UserNetInfo* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.usernetinfo_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.usernetinfo_ = reinterpret_cast<::SSToCS::UserNetInfo*>(value);
  // @@protoc_insertion_point(field_set_allocated:SSToCS.ReportUserOffline.usernetinfo)
}

// -------------------------------------------------------------------

// AskAllCfgList

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskAllCfgList];
inline bool AskAllCfgList::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskAllCfgList::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8199;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskAllCfgList::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskAllCfgList.mgsid)
  return _internal_mgsid();
}
inline void AskAllCfgList::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskAllCfgList.mgsid)
}
inline ::SSToCS::MsgID AskAllCfgList::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskAllCfgList::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskHeroCfgList

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskHeroCfgList];
inline bool AskHeroCfgList::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskHeroCfgList::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8200;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskHeroCfgList::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskHeroCfgList.mgsid)
  return _internal_mgsid();
}
inline void AskHeroCfgList::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskHeroCfgList.mgsid)
}
inline ::SSToCS::MsgID AskHeroCfgList::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskHeroCfgList::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskGoodsfgList

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskGoodsfgList];
inline bool AskGoodsfgList::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskGoodsfgList::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8202;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskGoodsfgList::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskGoodsfgList.mgsid)
  return _internal_mgsid();
}
inline void AskGoodsfgList::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskGoodsfgList.mgsid)
}
inline ::SSToCS::MsgID AskGoodsfgList::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskGoodsfgList::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskShopfgList

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskShopfgList];
inline bool AskShopfgList::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskShopfgList::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8201;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskShopfgList::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskShopfgList.mgsid)
  return _internal_mgsid();
}
inline void AskShopfgList::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskShopfgList.mgsid)
}
inline ::SSToCS::MsgID AskShopfgList::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskShopfgList::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskPublicLuaStr

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPublicLuaStr];
inline bool AskPublicLuaStr::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskPublicLuaStr::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8203;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskPublicLuaStr::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskPublicLuaStr.mgsid)
  return _internal_mgsid();
}
inline void AskPublicLuaStr::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskPublicLuaStr.mgsid)
}
inline ::SSToCS::MsgID AskPublicLuaStr::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskPublicLuaStr::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskMapCfgList

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskMapCfgList];
inline bool AskMapCfgList::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskMapCfgList::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8204;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SSToCS::MsgID AskMapCfgList::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskMapCfgList.mgsid)
  return _internal_mgsid();
}
inline void AskMapCfgList::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.AskMapCfgList.mgsid)
}
inline ::SSToCS::MsgID AskMapCfgList::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskMapCfgList::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int32 mapid = 2;
inline bool AskMapCfgList::has_mapid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskMapCfgList::clear_mapid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t AskMapCfgList::mapid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskMapCfgList.mapid)
  return _internal_mapid();
}
inline void AskMapCfgList::set_mapid(::int32_t value) {
  _internal_set_mapid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskMapCfgList.mapid)
}
inline ::int32_t AskMapCfgList::_internal_mapid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.mapid_;
}
inline void AskMapCfgList::_internal_set_mapid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mapid_ = value;
}

// -------------------------------------------------------------------

// AskNewSkillCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskNewSkillCfg];
inline bool AskNewSkillCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskNewSkillCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8211;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskNewSkillCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskNewSkillCfg.mgsid)
  return _internal_mgsid();
}
inline void AskNewSkillCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskNewSkillCfg.mgsid)
}
inline ::SSToCS::MsgID AskNewSkillCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskNewSkillCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskSkillEffectAccountCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectAccountCfg];
inline bool AskSkillEffectAccountCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSkillEffectAccountCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8213;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskSkillEffectAccountCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskSkillEffectAccountCfg.mgsid)
  return _internal_mgsid();
}
inline void AskSkillEffectAccountCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskSkillEffectAccountCfg.mgsid)
}
inline ::SSToCS::MsgID AskSkillEffectAccountCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskSkillEffectAccountCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskSkillEffectLeadingCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectLeadingCfg];
inline bool AskSkillEffectLeadingCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSkillEffectLeadingCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8216;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskSkillEffectLeadingCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskSkillEffectLeadingCfg.mgsid)
  return _internal_mgsid();
}
inline void AskSkillEffectLeadingCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskSkillEffectLeadingCfg.mgsid)
}
inline ::SSToCS::MsgID AskSkillEffectLeadingCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskSkillEffectLeadingCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskSkillEffectRangeCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectRangeCfg];
inline bool AskSkillEffectRangeCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSkillEffectRangeCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8215;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskSkillEffectRangeCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskSkillEffectRangeCfg.mgsid)
  return _internal_mgsid();
}
inline void AskSkillEffectRangeCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskSkillEffectRangeCfg.mgsid)
}
inline ::SSToCS::MsgID AskSkillEffectRangeCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskSkillEffectRangeCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskSkillEffectBufCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectBufCfg];
inline bool AskSkillEffectBufCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSkillEffectBufCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8217;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskSkillEffectBufCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskSkillEffectBufCfg.mgsid)
  return _internal_mgsid();
}
inline void AskSkillEffectBufCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskSkillEffectBufCfg.mgsid)
}
inline ::SSToCS::MsgID AskSkillEffectBufCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskSkillEffectBufCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskSkillEffectSummonCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectSummonCfg];
inline bool AskSkillEffectSummonCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSkillEffectSummonCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8218;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskSkillEffectSummonCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskSkillEffectSummonCfg.mgsid)
  return _internal_mgsid();
}
inline void AskSkillEffectSummonCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskSkillEffectSummonCfg.mgsid)
}
inline ::SSToCS::MsgID AskSkillEffectSummonCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskSkillEffectSummonCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskSkillEffectMoveCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectMoveCfg];
inline bool AskSkillEffectMoveCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSkillEffectMoveCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8219;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskSkillEffectMoveCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskSkillEffectMoveCfg.mgsid)
  return _internal_mgsid();
}
inline void AskSkillEffectMoveCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskSkillEffectMoveCfg.mgsid)
}
inline ::SSToCS::MsgID AskSkillEffectMoveCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskSkillEffectMoveCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskSkillEffectSwitchCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskSkillEffectSwitchCfg];
inline bool AskSkillEffectSwitchCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskSkillEffectSwitchCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8220;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskSkillEffectSwitchCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskSkillEffectSwitchCfg.mgsid)
  return _internal_mgsid();
}
inline void AskSkillEffectSwitchCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskSkillEffectSwitchCfg.mgsid)
}
inline ::SSToCS::MsgID AskSkillEffectSwitchCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskSkillEffectSwitchCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskPassitiveSkillCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveSkillCfg];
inline bool AskPassitiveSkillCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskPassitiveSkillCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8221;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskPassitiveSkillCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskPassitiveSkillCfg.mgsid)
  return _internal_mgsid();
}
inline void AskPassitiveSkillCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskPassitiveSkillCfg.mgsid)
}
inline ::SSToCS::MsgID AskPassitiveSkillCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskPassitiveSkillCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskPassitiveEffectBloodSeekCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveEffectBloodSeekCfg];
inline bool AskPassitiveEffectBloodSeekCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskPassitiveEffectBloodSeekCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8222;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskPassitiveEffectBloodSeekCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskPassitiveEffectBloodSeekCfg.mgsid)
  return _internal_mgsid();
}
inline void AskPassitiveEffectBloodSeekCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskPassitiveEffectBloodSeekCfg.mgsid)
}
inline ::SSToCS::MsgID AskPassitiveEffectBloodSeekCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskPassitiveEffectBloodSeekCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskPassitiveEffectReboundCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveEffectReboundCfg];
inline bool AskPassitiveEffectReboundCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskPassitiveEffectReboundCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8223;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskPassitiveEffectReboundCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskPassitiveEffectReboundCfg.mgsid)
  return _internal_mgsid();
}
inline void AskPassitiveEffectReboundCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskPassitiveEffectReboundCfg.mgsid)
}
inline ::SSToCS::MsgID AskPassitiveEffectReboundCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskPassitiveEffectReboundCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskPassitiveEffectReliveCfg

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskPassitiveEffectReliveCfg];
inline bool AskPassitiveEffectReliveCfg::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskPassitiveEffectReliveCfg::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8224;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::SSToCS::MsgID AskPassitiveEffectReliveCfg::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskPassitiveEffectReliveCfg.mgsid)
  return _internal_mgsid();
}
inline void AskPassitiveEffectReliveCfg::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskPassitiveEffectReliveCfg.mgsid)
}
inline ::SSToCS::MsgID AskPassitiveEffectReliveCfg::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskPassitiveEffectReliveCfg::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// -------------------------------------------------------------------

// AskUpdateGuideStep

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskUpdateGuideStep];
inline bool AskUpdateGuideStep::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AskUpdateGuideStep::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8225;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::SSToCS::MsgID AskUpdateGuideStep::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUpdateGuideStep.mgsid)
  return _internal_mgsid();
}
inline void AskUpdateGuideStep::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUpdateGuideStep.mgsid)
}
inline ::SSToCS::MsgID AskUpdateGuideStep::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskUpdateGuideStep::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 guid = 2;
inline bool AskUpdateGuideStep::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskUpdateGuideStep::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AskUpdateGuideStep::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUpdateGuideStep.guid)
  return _internal_guid();
}
inline void AskUpdateGuideStep::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUpdateGuideStep.guid)
}
inline ::uint64_t AskUpdateGuideStep::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void AskUpdateGuideStep::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 state = 3;
inline bool AskUpdateGuideStep::has_state() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskUpdateGuideStep::clear_state() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskUpdateGuideStep::state() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUpdateGuideStep.state)
  return _internal_state();
}
inline void AskUpdateGuideStep::set_state(::int32_t value) {
  _internal_set_state(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUpdateGuideStep.state)
}
inline ::int32_t AskUpdateGuideStep::_internal_state() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.state_;
}
inline void AskUpdateGuideStep::_internal_set_state(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.state_ = value;
}

// optional int32 stepid = 4;
inline bool AskUpdateGuideStep::has_stepid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskUpdateGuideStep::clear_stepid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t AskUpdateGuideStep::stepid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUpdateGuideStep.stepid)
  return _internal_stepid();
}
inline void AskUpdateGuideStep::set_stepid(::int32_t value) {
  _internal_set_stepid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUpdateGuideStep.stepid)
}
inline ::int32_t AskUpdateGuideStep::_internal_stepid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stepid_;
}
inline void AskUpdateGuideStep::_internal_set_stepid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stepid_ = value;
}

// -------------------------------------------------------------------

// AskUserGoHall

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AskUserGoHall];
inline bool AskUserGoHall::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void AskUserGoHall::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8226;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID AskUserGoHall::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUserGoHall.mgsid)
  return _internal_mgsid();
}
inline void AskUserGoHall::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUserGoHall.mgsid)
}
inline ::SSToCS::MsgID AskUserGoHall::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void AskUserGoHall::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional uint64 guid = 2;
inline bool AskUserGoHall::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AskUserGoHall::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t AskUserGoHall::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUserGoHall.guid)
  return _internal_guid();
}
inline void AskUserGoHall::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUserGoHall.guid)
}
inline ::uint64_t AskUserGoHall::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void AskUserGoHall::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional int32 type = 3;
inline bool AskUserGoHall::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void AskUserGoHall::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t AskUserGoHall::type() const {
  // @@protoc_insertion_point(field_get:SSToCS.AskUserGoHall.type)
  return _internal_type();
}
inline void AskUserGoHall::set_type(::int32_t value) {
  _internal_set_type(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.AskUserGoHall.type)
}
inline ::int32_t AskUserGoHall::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_;
}
inline void AskUserGoHall::_internal_set_type(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = value;
}

// -------------------------------------------------------------------

// SyncAllBattleInfo

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_AllBattleInfo];
inline bool SyncAllBattleInfo::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void SyncAllBattleInfo::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8229;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::SSToCS::MsgID SyncAllBattleInfo::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.SyncAllBattleInfo.mgsid)
  return _internal_mgsid();
}
inline void SyncAllBattleInfo::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.SyncAllBattleInfo.mgsid)
}
inline ::SSToCS::MsgID SyncAllBattleInfo::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void SyncAllBattleInfo::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// repeated uint64 playbattle = 2;
inline int SyncAllBattleInfo::_internal_playbattle_size() const {
  return _internal_playbattle().size();
}
inline int SyncAllBattleInfo::playbattle_size() const {
  return _internal_playbattle_size();
}
inline void SyncAllBattleInfo::clear_playbattle() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.playbattle_.Clear();
}
inline ::uint64_t SyncAllBattleInfo::playbattle(int index) const {
  // @@protoc_insertion_point(field_get:SSToCS.SyncAllBattleInfo.playbattle)
  return _internal_playbattle().Get(index);
}
inline void SyncAllBattleInfo::set_playbattle(int index, ::uint64_t value) {
  _internal_mutable_playbattle()->Set(index, value);
  // @@protoc_insertion_point(field_set:SSToCS.SyncAllBattleInfo.playbattle)
}
inline void SyncAllBattleInfo::add_playbattle(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_playbattle()->Add(value);
  // @@protoc_insertion_point(field_add:SSToCS.SyncAllBattleInfo.playbattle)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& SyncAllBattleInfo::playbattle() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SSToCS.SyncAllBattleInfo.playbattle)
  return _internal_playbattle();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* SyncAllBattleInfo::mutable_playbattle()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SSToCS.SyncAllBattleInfo.playbattle)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_playbattle();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& SyncAllBattleInfo::_internal_playbattle()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.playbattle_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* SyncAllBattleInfo::_internal_mutable_playbattle() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.playbattle_;
}

// optional uint64 maxbattleid = 3;
inline bool SyncAllBattleInfo::has_maxbattleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SyncAllBattleInfo::clear_maxbattleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxbattleid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t SyncAllBattleInfo::maxbattleid() const {
  // @@protoc_insertion_point(field_get:SSToCS.SyncAllBattleInfo.maxbattleid)
  return _internal_maxbattleid();
}
inline void SyncAllBattleInfo::set_maxbattleid(::uint64_t value) {
  _internal_set_maxbattleid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.SyncAllBattleInfo.maxbattleid)
}
inline ::uint64_t SyncAllBattleInfo::_internal_maxbattleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maxbattleid_;
}
inline void SyncAllBattleInfo::_internal_set_maxbattleid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maxbattleid_ = value;
}

// -------------------------------------------------------------------

// CreateBattleResponse

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_CreateBattleResponse];
inline bool CreateBattleResponse::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void CreateBattleResponse::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8300;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID CreateBattleResponse::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.CreateBattleResponse.mgsid)
  return _internal_mgsid();
}
inline void CreateBattleResponse::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.CreateBattleResponse.mgsid)
}
inline ::SSToCS::MsgID CreateBattleResponse::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void CreateBattleResponse::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 battleid = 2;
inline bool CreateBattleResponse::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void CreateBattleResponse::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t CreateBattleResponse::battleid() const {
  // @@protoc_insertion_point(field_get:SSToCS.CreateBattleResponse.battleid)
  return _internal_battleid();
}
inline void CreateBattleResponse::set_battleid(::int64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.CreateBattleResponse.battleid)
}
inline ::int64_t CreateBattleResponse::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void CreateBattleResponse::_internal_set_battleid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional bool rst = 3;
inline bool CreateBattleResponse::has_rst() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void CreateBattleResponse::clear_rst() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rst_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool CreateBattleResponse::rst() const {
  // @@protoc_insertion_point(field_get:SSToCS.CreateBattleResponse.rst)
  return _internal_rst();
}
inline void CreateBattleResponse::set_rst(bool value) {
  _internal_set_rst(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.CreateBattleResponse.rst)
}
inline bool CreateBattleResponse::_internal_rst() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.rst_;
}
inline void CreateBattleResponse::_internal_set_rst(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rst_ = value;
}

// -------------------------------------------------------------------

// FinishBattle_BattleUserData

// optional uint64 guid = 1;
inline bool FinishBattle_BattleUserData::has_guid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_guid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::uint64_t FinishBattle_BattleUserData::guid() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.guid)
  return _internal_guid();
}
inline void FinishBattle_BattleUserData::set_guid(::uint64_t value) {
  _internal_set_guid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.guid)
}
inline ::uint64_t FinishBattle_BattleUserData::_internal_guid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.guid_;
}
inline void FinishBattle_BattleUserData::_internal_set_guid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.guid_ = value;
}

// optional uint64 heroguid = 2;
inline bool FinishBattle_BattleUserData::has_heroguid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_heroguid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroguid_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::uint64_t FinishBattle_BattleUserData::heroguid() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.heroguid)
  return _internal_heroguid();
}
inline void FinishBattle_BattleUserData::set_heroguid(::uint64_t value) {
  _internal_set_heroguid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.heroguid)
}
inline ::uint64_t FinishBattle_BattleUserData::_internal_heroguid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroguid_;
}
inline void FinishBattle_BattleUserData::_internal_set_heroguid(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroguid_ = value;
}

// optional uint32 timeinsecond = 3;
inline bool FinishBattle_BattleUserData::has_timeinsecond() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_timeinsecond() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeinsecond_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uint32_t FinishBattle_BattleUserData::timeinsecond() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.timeinsecond)
  return _internal_timeinsecond();
}
inline void FinishBattle_BattleUserData::set_timeinsecond(::uint32_t value) {
  _internal_set_timeinsecond(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.timeinsecond)
}
inline ::uint32_t FinishBattle_BattleUserData::_internal_timeinsecond() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.timeinsecond_;
}
inline void FinishBattle_BattleUserData::_internal_set_timeinsecond(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.timeinsecond_ = value;
}

// optional bool ifEnd = 4;
inline bool FinishBattle_BattleUserData::has_ifend() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_ifend() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifend_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool FinishBattle_BattleUserData::ifend() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.ifEnd)
  return _internal_ifend();
}
inline void FinishBattle_BattleUserData::set_ifend(bool value) {
  _internal_set_ifend(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.ifEnd)
}
inline bool FinishBattle_BattleUserData::_internal_ifend() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifend_;
}
inline void FinishBattle_BattleUserData::_internal_set_ifend(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifend_ = value;
}

// optional int32 heroid = 5;
inline bool FinishBattle_BattleUserData::has_heroid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_heroid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::int32_t FinishBattle_BattleUserData::heroid() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.heroid)
  return _internal_heroid();
}
inline void FinishBattle_BattleUserData::set_heroid(::int32_t value) {
  _internal_set_heroid(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.heroid)
}
inline ::int32_t FinishBattle_BattleUserData::_internal_heroid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.heroid_;
}
inline void FinishBattle_BattleUserData::_internal_set_heroid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.heroid_ = value;
}

// optional int32 runepage = 6;
inline bool FinishBattle_BattleUserData::has_runepage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_runepage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runepage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::int32_t FinishBattle_BattleUserData::runepage() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.runepage)
  return _internal_runepage();
}
inline void FinishBattle_BattleUserData::set_runepage(::int32_t value) {
  _internal_set_runepage(value);
  _impl_._has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.runepage)
}
inline ::int32_t FinishBattle_BattleUserData::_internal_runepage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.runepage_;
}
inline void FinishBattle_BattleUserData::_internal_set_runepage(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.runepage_ = value;
}

// optional uint32 deadtimes = 7;
inline bool FinishBattle_BattleUserData::has_deadtimes() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_deadtimes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uint32_t FinishBattle_BattleUserData::deadtimes() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.deadtimes)
  return _internal_deadtimes();
}
inline void FinishBattle_BattleUserData::set_deadtimes(::uint32_t value) {
  _internal_set_deadtimes(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.deadtimes)
}
inline ::uint32_t FinishBattle_BattleUserData::_internal_deadtimes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.deadtimes_;
}
inline void FinishBattle_BattleUserData::_internal_set_deadtimes(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.deadtimes_ = value;
}

// optional uint32 herokills = 8;
inline bool FinishBattle_BattleUserData::has_herokills() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_herokills() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herokills_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::uint32_t FinishBattle_BattleUserData::herokills() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.herokills)
  return _internal_herokills();
}
inline void FinishBattle_BattleUserData::set_herokills(::uint32_t value) {
  _internal_set_herokills(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.herokills)
}
inline ::uint32_t FinishBattle_BattleUserData::_internal_herokills() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herokills_;
}
inline void FinishBattle_BattleUserData::_internal_set_herokills(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herokills_ = value;
}

// optional int32 destorybuilding = 9;
inline bool FinishBattle_BattleUserData::has_destorybuilding() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_destorybuilding() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destorybuilding_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::int32_t FinishBattle_BattleUserData::destorybuilding() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.destorybuilding)
  return _internal_destorybuilding();
}
inline void FinishBattle_BattleUserData::set_destorybuilding(::int32_t value) {
  _internal_set_destorybuilding(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.destorybuilding)
}
inline ::int32_t FinishBattle_BattleUserData::_internal_destorybuilding() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.destorybuilding_;
}
inline void FinishBattle_BattleUserData::_internal_set_destorybuilding(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.destorybuilding_ = value;
}

// optional int64 diamondused = 10;
inline bool FinishBattle_BattleUserData::has_diamondused() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_diamondused() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diamondused_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::int64_t FinishBattle_BattleUserData::diamondused() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.diamondused)
  return _internal_diamondused();
}
inline void FinishBattle_BattleUserData::set_diamondused(::int64_t value) {
  _internal_set_diamondused(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.diamondused)
}
inline ::int64_t FinishBattle_BattleUserData::_internal_diamondused() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.diamondused_;
}
inline void FinishBattle_BattleUserData::_internal_set_diamondused(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.diamondused_ = value;
}

// optional int64 goldused = 11;
inline bool FinishBattle_BattleUserData::has_goldused() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_goldused() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goldused_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::int64_t FinishBattle_BattleUserData::goldused() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.goldused)
  return _internal_goldused();
}
inline void FinishBattle_BattleUserData::set_goldused(::int64_t value) {
  _internal_set_goldused(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.goldused)
}
inline ::int64_t FinishBattle_BattleUserData::_internal_goldused() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.goldused_;
}
inline void FinishBattle_BattleUserData::_internal_set_goldused(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.goldused_ = value;
}

// optional int32 lasthitnum = 12;
inline bool FinishBattle_BattleUserData::has_lasthitnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_lasthitnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lasthitnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::int32_t FinishBattle_BattleUserData::lasthitnum() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.lasthitnum)
  return _internal_lasthitnum();
}
inline void FinishBattle_BattleUserData::set_lasthitnum(::int32_t value) {
  _internal_set_lasthitnum(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.lasthitnum)
}
inline ::int32_t FinishBattle_BattleUserData::_internal_lasthitnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.lasthitnum_;
}
inline void FinishBattle_BattleUserData::_internal_set_lasthitnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.lasthitnum_ = value;
}

// optional int32 asskillnum = 13;
inline bool FinishBattle_BattleUserData::has_asskillnum() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_asskillnum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.asskillnum_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::int32_t FinishBattle_BattleUserData::asskillnum() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.asskillnum)
  return _internal_asskillnum();
}
inline void FinishBattle_BattleUserData::set_asskillnum(::int32_t value) {
  _internal_set_asskillnum(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.asskillnum)
}
inline ::int32_t FinishBattle_BattleUserData::_internal_asskillnum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.asskillnum_;
}
inline void FinishBattle_BattleUserData::_internal_set_asskillnum(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.asskillnum_ = value;
}

// optional int32 herolv = 14;
inline bool FinishBattle_BattleUserData::has_herolv() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_herolv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herolv_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::int32_t FinishBattle_BattleUserData::herolv() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.herolv)
  return _internal_herolv();
}
inline void FinishBattle_BattleUserData::set_herolv(::int32_t value) {
  _internal_set_herolv(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.herolv)
}
inline ::int32_t FinishBattle_BattleUserData::_internal_herolv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.herolv_;
}
inline void FinishBattle_BattleUserData::_internal_set_herolv(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.herolv_ = value;
}

// optional int32 totalcp = 15;
inline bool FinishBattle_BattleUserData::has_totalcp() const {
  bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_totalcp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalcp_ = 0;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline ::int32_t FinishBattle_BattleUserData::totalcp() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.totalcp)
  return _internal_totalcp();
}
inline void FinishBattle_BattleUserData::set_totalcp(::int32_t value) {
  _internal_set_totalcp(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.totalcp)
}
inline ::int32_t FinishBattle_BattleUserData::_internal_totalcp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.totalcp_;
}
inline void FinishBattle_BattleUserData::_internal_set_totalcp(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.totalcp_ = value;
}

// optional bool ifAiRobot = 16;
inline bool FinishBattle_BattleUserData::has_ifairobot() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void FinishBattle_BattleUserData::clear_ifairobot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifairobot_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool FinishBattle_BattleUserData::ifairobot() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.BattleUserData.ifAiRobot)
  return _internal_ifairobot();
}
inline void FinishBattle_BattleUserData::set_ifairobot(bool value) {
  _internal_set_ifairobot(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.BattleUserData.ifAiRobot)
}
inline bool FinishBattle_BattleUserData::_internal_ifairobot() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ifairobot_;
}
inline void FinishBattle_BattleUserData::_internal_set_ifairobot(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ifairobot_ = value;
}

// -------------------------------------------------------------------

// FinishBattle

// optional .SSToCS.MsgID mgsid = 1 [default = eMsgToCSFromSS_FinishBattle];
inline bool FinishBattle::has_mgsid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void FinishBattle::clear_mgsid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mgsid_ = 8310;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::SSToCS::MsgID FinishBattle::mgsid() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.mgsid)
  return _internal_mgsid();
}
inline void FinishBattle::set_mgsid(::SSToCS::MsgID value) {
  _internal_set_mgsid(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.mgsid)
}
inline ::SSToCS::MsgID FinishBattle::_internal_mgsid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::SSToCS::MsgID>(_impl_.mgsid_);
}
inline void FinishBattle::_internal_set_mgsid(::SSToCS::MsgID value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  assert(::SSToCS::MsgID_IsValid(value));
  _impl_.mgsid_ = value;
}

// optional int64 battleid = 2;
inline bool FinishBattle::has_battleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FinishBattle::clear_battleid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t FinishBattle::battleid() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.battleid)
  return _internal_battleid();
}
inline void FinishBattle::set_battleid(::int64_t value) {
  _internal_set_battleid(value);
  _impl_._has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.battleid)
}
inline ::int64_t FinishBattle::_internal_battleid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.battleid_;
}
inline void FinishBattle::_internal_set_battleid(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.battleid_ = value;
}

// optional int32 winGrpID = 3;
inline bool FinishBattle::has_wingrpid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void FinishBattle::clear_wingrpid() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wingrpid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t FinishBattle::wingrpid() const {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.winGrpID)
  return _internal_wingrpid();
}
inline void FinishBattle::set_wingrpid(::int32_t value) {
  _internal_set_wingrpid(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:SSToCS.FinishBattle.winGrpID)
}
inline ::int32_t FinishBattle::_internal_wingrpid() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.wingrpid_;
}
inline void FinishBattle::_internal_set_wingrpid(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.wingrpid_ = value;
}

// repeated .SSToCS.FinishBattle.BattleUserData battelUserDataList = 4;
inline int FinishBattle::_internal_batteluserdatalist_size() const {
  return _internal_batteluserdatalist().size();
}
inline int FinishBattle::batteluserdatalist_size() const {
  return _internal_batteluserdatalist_size();
}
inline void FinishBattle::clear_batteluserdatalist() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.batteluserdatalist_.Clear();
}
inline ::SSToCS::FinishBattle_BattleUserData* FinishBattle::mutable_batteluserdatalist(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:SSToCS.FinishBattle.battelUserDataList)
  return _internal_mutable_batteluserdatalist()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>* FinishBattle::mutable_batteluserdatalist()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:SSToCS.FinishBattle.battelUserDataList)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_batteluserdatalist();
}
inline const ::SSToCS::FinishBattle_BattleUserData& FinishBattle::batteluserdatalist(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:SSToCS.FinishBattle.battelUserDataList)
  return _internal_batteluserdatalist().Get(index);
}
inline ::SSToCS::FinishBattle_BattleUserData* FinishBattle::add_batteluserdatalist() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::SSToCS::FinishBattle_BattleUserData* _add = _internal_mutable_batteluserdatalist()->Add();
  // @@protoc_insertion_point(field_add:SSToCS.FinishBattle.battelUserDataList)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>& FinishBattle::batteluserdatalist() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:SSToCS.FinishBattle.battelUserDataList)
  return _internal_batteluserdatalist();
}
inline const ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>&
FinishBattle::_internal_batteluserdatalist() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.batteluserdatalist_;
}
inline ::google::protobuf::RepeatedPtrField<::SSToCS::FinishBattle_BattleUserData>*
FinishBattle::_internal_mutable_batteluserdatalist() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.batteluserdatalist_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace SSToCS


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::SSToCS::MsgID> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::SSToCS::MsgID>() {
  return ::SSToCS::MsgID_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_SSToCS_2eproto_2epb_2eh
