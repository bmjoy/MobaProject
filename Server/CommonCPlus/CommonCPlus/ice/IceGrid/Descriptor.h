// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `Descriptor.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __IceGrid_Descriptor_h__
#define __IceGrid_Descriptor_h__

#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/Outgoing.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/Incoming.h>
#include <Ice/Direct.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <Ice/StreamF.h>
#include <Ice/Identity.h>
#include <Ice/BuiltinSequences.h>
#include <Ice/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 305
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 1
#       error Ice patch level mismatch!
#   endif
#endif

#ifndef ICE_GRID_API
#   ifdef ICE_GRID_API_EXPORTS
#       define ICE_GRID_API ICE_DECLSPEC_EXPORT
#   else
#       define ICE_GRID_API ICE_DECLSPEC_IMPORT
#   endif
#endif

namespace IceProxy
{

namespace IceGrid
{

class CommunicatorDescriptor;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::CommunicatorDescriptor>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::CommunicatorDescriptor*);

class ServerDescriptor;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ServerDescriptor>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::ServerDescriptor*);

class ServiceDescriptor;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ServiceDescriptor>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::ServiceDescriptor*);

class IceBoxDescriptor;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::IceBoxDescriptor>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::IceBoxDescriptor*);

class LoadBalancingPolicy;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::LoadBalancingPolicy>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::LoadBalancingPolicy*);

class RandomLoadBalancingPolicy;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::RandomLoadBalancingPolicy>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::RandomLoadBalancingPolicy*);

class OrderedLoadBalancingPolicy;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::OrderedLoadBalancingPolicy>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::OrderedLoadBalancingPolicy*);

class RoundRobinLoadBalancingPolicy;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::RoundRobinLoadBalancingPolicy>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::RoundRobinLoadBalancingPolicy*);

class AdaptiveLoadBalancingPolicy;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::AdaptiveLoadBalancingPolicy>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::AdaptiveLoadBalancingPolicy*);

class BoxedString;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::BoxedString>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::BoxedString*);

class BoxedDistributionDescriptor;
ICE_GRID_API void __read(::IceInternal::BasicStream*, ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::BoxedDistributionDescriptor>&);
ICE_GRID_API ::IceProxy::Ice::Object* upCast(::IceProxy::IceGrid::BoxedDistributionDescriptor*);

}

}

namespace IceGrid
{

class CommunicatorDescriptor;
bool operator==(const CommunicatorDescriptor&, const CommunicatorDescriptor&);
bool operator<(const CommunicatorDescriptor&, const CommunicatorDescriptor&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::CommunicatorDescriptor*);
typedef ::IceInternal::Handle< ::IceGrid::CommunicatorDescriptor> CommunicatorDescriptorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::CommunicatorDescriptor> CommunicatorDescriptorPrx;
ICE_GRID_API void __patch(CommunicatorDescriptorPtr&, const ::Ice::ObjectPtr&);

class ServerDescriptor;
bool operator==(const ServerDescriptor&, const ServerDescriptor&);
bool operator<(const ServerDescriptor&, const ServerDescriptor&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::ServerDescriptor*);
typedef ::IceInternal::Handle< ::IceGrid::ServerDescriptor> ServerDescriptorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ServerDescriptor> ServerDescriptorPrx;
ICE_GRID_API void __patch(ServerDescriptorPtr&, const ::Ice::ObjectPtr&);

class ServiceDescriptor;
bool operator==(const ServiceDescriptor&, const ServiceDescriptor&);
bool operator<(const ServiceDescriptor&, const ServiceDescriptor&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::ServiceDescriptor*);
typedef ::IceInternal::Handle< ::IceGrid::ServiceDescriptor> ServiceDescriptorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::ServiceDescriptor> ServiceDescriptorPrx;
ICE_GRID_API void __patch(ServiceDescriptorPtr&, const ::Ice::ObjectPtr&);

class IceBoxDescriptor;
bool operator==(const IceBoxDescriptor&, const IceBoxDescriptor&);
bool operator<(const IceBoxDescriptor&, const IceBoxDescriptor&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::IceBoxDescriptor*);
typedef ::IceInternal::Handle< ::IceGrid::IceBoxDescriptor> IceBoxDescriptorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::IceBoxDescriptor> IceBoxDescriptorPrx;
ICE_GRID_API void __patch(IceBoxDescriptorPtr&, const ::Ice::ObjectPtr&);

class LoadBalancingPolicy;
bool operator==(const LoadBalancingPolicy&, const LoadBalancingPolicy&);
bool operator<(const LoadBalancingPolicy&, const LoadBalancingPolicy&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::LoadBalancingPolicy*);
typedef ::IceInternal::Handle< ::IceGrid::LoadBalancingPolicy> LoadBalancingPolicyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::LoadBalancingPolicy> LoadBalancingPolicyPrx;
ICE_GRID_API void __patch(LoadBalancingPolicyPtr&, const ::Ice::ObjectPtr&);

class RandomLoadBalancingPolicy;
bool operator==(const RandomLoadBalancingPolicy&, const RandomLoadBalancingPolicy&);
bool operator<(const RandomLoadBalancingPolicy&, const RandomLoadBalancingPolicy&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::RandomLoadBalancingPolicy*);
typedef ::IceInternal::Handle< ::IceGrid::RandomLoadBalancingPolicy> RandomLoadBalancingPolicyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::RandomLoadBalancingPolicy> RandomLoadBalancingPolicyPrx;
ICE_GRID_API void __patch(RandomLoadBalancingPolicyPtr&, const ::Ice::ObjectPtr&);

class OrderedLoadBalancingPolicy;
bool operator==(const OrderedLoadBalancingPolicy&, const OrderedLoadBalancingPolicy&);
bool operator<(const OrderedLoadBalancingPolicy&, const OrderedLoadBalancingPolicy&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::OrderedLoadBalancingPolicy*);
typedef ::IceInternal::Handle< ::IceGrid::OrderedLoadBalancingPolicy> OrderedLoadBalancingPolicyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::OrderedLoadBalancingPolicy> OrderedLoadBalancingPolicyPrx;
ICE_GRID_API void __patch(OrderedLoadBalancingPolicyPtr&, const ::Ice::ObjectPtr&);

class RoundRobinLoadBalancingPolicy;
bool operator==(const RoundRobinLoadBalancingPolicy&, const RoundRobinLoadBalancingPolicy&);
bool operator<(const RoundRobinLoadBalancingPolicy&, const RoundRobinLoadBalancingPolicy&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::RoundRobinLoadBalancingPolicy*);
typedef ::IceInternal::Handle< ::IceGrid::RoundRobinLoadBalancingPolicy> RoundRobinLoadBalancingPolicyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::RoundRobinLoadBalancingPolicy> RoundRobinLoadBalancingPolicyPrx;
ICE_GRID_API void __patch(RoundRobinLoadBalancingPolicyPtr&, const ::Ice::ObjectPtr&);

class AdaptiveLoadBalancingPolicy;
bool operator==(const AdaptiveLoadBalancingPolicy&, const AdaptiveLoadBalancingPolicy&);
bool operator<(const AdaptiveLoadBalancingPolicy&, const AdaptiveLoadBalancingPolicy&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::AdaptiveLoadBalancingPolicy*);
typedef ::IceInternal::Handle< ::IceGrid::AdaptiveLoadBalancingPolicy> AdaptiveLoadBalancingPolicyPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::AdaptiveLoadBalancingPolicy> AdaptiveLoadBalancingPolicyPrx;
ICE_GRID_API void __patch(AdaptiveLoadBalancingPolicyPtr&, const ::Ice::ObjectPtr&);

class BoxedString;
bool operator==(const BoxedString&, const BoxedString&);
bool operator<(const BoxedString&, const BoxedString&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::BoxedString*);
typedef ::IceInternal::Handle< ::IceGrid::BoxedString> BoxedStringPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::BoxedString> BoxedStringPrx;
ICE_GRID_API void __patch(BoxedStringPtr&, const ::Ice::ObjectPtr&);

class BoxedDistributionDescriptor;
bool operator==(const BoxedDistributionDescriptor&, const BoxedDistributionDescriptor&);
bool operator<(const BoxedDistributionDescriptor&, const BoxedDistributionDescriptor&);
ICE_GRID_API ::Ice::Object* upCast(::IceGrid::BoxedDistributionDescriptor*);
typedef ::IceInternal::Handle< ::IceGrid::BoxedDistributionDescriptor> BoxedDistributionDescriptorPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::IceGrid::BoxedDistributionDescriptor> BoxedDistributionDescriptorPrx;
ICE_GRID_API void __patch(BoxedDistributionDescriptorPtr&, const ::Ice::ObjectPtr&);

}

namespace IceGrid
{

typedef ::std::map< ::std::string, ::std::string> StringStringDict;

struct PropertyDescriptor
{
    ::std::string name;
    ::std::string value;

    bool operator==(const PropertyDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(value != __rhs.value)
        {
            return false;
        }
        return true;
    }

    bool operator<(const PropertyDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(value < __rhs.value)
        {
            return true;
        }
        else if(__rhs.value < value)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const PropertyDescriptor& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const PropertyDescriptor& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const PropertyDescriptor& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const PropertyDescriptor& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::IceGrid::PropertyDescriptor> PropertyDescriptorSeq;

struct PropertySetDescriptor
{
    ::Ice::StringSeq references;
    ::IceGrid::PropertyDescriptorSeq properties;

    bool operator==(const PropertySetDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(references != __rhs.references)
        {
            return false;
        }
        if(properties != __rhs.properties)
        {
            return false;
        }
        return true;
    }

    bool operator<(const PropertySetDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(references < __rhs.references)
        {
            return true;
        }
        else if(__rhs.references < references)
        {
            return false;
        }
        if(properties < __rhs.properties)
        {
            return true;
        }
        else if(__rhs.properties < properties)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const PropertySetDescriptor& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const PropertySetDescriptor& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const PropertySetDescriptor& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const PropertySetDescriptor& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::map< ::std::string, ::IceGrid::PropertySetDescriptor> PropertySetDescriptorDict;

struct ObjectDescriptor
{
    ::Ice::Identity id;
    ::std::string type;
    ::std::string proxyOptions;

    bool operator==(const ObjectDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(id != __rhs.id)
        {
            return false;
        }
        if(type != __rhs.type)
        {
            return false;
        }
        if(proxyOptions != __rhs.proxyOptions)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ObjectDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(id < __rhs.id)
        {
            return true;
        }
        else if(__rhs.id < id)
        {
            return false;
        }
        if(type < __rhs.type)
        {
            return true;
        }
        else if(__rhs.type < type)
        {
            return false;
        }
        if(proxyOptions < __rhs.proxyOptions)
        {
            return true;
        }
        else if(__rhs.proxyOptions < proxyOptions)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ObjectDescriptor& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ObjectDescriptor& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ObjectDescriptor& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ObjectDescriptor& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::IceGrid::ObjectDescriptor> ObjectDescriptorSeq;

struct AdapterDescriptor
{
    ::std::string name;
    ::std::string description;
    ::std::string id;
    ::std::string replicaGroupId;
    ::std::string priority;
    bool registerProcess;
    bool serverLifetime;
    ::IceGrid::ObjectDescriptorSeq objects;
    ::IceGrid::ObjectDescriptorSeq allocatables;

    bool operator==(const AdapterDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(description != __rhs.description)
        {
            return false;
        }
        if(id != __rhs.id)
        {
            return false;
        }
        if(replicaGroupId != __rhs.replicaGroupId)
        {
            return false;
        }
        if(priority != __rhs.priority)
        {
            return false;
        }
        if(registerProcess != __rhs.registerProcess)
        {
            return false;
        }
        if(serverLifetime != __rhs.serverLifetime)
        {
            return false;
        }
        if(objects != __rhs.objects)
        {
            return false;
        }
        if(allocatables != __rhs.allocatables)
        {
            return false;
        }
        return true;
    }

    bool operator<(const AdapterDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(description < __rhs.description)
        {
            return true;
        }
        else if(__rhs.description < description)
        {
            return false;
        }
        if(id < __rhs.id)
        {
            return true;
        }
        else if(__rhs.id < id)
        {
            return false;
        }
        if(replicaGroupId < __rhs.replicaGroupId)
        {
            return true;
        }
        else if(__rhs.replicaGroupId < replicaGroupId)
        {
            return false;
        }
        if(priority < __rhs.priority)
        {
            return true;
        }
        else if(__rhs.priority < priority)
        {
            return false;
        }
        if(registerProcess < __rhs.registerProcess)
        {
            return true;
        }
        else if(__rhs.registerProcess < registerProcess)
        {
            return false;
        }
        if(serverLifetime < __rhs.serverLifetime)
        {
            return true;
        }
        else if(__rhs.serverLifetime < serverLifetime)
        {
            return false;
        }
        if(objects < __rhs.objects)
        {
            return true;
        }
        else if(__rhs.objects < objects)
        {
            return false;
        }
        if(allocatables < __rhs.allocatables)
        {
            return true;
        }
        else if(__rhs.allocatables < allocatables)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const AdapterDescriptor& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const AdapterDescriptor& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const AdapterDescriptor& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const AdapterDescriptor& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::IceGrid::AdapterDescriptor> AdapterDescriptorSeq;

struct DbEnvDescriptor
{
    ::std::string name;
    ::std::string description;
    ::std::string dbHome;
    ::IceGrid::PropertyDescriptorSeq properties;

    bool operator==(const DbEnvDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(description != __rhs.description)
        {
            return false;
        }
        if(dbHome != __rhs.dbHome)
        {
            return false;
        }
        if(properties != __rhs.properties)
        {
            return false;
        }
        return true;
    }

    bool operator<(const DbEnvDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(description < __rhs.description)
        {
            return true;
        }
        else if(__rhs.description < description)
        {
            return false;
        }
        if(dbHome < __rhs.dbHome)
        {
            return true;
        }
        else if(__rhs.dbHome < dbHome)
        {
            return false;
        }
        if(properties < __rhs.properties)
        {
            return true;
        }
        else if(__rhs.properties < properties)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const DbEnvDescriptor& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const DbEnvDescriptor& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const DbEnvDescriptor& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const DbEnvDescriptor& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::IceGrid::DbEnvDescriptor> DbEnvDescriptorSeq;

struct DistributionDescriptor
{
    ::std::string icepatch;
    ::Ice::StringSeq directories;

    bool operator==(const DistributionDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(icepatch != __rhs.icepatch)
        {
            return false;
        }
        if(directories != __rhs.directories)
        {
            return false;
        }
        return true;
    }

    bool operator<(const DistributionDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(icepatch < __rhs.icepatch)
        {
            return true;
        }
        else if(__rhs.icepatch < icepatch)
        {
            return false;
        }
        if(directories < __rhs.directories)
        {
            return true;
        }
        else if(__rhs.directories < directories)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const DistributionDescriptor& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const DistributionDescriptor& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const DistributionDescriptor& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const DistributionDescriptor& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::IceGrid::ServerDescriptorPtr> ServerDescriptorSeq;

typedef ::std::vector< ::IceGrid::ServiceDescriptorPtr> ServiceDescriptorSeq;

struct ServerInstanceDescriptor
{
    ::std::string _cpp_template;
    ::IceGrid::StringStringDict parameterValues;
    ::IceGrid::PropertySetDescriptor propertySet;
    ::IceGrid::PropertySetDescriptorDict servicePropertySets;

    bool operator==(const ServerInstanceDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(_cpp_template != __rhs._cpp_template)
        {
            return false;
        }
        if(parameterValues != __rhs.parameterValues)
        {
            return false;
        }
        if(propertySet != __rhs.propertySet)
        {
            return false;
        }
        if(servicePropertySets != __rhs.servicePropertySets)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ServerInstanceDescriptor& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(_cpp_template < __rhs._cpp_template)
        {
            return true;
        }
        else if(__rhs._cpp_template < _cpp_template)
        {
            return false;
        }
        if(parameterValues < __rhs.parameterValues)
        {
            return true;
        }
        else if(__rhs.parameterValues < parameterValues)
        {
            return false;
        }
        if(propertySet < __rhs.propertySet)
        {
            return true;
        }
        else if(__rhs.propertySet < propertySet)
        {
            return false;
        }
        if(servicePropertySets < __rhs.servicePropertySets)
        {
            return true;
        }
        else if(__rhs.servicePropertySets < servicePropertySets)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ServerInstanceDescriptor& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ServerInstanceDescriptor& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ServerInstanceDescriptor& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ServerInstanceDescriptor& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::IceGrid::ServerInstanceDescriptor> ServerInstanceDescriptorSeq;

struct TemplateDescriptor
{
    ::IceGrid::CommunicatorDescriptorPtr descriptor;
    ::Ice::StringSeq parameters;
    ::IceGrid::StringStringDict parameterDefaults;
};

typedef ::std::map< ::std::string, ::IceGrid::TemplateDescriptor> TemplateDescriptorDict;

struct ServiceInstanceDescriptor
{
    ::std::string _cpp_template;
    ::IceGrid::StringStringDict parameterValues;
    ::IceGrid::ServiceDescriptorPtr descriptor;
    ::IceGrid::PropertySetDescriptor propertySet;
};

typedef ::std::vector< ::IceGrid::ServiceInstanceDescriptor> ServiceInstanceDescriptorSeq;

struct NodeDescriptor
{
    ::IceGrid::StringStringDict variables;
    ::IceGrid::ServerInstanceDescriptorSeq serverInstances;
    ::IceGrid::ServerDescriptorSeq servers;
    ::std::string loadFactor;
    ::std::string description;
    ::IceGrid::PropertySetDescriptorDict propertySets;
};

typedef ::std::map< ::std::string, ::IceGrid::NodeDescriptor> NodeDescriptorDict;

struct ReplicaGroupDescriptor
{
    ::std::string id;
    ::IceGrid::LoadBalancingPolicyPtr loadBalancing;
    ::std::string proxyOptions;
    ::IceGrid::ObjectDescriptorSeq objects;
    ::std::string description;
};

typedef ::std::vector< ::IceGrid::ReplicaGroupDescriptor> ReplicaGroupDescriptorSeq;

struct ApplicationDescriptor
{
    ::std::string name;
    ::IceGrid::StringStringDict variables;
    ::IceGrid::ReplicaGroupDescriptorSeq replicaGroups;
    ::IceGrid::TemplateDescriptorDict serverTemplates;
    ::IceGrid::TemplateDescriptorDict serviceTemplates;
    ::IceGrid::NodeDescriptorDict nodes;
    ::IceGrid::DistributionDescriptor distrib;
    ::std::string description;
    ::IceGrid::PropertySetDescriptorDict propertySets;
};

typedef ::std::vector< ::IceGrid::ApplicationDescriptor> ApplicationDescriptorSeq;

struct NodeUpdateDescriptor
{
    ::std::string name;
    ::IceGrid::BoxedStringPtr description;
    ::IceGrid::StringStringDict variables;
    ::Ice::StringSeq removeVariables;
    ::IceGrid::PropertySetDescriptorDict propertySets;
    ::Ice::StringSeq removePropertySets;
    ::IceGrid::ServerInstanceDescriptorSeq serverInstances;
    ::IceGrid::ServerDescriptorSeq servers;
    ::Ice::StringSeq removeServers;
    ::IceGrid::BoxedStringPtr loadFactor;
};

typedef ::std::vector< ::IceGrid::NodeUpdateDescriptor> NodeUpdateDescriptorSeq;

struct ApplicationUpdateDescriptor
{
    ::std::string name;
    ::IceGrid::BoxedStringPtr description;
    ::IceGrid::BoxedDistributionDescriptorPtr distrib;
    ::IceGrid::StringStringDict variables;
    ::Ice::StringSeq removeVariables;
    ::IceGrid::PropertySetDescriptorDict propertySets;
    ::Ice::StringSeq removePropertySets;
    ::IceGrid::ReplicaGroupDescriptorSeq replicaGroups;
    ::Ice::StringSeq removeReplicaGroups;
    ::IceGrid::TemplateDescriptorDict serverTemplates;
    ::Ice::StringSeq removeServerTemplates;
    ::IceGrid::TemplateDescriptorDict serviceTemplates;
    ::Ice::StringSeq removeServiceTemplates;
    ::IceGrid::NodeUpdateDescriptorSeq nodes;
    ::Ice::StringSeq removeNodes;
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::IceGrid::PropertyDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::PropertyDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::PropertyDescriptor& v)
    {
        __os->write(v.name);
        __os->write(v.value);
    }
};

template<class S>
struct StreamReader< ::IceGrid::PropertyDescriptor, S>
{
    static void read(S* __is, ::IceGrid::PropertyDescriptor& v)
    {
        __is->read(v.name);
        __is->read(v.value);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::PropertyDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::PropertyDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::PropertySetDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::PropertySetDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::PropertySetDescriptor& v)
    {
        __os->write(v.references);
        __os->write(v.properties);
    }
};

template<class S>
struct StreamReader< ::IceGrid::PropertySetDescriptor, S>
{
    static void read(S* __is, ::IceGrid::PropertySetDescriptor& v)
    {
        __is->read(v.references);
        __is->read(v.properties);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::PropertySetDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::PropertySetDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::ObjectDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::ObjectDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::ObjectDescriptor& v)
    {
        __os->write(v.id);
        __os->write(v.type);
        __os->write(v.proxyOptions);
    }
};

template<class S>
struct StreamReader< ::IceGrid::ObjectDescriptor, S>
{
    static void read(S* __is, ::IceGrid::ObjectDescriptor& v)
    {
        __is->read(v.id);
        __is->read(v.type);
        __is->read(v.proxyOptions);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::ObjectDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ObjectDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::AdapterDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::AdapterDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::AdapterDescriptor& v)
    {
        __os->write(v.name);
        __os->write(v.description);
        __os->write(v.id);
        __os->write(v.replicaGroupId);
        __os->write(v.priority);
        __os->write(v.registerProcess);
        __os->write(v.serverLifetime);
        __os->write(v.objects);
        __os->write(v.allocatables);
    }
};

template<class S>
struct StreamReader< ::IceGrid::AdapterDescriptor, S>
{
    static void read(S* __is, ::IceGrid::AdapterDescriptor& v)
    {
        __is->read(v.name);
        __is->read(v.description);
        __is->read(v.id);
        __is->read(v.replicaGroupId);
        __is->read(v.priority);
        __is->read(v.registerProcess);
        __is->read(v.serverLifetime);
        __is->read(v.objects);
        __is->read(v.allocatables);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::AdapterDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::AdapterDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::DbEnvDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::DbEnvDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::DbEnvDescriptor& v)
    {
        __os->write(v.name);
        __os->write(v.description);
        __os->write(v.dbHome);
        __os->write(v.properties);
    }
};

template<class S>
struct StreamReader< ::IceGrid::DbEnvDescriptor, S>
{
    static void read(S* __is, ::IceGrid::DbEnvDescriptor& v)
    {
        __is->read(v.name);
        __is->read(v.description);
        __is->read(v.dbHome);
        __is->read(v.properties);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::DbEnvDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::DbEnvDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::DistributionDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::DistributionDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::DistributionDescriptor& v)
    {
        __os->write(v.icepatch);
        __os->write(v.directories);
    }
};

template<class S>
struct StreamReader< ::IceGrid::DistributionDescriptor, S>
{
    static void read(S* __is, ::IceGrid::DistributionDescriptor& v)
    {
        __is->read(v.icepatch);
        __is->read(v.directories);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::DistributionDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::DistributionDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::ServerInstanceDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::ServerInstanceDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::ServerInstanceDescriptor& v)
    {
        __os->write(v._cpp_template);
        __os->write(v.parameterValues);
        __os->write(v.propertySet);
        __os->write(v.servicePropertySets);
    }
};

template<class S>
struct StreamReader< ::IceGrid::ServerInstanceDescriptor, S>
{
    static void read(S* __is, ::IceGrid::ServerInstanceDescriptor& v)
    {
        __is->read(v._cpp_template);
        __is->read(v.parameterValues);
        __is->read(v.propertySet);
        __is->read(v.servicePropertySets);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::ServerInstanceDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ServerInstanceDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::TemplateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::TemplateDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::TemplateDescriptor& v)
    {
        __os->write(v.descriptor);
        __os->write(v.parameters);
        __os->write(v.parameterDefaults);
    }
};

template<class S>
struct StreamReader< ::IceGrid::TemplateDescriptor, S>
{
    static void read(S* __is, ::IceGrid::TemplateDescriptor& v)
    {
        __is->read(v.descriptor);
        __is->read(v.parameters);
        __is->read(v.parameterDefaults);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::TemplateDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::TemplateDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::ServiceInstanceDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::ServiceInstanceDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::ServiceInstanceDescriptor& v)
    {
        __os->write(v._cpp_template);
        __os->write(v.parameterValues);
        __os->write(v.descriptor);
        __os->write(v.propertySet);
    }
};

template<class S>
struct StreamReader< ::IceGrid::ServiceInstanceDescriptor, S>
{
    static void read(S* __is, ::IceGrid::ServiceInstanceDescriptor& v)
    {
        __is->read(v._cpp_template);
        __is->read(v.parameterValues);
        __is->read(v.descriptor);
        __is->read(v.propertySet);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::ServiceInstanceDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ServiceInstanceDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::NodeDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 6;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::NodeDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::NodeDescriptor& v)
    {
        __os->write(v.variables);
        __os->write(v.serverInstances);
        __os->write(v.servers);
        __os->write(v.loadFactor);
        __os->write(v.description);
        __os->write(v.propertySets);
    }
};

template<class S>
struct StreamReader< ::IceGrid::NodeDescriptor, S>
{
    static void read(S* __is, ::IceGrid::NodeDescriptor& v)
    {
        __is->read(v.variables);
        __is->read(v.serverInstances);
        __is->read(v.servers);
        __is->read(v.loadFactor);
        __is->read(v.description);
        __is->read(v.propertySets);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::NodeDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::NodeDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::ReplicaGroupDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::ReplicaGroupDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::ReplicaGroupDescriptor& v)
    {
        __os->write(v.id);
        __os->write(v.loadBalancing);
        __os->write(v.proxyOptions);
        __os->write(v.objects);
        __os->write(v.description);
    }
};

template<class S>
struct StreamReader< ::IceGrid::ReplicaGroupDescriptor, S>
{
    static void read(S* __is, ::IceGrid::ReplicaGroupDescriptor& v)
    {
        __is->read(v.id);
        __is->read(v.loadBalancing);
        __is->read(v.proxyOptions);
        __is->read(v.objects);
        __is->read(v.description);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::ReplicaGroupDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ReplicaGroupDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::ApplicationDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::ApplicationDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::ApplicationDescriptor& v)
    {
        __os->write(v.name);
        __os->write(v.variables);
        __os->write(v.replicaGroups);
        __os->write(v.serverTemplates);
        __os->write(v.serviceTemplates);
        __os->write(v.nodes);
        __os->write(v.distrib);
        __os->write(v.description);
        __os->write(v.propertySets);
    }
};

template<class S>
struct StreamReader< ::IceGrid::ApplicationDescriptor, S>
{
    static void read(S* __is, ::IceGrid::ApplicationDescriptor& v)
    {
        __is->read(v.name);
        __is->read(v.variables);
        __is->read(v.replicaGroups);
        __is->read(v.serverTemplates);
        __is->read(v.serviceTemplates);
        __is->read(v.nodes);
        __is->read(v.distrib);
        __is->read(v.description);
        __is->read(v.propertySets);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::ApplicationDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ApplicationDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::NodeUpdateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 10;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::NodeUpdateDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::NodeUpdateDescriptor& v)
    {
        __os->write(v.name);
        __os->write(v.description);
        __os->write(v.variables);
        __os->write(v.removeVariables);
        __os->write(v.propertySets);
        __os->write(v.removePropertySets);
        __os->write(v.serverInstances);
        __os->write(v.servers);
        __os->write(v.removeServers);
        __os->write(v.loadFactor);
    }
};

template<class S>
struct StreamReader< ::IceGrid::NodeUpdateDescriptor, S>
{
    static void read(S* __is, ::IceGrid::NodeUpdateDescriptor& v)
    {
        __is->read(v.name);
        __is->read(v.description);
        __is->read(v.variables);
        __is->read(v.removeVariables);
        __is->read(v.propertySets);
        __is->read(v.removePropertySets);
        __is->read(v.serverInstances);
        __is->read(v.servers);
        __is->read(v.removeServers);
        __is->read(v.loadFactor);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::NodeUpdateDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::NodeUpdateDescriptor, ::IceInternal::BasicStream>;
#endif

template<>
struct StreamableTraits< ::IceGrid::ApplicationUpdateDescriptor>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 15;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::IceGrid::ApplicationUpdateDescriptor, S>
{
    static void write(S* __os, const ::IceGrid::ApplicationUpdateDescriptor& v)
    {
        __os->write(v.name);
        __os->write(v.description);
        __os->write(v.distrib);
        __os->write(v.variables);
        __os->write(v.removeVariables);
        __os->write(v.propertySets);
        __os->write(v.removePropertySets);
        __os->write(v.replicaGroups);
        __os->write(v.removeReplicaGroups);
        __os->write(v.serverTemplates);
        __os->write(v.removeServerTemplates);
        __os->write(v.serviceTemplates);
        __os->write(v.removeServiceTemplates);
        __os->write(v.nodes);
        __os->write(v.removeNodes);
    }
};

template<class S>
struct StreamReader< ::IceGrid::ApplicationUpdateDescriptor, S>
{
    static void read(S* __is, ::IceGrid::ApplicationUpdateDescriptor& v)
    {
        __is->read(v.name);
        __is->read(v.description);
        __is->read(v.distrib);
        __is->read(v.variables);
        __is->read(v.removeVariables);
        __is->read(v.propertySets);
        __is->read(v.removePropertySets);
        __is->read(v.replicaGroups);
        __is->read(v.removeReplicaGroups);
        __is->read(v.serverTemplates);
        __is->read(v.removeServerTemplates);
        __is->read(v.serviceTemplates);
        __is->read(v.removeServiceTemplates);
        __is->read(v.nodes);
        __is->read(v.removeNodes);
    }
};

#if defined(ICE_HAS_DECLSPEC_IMPORT_EXPORT) && !defined(ICE_GRID_API_EXPORTS)
template struct ICE_GRID_API StreamWriter< ::IceGrid::ApplicationUpdateDescriptor, ::IceInternal::BasicStream>;
template struct ICE_GRID_API StreamReader< ::IceGrid::ApplicationUpdateDescriptor, ::IceInternal::BasicStream>;
#endif

}

namespace IceGrid
{

}

namespace IceProxy
{

namespace IceGrid
{

class CommunicatorDescriptor : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_secure(bool __secure) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_twoway() const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_oneway() const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_batchOneway() const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_datagram() const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_batchDatagram() const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_compress(bool __compress) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_timeout(int __timeout) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<CommunicatorDescriptor> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<CommunicatorDescriptor*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServerDescriptor : virtual public ::IceProxy::IceGrid::CommunicatorDescriptor
{
public:
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_secure(bool __secure) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_twoway() const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_oneway() const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_batchOneway() const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_datagram() const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_batchDatagram() const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_compress(bool __compress) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ServerDescriptor> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ServerDescriptor*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class ServiceDescriptor : virtual public ::IceProxy::IceGrid::CommunicatorDescriptor
{
public:
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_secure(bool __secure) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_twoway() const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_oneway() const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_batchOneway() const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_datagram() const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_batchDatagram() const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_compress(bool __compress) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_timeout(int __timeout) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<ServiceDescriptor> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<ServiceDescriptor*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class IceBoxDescriptor : virtual public ::IceProxy::IceGrid::ServerDescriptor
{
public:
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_secure(bool __secure) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_twoway() const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_oneway() const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_batchOneway() const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_datagram() const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_batchDatagram() const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_compress(bool __compress) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_timeout(int __timeout) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<IceBoxDescriptor> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<IceBoxDescriptor*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class LoadBalancingPolicy : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_secure(bool __secure) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_twoway() const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_oneway() const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_batchOneway() const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_datagram() const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_batchDatagram() const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_compress(bool __compress) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_timeout(int __timeout) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<LoadBalancingPolicy> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<LoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class RandomLoadBalancingPolicy : virtual public ::IceProxy::IceGrid::LoadBalancingPolicy
{
public:
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_secure(bool __secure) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_twoway() const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_oneway() const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_batchOneway() const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_datagram() const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_batchDatagram() const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_compress(bool __compress) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_timeout(int __timeout) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RandomLoadBalancingPolicy> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<RandomLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class OrderedLoadBalancingPolicy : virtual public ::IceProxy::IceGrid::LoadBalancingPolicy
{
public:
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_secure(bool __secure) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_twoway() const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_oneway() const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_batchOneway() const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_datagram() const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_batchDatagram() const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_compress(bool __compress) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_timeout(int __timeout) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<OrderedLoadBalancingPolicy> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<OrderedLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class RoundRobinLoadBalancingPolicy : virtual public ::IceProxy::IceGrid::LoadBalancingPolicy
{
public:
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_secure(bool __secure) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_twoway() const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_oneway() const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_batchOneway() const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_datagram() const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_batchDatagram() const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_compress(bool __compress) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_timeout(int __timeout) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<RoundRobinLoadBalancingPolicy> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<RoundRobinLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class AdaptiveLoadBalancingPolicy : virtual public ::IceProxy::IceGrid::LoadBalancingPolicy
{
public:
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_secure(bool __secure) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_twoway() const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_oneway() const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_batchOneway() const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_datagram() const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_batchDatagram() const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_compress(bool __compress) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_timeout(int __timeout) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<AdaptiveLoadBalancingPolicy> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<AdaptiveLoadBalancingPolicy*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BoxedString : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<BoxedString> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_secure(bool __secure) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_twoway() const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_oneway() const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_batchOneway() const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_datagram() const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_batchDatagram() const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_compress(bool __compress) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedString> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BoxedString*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

class BoxedDistributionDescriptor : virtual public ::IceProxy::Ice::Object
{
public:
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_context(const ::Ice::Context& __context) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_context(__context).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_adapterId(const ::std::string& __id) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_adapterId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_endpoints(const ::Ice::EndpointSeq& __endpoints) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_endpoints(__endpoints).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_locatorCacheTimeout(int __timeout) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_locatorCacheTimeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_connectionCached(bool __cached) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_connectionCached(__cached).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_endpointSelection(::Ice::EndpointSelectionType __est) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_endpointSelection(__est).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_secure(bool __secure) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_secure(__secure).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_preferSecure(bool __preferSecure) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_preferSecure(__preferSecure).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_router(const ::Ice::RouterPrx& __router) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_router(__router).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_locator(const ::Ice::LocatorPrx& __locator) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_locator(__locator).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_collocationOptimized(bool __co) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_collocationOptimized(__co).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_twoway() const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_twoway().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_oneway() const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_oneway().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_batchOneway() const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_batchOneway().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_datagram() const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_datagram().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_batchDatagram() const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_batchDatagram().get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_compress(bool __compress) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_compress(__compress).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_timeout(int __timeout) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_timeout(__timeout).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_connectionId(const ::std::string& __id) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_connectionId(__id).get());
    }
    
    ::IceInternal::ProxyHandle<BoxedDistributionDescriptor> ice_encodingVersion(const ::Ice::EncodingVersion& __v) const
    {
        return dynamic_cast<BoxedDistributionDescriptor*>(::IceProxy::Ice::Object::ice_encodingVersion(__v).get());
    }
    
    ICE_GRID_API static const ::std::string& ice_staticId();

private: 

    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateM::Ice::Object> __createDelegateM();
    ICE_GRID_API virtual ::IceInternal::Handle< ::IceDelegateD::Ice::Object> __createDelegateD();
    ICE_GRID_API virtual ::IceProxy::Ice::Object* __newInstance() const;
};

}

}

namespace IceDelegate
{

namespace IceGrid
{

class ICE_GRID_API CommunicatorDescriptor : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ICE_GRID_API ServerDescriptor : virtual public ::IceDelegate::IceGrid::CommunicatorDescriptor
{
public:
};

class ICE_GRID_API ServiceDescriptor : virtual public ::IceDelegate::IceGrid::CommunicatorDescriptor
{
public:
};

class ICE_GRID_API IceBoxDescriptor : virtual public ::IceDelegate::IceGrid::ServerDescriptor
{
public:
};

class ICE_GRID_API LoadBalancingPolicy : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ICE_GRID_API RandomLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API OrderedLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API RoundRobinLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API AdaptiveLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API BoxedString : virtual public ::IceDelegate::Ice::Object
{
public:
};

class ICE_GRID_API BoxedDistributionDescriptor : virtual public ::IceDelegate::Ice::Object
{
public:
};

}

}

namespace IceDelegateM
{

namespace IceGrid
{

class ICE_GRID_API CommunicatorDescriptor : virtual public ::IceDelegate::IceGrid::CommunicatorDescriptor,
                                            virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ICE_GRID_API ServerDescriptor : virtual public ::IceDelegate::IceGrid::ServerDescriptor,
                                      virtual public ::IceDelegateM::IceGrid::CommunicatorDescriptor
{
public:
};

class ICE_GRID_API ServiceDescriptor : virtual public ::IceDelegate::IceGrid::ServiceDescriptor,
                                       virtual public ::IceDelegateM::IceGrid::CommunicatorDescriptor
{
public:
};

class ICE_GRID_API IceBoxDescriptor : virtual public ::IceDelegate::IceGrid::IceBoxDescriptor,
                                      virtual public ::IceDelegateM::IceGrid::ServerDescriptor
{
public:
};

class ICE_GRID_API LoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::LoadBalancingPolicy,
                                         virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ICE_GRID_API RandomLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::RandomLoadBalancingPolicy,
                                               virtual public ::IceDelegateM::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API OrderedLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::OrderedLoadBalancingPolicy,
                                                virtual public ::IceDelegateM::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API RoundRobinLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::RoundRobinLoadBalancingPolicy,
                                                   virtual public ::IceDelegateM::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API AdaptiveLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::AdaptiveLoadBalancingPolicy,
                                                 virtual public ::IceDelegateM::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API BoxedString : virtual public ::IceDelegate::IceGrid::BoxedString,
                                 virtual public ::IceDelegateM::Ice::Object
{
public:
};

class ICE_GRID_API BoxedDistributionDescriptor : virtual public ::IceDelegate::IceGrid::BoxedDistributionDescriptor,
                                                 virtual public ::IceDelegateM::Ice::Object
{
public:
};

}

}

namespace IceDelegateD
{

namespace IceGrid
{

class ICE_GRID_API CommunicatorDescriptor : virtual public ::IceDelegate::IceGrid::CommunicatorDescriptor,
                                            virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ICE_GRID_API ServerDescriptor : virtual public ::IceDelegate::IceGrid::ServerDescriptor,
                                      virtual public ::IceDelegateD::IceGrid::CommunicatorDescriptor
{
public:
};

class ICE_GRID_API ServiceDescriptor : virtual public ::IceDelegate::IceGrid::ServiceDescriptor,
                                       virtual public ::IceDelegateD::IceGrid::CommunicatorDescriptor
{
public:
};

class ICE_GRID_API IceBoxDescriptor : virtual public ::IceDelegate::IceGrid::IceBoxDescriptor,
                                      virtual public ::IceDelegateD::IceGrid::ServerDescriptor
{
public:
};

class ICE_GRID_API LoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::LoadBalancingPolicy,
                                         virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ICE_GRID_API RandomLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::RandomLoadBalancingPolicy,
                                               virtual public ::IceDelegateD::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API OrderedLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::OrderedLoadBalancingPolicy,
                                                virtual public ::IceDelegateD::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API RoundRobinLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::RoundRobinLoadBalancingPolicy,
                                                   virtual public ::IceDelegateD::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API AdaptiveLoadBalancingPolicy : virtual public ::IceDelegate::IceGrid::AdaptiveLoadBalancingPolicy,
                                                 virtual public ::IceDelegateD::IceGrid::LoadBalancingPolicy
{
public:
};

class ICE_GRID_API BoxedString : virtual public ::IceDelegate::IceGrid::BoxedString,
                                 virtual public ::IceDelegateD::Ice::Object
{
public:
};

class ICE_GRID_API BoxedDistributionDescriptor : virtual public ::IceDelegate::IceGrid::BoxedDistributionDescriptor,
                                                 virtual public ::IceDelegateD::Ice::Object
{
public:
};

}

}

namespace IceGrid
{

class ICE_GRID_API CommunicatorDescriptor : virtual public ::Ice::Object
{
public:

    typedef CommunicatorDescriptorPrx ProxyType;
    typedef CommunicatorDescriptorPtr PointerType;

    CommunicatorDescriptor()
    {
    }

    CommunicatorDescriptor(const ::IceGrid::AdapterDescriptorSeq& __ice_adapters, const ::IceGrid::PropertySetDescriptor& __ice_propertySet, const ::IceGrid::DbEnvDescriptorSeq& __ice_dbEnvs, const ::Ice::StringSeq& __ice_logs, const ::std::string& __ice_description) :
        adapters(__ice_adapters),
        propertySet(__ice_propertySet),
        dbEnvs(__ice_dbEnvs),
        logs(__ice_logs),
        description(__ice_description)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::IceGrid::AdapterDescriptorSeq adapters;

    ::IceGrid::PropertySetDescriptor propertySet;

    ::IceGrid::DbEnvDescriptorSeq dbEnvs;

    ::Ice::StringSeq logs;

    ::std::string description;

protected:

    virtual ~CommunicatorDescriptor() {}

    friend class CommunicatorDescriptor__staticInit;
};

class CommunicatorDescriptor__staticInit
{
public:

    ::IceGrid::CommunicatorDescriptor _init;
};

static CommunicatorDescriptor__staticInit _CommunicatorDescriptor_init;

inline bool operator==(const CommunicatorDescriptor& l, const CommunicatorDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const CommunicatorDescriptor& l, const CommunicatorDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API ServerDescriptor : public ::IceGrid::CommunicatorDescriptor
{
public:

    typedef ServerDescriptorPrx ProxyType;
    typedef ServerDescriptorPtr PointerType;

    ServerDescriptor()
    {
    }

    ServerDescriptor(const ::IceGrid::AdapterDescriptorSeq& __ice_adapters, const ::IceGrid::PropertySetDescriptor& __ice_propertySet, const ::IceGrid::DbEnvDescriptorSeq& __ice_dbEnvs, const ::Ice::StringSeq& __ice_logs, const ::std::string& __ice_description, const ::std::string& __ice_id, const ::std::string& __ice_exe, const ::std::string& __ice_iceVersion, const ::std::string& __ice_pwd, const ::Ice::StringSeq& __ice_options, const ::Ice::StringSeq& __ice_envs, const ::std::string& __ice_activation, const ::std::string& __ice_activationTimeout, const ::std::string& __ice_deactivationTimeout, bool __ice_applicationDistrib, const ::IceGrid::DistributionDescriptor& __ice_distrib, bool __ice_allocatable, const ::std::string& __ice_user) :
        ::IceGrid::CommunicatorDescriptor(__ice_adapters, __ice_propertySet, __ice_dbEnvs, __ice_logs, __ice_description)
        ,
        id(__ice_id),
        exe(__ice_exe),
        iceVersion(__ice_iceVersion),
        pwd(__ice_pwd),
        options(__ice_options),
        envs(__ice_envs),
        activation(__ice_activation),
        activationTimeout(__ice_activationTimeout),
        deactivationTimeout(__ice_deactivationTimeout),
        applicationDistrib(__ice_applicationDistrib),
        distrib(__ice_distrib),
        allocatable(__ice_allocatable),
        user(__ice_user)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::IceGrid::CommunicatorDescriptor::__writeImpl;
    using ::IceGrid::CommunicatorDescriptor::__readImpl;
    #endif

public:

    ::std::string id;

    ::std::string exe;

    ::std::string iceVersion;

    ::std::string pwd;

    ::Ice::StringSeq options;

    ::Ice::StringSeq envs;

    ::std::string activation;

    ::std::string activationTimeout;

    ::std::string deactivationTimeout;

    bool applicationDistrib;

    ::IceGrid::DistributionDescriptor distrib;

    bool allocatable;

    ::std::string user;

protected:

    virtual ~ServerDescriptor() {}
};

inline bool operator==(const ServerDescriptor& l, const ServerDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServerDescriptor& l, const ServerDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API ServiceDescriptor : public ::IceGrid::CommunicatorDescriptor
{
public:

    typedef ServiceDescriptorPrx ProxyType;
    typedef ServiceDescriptorPtr PointerType;

    ServiceDescriptor()
    {
    }

    ServiceDescriptor(const ::IceGrid::AdapterDescriptorSeq& __ice_adapters, const ::IceGrid::PropertySetDescriptor& __ice_propertySet, const ::IceGrid::DbEnvDescriptorSeq& __ice_dbEnvs, const ::Ice::StringSeq& __ice_logs, const ::std::string& __ice_description, const ::std::string& __ice_name, const ::std::string& __ice_entry) :
        ::IceGrid::CommunicatorDescriptor(__ice_adapters, __ice_propertySet, __ice_dbEnvs, __ice_logs, __ice_description)
        ,
        name(__ice_name),
        entry(__ice_entry)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::IceGrid::CommunicatorDescriptor::__writeImpl;
    using ::IceGrid::CommunicatorDescriptor::__readImpl;
    #endif

public:

    ::std::string name;

    ::std::string entry;

protected:

    virtual ~ServiceDescriptor() {}
};

inline bool operator==(const ServiceDescriptor& l, const ServiceDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const ServiceDescriptor& l, const ServiceDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API IceBoxDescriptor : public ::IceGrid::ServerDescriptor, public IceInternal::GCShared
{
public:

    typedef IceBoxDescriptorPrx ProxyType;
    typedef IceBoxDescriptorPtr PointerType;

    IceBoxDescriptor()
    {
    }

    IceBoxDescriptor(const ::IceGrid::AdapterDescriptorSeq& __ice_adapters, const ::IceGrid::PropertySetDescriptor& __ice_propertySet, const ::IceGrid::DbEnvDescriptorSeq& __ice_dbEnvs, const ::Ice::StringSeq& __ice_logs, const ::std::string& __ice_description, const ::std::string& __ice_id, const ::std::string& __ice_exe, const ::std::string& __ice_iceVersion, const ::std::string& __ice_pwd, const ::Ice::StringSeq& __ice_options, const ::Ice::StringSeq& __ice_envs, const ::std::string& __ice_activation, const ::std::string& __ice_activationTimeout, const ::std::string& __ice_deactivationTimeout, bool __ice_applicationDistrib, const ::IceGrid::DistributionDescriptor& __ice_distrib, bool __ice_allocatable, const ::std::string& __ice_user, const ::IceGrid::ServiceInstanceDescriptorSeq& __ice_services) :
        ::IceGrid::ServerDescriptor(__ice_adapters, __ice_propertySet, __ice_dbEnvs, __ice_logs, __ice_description, __ice_id, __ice_exe, __ice_iceVersion, __ice_pwd, __ice_options, __ice_envs, __ice_activation, __ice_activationTimeout, __ice_deactivationTimeout, __ice_applicationDistrib, __ice_distrib, __ice_allocatable, __ice_user)
        ,
        services(__ice_services)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    virtual void __addObject(::IceInternal::GCCountMap&);
    virtual bool __usesGC();
    virtual void __gcReachable(::IceInternal::GCCountMap&) const;
    virtual void __gcClear();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::IceGrid::ServerDescriptor::__writeImpl;
    using ::IceGrid::ServerDescriptor::__readImpl;
    #endif

public:

    ::IceGrid::ServiceInstanceDescriptorSeq services;

protected:

    virtual ~IceBoxDescriptor() {}
};

inline bool operator==(const IceBoxDescriptor& l, const IceBoxDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const IceBoxDescriptor& l, const IceBoxDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API LoadBalancingPolicy : virtual public ::Ice::Object
{
public:

    typedef LoadBalancingPolicyPrx ProxyType;
    typedef LoadBalancingPolicyPtr PointerType;

    LoadBalancingPolicy()
    {
    }

    explicit LoadBalancingPolicy(const ::std::string& __ice_nReplicas) :
        nReplicas(__ice_nReplicas)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string nReplicas;

protected:

    virtual ~LoadBalancingPolicy() {}
};

inline bool operator==(const LoadBalancingPolicy& l, const LoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const LoadBalancingPolicy& l, const LoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API RandomLoadBalancingPolicy : public ::IceGrid::LoadBalancingPolicy
{
public:

    typedef RandomLoadBalancingPolicyPrx ProxyType;
    typedef RandomLoadBalancingPolicyPtr PointerType;

    RandomLoadBalancingPolicy()
    {
    }

    explicit RandomLoadBalancingPolicy(const ::std::string& __ice_nReplicas) :
        ::IceGrid::LoadBalancingPolicy(__ice_nReplicas)
        
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::IceGrid::LoadBalancingPolicy::__writeImpl;
    using ::IceGrid::LoadBalancingPolicy::__readImpl;
    #endif

    virtual ~RandomLoadBalancingPolicy() {}
};

inline bool operator==(const RandomLoadBalancingPolicy& l, const RandomLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RandomLoadBalancingPolicy& l, const RandomLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API OrderedLoadBalancingPolicy : public ::IceGrid::LoadBalancingPolicy
{
public:

    typedef OrderedLoadBalancingPolicyPrx ProxyType;
    typedef OrderedLoadBalancingPolicyPtr PointerType;

    OrderedLoadBalancingPolicy()
    {
    }

    explicit OrderedLoadBalancingPolicy(const ::std::string& __ice_nReplicas) :
        ::IceGrid::LoadBalancingPolicy(__ice_nReplicas)
        
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::IceGrid::LoadBalancingPolicy::__writeImpl;
    using ::IceGrid::LoadBalancingPolicy::__readImpl;
    #endif

    virtual ~OrderedLoadBalancingPolicy() {}
};

inline bool operator==(const OrderedLoadBalancingPolicy& l, const OrderedLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const OrderedLoadBalancingPolicy& l, const OrderedLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API RoundRobinLoadBalancingPolicy : public ::IceGrid::LoadBalancingPolicy
{
public:

    typedef RoundRobinLoadBalancingPolicyPrx ProxyType;
    typedef RoundRobinLoadBalancingPolicyPtr PointerType;

    RoundRobinLoadBalancingPolicy()
    {
    }

    explicit RoundRobinLoadBalancingPolicy(const ::std::string& __ice_nReplicas) :
        ::IceGrid::LoadBalancingPolicy(__ice_nReplicas)
        
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();

    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::IceGrid::LoadBalancingPolicy::__writeImpl;
    using ::IceGrid::LoadBalancingPolicy::__readImpl;
    #endif

    virtual ~RoundRobinLoadBalancingPolicy() {}
};

inline bool operator==(const RoundRobinLoadBalancingPolicy& l, const RoundRobinLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const RoundRobinLoadBalancingPolicy& l, const RoundRobinLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API AdaptiveLoadBalancingPolicy : public ::IceGrid::LoadBalancingPolicy
{
public:

    typedef AdaptiveLoadBalancingPolicyPrx ProxyType;
    typedef AdaptiveLoadBalancingPolicyPtr PointerType;

    AdaptiveLoadBalancingPolicy()
    {
    }

    AdaptiveLoadBalancingPolicy(const ::std::string& __ice_nReplicas, const ::std::string& __ice_loadSample) :
        ::IceGrid::LoadBalancingPolicy(__ice_nReplicas)
        ,
        loadSample(__ice_loadSample)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::IceGrid::LoadBalancingPolicy::__writeImpl;
    using ::IceGrid::LoadBalancingPolicy::__readImpl;
    #endif

public:

    ::std::string loadSample;

protected:

    virtual ~AdaptiveLoadBalancingPolicy() {}
};

inline bool operator==(const AdaptiveLoadBalancingPolicy& l, const AdaptiveLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const AdaptiveLoadBalancingPolicy& l, const AdaptiveLoadBalancingPolicy& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API BoxedString : virtual public ::Ice::Object
{
public:

    typedef BoxedStringPrx ProxyType;
    typedef BoxedStringPtr PointerType;

    BoxedString()
    {
    }

    explicit BoxedString(const ::std::string& __ice_value) :
        value(__ice_value)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::std::string value;

protected:

    virtual ~BoxedString() {}
};

inline bool operator==(const BoxedString& l, const BoxedString& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BoxedString& l, const BoxedString& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

class ICE_GRID_API BoxedDistributionDescriptor : virtual public ::Ice::Object
{
public:

    typedef BoxedDistributionDescriptorPrx ProxyType;
    typedef BoxedDistributionDescriptorPtr PointerType;

    BoxedDistributionDescriptor()
    {
    }

    explicit BoxedDistributionDescriptor(const ::IceGrid::DistributionDescriptor& __ice_value) :
        value(__ice_value)
    {
    }

    virtual ::Ice::ObjectPtr ice_clone() const;

    virtual bool ice_isA(const ::std::string&, const ::Ice::Current& = ::Ice::Current()) const;
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& = ::Ice::Current()) const;
    virtual const ::std::string& ice_id(const ::Ice::Current& = ::Ice::Current()) const;
    static const ::std::string& ice_staticId();


    static const ::Ice::ObjectFactoryPtr& ice_factory();

protected:
    virtual void __writeImpl(::IceInternal::BasicStream*) const;
    virtual void __readImpl(::IceInternal::BasicStream*);
    #ifdef __SUNPRO_CC
    using ::Ice::Object::__writeImpl;
    using ::Ice::Object::__readImpl;
    #endif

public:

    ::IceGrid::DistributionDescriptor value;

protected:

    virtual ~BoxedDistributionDescriptor() {}
};

inline bool operator==(const BoxedDistributionDescriptor& l, const BoxedDistributionDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) == static_cast<const ::Ice::Object&>(r);
}

inline bool operator<(const BoxedDistributionDescriptor& l, const BoxedDistributionDescriptor& r)
{
    return static_cast<const ::Ice::Object&>(l) < static_cast<const ::Ice::Object&>(r);
}

}

namespace IceGrid
{

}

#endif
